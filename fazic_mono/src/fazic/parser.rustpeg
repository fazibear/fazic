use fazic::enums::*;
use fazic::nodes::*;

pub parse_all -> Entry
    = i:integer _ a:(all ++ ":") { entry_node(&Some(i), a) }
    / a:(all ++ ":") { entry_node(&None, a) }

all -> Vec<NodeElement>
    = _ c:command _ { c }
    // _ e:expression _ { vec![e] }

command -> Vec<NodeElement>
    = v:varname _ "=" _ e:expression { nodes("let", vec![v, e]) }
    / ("LET" / "let") _ v:varname _ "=" _ e:expression { nodes("let", vec![v, e]) }

    / ("?" / "PRINT" / "print") _ e:expression { nodes("print", vec![e]) }

    / ("GOTO" / "goto") _ i:integer { nodes("goto", vec![i]) }
    / ("GOSUB" / "gosub") _ i:integer { nodes("gosub", vec![i]) }

    / ("FOR" / "for") _ v:varname _ "=" _ e:expression _ ("TO" / "to") _ t:expression _ ("STEP" / "step") _ s:expression { nodes("for", vec![v, e, t, s]) }
    / ("FOR" / "for") _ v:varname _ "=" _ e:expression _ ("TO" / "to") _ t:expression { nodes("for", vec![v, e, t, integer_node("1")]) }

    / ("IF" / "if") _ e:expression _ ("GOTO" / "goto") _ i:integer {
        vec![node("if", vec![e]), node("goto", vec![i])]
    }
    / ("IF" / "if") _ e:expression _ ("GOSUB" / "gosub") _ i:integer {
        vec![node("if", vec![e]), node("gosub", vec![i])]
    }
    / ("IF" / "if") _ e:expression _ ("THEN" / "then") _ i:integer {
        vec![node("if", vec![e]), node("goto", vec![i])]
    }
    / ("IF" / "if") _ e:expression _ ("THEN" / "then") _ a:all {
        let mut vec = nodes("if", vec![e]);
        vec.extend(a);
        vec
    }
    / ("DOT" / "dot") _ x:expression _ "," _ y:expression { nodes("dot", vec![x, y]) }

    / ("NEXT" / "next" ) _ v:(varname ++ (_ "," _) ) {
        let mut vec = vec![];
        for varname in v.into_iter() {
            vec.extend(nodes("next", vec![varname]));
        };
        vec
    }

    / ("LOAD" / "load") _ s:string { nodes("load", vec![s]) }
    / ("SAVE" / "save") _ s:string { nodes("save", vec![s]) }

    / ("NEXT" / "next" ) { nodes("next", vec![]) }

    / ("COLOR" / "color") _ e:expression { nodes("color", vec![e]) }
    / ("FLIP" / "flip") { nodes("flip", vec![]) }
    / ("MODE" / "mode") _ i:integer { nodes("mode", vec![i]) }

    / ("RETURN" / "return") { nodes("return", vec![]) }
    / ("LIST" / "list")  { nodes("list", vec![]) }
    / ("CLR" / "clr")  { nodes("clr", vec![]) }
    / ("CONT" / "cont")  { nodes("cont", vec![]) }
    / ("STOP" / "stop")  { nodes("stop", vec![]) }
    / ("NEW" / "new")  { nodes("new", vec![]) }
    / ("RUN" / "run")  { nodes("run", vec![]) }
    / ("END" / "end")  { nodes("end", vec![]) }
    / ("REM" / "rem") .* { nodes("rem", vec![]) }

function -> NodeElement
    = ("ABS(" / "abs(") _ e:expression _ ")" { node("abs", vec![e]) }
    / ("RND(" / "rnd(") _ e:expression _ ")" { node("rnd", vec![e]) }

expression -> NodeElement
    = #infix<term> {
        #L l ("AND" / "and") r { node("and", vec![l, r]) }
           l ("OR" / "or") r { node("or", vec![l, r]) }
        #L l "="  r { node("eq", vec![l, r]) }
           l "==" r { node("eq", vec![l, r]) }
           l "!=" r { node("neq", vec![l, r]) }
           l "<>" r { node("neq", vec![l, r]) }
           l "<"  r { node("lt", vec![l, r]) }
           l ">"  r { node("gt", vec![l, r]) }
           l "<=" r { node("lteq", vec![l, r]) }
           l ">=" r { node("gteq", vec![l, r]) }
           l "=<" r { node("lteq", vec![l, r]) }
           l "=>" r { node("gteq", vec![l, r]) }
        #L l "+"  r { node("add", vec![l, r]) }
           l "-"  r { node("sub", vec![l, r]) }
        #L l "*"  r { node("mul", vec![l, r]) }
           l "/"  r { node("div", vec![l, r]) }
        #R l "^"  r { node("pow", vec![l, r]) }
    }

term -> NodeElement
    = _ f:float _ { f }
    / _ i:integer _ { i }
    / _ s:string _ { s }
    / _ f:function _ { f }
    / _ "(" _ e:expression _ ")" _ { e }
    / _ "-" _ t:term _ { node("neg", vec![t]) }
    / _ ("NOT" / "not") _ e:expression _ { node("not", vec![e]) }
    / _ v:variable _ { v }

float -> NodeElement
    = f:$([0-9]* "." [0-9]+) { println!("{}", f); float_node(f) }

integer -> NodeElement
    = i:$([0-9]+) { integer_node(i) }

string -> NodeElement
    = "\"" s:$([^"]*) "\"" { string_node(s) }
    / "'" s:$([^']*) "'" { string_node(s) }

variable -> NodeElement
    = v:$([a-zA-Z]+) { variable_node(v) }

varname -> NodeElement
    = v:$([a-zA-Z]+) { variable_name(v) }

_ = #quiet<" "*>
