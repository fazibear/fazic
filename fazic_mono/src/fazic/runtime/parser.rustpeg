use fazic::runtime::ast::*;
use fazic::runtime::node_builder::*;

pub parse_all -> Entry
    = i:integer _ a:(all ++ ":") { entry_node(Some(i), a) }
    / a:(all ++ ":") { entry_node(None, a) }

all -> Vec<NodeElement>
    = _ c:command _ { c }
    / _ e:expression _ { vec![e] }

command -> Vec<NodeElement>
    = v:varname _ "=" _ e:expression { nodes(Opcode::Let, vec![v, e]) }
    / ("LET" / "let") _ v:varname _ "=" _ e:expression { nodes(Opcode::Let, vec![v, e]) }

    / ("?" / "PRINT" / "print") _ e:expression { nodes(Opcode::Print, vec![e]) }

    / ("GOTO" / "goto") _ i:integer { nodes(Opcode::Goto, vec![i]) }
    / ("GOSUB" / "gosub") _ i:integer { nodes(Opcode::Gosub, vec![i]) }

    / ("FOR" / "for") _ v:varname _ "=" _ e:expression _ ("TO" / "to") _ t:expression _ ("STEP" / "step") _ s:expression { nodes(Opcode::For, vec![v, e, t, s]) }
    / ("FOR" / "for") _ v:varname _ "=" _ e:expression _ ("TO" / "to") _ t:expression { nodes(Opcode::For, vec![v, e, t, integer_node("1")]) }

    / ("IF" / "if") _ e:expression _ ("GOTO" / "goto") _ i:integer {
        vec![node(Opcode::If, vec![e]), node(Opcode::Goto, vec![i])]
    }
    / ("IF" / "if") _ e:expression _ ("GOSUB" / "gosub") _ i:integer {
        vec![node(Opcode::If, vec![e]), node(Opcode::Gosub, vec![i])]
    }
    / ("IF" / "if") _ e:expression _ ("THEN" / "then") _ i:integer {
        vec![node(Opcode::If, vec![e]), node(Opcode::Goto, vec![i])]
    }
    / ("IF" / "if") _ e:expression _ ("THEN" / "then") _ a:all {
        let mut vec = nodes(Opcode::If, vec![e]);
        vec.extend(a);
        vec
    }

    / ("NEXT" / "next" ) _ v:(varname ++ (_ "," _) ) {
        let mut vec = vec![];
        for varname in v.into_iter() {
            vec.extend(nodes(Opcode::Next, vec![varname]));
        };
        vec
    }
    / ("NEXT" / "next" ) { nodes(Opcode::Next, vec![]) }

    / ("RETURN" / "return") { nodes(Opcode::Return, vec![]) }
    / ("LIST" / "list")  { nodes(Opcode::List, vec![]) }
    / ("REM" / "rem") .* { nodes(Opcode::Rem, vec![]) }
    / ("RUN" / "run")  { nodes(Opcode::Run, vec![]) }
    / ("END" / "end")  { nodes(Opcode::End, vec![]) }

function -> NodeElement
    = ("ABS(" / "abs(") _ e:expression _ ")" { node(Opcode::Abs, vec![e]) }

expression -> NodeElement
    = #infix<term> {
        #L l ("AND" / "and") r { node(Opcode::And, vec![l, r]) }
           l ("OR" / "or") r { node(Opcode::Or, vec![l, r]) }
        #L l "="  r { node(Opcode::Eql, vec![l, r]) }
           l "==" r { node(Opcode::Eql, vec![l, r]) }
           l "!=" r { node(Opcode::NotEql, vec![l, r]) }
           l "<>" r { node(Opcode::NotEql, vec![l, r]) }
           l "<"  r { node(Opcode::Lt, vec![l, r]) }
           l ">"  r { node(Opcode::Gt, vec![l, r]) }
           l "<=" r { node(Opcode::LtEql, vec![l, r]) }
           l ">=" r { node(Opcode::GtEql, vec![l, r]) }
           l "=<" r { node(Opcode::LtEql, vec![l, r]) }
           l "=>" r { node(Opcode::GtEql, vec![l, r]) }
        #L l "+"  r { node(Opcode::Add, vec![l, r]) }
           l "-"  r { node(Opcode::Sub, vec![l, r]) }
        #L l "*"  r { node(Opcode::Mul, vec![l, r]) }
           l "/"  r { node(Opcode::Div, vec![l, r]) }
        #R l "^"  r { node(Opcode::Pow, vec![l, r]) }
    }

term -> NodeElement
    = _ f:float _ { f }
    / _ i:integer _ { i }
    / _ s:string _ { s }
    / _ f:function _ { f }
    / _ "(" _ e:expression _ ")" _ { e }
    / _ "-" _ t:term _ { node(Opcode::Neg, vec![t]) }
    / _ ("NOT" / "not") _ e:expression _ { node(Opcode::Not, vec![e]) }
    / _ v:variable _ { v }

float -> NodeElement
    = f:$([0-9]* "." [0-9]+) { println!("{}", f); float_node(f) }

integer -> NodeElement
    = i:$([0-9]+) { integer_node(i) }

string -> NodeElement
    = "\"" s:$([^"]*) "\"" { string_node(s) }
    / "'" s:$([^']*) "'" { string_node(s) }

variable -> NodeElement
    = v:$([a-zA-Z]+) { variable_node(v) }

 varname -> NodeElement
     = v:$([a-zA-Z]+) { variable_name(v) }

_ = #quiet<" "*>
