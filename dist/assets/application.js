(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (global_object.console == null) {
    global_object.console = {};
  }

  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal.Opal class (helpers etc.)
  var _Opal;

  // The Kernel module
  var Kernel;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    experimental_features_severity: 'warning',// warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $call      = Function.prototype.call;
  var $bind      = Function.prototype.bind;
  var $has_own   = Object.hasOwn || $call.bind(Object.prototype.hasOwnProperty);
  var $set_proto = Object.setPrototypeOf;
  var $slice     = $call.bind(Array.prototype.slice);
  var $splice    = $call.bind(Array.prototype.splice);

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  function $uid() {
    unique_id += 2;
    return unique_id;
  };
  Opal.uid = $uid;

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id == null) {
      $prop(obj, '$$id', $uid());
    }
    return obj.$$id;
  };

  // Globals table
  var $gvars = Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if ($gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    var exception = Opal.exceptions.pop();
    if (exception) {
      $gvars["!"] = exception;
      $gvars["@"] = exception.$backtrace();
    }
    else {
      $gvars["!"] = $gvars["@"] = nil;
    }
  };

  // A helper function for raising things, that gracefully degrades if necessary
  // functionality is not yet loaded.
  function $raise(klass, message) {
    // Raise Exception, so we can know that something wrong is going on.
    if (!klass) klass = Opal.Exception || Error;

    if (Kernel && Kernel.$raise) {
      if (arguments.length > 2) {
        Kernel.$raise(klass.$new.apply(klass, $slice(arguments, 1)));
      }
      else {
        Kernel.$raise(klass, message);
      }
    }
    else if (!klass.$new) {
      throw new klass(message);
    }
    else {
      throw klass.$new(message);
    }
  }

  function $prop(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.prop = $prop;

  // @deprecated
  Opal.defineProperty = Opal.prop;

  Opal.slice = $slice;

  // Helpers
  // -----

  var $truthy = Opal.truthy = function(val) {
    return false !== val && nil !== val && undefined !== val && null !== val && (!(val instanceof Boolean) || true === val.valueOf());
  };

  Opal.falsy = function(val) {
    return !$truthy(val);
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      $raise(Opal.TypeError,
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      $raise(Opal.TypeError,
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    var body;

    if (method === 'to_int' && type === Opal.Integer && object.$$is_number)
      return object < 0 ? Math.ceil(object) : Math.floor(object);

    if (method === 'to_str' && type === Opal.String && object.$$is_string)
      return object;

    if (Opal.is_a(object, type)) return object;

    // Fast path for the most common situation
    if (object['$respond_to?'].$$pristine && object.$method_missing.$$pristine) {
      body = object[$jsid(method)];
      if (body == null || body.$$stub) Opal.type_error(object, type);
      return body.apply(object, args);
    }

    if (!object['$respond_to?'](method)) {
      Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
      if (!obj['$respond_to_missing?'].$$pristine) {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }

  // TracePoint support
  // ------------------
  //
  // Support for `TracePoint.trace(:class) do ... end`
  Opal.trace_class = false;
  Opal.tracers_for_class = [];

  function invoke_tracers_for_class(klass_or_module) {
    var i, ii, tracer;

    for(i = 0, ii = Opal.tracers_for_class.length; i < ii; i++) {
      tracer = Opal.tracers_for_class[i];
      tracer.trace_object = klass_or_module;
      tracer.block.$call(tracer);
    }
  }

  function handle_autoload(cref, name) {
    if (!cref.$$autoload[name].loaded) {
      cref.$$autoload[name].loaded = true;
      try {
        Opal.Kernel.$require(cref.$$autoload[name].path);
      } catch (e) {
        cref.$$autoload[name].exception = e;
        throw e;
      }
      cref.$$autoload[name].required = true;
      if (cref.$$const[name] != null) {
        cref.$$autoload[name].success = true;
        return cref.$$const[name];
      }
    } else if (cref.$$autoload[name].loaded && !cref.$$autoload[name].required) {
      if (cref.$$autoload[name].exception) { throw cref.$$autoload[name].exception; }
    }
  }

  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) {
      if (cref.$$const[name] != null) { return cref.$$const[name]; }
      if (cref.$$autoload && cref.$$autoload[name]) {
        return handle_autoload(cref, name);
      }
    }
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) {
        return constant;
      } else if (nesting[i].$$autoload && nesting[i].$$autoload[name]) {
        return handle_autoload(nesting[i], name);
      }
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = $ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      } else if (ancestors[i].$$autoload && ancestors[i].$$autoload[name]) {
        return handle_autoload(ancestors[i], name);
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name) {
    return (cref || _Object).$const_missing(name);
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      $raise(Opal.TypeError, cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);
    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (name == null) {
      // A shortpath for calls like ::String => $$$("String")
      result = const_get_name(_Object, cref);

      if (result != null) return result;
      return Opal.const_get_qualified(_Object, cref, skip_missing);
    }

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      $raise(Opal.TypeError, cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $prop(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $prop(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  function $const_set(cref, name, value) {
    var new_const = true;

    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));

    if (name in cref.$$const || ("$$autoload" in cref && name in cref.$$autoload)) {
      new_const = false;
    }

    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $prop(cref, name, value);

    if (new_const && cref.$const_added && !cref.$const_added.$$pristine) {
      cref.$const_added(name);
    }

    return value;
  };

  Opal.const_set = $const_set;

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat($ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat($ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
      if (module.$$autoload) {
        for (constant in module.$$autoload) {
          constants[constant] = true;
        }
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload && cref.$$autoload[name]) {
      delete cref.$$autoload[name];
      return nil;
    }

    $raise(Opal.NameError, "constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Generates a function that is a curried const_get_relative.
  Opal.const_get_relative_factory = function(nesting) {
    return function(name, skip_missing) {
      return Opal.$$(nesting, name, skip_missing);
    }
  }

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;
  Opal.$r = Opal.const_get_relative_factory;

  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass   [Class,null] superclass of the new class (may be null)
  // @param singleton    [Boolean,null] a true value denotes we want to allocate
  //                                    a singleton
  //
  // @return new [Class]  or existing ruby class
  //
  function $allocate_class(name, superclass, singleton) {
    var klass;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      klass = function() {
        var args = $slice(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      klass = function(){};
    }

    if (name && name !== nil) {
      $prop(klass, 'displayName', '::'+name);
    }

    $prop(klass, '$$name', name);
    $prop(klass, '$$constructor', klass);
    $prop(klass, '$$prototype', klass.prototype);
    $prop(klass, '$$const', {});
    $prop(klass, '$$is_class', true);
    $prop(klass, '$$is_a_module', true);
    $prop(klass, '$$super', superclass);
    $prop(klass, '$$cvars', {});
    $prop(klass, '$$own_included_modules', []);
    $prop(klass, '$$own_prepended_modules', []);
    $prop(klass, '$$ancestors', []);
    $prop(klass, '$$ancestors_cache_version', null);
    $prop(klass, '$$subclasses', []);

    $prop(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (singleton !== true) {
        // Let's not forbid GC from cleaning up our
        // subclasses.
        if (typeof WeakRef !== 'undefined') {
          // First, let's clean up our array from empty objects.
          var i, subclass, rebuilt_subclasses = [];
          for (i = 0; i < superclass.$$subclasses.length; i++) {
            subclass = superclass.$$subclasses[i];
            if (subclass.deref() !== undefined) {
              rebuilt_subclasses.push(subclass);
            }
          }
          // Now, let's add our class.
          rebuilt_subclasses.push(new WeakRef(klass));
          superclass.$$subclasses = rebuilt_subclasses;
        }
        else {
          superclass.$$subclasses.push(klass);
        }
      }

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };
  Opal.allocate_class = $allocate_class;


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        $raise(Opal.TypeError, name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      $raise(Opal.TypeError, "superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        $raise(Opal.TypeError, "superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass != null) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
    }
    else {
      // Class doesn't exist, create a new one with given superclass...

      // Not specifying a superclass means we can assume it to be Object
      if (superclass == null) {
        superclass = _Object;
      }

      // Create the class object (instance of Class)
      klass = $allocate_class(name, superclass);
      $const_set(scope, name, klass);

      // Call .inherited() hook with new class on the superclass
      if (superclass.$inherited) {
        superclass.$inherited(klass);
      }

      if (bridged) {
        Opal.bridge(bridged, klass);
      }
    }

    if (Opal.trace_class) { invoke_tracers_for_class(klass); }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  function $allocate_module(name) {
    var constructor = function(){};
    var module = constructor;

    if (name)
      $prop(constructor, 'displayName', name+'.constructor');

    $prop(module, '$$name', name);
    $prop(module, '$$prototype', constructor.prototype);
    $prop(module, '$$const', {});
    $prop(module, '$$is_module', true);
    $prop(module, '$$is_a_module', true);
    $prop(module, '$$cvars', {});
    $prop(module, '$$iclasses', []);
    $prop(module, '$$own_included_modules', []);
    $prop(module, '$$own_prepended_modules', []);
    $prop(module, '$$ancestors', [module]);
    $prop(module, '$$ancestors_cache_version', null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };
  Opal.allocate_module = $allocate_module;

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        $raise(Opal.TypeError, name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module == null) {
      // Module doesnt exist, create a new one...
      module = $allocate_module(name);
      $const_set(scope, name, module);
    }

    if (Opal.trace_class) { invoke_tracers_for_class(module); }

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$is_number) {
      $raise(Opal.TypeError, "can't define singleton");
    }
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // helper to set $$meta on klass, module or instance
  function set_meta(obj, meta) {
    if (obj.hasOwnProperty('$$meta')) {
      obj.$$meta = meta;
    } else {
      $prop(obj, '$$meta', meta);
    }
    if (obj.$$frozen) {
      // If a object is frozen (sealed), freeze $$meta too.
      // No need to inject $$meta.$$prototype in the prototype chain,
      // as $$meta cannot be modified anyway.
      obj.$$meta.$freeze();
    } else {
      $set_proto(obj, meta.$$prototype);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    var superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    var meta = $allocate_class(null, superclass, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', klass);
    set_meta(klass, meta);
    // Restoring ClassName.class
    $prop(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = $allocate_class(null, Opal.Module, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', mod);
    set_meta(mod, meta);
    // Restoring ModuleName.class
    $prop(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = $allocate_class(nil, superclass, true);

    $prop(klass, '$$is_singleton', true);
    $prop(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    set_meta(object, klass);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = $ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(obj.$$meta || obj.$$class);
  };

  Opal.own_methods = function(obj) {
    return obj.$$meta ? Opal.own_instance_methods(obj.$$meta) : [];
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = $ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      $raise(Opal.NameError, 'uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      $raise(Opal.ArgumentError, 'cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = $ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      $raise(Opal.ArgumentError, 'cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $prop(dummy_prepender, '$$dummy', true);
      $prop(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = $ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      $raise(Opal.RuntimeError, "Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $prop(iclass, prop, proto[prop]);
    }

    $prop(iclass, '$$iclass', true);
    $prop(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $prop(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      $raise(Opal.ArgumentError, "already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $prop(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $prop(klass, '$$prototype', native_klass.prototype);

    $prop(klass.$$prototype, '$$class', klass);
    $prop(klass, '$$constructor', native_klass);
    $prop(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  function $ancestors(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = $ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };
  Opal.ancestors = $ancestors;

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs("foo,bar,baz=");
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;
    var stub, existing_method;
    stubs = stubs.split(',');

    for (var i = 0, length = stubs.length; i < length; i++) {
      stub = $jsid(stubs[i]), existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    // Opal.stub_for(stub) is the method_missing_stub
    $prop(prototype, stub, Opal.stub_for(stub));
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {

    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    $raise(Opal.ArgumentError, '[' + inspect + '] wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    $raise(Opal.ArgumentError, inspect + ': wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  function get_ancestors(obj) {
    if (obj.hasOwnProperty('$$meta') && obj.$$meta !== null) {
      return $ancestors(obj.$$meta);
    } else {
      return $ancestors(obj.$$class);
    }
  };

  // Super dispatcher
  Opal.find_super = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = $jsid(mid), ancestors, super_method;

    ancestors = get_ancestors(obj);

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      $raise(Opal.NoMethodError, 'super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_block_super = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      $raise(Opal.RuntimeError, "super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      $raise(Opal.RuntimeError,
        "implicit argument passing of super from method defined by define_method() is not supported. " +
        "Specify all arguments explicitly"
      );
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super(obj, call_jsid, current_func, defcheck);
  };

  // @deprecated
  Opal.find_super_dispatcher = Opal.find_super;

  // @deprecated
  Opal.find_iter_super_dispatcher = Opal.find_block_super;

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      $raise(Opal.LocalJumpError, "no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      $raise(Opal.LocalJumpError, "no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error || candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var ancestors = $ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    return ancestors.indexOf(klass) !== -1;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        $raise(Opal.TypeError, "Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      $raise(Opal.TypeError, "no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        $raise(Opal.TypeError, "Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        $raise(Opal.TypeError, "Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice(parameters, parameters.length - 1);
      return kwargs;
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  function apply_blockopts(block, blockopts) {
    if (typeof(blockopts) === 'number') {
      block.$$arity = blockopts;
    }
    else if (typeof(blockopts) === 'object') {
      Object.assign(block, blockopts);
    }
  }

  // Optimization for a costly operation of prepending '$' to method names
  var jsid_cache = {}
  function $jsid(name) {
    return jsid_cache[name] || (jsid_cache[name] = '$' + name);
  }
  Opal.jsid = $jsid;

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @param blockopts [Object, Number] optional properties to set on the block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block, blockopts) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv[$jsid(method)];
    } else {
      $raise(Opal.NameError, "Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block, blockopts);
  };

  Opal.send2 = function(recv, body, method, args, block, blockopts) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    apply_blockopts(block, blockopts);

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.refined_send = function(refinement_groups, recv, method, args, block, blockopts) {
    var i, j, k, ancestors, ancestor, refinements, refinement, refine_modules, refine_module, body;

    ancestors = get_ancestors(recv);

    // For all ancestors that there are, starting from the closest to the furthest...
    for (i = 0; i < ancestors.length; i++) {
      ancestor = Opal.id(ancestors[i]);

      // For all refinement groups there are, starting from the closest scope to the furthest...
      for (j = 0; j < refinement_groups.length; j++) {
        refinements = refinement_groups[j];

        // For all refinements there are, starting from the last `using` call to the furthest...
        for (k = refinements.length - 1; k >= 0; k--) {
          refinement = refinements[k];
          if (typeof refinement.$$refine_modules === 'undefined') continue;

          // A single module being given as an argument of the `using` call contains multiple
          // refinement modules
          refine_modules = refinement.$$refine_modules;

          // Does this module refine a given call for a given ancestor module?
          if (typeof refine_modules[ancestor] === 'undefined') continue;
          refine_module = refine_modules[ancestor];

          // Does this module define a method we want to call?
          if (typeof refine_module.$$prototype[$jsid(method)] !== 'undefined') {
            body = refine_module.$$prototype[$jsid(method)];
            return Opal.send2(recv, body, method, args, block, blockopts);
          }
        }
      }
    }

    return Opal.send(recv, method, args, block, blockopts);
  };

  Opal.lambda = function(block, blockopts) {
    block.$$is_lambda = true;

    apply_blockopts(block, blockopts);

    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @param blockopts [Object, Number] optional properties to set on the body
  // @return [null]
  //
  Opal.def = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      return Opal.defn(Opal.Object, jsid, body);
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      return Opal.defn(obj, jsid, body);
    }
    else {
      return Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    $deny_frozen_access(module);

    body.displayName = jsid;
    body.$$owner = module;

    var name = jsid.substr(1);

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $prop(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $prop(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(name);
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(name);
    }

    return name;
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    if (obj.$$is_string || obj.$$is_number) {
      $raise(Opal.TypeError, "can't define singleton");
    }
    return Opal.defn(Opal.get_singleton_class(obj), jsid, body);
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own(obj.$$prototype, jsid)) {
      $raise(Opal.NameError, "method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      $raise(Opal.NameError, "method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = $jsid(name),
        old_id = $jsid(old),
        body,
        alias;

    // Aliasing on main means aliasing on Object...
    if (typeof obj.$$prototype === 'undefined') {
      obj = Opal.Object;
    }

    body = obj.$$prototype[old_id];

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        $raise(Opal.NameError, "undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      alias.$$p = null;

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, 'length', { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName       = name;

    alias.$$arity           = body.$$arity == null ? body.length : body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_gvar = function(new_name, old_name) {
    Object.defineProperty($gvars, new_name, {
      configurable: true,
      enumerable: true,
      get: function() {
        return $gvars[old_name];
      },
      set: function(new_value) {
        $gvars[old_name] = new_value;
      }
    });
    return nil;
  }

  Opal.alias_native = function(obj, name, native_name) {
    var id   = $jsid(name),
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      $raise(Opal.NameError, "undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($has_own(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value, key_tmp;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        key_tmp = keys[i];

        if (key_tmp.$$is_string && typeof key_tmp !== "string") {
          key_tmp = key_tmp.valueOf();
        }

        if (key_tmp === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1) {
      args = arguments[0];

      if (arguments[0].$$is_array) {
        length = args.length;

        for (i = 0; i < length; i++) {
          if (args[i].length !== 2) {
            $raise(Opal.ArgumentError, "value not of length 2: " + args[i].$inspect());
          }

          key = args[i][0];
          value = args[i][1];

          Opal.hash_put(hash, key, value);
        }

        return hash;
      }
      else {
        args = arguments[0];
        for (key in args) {
          if ($has_own(args, key)) {
            value = args[key];

            Opal.hash_put(hash, key, value);
          }
        }

        return hash;
      }
    }

    if (arguments_length % 2 !== 0) {
      $raise(Opal.ArgumentError, "odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  var reserved_ivar_names = [
    // properties
    "constructor", "displayName", "__count__", "__noSuchMethod__",
    "__parent__", "__proto__",
    // methods
    "hasOwnProperty", "valueOf"
  ];

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (reserved_ivar_names.indexOf(name) !== -1) {
      name += "$";
    }

    return name;
  };

  // Support for #freeze
  // -------------------

  // helper that can be used from methods
  function $deny_frozen_access(obj) {
    if (obj.$$frozen) {
      $raise(Opal.FrozenError, "can't modify frozen " + (obj.$class()) + ": " + (obj), Opal.hash2(["receiver"], {"receiver": obj}));
    }
  };
  Opal.deny_frozen_access = $deny_frozen_access;

  // common #freeze runtime support
  Opal.freeze = function(obj) {
    $prop(obj, "$$frozen", true);

    // set $$id
    if (!obj.hasOwnProperty('$$id')) { $prop(obj, '$$id', $uid()); }

    if (obj.hasOwnProperty('$$meta')) {
      // freeze $$meta if it has already been set
      obj.$$meta.$freeze();
    } else {
      // ensure $$meta can be set lazily, $$meta is frozen when set in runtime.js
      $prop(obj, '$$meta', null);
    }

    // $$comparable is used internally and set multiple times
    // defining it before sealing ensures it can be modified later on
    if (!obj.hasOwnProperty('$$comparable')) { $prop(obj, '$$comparable', null); }

    // seal the Object
    Object.seal(obj);

    return obj;
  };

  // freze props, make setters of instance variables throw FrozenError
  Opal.freeze_props = function(obj) {
    var prop, prop_type, desc;

    for(prop in obj) {
      prop_type = typeof(prop);

      // prop_type "object" here is a String(), skip $ props
      if ((prop_type === "string" || prop_type === "object") && prop[0] === '$') {
        continue;
      }

      desc = Object.getOwnPropertyDescriptor(obj, prop);
      if (desc && desc.enumerable && desc.writable) {
        // create closure to retain current value as cv
        // for Opal 2.0 let for cv should do the trick, instead of a function
        (function() {
          // set v to undefined, as if the property is not set
          var cv = obj[prop];
          Object.defineProperty(obj, prop, {
            get: function() { return cv; },
            set: function(_val) { $deny_frozen_access(obj); },
            enumerable: true
          });
        })();
      }
    }
  };

  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result, flags;

    // RegExp already has the global and multiline flag
    if (pattern.global && pattern.multiline) return pattern;

    flags = 'gm' + (pattern.ignoreCase ? 'i' : '');
    if (pattern.multiline) {
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g == null) {
        pattern.$$g = new RegExp(pattern.source, flags);
      }
      result = pattern.$$g;
    } else {
      if (pattern.$$gm == null) {
        pattern.$$gm = new RegExp(pattern.source, flags);
      }
      result = pattern.$$gm;
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({uplevel: 1})
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load_normalized = function(path) {
    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      var retval = module(Opal);
      if (typeof Promise !== 'undefined' && retval instanceof Promise) {
        // A special case of require having an async top:
        // We will need to await it.
        return retval.then($return_val(true));
      }
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        $raise(Opal.LoadError, message);
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    return Opal.load_normalized(path);
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load_normalized(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      $raise(Opal.FrozenError, "can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) $raise(Opal.ArgumentError, "unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }

  Opal.last_promise = null;
  Opal.promise_unhandled_exception = false;

  // Run a block of code, but if it returns a Promise, don't run the next
  // one, but queue it.
  Opal.queue = function(proc) {
    if (Opal.last_promise) {
      // The async path is taken only if anything before returned a
      // Promise(V2).
      Opal.last_promise = Opal.last_promise.then(function() {
        if (!Opal.promise_unhandled_exception) return proc(Opal);
      })['catch'](function(error) {
        if (Opal.respond_to(error, '$full_message')) {
          error = error.$full_message();
        }
        console.error(error);
        // Abort further execution
        Opal.promise_unhandled_exception = true;
        Opal.exit(1);
      });
      return Opal.last_promise;
    }
    else {
      var ret = proc(Opal);
      if (typeof Promise === 'function' && typeof ret === 'object' && ret instanceof Promise) {
        Opal.last_promise = ret;
      }
      return ret;
    }
  }

  // Operator helpers
  // ----------------

  function are_both_numbers(l,r) { return typeof(l) === 'number' && typeof(r) === 'number' }

  Opal.rb_plus   = function(l,r) { return are_both_numbers(l,r) ? l + r : l['$+'](r); }
  Opal.rb_minus  = function(l,r) { return are_both_numbers(l,r) ? l - r : l['$-'](r); }
  Opal.rb_times  = function(l,r) { return are_both_numbers(l,r) ? l * r : l['$*'](r); }
  Opal.rb_divide = function(l,r) { return are_both_numbers(l,r) ? l / r : l['$/'](r); }
  Opal.rb_lt     = function(l,r) { return are_both_numbers(l,r) ? l < r : l['$<'](r); }
  Opal.rb_gt     = function(l,r) { return are_both_numbers(l,r) ? l > r : l['$>'](r); }
  Opal.rb_le     = function(l,r) { return are_both_numbers(l,r) ? l <= r : l['$<='](r); }
  Opal.rb_ge     = function(l,r) { return are_both_numbers(l,r) ? l >= r : l['$>='](r); }

  // Optimized helpers for calls like $truthy((a)['$==='](b)) -> $eqeqeq(a, b)
  function are_both_numbers_or_strings(lhs, rhs) {
    return (typeof lhs === 'number' && typeof rhs === 'number') ||
           (typeof lhs === 'string' && typeof rhs === 'string');
  }

  function $eqeq(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$=='](rhs));
  };
  Opal.eqeq = $eqeq;
  Opal.eqeqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$==='](rhs));
  };
  Opal.neqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs !== rhs : $truthy((lhs)['$!='](rhs));
  };
  Opal.not = function(arg) {
    if (undefined === arg || null === arg || false === arg || nil === arg) return true;
    if (true === arg || arg['$!'].$$pristine) return false;
    return $truthy(arg['$!']());
  }

  // Shortcuts - optimized function generators for simple kinds of functions
  function $return_val(arg) {
    return function() {
      return arg;
    }
  }
  Opal.return_val = $return_val;

  Opal.return_self = function() {
    return this;
  }
  Opal.return_ivar = function(ivar) {
    return function() {
      if (this[ivar] == null) { return nil; }
      return this[ivar];
    }
  }
  Opal.assign_ivar = function(ivar) {
    return function(val) {
      $deny_frozen_access(this);
      return this[ivar] = val;
    }
  }
  Opal.assign_ivar_val = function(ivar, static_val) {
    return function() {
      $deny_frozen_access(this);
      return this[ivar] = static_val;
    }
  }

  // Primitives for handling parameters
  Opal.ensure_kwargs = function(kwargs) {
    if (kwargs == null) {
      return Opal.hash2([], {});
    } else if (kwargs.$$is_hash) {
      return kwargs;
    } else {
      $raise(Opal.ArgumentError, 'expected kwargs');
    }
  }

  Opal.get_kwarg = function(kwargs, key) {
    if (!$has_own(kwargs.$$smap, key)) {
      $raise(Opal.ArgumentError, 'missing keyword: '+key);
    }
    return kwargs.$$smap[key];
  }

  // Arrays of size > 32 elements that contain only strings,
  // symbols, integers and nils are compiled as a self-extracting
  // string.
  Opal.large_array_unpack = function(str) {
    var array = str.split(","), length = array.length, i;
    for (i = 0; i < length; i++) {
      switch(array[i][0]) {
        case undefined:
          array[i] = nil
          break;
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          array[i] = +array[i];
      }
    }
    return array;
  }

  // Initialization
  // --------------
  Opal.BasicObject = BasicObject = $allocate_class('BasicObject', null);
  Opal.Object      = _Object     = $allocate_class('Object', Opal.BasicObject);
  Opal.Module      = Module      = $allocate_class('Module', Opal.Object);
  Opal.Class       = Class       = $allocate_class('Class', Opal.Module);
  Opal.Opal        = _Opal       = $allocate_module('Opal');
  Opal.Kernel      = Kernel      = $allocate_module('Kernel');

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const.BasicObject = BasicObject;

  // Assign basic constants
  $const_set(_Object, "BasicObject",  BasicObject);
  $const_set(_Object, "Object",       _Object);
  $const_set(_Object, "Module",       Module);
  $const_set(_Object, "Class",        Class);
  $const_set(_Object, "Opal",         _Opal);
  $const_set(_Object, "Kernel",       Kernel);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;
  _Opal.$$class       = Module;
  Kernel.$$class      = Module;

  // Forward .toString() to #to_s
  $prop(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $prop(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = $return_val('main');
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = $slice(arguments);
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, 'define_method', args, block)
  };

  // Nil
  Opal.NilClass = $allocate_class('NilClass', Opal.Object);
  $const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { $raise(Opal.LocalJumpError, 'no block given'); };
  nil.$$frozen = true;
  nil.$$comparable = false;
  Object.seal(nil);

  Opal.thrower = function(type) {
    var thrower = new Error('unexpected '+type);
    thrower.$thrower_type = type;
    thrower.$throw = function(value) {
      if (value == null) value = nil;
      thrower.$v = value;
      throw thrower;
    };
    return thrower;
  };

  Opal.t_eval_return = Opal.thrower("return");

  TypeError.$$super = Error;

  // If enable-file-source-embed compiler option is enabled, each module loaded will add its
  // sources to this object
  Opal.file_sources = {};
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
Opal.modules["corelib/helpers"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $defs = Opal.defs, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $Opal = Opal.Opal, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('===,raise,respond_to?,nil?,__send__,<=>,class,coerce_to!,new,to_s,__id__');
  return (function($base) {
    var self = $module($base, 'Opal');

    
    
    $defs(self, '$bridge', function $$bridge(constructor, klass) {
      
      return Opal.bridge(constructor, klass);
    });
    $defs(self, '$coerce_to!', function $Opal_coerce_to$excl$1(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice(arguments, 3);
      args = $post_args;
      coerced = $coerce_to(object, type, method, args);
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$coerce_to?', function $Opal_coerce_to$ques$2(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice(arguments, 3);
      args = $post_args;
      if (!$truthy(object['$respond_to?'](method))) {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil
      };
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$try_convert', function $$try_convert(object, type, method) {
      
      
      if ($eqeqeq(type, object)) {
        return object
      };
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    });
    $defs(self, '$compare', function $$compare(a, b) {
      var compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")
      };
      return compare;
    });
    $defs(self, '$destructure', function $$destructure(args) {
      
      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    });
    $defs(self, '$respond_to?', function $Opal_respond_to$ques$3(obj, method, include_all) {
      
      
      if (include_all == null) include_all = false;
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, -3);
    $defs(self, '$instance_variable_name!', function $Opal_instance_variable_name$excl$4(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if (!$truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
        $Kernel.$raise($$$('NameError').$new("'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    });
    $defs(self, '$class_variable_name!', function $Opal_class_variable_name$excl$5(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        $Kernel.$raise($$$('NameError').$new("`" + (name) + "' is not allowed as a class variable name", name))
      };
      return name;
    });
    $defs(self, '$const_name?', function $Opal_const_name$ques$6(const_name) {
      
      
      if (typeof const_name !== 'string') {
        (const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str"))
      }

      return const_name[0] === const_name[0].toUpperCase()
    
    });
    $defs(self, '$const_name!', function $Opal_const_name$excl$7(const_name) {
      var $a, self = this;

      
      if ($truthy((($a = $$$('::', 'String', 'skip_raise')) ? 'constant' : nil))) {
        const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str")
      };
      
      if (!const_name || const_name[0] != const_name[0].toUpperCase()) {
        self.$raise($$$('NameError'), "wrong constant name " + (const_name))
      }
    ;
      return const_name;
    });
    $defs(self, '$pristine', function $$pristine(owner_class, $a) {
      var $post_args, method_names;

      
      $post_args = $slice(arguments, 1);
      method_names = $post_args;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype[Opal.jsid(method_name)];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, -2);
    var inspect_stack = [];
    return $defs(self, '$inspect', function $$inspect(value) {
      var e = nil;

      
      ;
      var pushed = false;
      
      return (function() { try {
      try {
        
        
        if (value === null) {
          // JS null value
          return 'null';
        }
        else if (value === undefined) {
          // JS undefined value
          return 'undefined';
        }
        else if (typeof value.$$class === 'undefined') {
          // JS object / other value that is not bridged
          return Object.prototype.toString.apply(value);
        }
        else if (typeof value.$inspect !== 'function' || value.$inspect.$$stub) {
          // BasicObject and friends
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else if (inspect_stack.indexOf(value.$__id__()) !== -1) {
          // inspect recursing inside inspect to find out about the
          // same object
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else {
          // anything supporting Opal
          inspect_stack.push(value.$__id__());
          pushed = true;
          return value.$inspect();
        }
      ;
        return nil;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {(e = $err)
          try {
            return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, -1);
  })('::')
};

Opal.modules["corelib/module"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $const_set = Opal.const_set, $Object = Opal.Object, $return_ivar = Opal.return_ivar, $assign_ivar = Opal.assign_ivar, $ivar = Opal.ivar, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $prop = Opal.prop, $jsid = Opal.jsid, $klass = Opal.klass, $defs = Opal.defs, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $Module = Opal.Module, $Kernel = Opal.Kernel, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $slice = Opal.slice, $to_a = Opal.to_a, $hash2 = Opal.hash2, $Opal = Opal.Opal, $return_val = Opal.return_val, $eqeq = Opal.eqeq, $lambda = Opal.lambda, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('module_eval,to_proc,===,raise,equal?,<,>,nil?,attr_reader,attr_writer,warn,attr_accessor,const_name?,class_variable_name!,pristine,const_name!,=~,new,inject,split,const_get,==,start_with?,!~,bind,call,class,frozen?,name,append_features,included,cover?,size,merge,compile,proc,any?,prepend_features,prepended,to_s,__id__,constants,include?,copy_class_variables,copy_constants,class_exec,module_exec,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    });
    
    $def(self, '$initialize', function $$initialize() {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    });
    
    $def(self, '$===', function $Module_$eq_eq_eq$1(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false
      };
      return Opal.is_a(object, self);;
    });
    
    $def(self, '$<', function $Module_$lt$2(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    });
    
    $def(self, '$<=', function $Module_$lt_eq$3(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    });
    
    $def(self, '$>', function $Module_$gt$4(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    });
    
    $def(self, '$>=', function $Module_$gt_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_gt(self, other)
      }
    });
    
    $def(self, '$<=>', function $Module_$lt_eq_gt$6(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if (!$eqeqeq($Module, other)) {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil
      };
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    });
    
    $def(self, '$alias_method', function $$alias_method(newname, oldname) {
      var self = this;

      
      $deny_frozen_access(self);
      newname = $coerce_to(newname, $$$('String'), 'to_str');
      oldname = $coerce_to(oldname, $$$('String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    });
    
    $def(self, '$alias_native', function $$alias_native(mid, jsid) {
      var self = this;

      
      if (jsid == null) jsid = mid;
      $deny_frozen_access(self);
      Opal.alias_native(self, mid, jsid);
      return self;
    }, -2);
    
    $def(self, '$ancestors', function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    });
    
    $def(self, '$append_features', function $$append_features(includer) {
      var self = this;

      
      $deny_frozen_access(includer);
      Opal.append_features(self, includer);
      return self;
    });
    
    $def(self, '$attr_accessor', function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      $send(self, 'attr_reader', $to_a(names));
      return $send(self, 'attr_writer', $to_a(names));
    }, -1);
    
    $def(self, '$attr', function $$attr($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], {"uplevel": 1}))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', $to_a(args));
    }, -1);
    
    $def(self, '$attr_reader', function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = $jsid(name),
            ivar = $ivar(name);

        var body = $return_ivar(ivar);

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$attr_writer', function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = $jsid(name + '='),
            ivar = $ivar(name);

        var body = $assign_ivar(ivar)

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$autoload', function $$autoload(const$, path) {
      var self = this;

      
      $deny_frozen_access(self);

      if (!$$('Opal')['$const_name?'](const$)) {
        $Kernel.$raise($$$('NameError'), "autoload must be constant name: " + (const$))
      }

      if (path == "") {
        $Kernel.$raise($$$('ArgumentError'), "empty file name")
      }

      if (!self.$$const.hasOwnProperty(const$)) {
        if (!self.$$autoload) {
          self.$$autoload = {};
        }
        Opal.const_cache_version++;
        self.$$autoload[const$] = { path: path, loaded: false, required: false, success: false, exception: false };

        if (self.$const_added && !self.$const_added.$$pristine) {
          self.$const_added(const$);
        }
      }
      return nil;
    
    });
    
    $def(self, '$autoload?', function $Module_autoload$ques$7(const$) {
      var self = this;

      
      if (self.$$autoload && self.$$autoload[const$] && !self.$$autoload[const$].required && !self.$$autoload[const$].success) {
        return self.$$autoload[const$].path;
      }

      var ancestors = self.$ancestors();

      for (var i = 0, length = ancestors.length; i < length; i++) {
        if (ancestors[i].$$autoload && ancestors[i].$$autoload[const$] && !ancestors[i].$$autoload[const$].required && !ancestors[i].$$autoload[const$].success) {
          return ancestors[i].$$autoload[const$].path;
        }
      }
      return nil;
    
    });
    
    $def(self, '$class_variables', function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    });
    
    $def(self, '$class_variable_get', function $$class_variable_get(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    });
    
    $def(self, '$class_variable_set', function $$class_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    });
    
    $def(self, '$class_variable_defined?', function $Module_class_variable_defined$ques$8(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    });
    
    $def(self, '$const_added', $return_val(nil));
    $Opal.$pristine(self, "const_added");
    
    $def(self, '$remove_class_variable', function $$remove_class_variable(name) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        $Kernel.$raise($$$('NameError'), "cannot remove " + (name) + " for " + (self))
      }
    ;
    });
    
    $def(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      return Opal.constants(self, inherit);;
    }, -1);
    $defs(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat($Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, -1);
    $defs(self, '$nesting', function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    });
    
    $def(self, '$const_defined?', function $Module_const_defined$ques$9(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([$Object]).concat(Opal.ancestors($Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) { return true; }
        if (
          module.$$autoload &&
          module.$$autoload[name] &&
          !module.$$autoload[name].required &&
          !module.$$autoload[name].success
        ) {
          return true;
        }
      }

      return false;
    ;
    }, -2);
    
    $def(self, '$const_get', function $$const_get(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], function $$10(o, c){
          
          if (o == null) o = nil;
          if (c == null) c = nil;
          return o.$const_get(c);})
      };
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return Opal.$$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, -2);
    
    $def(self, '$const_missing', function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      full_const_name = ($eqeq(self, $Object) ? (name) : ("" + (self) + "::" + (name)));
      return $Kernel.$raise($$$('NameError').$new("uninitialized constant " + (full_const_name), name));
    });
    
    $def(self, '$const_set', function $$const_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$const_name!'](name);
      if (($truthy(name['$!~']($$$($Opal, 'CONST_NAME_REGEXP'))) || ($truthy(name['$start_with?']("::"))))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      $const_set(self, name, value);
      return value;
    });
    
    $def(self, '$public_constant', $return_val(nil));
    
    $def(self, '$define_method', function $$define_method(name, method) {
      var block = $$define_method.$$p || nil, self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      $$define_method.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (method === undefined && block === nil)
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
    ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($eqeqeq($$$('Proc'), ($ret_or_2 = method)) ? (method) : ($eqeqeq($$$('Method'), $ret_or_2) ? (method.$to_proc().$$unbound) : ($eqeqeq($$$('UnboundMethod'), $ret_or_2) ? ($lambda(function $$11($a){var $post_args, args, self = $$11.$$s == null ? this : $$11.$$s, bound = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        bound = method.$bind(self);
        return $send(bound, 'call', $to_a(args));}, {$$arity: -1, $$s: self})) : ($Kernel.$raise($$$('TypeError'), "wrong argument type " + (block.$class()) + " (expected Proc/Method)"))))));
      
      if (typeof(Proxy) !== 'undefined') {
        var meta = Object.create(null)

        block.$$proxy_target = block
        block = new Proxy(block, {
          apply: function(target, self, args) {
            var old_name = target.$$jsid
            target.$$jsid = name;
            try {
              return target.apply(self, args);
            } catch(e) {
              if (e === target.$$brk || e === target.$$ret) return e.$v;
              throw e;
            } finally {
              target.$$jsid = old_name
            }
          }
        })
      }

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      return Opal.defn(self, $jsid(name), block);
    ;
    }, -2);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$base_module')) { $prop(self, '$$base_module', null); }

      return $freeze(self);
    ;
    });
    
    $def(self, '$remove_method', function $$remove_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        if (!(typeof name === "string" || name.$$is_string)) {
          self.$raise($$$('TypeError'), "" + (self.$name()) + " is not a symbol nor a string")
        }
        $deny_frozen_access(self);

        Opal.rdef(self, "$" + name);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$singleton_class?', function $Module_singleton_class$ques$12() {
      var self = this;

      return !!self.$$is_singleton;
    });
    
    $def(self, '$include', function $$include($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice(arguments);
      mods = $post_args;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$included_modules', function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    });
    
    $def(self, '$include?', function $Module_include$ques$13(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    });
    
    $def(self, '$instance_method', function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype[$jsid(name)];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$$('UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    });
    
    $def(self, '$instance_methods', function $$instance_methods(include_super) {
      var self = this;

      
      if (include_super == null) include_super = true;
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$included', $return_val(nil));
    
    $def(self, '$extended', $return_val(nil));
    
    $def(self, '$extend_object', function $$extend_object(object) {
      
      
      $deny_frozen_access(object);
      return nil;
    });
    
    $def(self, '$method_added', function $$method_added($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_removed', function $$method_removed($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_undefined', function $$method_undefined($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$module_eval', function $$module_eval($a) {
      var block = $$module_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$module_eval.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$s: self});
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "" + ("wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$module_exec', function $$module_exec($a) {
      var block = $$module_exec.$$p || nil, $post_args, args, self = this;

      $$module_exec.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (block === nil) {
        $Kernel.$raise($$$('LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$method_defined?', function $Module_method_defined$ques$15(method) {
      var self = this;

      
      var body = self.$$prototype[$jsid(method)];
      return (!!body) && !body.$$stub;
    
    });
    
    $def(self, '$module_function', function $$module_function($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      
      $deny_frozen_access(self);

      if (methods.length === 0) {
        self.$$module_function = true;
        return nil;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = $jsid(meth),
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
        return methods.length === 1 ? methods[0] : methods;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$name', function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === $Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    });
    
    $def(self, '$prepend', function $$prepend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice(arguments);
      mods = $post_args;
      
      if (mods.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$prepend_features', function $$prepend_features(prepender) {
      var self = this;

      
      
      $deny_frozen_access(prepender);

      if (!self.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    });
    
    $def(self, '$prepended', $return_val(nil));
    
    $def(self, '$remove_const', function $$remove_const(name) {
      var self = this;

      
      $deny_frozen_access(self);
      return Opal.const_remove(self, name);;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = Opal.Module.$name.call(self)))) {
        return $ret_or_1
      } else {
        return "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    });
    
    $def(self, '$undef_method', function $$undef_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        if (!(typeof name === "string" || name.$$is_string)) {
          self.$raise($$$('TypeError'), "" + (self.$name()) + " is not a symbol nor a string")
        }
        $deny_frozen_access(self);

        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    });
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this, copy = nil;

      $$dup.$$p = null;
      
      copy = $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    });
    
    $def(self, '$copy_class_variables', function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    });
    
    $def(self, '$copy_constants', function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        $const_set(self, name, other_constants[name]);
      }
    
    });
    
    $def(self, '$refine', function $$refine(klass) {
      var block = $$refine.$$p || nil, $a, self = this, refinement_module = nil, m = nil, klass_id = nil;

      $$refine.$$p = null;
      
      ;
      $a = [self, nil, nil], (refinement_module = $a[0]), (m = $a[1]), (klass_id = $a[2]), $a;
      
      klass_id = Opal.id(klass);
      if (typeof self.$$refine_modules === "undefined") {
        self.$$refine_modules = Object.create(null);
      }
      if (typeof self.$$refine_modules[klass_id] === "undefined") {
        m = self.$$refine_modules[klass_id] = $$$('Refinement').$new();
      }
      else {
        m = self.$$refine_modules[klass_id];
      }
      m.refinement_module = refinement_module
      m.refined_class = klass
    ;
      $send(m, 'class_exec', [], block.$to_proc());
      return m;
    });
    
    $def(self, '$refinements', function $$refinements() {
      var self = this;

      
      var refine_modules = self.$$refine_modules, hash = $hash2([], {});;
      if (typeof refine_modules === "undefined") return hash;
      for (var id in refine_modules) {
        hash['$[]='](refine_modules[id].refined_class, refine_modules[id]);
      }
      return hash;
    
    });
    
    $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("Module#using is not permitted in methods")
    });
    $alias(self, "class_eval", "module_eval");
    $alias(self, "class_exec", "module_exec");
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Refinement');

    var $proto = self.$$prototype;

    $proto.refinement_module = $proto.refined_class = nil;
    
    self.$attr_reader("refined_class");
    return $def(self, '$inspect', function $$inspect() {
      var $yield = $$inspect.$$p || nil, self = this;

      $$inspect.$$p = null;
      if ($truthy(self.refinement_module)) {
        return "#<refinement:" + (self.refined_class.$inspect()) + "@" + (self.refinement_module.$inspect()) + ">"
      } else {
        return $send2(self, $find_super(self, 'inspect', $$inspect, false, true), 'inspect', [], $yield)
      }
    });
  })('::', $Module);
};

Opal.modules["corelib/class"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $rb_plus = Opal.rb_plus, $return_val = Opal.return_val, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $Kernel = Opal.Kernel, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,class_eval,to_proc,+,subclasses,flatten,map,initialize_copy,allocate,name,to_s,raise');
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$new', function $Class_new$1(superclass) {
      var block = $Class_new$1.$$p || nil;

      $Class_new$1.$$p = null;
      
      ;
      if (superclass == null) superclass = $$('Object');
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      ((block !== nil) ? ($send((klass), 'class_eval', [], block.$to_proc())) : nil)
      return klass;
    ;
    }, -1);
    
    $def(self, '$allocate', function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    });
    
    $def(self, '$descendants', function $$descendants() {
      var self = this;

      return $rb_plus(self.$subclasses(), $send(self.$subclasses(), 'map', [], "descendants".$to_proc()).$flatten())
    });
    
    $def(self, '$inherited', $return_val(nil));
    
    $def(self, '$initialize_dup', function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    });
    
    $def(self, '$new', function $Class_new$2($a) {
      var block = $Class_new$2.$$p || nil, $post_args, args, self = this;

      $Class_new$2.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, -1);
    
    $def(self, '$subclasses', function $$subclasses() {
      var self = this;

      
      if (typeof WeakRef !== 'undefined') {
        var i, subclass, out = [];
        for (i = 0; i < self.$$subclasses.length; i++) {
          subclass = self.$$subclasses[i].deref();
          if (subclass !== undefined) {
            out.push(subclass);
          }
        }
        return out;
      }
      else {
        return self.$$subclasses;
      }
    
    });
    
    $def(self, '$superclass', function $$superclass() {
      var self = this;

      return self.$$super || nil;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var $yield = $$to_s.$$p || nil, self = this;

      $$to_s.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, $find_super(self, 'to_s', $$to_s, false, true), 'to_s', [], null);
    
    });
    
    $def(self, '$attached_object', function $$attached_object() {
      var self = this;

      
      if (self.$$singleton_of != null) {
        return self.$$singleton_of;
      }
      else {
        $Kernel.$raise($$$('TypeError'), "`" + (self) + "' is not a singleton class")
      }
    
    });
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
};

Opal.modules["corelib/basic_object"] = function(Opal) {/* Generated by Opal 1.7.3 */
  "use strict";
  var $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $alias = Opal.alias, $return_val = Opal.return_val, $Opal = Opal.Opal, $truthy = Opal.truthy, $range = Opal.range, $Kernel = Opal.Kernel, $to_a = Opal.to_a, $hash2 = Opal.hash2, $send = Opal.send, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('==,raise,inspect,pristine,!,nil?,cover?,size,merge,compile,proc,[],first,>=,length,instance_variable_get,any?,new,caller');
  return (function($base, $super) {
    var self = $klass($base, $super, 'BasicObject');

    
    
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$==', function $BasicObject_$eq_eq$1(other) {
      var self = this;

      return self === other;
    });
    
    $def(self, '$eql?', function $BasicObject_eql$ques$2(other) {
      var self = this;

      return self['$=='](other)
    });
    $alias(self, "equal?", "==");
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.prop(self, '$$id', Opal.uid());
      return self.$$id;
    
    });
    
    $def(self, '$__send__', function $$__send__(symbol, $a) {
      var block = $$__send__.$$p || nil, $post_args, args, self = this;

      $$__send__.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      
      if (!symbol.$$is_string) {
        self.$raise($$$('TypeError'), "" + (self.$inspect()) + " is not a symbol nor a string")
      }

      var func = self[Opal.jsid(symbol)];

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, -2);
    
    $def(self, '$!', $return_val(false));
    $Opal.$pristine("!");
    
    $def(self, '$!=', function $BasicObject_$not_eq$3(other) {
      var self = this;

      return self['$=='](other)['$!']()
    });
    
    $def(self, '$instance_eval', function $$instance_eval($a) {
      var block = $$instance_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$instance_eval.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$s: self});
      } else if ((($truthy(block['$nil?']()) && ($truthy($rb_ge(args.$length(), 1)))) && ($eqeq(args.$first()['$[]'](0), "@")))) {
        return self.$instance_variable_get(args.$first())
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$size()) + " for 0)")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$instance_exec', function $$instance_exec($a) {
      var block = $$instance_exec.$$p || nil, $post_args, args, self = this;

      $$instance_exec.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$singleton_method_added', function $$singleton_method_added($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_removed', function $$singleton_method_removed($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_undefined', function $$singleton_method_undefined($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(symbol, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this, inspect_result = nil;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      inspect_result = $Opal.$inspect(self);
      return $Kernel.$raise($$$('NoMethodError').$new("undefined method `" + (symbol) + "' for " + (inspect_result), symbol, args), nil, $Kernel.$caller(1));
    }, -2);
    $Opal.$pristine(self, "method_missing");
    return $def(self, '$respond_to_missing?', function $BasicObject_respond_to_missing$ques$5(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
  })('::', null)
};

Opal.modules["corelib/kernel"] = function(Opal) {/* Generated by Opal 1.7.3 */
  "use strict";
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $Opal = Opal.Opal, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $freeze_props = Opal.freeze_props, $jsid = Opal.jsid, $module = Opal.module, $return_val = Opal.return_val, $def = Opal.def, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $ensure_kwargs = Opal.ensure_kwargs, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $eqeqeq = Opal.eqeqeq, $return_self = Opal.return_self, $rb_le = Opal.rb_le, $extract_kwargs = Opal.extract_kwargs, $rb_lt = Opal.rb_lt, $Object = Opal.Object, $alias = Opal.alias, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('!,=~,==,object_id,raise,new,class,coerce_to?,<<,map,caller,nil?,allocate,copy_instance_variables,copy_singleton_methods,initialize_clone,frozen?,freeze,initialize_copy,define_method,singleton_class,to_proc,initialize_dup,for,empty?,pop,call,append_features,extend_object,extended,gets,__id__,include?,each,instance_variables,instance_variable_get,inspect,+,to_s,instance_variable_name!,respond_to?,to_int,coerce_to!,Integer,===,enum_for,result,any?,print,format,puts,<=,length,[],readline,<,first,split,to_str,exception,backtrace,rand,respond_to_missing?,pristine,try_convert!,expand_path,join,start_with?,new_seed,srand,tag,value,open,is_a?,__send__,yield_self,include');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$=~', $return_val(false));
    
    $def(self, '$!~', function $Kernel_$excl_tilde$1(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    });
    
    $def(self, '$===', function $Kernel_$eq_eq_eq$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    });
    
    $def(self, '$<=>', function $Kernel_$lt_eq_gt$3(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    });
    
    $def(self, '$method', function $$method(name) {
      var self = this;

      
      var meth = self[$jsid(name)];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$$('Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    });
    
    $def(self, '$methods', function $$methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$public_methods', function $$public_methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$Array', function $$Array(object) {
      
      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    });
    
    $def(self, '$at_exit', function $$at_exit() {
      var block = $$at_exit.$$p || nil, $ret_or_1 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      $$at_exit.$$p = null;
      
      ;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      $gvars.__at_exit__['$<<'](block);
      return block;
    });
    
    $def(self, '$caller', function $$caller(start, length) {
      
      
      if (start == null) start = 1;
      if (length == null) length = nil;
      
      var stack, result;

      stack = new Error().$backtrace();
      result = [];

      for (var i = start + 1, ii = stack.length; i < ii; i++) {
        if (!stack[i].match(/runtime\.js/)) {
          result.push(stack[i]);
        }
      }
      if (length != nil) result = result.slice(0, length);
      return result;
    ;
    }, -1);
    
    $def(self, '$caller_locations', function $$caller_locations($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($send(self, 'caller', $to_a(args)), 'map', [], function $$4(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);});
    }, -1);
    
    $def(self, '$class', function $Kernel_class$5() {
      var self = this;

      return self.$$class;
    });
    
    $def(self, '$copy_instance_variables', function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    });
    
    $def(self, '$copy_singleton_methods', function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta') && other.$$meta !== null) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    });
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + (freeze.$class()))
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, $hash2(["freeze"], {"freeze": freeze}));
      if (($eqeq(freeze, true) || (($truthy(freeze['$nil?']()) && ($truthy(self['$frozen?']())))))) {
        copy.$freeze()
      };
      return copy;
    }, -1);
    
    $def(self, '$initialize_clone', function $$initialize_clone(other, $kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = nil;
      self.$initialize_copy(other);
      return self;
    }, -2);
    
    $def(self, '$define_singleton_method', function $$define_singleton_method(name, method) {
      var block = $$define_singleton_method.$$p || nil, self = this;

      $$define_singleton_method.$$p = null;
      
      ;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$initialize_dup', function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    });
    
    $def(self, '$enum_for', function $$enum_for($a, $b) {
      var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

      $$enum_for.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      return $send($$$('Enumerator'), 'for', [self, method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$equal?', function $Kernel_equal$ques$6(other) {
      var self = this;

      return self === other;
    });
    
    $def(self, '$exit', function $$exit(status) {
      var $ret_or_1 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      if (status == null) status = true;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
      
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$$('Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, -1);
    
    $def(self, '$extend', function $$extend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice(arguments);
      mods = $post_args;
      
      if (mods.length == 0) {
        self.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      $deny_frozen_access(self);

      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (typeof(self) === "object") {
        $freeze_props(self);
        return $freeze(self);
      }
      return self;
    ;
    });
    
    $def(self, '$frozen?', function $Kernel_frozen$ques$7() {
      var self = this;

      
      switch (typeof(self)) {
      case "string":
      case "symbol":
      case "number":
      case "boolean":
        return true;
      case "object":
        return (self.$$frozen || false);
      default:
        return false;
      }
    
    });
    
    $def(self, '$gets', function $$gets($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'gets', $to_a(args));
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.$__id__()
    });
    
    $def(self, '$initialize_copy', $return_val(nil));
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, ivs = nil, id = nil, pushed = nil, e = nil;

      return (function() { try {
      try {
        
        ivs = "";
        id = self.$__id__();
        if ($truthy((inspect_stack)['$include?'](id))) {
          ivs = " ..."
        } else {
          
          (inspect_stack)['$<<'](id);
          pushed = true;
          $send(self.$instance_variables(), 'each', [], function $$8(i){var self = $$8.$$s == null ? this : $$8.$$s, ivar = nil, inspect = nil;

            
            if (i == null) i = nil;
            ivar = self.$instance_variable_get(i);
            inspect = $$('Opal').$inspect(ivar);
            return (ivs = $rb_plus(ivs, " " + (i) + "=" + (inspect)));}, {$$s: self});
        };
        return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + (ivs) + ">";
      } catch ($err) {
        if (Opal.rescue($err, [$$('StandardError')])) {(e = $err)
          try {
            return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        ($truthy(pushed) ? ((inspect_stack).$pop()) : nil)
      }; })()
    });
    
    $def(self, '$instance_of?', function $Kernel_instance_of$ques$9(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    });
    
    $def(self, '$instance_variable_defined?', function $Kernel_instance_variable_defined$ques$10(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    });
    
    $def(self, '$instance_variable_get', function $$instance_variable_get(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    });
    
    $def(self, '$instance_variable_set', function $$instance_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    });
    
    $def(self, '$remove_instance_variable', function $$remove_instance_variable(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return $Kernel.$raise($$$('NameError'), "instance variable " + (name) + " not defined");
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    });
    
    $def(self, '$Integer', function $$Integer(value, base) {
      
      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          $Kernel.$raise($$$('ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          $Kernel.$raise($$$('TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            $Kernel.$raise($$$('FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $Opal['$coerce_to!'](value, $$$('Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$$('Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
          // no-break
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
          // no-break
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
          // no-break
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
          // no-break
        }
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, -2);
    
    $def(self, '$Float', function $$Float(value) {
      
      
      var str;

      if (value === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return $Kernel.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $Opal['$coerce_to!'](value, $$$('Float'), "to_f");
    
    });
    
    $def(self, '$Hash', function $$Hash(arg) {
      
      
      if (($truthy(arg['$nil?']()) || ($eqeq(arg, [])))) {
        return $hash2([], {})
      };
      if ($eqeqeq($$$('Hash'), arg)) {
        return arg
      };
      return $Opal['$coerce_to!'](arg, $$$('Hash'), "to_hash");
    });
    
    $def(self, '$is_a?', function $Kernel_is_a$ques$11(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    });
    
    $def(self, '$itself', $return_self);
    
    $def(self, '$lambda', function $$lambda() {
      var block = $$lambda.$$p || nil;

      $$lambda.$$p = null;
      
      ;
      return Opal.lambda(block);;
    });
    
    $def(self, '$load', function $$load(file) {
      
      
      file = $Opal['$coerce_to!'](file, $$$('String'), "to_str");
      return Opal.load(file);
    });
    
    $def(self, '$loop', function $$loop() {
      var $yield = $$loop.$$p || nil, self = this, e = nil;

      $$loop.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["loop"], function $$12(){
          return $$$($$$('Float'), 'INFINITY')})
      };
      while ($truthy(true)) {
      
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$$('StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };
      };
      return self;
    });
    
    $def(self, '$nil?', $return_val(false));
    
    $def(self, '$printf', function $$printf($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', $to_a(args)))
      };
      return nil;
    }, -1);
    
    $def(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil;

      $$proc.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    });
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'puts', $to_a(strs));
    }, -1);
    
    $def(self, '$p', function $$p($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      $send(args, 'each', [], function $$13(obj){        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        if (obj == null) obj = nil;
        return $gvars.stdout.$puts(obj.$inspect());});
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, -1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'print', $to_a(strs));
    }, -1);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'readline', $to_a(args));
    }, -1);
    
    $def(self, '$warn', function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $c, $d, self = this, location = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      strs = $post_args;
      
      uplevel = $kwargs.$$smap["uplevel"];if (uplevel == null) uplevel = nil;
      if ($truthy(uplevel)) {
        
        uplevel = $Opal['$coerce_to!'](uplevel, $$$('Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "negative level (" + (uplevel) + ")")
        };
        location = ($c = ($d = self.$caller($rb_plus(uplevel, 1), 1).$first(), ($d === nil || $d == null) ? nil : $d.$split(":in `")), ($c === nil || $c == null) ? nil : $c.$first());
        if ($truthy(location)) {
          location = "" + (location) + ": "
        };
        strs = $send(strs, 'map', [], function $$14(s){
          
          if (s == null) s = nil;
          return "" + (location) + "warning: " + (s);});
      };
      if (($truthy($gvars.VERBOSE['$nil?']()) || ($truthy(strs['$empty?']())))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', $to_a(strs))
      };
    }, -1);
    
    $def(self, '$raise', function $$raise(exception, string, backtrace) {
            if ($gvars["!"] == null) $gvars["!"] = nil;
      if ($gvars["@"] == null) $gvars["@"] = nil;

      
      ;
      if (string == null) string = nil;
      if (backtrace == null) backtrace = nil;
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$$('RuntimeError').$new("");
      }
      else if ($respond_to(exception, '$to_str')) {
        exception = $$$('RuntimeError').$new(exception.$to_str());
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && $respond_to(exception, '$exception')) {
        exception = exception.$exception(string);
      }
      else if (exception.$$is_exception) {
        // exception is fine
      }
      else {
        exception = $$$('TypeError').$new("exception class/object expected");
      }

      if (backtrace !== nil) {
        exception.$set_backtrace(backtrace);
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;
      $gvars["@"] = (exception).$backtrace();

      throw exception;
    ;
    }, -1);
    
    $def(self, '$rand', function $$rand(max) {
      
      
      ;
      
      if (max === undefined) {
        return $$$($$$('Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$$('Random'), 'DEFAULT').$rand(max);
    }, -1);
    
    $def(self, '$respond_to?', function $Kernel_respond_to$ques$15(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      
      var body = self[$jsid(name)];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Kernel_respond_to_missing$ques$16(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
    $Opal.$pristine(self, "respond_to?", "respond_to_missing?");
    
    $def(self, '$require', function $$require(file) {
      
      
      // As Object.require refers to Kernel.require once Kernel has been loaded the String
      // class may not be available yet, the coercion requires both  String and Array to be loaded.
      if (typeof file !== 'string' && Opal.String && Opal.Array) {
        (file = $Opal['$coerce_to!'](file, $$$('String'), "to_str"))
      }
      return Opal.require(file)
    
    });
    
    $def(self, '$require_relative', function $$require_relative(file) {
      
      
      $Opal['$try_convert!'](file, $$$('String'), "to_str");
      file = $$$('File').$expand_path($$$('File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    });
    
    $def(self, '$require_tree', function $$require_tree(path, $kwargs) {
      var autoload;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      autoload = $kwargs.$$smap["autoload"];if (autoload == null) autoload = false;
      
      var result = [];

      path = $$$('File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          if(!autoload) {
            result.push([name, Opal.require(name)]);
          } else {
            result.push([name, true]); // do nothing, delegated to a autoloading
          }
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    });
    
    $def(self, '$sleep', function $$sleep(seconds) {
      
      
      if (seconds == null) seconds = nil;
      
      if (seconds === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        $Kernel.$raise($$$('ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, -1);
    
    $def(self, '$srand', function $$srand(seed) {
      
      
      if (seed == null) seed = $$('Random').$new_seed();
      return $$$('Random').$srand(seed);
    }, -1);
    
    $def(self, '$String', function $$String(str) {
      var $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $Opal['$coerce_to?'](str, $$$('String'), "to_str")))) {
        return $ret_or_1
      } else {
        return $Opal['$coerce_to!'](str, $$$('String'), "to_s")
      }
    });
    
    $def(self, '$tap', function $$tap() {
      var block = $$tap.$$p || nil, self = this;

      $$tap.$$p = null;
      
      ;
      Opal.yield1(block, self);
      return self;
    });
    
    $def(self, '$to_proc', $return_self);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    });
    
    $def(self, '$catch', function $Kernel_catch$17(tag) {
      var $yield = $Kernel_catch$17.$$p || nil, $ret_or_1 = nil, e = nil;

      $Kernel_catch$17.$$p = null;
      
      if (tag == null) tag = nil;
      try {
        
        tag = ($truthy(($ret_or_1 = tag)) ? ($ret_or_1) : ($Object.$new()));
        return Opal.yield1($yield, tag);;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('UncaughtThrowError')])) {(e = $err)
          try {
            
            if ($eqeq(e.$tag(), tag)) {
              return e.$value()
            };
            return $Kernel.$raise();
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };
    }, -1);
    
    $def(self, '$throw', function $Kernel_throw$18(tag, obj) {
      
      
      if (obj == null) obj = nil;
      return $Kernel.$raise($$$('UncaughtThrowError').$new(tag, obj));
    }, -2);
    
    $def(self, '$open', function $$open($a) {
      var block = $$open.$$p || nil, $post_args, args;

      $$open.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($$$('File'), 'open', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$yield_self', function $$yield_self() {
      var $yield = $$yield_self.$$p || nil, self = this;

      $$yield_self.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["yield_self"], $return_val(1))
      };
      return Opal.yield1($yield, self);;
    });
    $alias(self, "fail", "raise");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "object_id", "__id__");
    $alias(self, "public_send", "__send__");
    $alias(self, "send", "__send__");
    $alias(self, "then", "yield_self");
    return $alias(self, "to_enum", "enum_for");
  })('::', $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    
    delete $Object.$$prototype.$require;
    return self.$include($Kernel);
  })('::', null);
};

Opal.modules["corelib/main"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $return_val = Opal.return_val, $def = Opal.def, $Object = Opal.Object, $slice = Opal.slice, $Kernel = Opal.Kernel, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,raise');
  return (function(self, $parent_nesting) {
    
    
    
    $def(self, '$to_s', $return_val("main"));
    
    $def(self, '$include', function $$include(mod) {
      
      return $Object.$include(mod)
    });
    
    $def(self, '$autoload', function $$autoload($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return Opal.Object.$autoload.apply(Opal.Object, args);;
    }, -1);
    return $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("main.using is permitted only at toplevel")
    });
  })(Opal.get_singleton_class(self), $nesting)
};

Opal.modules["corelib/error/errno"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('+,errno,class,attr_reader');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting), errors = nil, klass = nil;

    
    errors = [["EINVAL", "Invalid argument", 22], ["EEXIST", "File exists", 17], ["EISDIR", "Is a directory", 21], ["EMFILE", "Too many open files", 24], ["ESPIPE", "Illegal seek", 29], ["EACCES", "Permission denied", 13], ["EPERM", "Operation not permitted", 1], ["ENOENT", "No such file or directory", 2], ["ENAMETOOLONG", "File name too long", 36]];
    klass = nil;
    
    var i;
    for (i = 0; i < errors.length; i++) {
      (function() { // Create a closure
        var class_name = errors[i][0];
        var default_message = errors[i][1];
        var errno = errors[i][2];

        klass = Opal.klass(self, Opal.SystemCallError, class_name);
        klass.errno = errno;

        (function(self, $parent_nesting) {
      
      return $def(self, '$new', function $new$1(name) {
        var $yield = $new$1.$$p || nil, self = this, message = nil;

        $new$1.$$p = null;
        
        if (name == null) name = nil;
        message = default_message;
        if ($truthy(name)) {
          message = $rb_plus(message, " - " + (name))
        };
        return $send2(self, $find_super(self, 'new', $new$1, false, true), 'new', [message], null);
      }, -1)
    })(Opal.get_singleton_class(klass), $nesting)
      })();
    }
  ;
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    
    
    $def(self, '$errno', function $$errno() {
      var self = this;

      return self.$class().$errno()
    });
    return (function(self, $parent_nesting) {
      
      return self.$attr_reader("errno")
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('StandardError'), $nesting);
};

Opal.modules["corelib/error"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $slice = Opal.slice, $gvars = Opal.gvars, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $Kernel = Opal.Kernel, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $Object = Opal.Object, $ensure_kwargs = Opal.ensure_kwargs, $send2 = Opal.send2, $find_super = Opal.find_super, $module = Opal.module, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,map,backtrace,clone,to_s,merge,tty?,[],include?,raise,dup,empty?,!,caller,shift,+,class,join,cause,full_message,==,reverse,split,autoload,attr_reader,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.message = nil;
    
    Opal.prop(self.$$prototype, '$$is_exception', true);
    var stack_trace_limit;
    Error.stackTraceLimit = 100;
    $defs(self, '$new', function $Exception_new$1($a) {
      var $post_args, args, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      error.cause   = $gvars["!"];
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, -1);
    stack_trace_limit = self.$new;
    $defs(self, '$exception', function $$exception($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, -1);
    
    // Convert backtrace from any format to Ruby format
    function correct_backtrace(backtrace) {
      var new_bt = [], m;

      for (var i = 0; i < backtrace.length; i++) {
        var loc = backtrace[i];
        if (!loc || !loc.$$is_string) {
          /* Do nothing */
        }
        /* Chromium format */
        else if ((m = loc.match(/^    at (.*?) \((.*?)\)$/))) {
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        }
        else if ((m = loc.match(/^    at (.*?)$/))) {
          new_bt.push(m[1] + ":in `undefined'");
        }
        /* Node format */
        else if ((m = loc.match(/^  from (.*?)$/))) {
          new_bt.push(m[1]);
        }
        /* Mozilla/Apple format */
        else if ((m = loc.match(/^(.*?)@(.*?)$/))) {
          new_bt.push(m[2] + ':in `' + m[1] + "'");
        }
      }

      return new_bt;
    }
  ;
    
    $def(self, '$backtrace', function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) !== 'undefined' && backtrace.$$is_string) {
        return self.backtrace = correct_backtrace(backtrace.split("\n"));
      }
      else if (backtrace) {
        return self.backtrace = correct_backtrace(backtrace);
      }

      return [];
    
    });
    
    $def(self, '$backtrace_locations', function $$backtrace_locations() {
      var $a, self = this;

      
      if (self.backtrace_locations) return self.backtrace_locations;
      self.backtrace_locations = ($a = self.$backtrace(), ($a === nil || $a == null) ? nil : $send($a, 'map', [], function $$2(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);}))
      return self.backtrace_locations;
    
    });
    
    $def(self, '$cause', function $$cause() {
      var self = this;

      return self.cause || nil;
    });
    
    $def(self, '$exception', function $$exception(str) {
      var self = this;

      
      if (str == null) str = nil;
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      if (self.backtrace) cloned.backtrace = self.backtrace.$dup();
      cloned.stack = self.stack;
      cloned.cause = self.cause;
      return cloned;
    ;
    }, -1);
    
    $def(self, '$message', function $$message() {
      var self = this;

      return self.$to_s()
    });
    
    $def(self, '$full_message', function $$full_message(kwargs) {
      var $a, $b, self = this, $ret_or_1 = nil, highlight = nil, order = nil, bold_underline = nil, bold = nil, reset = nil, bt = nil, first = nil, msg = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      if (kwargs == null) kwargs = nil;
      if (!$truthy((($a = $$('Hash', 'skip_raise')) ? 'constant' : nil))) {
        return "" + (self.message) + "\n" + (self.stack)
      };
      kwargs = $hash2(["highlight", "order"], {"highlight": $gvars.stderr['$tty?'](), "order": "top"}).$merge(($truthy(($ret_or_1 = kwargs)) ? ($ret_or_1) : ($hash2([], {}))));
      $b = [kwargs['$[]']("highlight"), kwargs['$[]']("order")], (highlight = $b[0]), (order = $b[1]), $b;
      if (!$truthy([true, false]['$include?'](highlight))) {
        $Kernel.$raise($$$('ArgumentError'), "expected true or false as highlight: " + (highlight))
      };
      if (!$truthy(["top", "bottom"]['$include?'](order))) {
        $Kernel.$raise($$$('ArgumentError'), "expected :top or :bottom as order: " + (order))
      };
      if ($truthy(highlight)) {
        
        bold_underline = "\u001b[1;4m";
        bold = "\u001b[1m";
        reset = "\u001b[m";
      } else {
        bold_underline = (bold = (reset = ""))
      };
      bt = self.$backtrace().$dup();
      if (($not(bt) || ($truthy(bt['$empty?']())))) {
        bt = self.$caller()
      };
      first = bt.$shift();
      msg = "" + (first) + ": ";
      msg = $rb_plus(msg, "" + (bold) + (self.$to_s()) + " (" + (bold_underline) + (self.$class()) + (reset) + (bold) + ")" + (reset) + "\n");
      msg = $rb_plus(msg, $send(bt, 'map', [], function $$3(loc){
        
        if (loc == null) loc = nil;
        return "\tfrom " + (loc) + "\n";}).$join());
      if ($truthy(self.$cause())) {
        msg = $rb_plus(msg, self.$cause().$full_message($hash2(["highlight"], {"highlight": highlight})))
      };
      if ($eqeq(order, "bottom")) {
        
        msg = msg.$split("\n").$reverse().$join("\n");
        msg = $rb_plus("" + (bold) + "Traceback" + (reset) + " (most recent call last):\n", msg);
      };
      return msg;
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    });
    
    $def(self, '$set_backtrace', function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = '  from ' + backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          $Kernel.$raise($$$('TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = $send((backtrace), 'map', [], function $$4(i){
        
        if (i == null) i = nil;
        return $rb_plus("  from ", i);}).join("\n");
      }

      return backtrace;
    
    });
    return $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.message)) ? (self.message.$to_s()) : ($ret_or_2))))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    });
  })('::', Error, $nesting);
  $klass('::', $$$('Exception'), 'ScriptError');
  $klass('::', $$$('ScriptError'), 'SyntaxError');
  $klass('::', $$$('ScriptError'), 'LoadError');
  $klass('::', $$$('ScriptError'), 'NotImplementedError');
  $klass('::', $$$('Exception'), 'SystemExit');
  $klass('::', $$$('Exception'), 'NoMemoryError');
  $klass('::', $$$('Exception'), 'SignalException');
  $klass('::', $$$('SignalException'), 'Interrupt');
  $klass('::', $$$('Exception'), 'SecurityError');
  $klass('::', $$$('Exception'), 'SystemStackError');
  $klass('::', $$$('Exception'), 'StandardError');
  $klass('::', $$$('StandardError'), 'EncodingError');
  $klass('::', $$$('StandardError'), 'ZeroDivisionError');
  $klass('::', $$$('StandardError'), 'NameError');
  $klass('::', $$$('NameError'), 'NoMethodError');
  $klass('::', $$$('StandardError'), 'RuntimeError');
  $klass('::', $$$('RuntimeError'), 'FrozenError');
  $klass('::', $$$('StandardError'), 'LocalJumpError');
  $klass('::', $$$('StandardError'), 'TypeError');
  $klass('::', $$$('StandardError'), 'ArgumentError');
  $klass('::', $$$('ArgumentError'), 'UncaughtThrowError');
  $klass('::', $$$('StandardError'), 'IndexError');
  $klass('::', $$$('IndexError'), 'StopIteration');
  $klass('::', $$$('StopIteration'), 'ClosedQueueError');
  $klass('::', $$$('IndexError'), 'KeyError');
  $klass('::', $$$('StandardError'), 'RangeError');
  $klass('::', $$$('RangeError'), 'FloatDomainError');
  $klass('::', $$$('StandardError'), 'IOError');
  $klass('::', $$$('IOError'), 'EOFError');
  $klass('::', $$$('StandardError'), 'SystemCallError');
  $klass('::', $$$('StandardError'), 'RegexpError');
  $klass('::', $$$('StandardError'), 'ThreadError');
  $klass('::', $$$('StandardError'), 'FiberError');
  $Object.$autoload("Errno", "corelib/error/errno");
  (function($base, $super) {
    var self = $klass($base, $super, 'FrozenError');

    
    
    self.$attr_reader("receiver");
    return $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $kwargs.$$smap["receiver"];if (receiver == null) receiver = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.receiver = receiver);
    }, -2);
  })('::', $$$('RuntimeError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $proto = self.$$prototype;

    $proto.tag = nil;
    
    self.$attr_reader("tag", "value");
    return $def(self, '$initialize', function $$initialize(tag, value) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (value == null) value = nil;
      self.tag = tag;
      self.value = value;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', ["uncaught throw " + (self.tag.$inspect())], null);
    }, -2);
  })('::', $$$('ArgumentError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'NameError');

    
    
    self.$attr_reader("name");
    return $def(self, '$initialize', function $$initialize(message, name) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NoMethodError');

    
    
    self.$attr_reader("args");
    return $def(self, '$initialize', function $$initialize(message, name, args) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      if (args == null) args = [];
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'StopIteration');

    
    return self.$attr_reader("result")
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'KeyError');

    var $proto = self.$$prototype;

    $proto.receiver = $proto.key = nil;
    
    
    $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, key, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $kwargs.$$smap["receiver"];if (receiver == null) receiver = nil;
      
      key = $kwargs.$$smap["key"];if (key == null) key = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, -2);
    
    $def(self, '$receiver', function $$receiver() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.receiver))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no receiver is available")
      }
    });
    return $def(self, '$key', function $$key() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.key))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no key is available")
      }
    });
  })('::', null);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    return ($klass($nesting[0], null, 'Error'), nil)
  })('::', $nesting);
};

Opal.modules["corelib/constants"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $const_set = Opal.const_set, nil = Opal.nil, $$$ = Opal.$$$;

  
  $const_set('::', 'RUBY_PLATFORM', "opal");
  $const_set('::', 'RUBY_ENGINE', "opal");
  $const_set('::', 'RUBY_VERSION', "3.2.0");
  $const_set('::', 'RUBY_ENGINE_VERSION', "1.7.3");
  $const_set('::', 'RUBY_RELEASE_DATE', "2023-03-23");
  $const_set('::', 'RUBY_PATCHLEVEL', 0);
  $const_set('::', 'RUBY_REVISION', "0");
  $const_set('::', 'RUBY_COPYRIGHT', "opal - Copyright (C) 2011-2023 Adam Beynon and the Opal contributors");
  return $const_set('::', 'RUBY_DESCRIPTION', "opal " + ($$$('RUBY_ENGINE_VERSION')) + " (" + ($$$('RUBY_RELEASE_DATE')) + " revision " + ($$$('RUBY_REVISION')) + ")");
};

Opal.modules["opal/base"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("corelib/runtime");
  $Object.$require("corelib/helpers");
  $Object.$require("corelib/module");
  $Object.$require("corelib/class");
  $Object.$require("corelib/basic_object");
  $Object.$require("corelib/kernel");
  $Object.$require("corelib/main");
  $Object.$require("corelib/error");
  return $Object.$require("corelib/constants");
};

Opal.modules["corelib/nil"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_val = Opal.return_val, $ensure_kwargs = Opal.ensure_kwargs, $NilClass = Opal.NilClass, $slice = Opal.slice, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,new,>,length,Rational,to_i');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$!', $return_val(true));
    
    $def(self, '$&', $return_val(false));
    
    $def(self, '$|', function $NilClass_$$1(other) {
      
      return other !== false && other !== nil;
    });
    
    $def(self, '$^', function $NilClass_$$2(other) {
      
      return other !== false && other !== nil;
    });
    
    $def(self, '$==', function $NilClass_$eq_eq$3(other) {
      
      return other === nil;
    });
    
    $def(self, '$dup', $return_val(nil));
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = true;
      return nil;
    }, -1);
    
    $def(self, '$inspect', $return_val("nil"));
    
    $def(self, '$nil?', $return_val(true));
    
    $def(self, '$singleton_class', function $$singleton_class() {
      
      return $NilClass
    });
    
    $def(self, '$to_a', function $$to_a() {
      
      return []
    });
    
    $def(self, '$to_h', function $$to_h() {
      
      return Opal.hash();
    });
    
    $def(self, '$to_i', $return_val(0));
    
    $def(self, '$to_s', $return_val(""));
    
    $def(self, '$to_c', function $$to_c() {
      
      return $$$('Complex').$new(0, 0)
    });
    
    $def(self, '$rationalize', function $$rationalize($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy($rb_gt(args.$length(), 1))) {
        $Kernel.$raise($$$('ArgumentError'))
      };
      return $Kernel.$Rational(0, 1);
    }, -1);
    
    $def(self, '$to_r', function $$to_r() {
      
      return $Kernel.$Rational(0, 1)
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    });
    return $alias(self, "to_f", "to_i");
  })('::', null, $nesting)
};

Opal.modules["corelib/boolean"] = function(Opal) {/* Generated by Opal 1.7.3 */
  "use strict";
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_self = Opal.return_self, $ensure_kwargs = Opal.ensure_kwargs, $slice = Opal.slice, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,==,to_s,__id__');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.prop(self.$$prototype, '$$is_boolean', true);
    
    var properties = ['$$class', '$$meta'];

    for (var i = 0; i < properties.length; i++) {
      Object.defineProperty(self.$$prototype, properties[i], {
        configurable: true,
        enumerable: false,
        get: function() {
          return this == true  ? Opal.TrueClass :
                 this == false ? Opal.FalseClass :
                                 Opal.Boolean;
        }
      });
    }

    Object.defineProperty(self.$$prototype, "$$id", {
      configurable: true,
      enumerable: false,
      get: function() {
        return this == true  ? 2 :
               this == false ? 0 :
                               nil;
      }
    });
  ;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    });
    
    $def(self, '$!', function $Boolean_$excl$1() {
      var self = this;

      return self != true;
    });
    
    $def(self, '$&', function $Boolean_$$2(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    });
    
    $def(self, '$|', function $Boolean_$$3(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    });
    
    $def(self, '$^', function $Boolean_$$4(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    });
    
    $def(self, '$==', function $Boolean_$eq_eq$5(other) {
      var self = this;

      return (self == true) === other.valueOf();
    });
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return self.$$meta;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    });
    
    $def(self, '$dup', $return_self);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(method, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      var body = self.$$class.$$prototype[Opal.jsid(method)];
      if (!$truthy(typeof body !== 'undefined' && !body.$$stub)) {
        $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [method].concat($to_a(args)), block)
      };
      return Opal.send(self, body, args, block);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Boolean_respond_to_missing$ques$6(method, _include_all) {
      var self = this;

      
      if (_include_all == null) _include_all = false;
      var body = self.$$class.$$prototype[Opal.jsid(method)];
      return typeof body !== 'undefined' && !body.$$stub;;
    }, -2);
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "==");
    $alias(self, "inspect", "to_s");
    return $alias(self, "object_id", "__id__");
  })('::', Boolean, $nesting);
  $klass('::', $$$('Boolean'), 'TrueClass');
  return ($klass('::', $$$('Boolean'), 'FalseClass'), nil);
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $def = Opal.def, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        self.$$comparable = false;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    });
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    });
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    });
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    });
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    });
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false
      };
      if ($rb_gt(self, max)) {
        return false
      };
      return true;
    });
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      if (max == null) max = nil;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/regexp"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $coerce_to = Opal.coerce_to, $prop = Opal.prop, $freeze = Opal.freeze, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $slice = Opal.slice, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $alias = Opal.alias, $send = Opal.send, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $ensure_kwargs = Opal.ensure_kwargs, $rb_ge = Opal.rb_ge, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('nil?,[],raise,escape,options,to_str,new,join,coerce_to!,!,match,coerce_to?,begin,frozen?,uniq,map,scan,source,to_proc,transform_values,group_by,each_with_index,+,last,=~,==,attr_reader,>=,length,is_a?,include?,names,regexp,named_captures,===,captures,-,inspect,empty?,each,to_a');
  
  $klass('::', $$$('StandardError'), 'RegexpError');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'IGNORECASE', 1);
    $const_set(self, 'EXTENDED', 2);
    $const_set(self, 'MULTILINE', 4);
    Opal.prop(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var $yield = $$allocate.$$p || nil, self = this, allocated = nil;

        $$allocate.$$p = null;
        
        allocated = $send2(self, $find_super(self, 'allocate', $$allocate, false, true), 'allocate', [], $yield);
        allocated.uninitialized = true;
        return allocated;
      });
      
      $def(self, '$escape', function $$escape(string) {
        
        return Opal.escape_regexp(string);
      });
      
      $def(self, '$last_match', function $$last_match(n) {
                if ($gvars["~"] == null) $gvars["~"] = nil;

        
        if (n == null) n = nil;
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else if ($truthy($gvars["~"])) {
          return $gvars["~"]['$[]'](n)
        } else {
          return nil
        };
      }, -1);
      
      $def(self, '$union', function $$union($a) {
        var $post_args, parts, self = this;

        
        $post_args = $slice(arguments);
        parts = $post_args;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              $Kernel.$raise($$$('TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, -1);
      
      $def(self, '$new', function $new$1(regexp, options) {
        
        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $Opal['$coerce_to!'](regexp, $$$('String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          $Kernel.$raise($$$('RegexpError'), "too short escape sequence: /" + (regexp) + "/")
        }

        regexp = regexp.replace('\\A', '^').replace('\\z', '$')

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$('IGNORECASE') & options) { temp += 'i'; }
          if ($$('MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, -2);
      $alias(self, "compile", "new");
      return $alias(self, "quote", "escape");
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$==', function $Regexp_$eq_eq$2(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    });
    
    $def(self, '$===', function $Regexp_$eq_eq_eq$3(string) {
      var self = this;

      return self.$match($Opal['$coerce_to?'](string, $$$('String'), "to_str")) !== nil
    });
    
    $def(self, '$=~', function $Regexp_$eq_tilde$4(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$g')) { $prop(self, '$$g', null); }
      if (!self.hasOwnProperty('$$gm')) { $prop(self, '$$gm', null); }

      return $freeze(self);
    ;
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    });
    
    $def(self, '$match', function $$match(string, pos) {
      var block = $$match.$$p || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      $$match.$$p = null;
      
      ;
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$$('String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$$('MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$$('MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, -2);
    
    $def(self, '$match?', function $Regexp_match$ques$5(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$$('String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, -2);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return $send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$uniq()
    });
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this;

      return $send($send($send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$each_with_index(), 'group_by', [], "first".$to_proc()), 'transform_values', [], function $$6(i){
        
        if (i == null) i = nil;
        return $send(i, 'map', [], function $$7(j){
          
          if (j == null) j = nil;
          return $rb_plus(j.$last(), 1);});})
    });
    
    $def(self, '$~', function $Regexp_$$8() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    });
    
    $def(self, '$source', function $$source() {
      var self = this;

      return self.source;
    });
    
    $def(self, '$options', function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$('MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$('IGNORECASE');
      }
      return result;
    
    });
    
    $def(self, '$casefold?', function $Regexp_casefold$ques$9() {
      var self = this;

      return self.ignoreCase;
    });
    $alias(self, "eql?", "==");
    return $alias(self, "to_s", "source");
  })('::', RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    $def(self, '$initialize', function $$initialize(regexp, match_groups, $kwargs) {
      var no_matchdata, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];if (no_matchdata == null) no_matchdata = false;
      if (!$truthy(no_matchdata)) {
        $gvars["~"] = self
      };
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, -3);
    
    $def(self, '$match', function $$match(idx) {
      var self = this, match = nil;

      if ($truthy((match = self['$[]'](idx)))) {
        return match
      } else if (($truthy(idx['$is_a?']($$('Integer'))) && ($truthy($rb_ge(idx, self.$length()))))) {
        return $Kernel.$raise($$$('IndexError'), "index " + (idx) + " out of matches")
      } else {
        return nil
      }
    });
    
    $def(self, '$match_length', function $$match_length(idx) {
      var $a, self = this;

      return ($a = self.$match(idx), ($a === nil || $a == null) ? nil : $a.$length())
    });
    
    $def(self, '$[]', function $MatchData_$$$10($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (args[0].$$is_string) {
        if (self.$regexp().$names()['$include?'](args['$[]'](0))['$!']()) {
          $Kernel.$raise($$$('IndexError'), "undefined group name reference: " + (args['$[]'](0)))
        }
        return self.$named_captures()['$[]'](args['$[]'](0))
      }
      else {
        return $send(self.matches, '[]', $to_a(args))
      }
    ;
    }, -1);
    
    $def(self, '$offset', function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    });
    
    $def(self, '$==', function $MatchData_$eq_eq$11(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

      
      if (!$eqeqeq($$$('MatchData'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.string == other.string)) ? (self.regexp.toString() == other.regexp.toString()) : ($ret_or_4)))) ? (self.pre_match == other.pre_match) : ($ret_or_3)))) ? (self.post_match == other.post_match) : ($ret_or_2))))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$begin', function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    });
    
    $def(self, '$end', function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    });
    
    $def(self, '$captures', function $$captures() {
      var self = this;

      return self.matches.slice(1)
    });
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this, matches = nil;

      
      matches = self.$captures();
      return $send(self.$regexp().$named_captures(), 'transform_values', [], function $$12(i){
        
        if (i == null) i = nil;
        return matches['$[]']($rb_minus(i.$last(), 1));});
    });
    
    $def(self, '$names', function $$names() {
      var self = this;

      return self.$regexp().$names()
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      if (self.$regexp().$names()['$empty?']()) {
        for (var i = 1, length = self.matches.length; i < length; i++) {
          str += " " + i + ":" + (self.matches[i]).$inspect();
        }
      }
      else {
        $send(self.$named_captures(), 'each', [], function $$13(k, v){
        
        if (k == null) k = nil;
        if (v == null) v = nil;
        return                str += " " + k + ":" + v.$inspect();})
      }

      return str + ">";
    
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.matches.length
    });
    
    $def(self, '$to_a', $return_ivar("matches"));
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.matches[0]
    });
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $Opal['$coerce_to!'](args[i], $$$('Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, -1);
    $alias(self, "eql?", "==");
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/string"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $global_multiline_regexp = Opal.global_multiline_regexp, $prop = Opal.prop, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $defs = Opal.defs, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $gvars = Opal.gvars, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $alias = Opal.alias, $const_set = Opal.const_set, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,initialize,===,format,raise,respond_to?,to_s,to_str,<=>,==,=~,new,force_encoding,casecmp,empty?,ljust,ceil,/,+,rjust,floor,coerce_to!,nil?,class,copy_singleton_methods,initialize_clone,initialize_dup,enum_for,chomp,[],to_i,length,each_line,to_proc,to_a,match,match?,captures,proc,succ,escape,include?,upcase,unicode_normalize,dup,__id__,next,intern,pristine');
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    Opal.prop(self.$$prototype, '$$is_string', true);
  ;
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.toString();
    });
    $defs(self, '$try_convert', function $$try_convert(what) {
      
      return $Opal['$coerce_to?'](what, $$$('String'), "to_str")
    });
    $defs(self, '$new', function $String_new$1($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$$('String'), 'to_str');
      if (opts && opts.$$is_hash) {
        if (opts.$$smap.encoding) str = str.$force_encoding(opts.$$smap.encoding);
      }
      str = new self.$$constructor(str);
      if (!str.$initialize.$$pristine) $send((str), 'initialize', $to_a(args));
      return str;
    ;
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) str = $post_args.shift();;
      
      encoding = $kwargs.$$smap["encoding"];if (encoding == null) encoding = nil;
      
      capacity = $kwargs.$$smap["capacity"];if (capacity == null) capacity = nil;
      return nil;
    }, -1);
    
    $def(self, '$%', function $String_$percent$2(data) {
      var self = this;

      if ($eqeqeq($$$('Array'), data)) {
        return $send(self, 'format', [self].concat($to_a(data)))
      } else {
        return self.$format(self, data)
      }
    });
    
    $def(self, '$*', function $String_$$3(count) {
      var self = this;

      
      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return '';
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        $Kernel.$raise($$$('RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return result;
    
    });
    
    $def(self, '$+', function $String_$plus$4(other) {
      var self = this;

      
      other = $coerce_to(other, $$$('String'), 'to_str');
      
      if (other == "" && self.$$class === Opal.String) return self;
      if (self == "" && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    });
    
    $def(self, '$<=>', function $String_$lt_eq_gt$5(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    });
    
    $def(self, '$==', function $String_$eq_eq$6(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    });
    
    $def(self, '$=~', function $String_$eq_tilde$7(other) {
      var self = this;

      
      if (other.$$is_string) {
        $Kernel.$raise($$$('TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    });
    
    $def(self, '$[]', function $String_$$$8(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude, range;

      if (index.$$is_range) {
        exclude = index.excl;
        range   = index;
        length  = index.end === nil ? -1 : $coerce_to(index.end, $$$('Integer'), 'to_int');
        index   = index.begin === nil ? 0 : $coerce_to(index.begin, $$$('Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude || range.end === nil) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.substr(index, length);
      }


      if (index.$$is_string) {
        if (length != null) {
          $Kernel.$raise($$$('TypeError'))
        }
        return self.indexOf(index) !== -1 ? index : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$$('MatchData').$new(index, match))

        if (length == null) {
          return match[0];
        }

        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return match[length += match.length];
        }

        if (length >= 0 && length < match.length) {
          return match[length];
        }

        return nil;
      }


      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.substr(index, 1);
      }

      length = $coerce_to(length, $$$('Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.substr(index, length);
    ;
    }, -2);
    
    $def(self, '$b', function $$b() {
      var self = this;

      return (new String(self)).$force_encoding("binary")
    });
    
    $def(self, '$capitalize', function $$capitalize() {
      var self = this;

      return self.charAt(0).toUpperCase() + self.substr(1).toLowerCase();
    });
    
    $def(self, '$casecmp', function $$casecmp(other) {
      var self = this;

      
      if (!$truthy(other['$respond_to?']("to_str"))) {
        return nil
      };
      other = ($coerce_to(other, $$$('String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    });
    
    $def(self, '$casecmp?', function $String_casecmp$ques$9(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    });
    
    $def(self, '$center', function $$center(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return rjustified + ljustified.slice(self.length);
    ;
    }, -2);
    
    $def(self, '$chomp', function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      if ($truthy(separator === nil || self.length === 0)) {
        return self
      };
      separator = $Opal['$coerce_to!'](separator, $$$('String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return result;
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$chop', function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return result;
    
    });
    
    $def(self, '$chr', function $$chr() {
      var self = this;

      return self.charAt(0);
    });
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + (freeze.$class()))
      };
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, $hash2(["freeze"], {"freeze": freeze}));
      if ($eqeq(freeze, true)) {
        if (!copy.$$frozen) { copy.$$frozen = true; }
      } else if ($truthy(freeze['$nil?']())) {
        if (self.$$frozen) { copy.$$frozen = true; }
      };
      return copy;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$count', function $$count($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, -1);
    
    $def(self, '$delete', function $String_delete$10($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp(char_class, 'g'), '');
    ;
    }, -1);
    
    $def(self, '$delete_prefix', function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$$('String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.slice(prefix.length);
      } else {
        return self;
      }
    
    });
    
    $def(self, '$delete_suffix', function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$$('String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.slice(0, self.length - suffix.length);
      } else {
        return self;
      }
    
    });
    
    $def(self, '$downcase', function $$downcase() {
      var self = this;

      return self.toLowerCase();
    });
    
    $def(self, '$each_line', function $$each_line($a, $b) {
      var block = $$each_line.$$p || nil, $post_args, $kwargs, separator, chomp, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each_line.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $kwargs.$$smap["chomp"];if (chomp == null) chomp = false;
      if (!(block !== nil)) {
        return self.$enum_for("each_line", separator, $hash2(["chomp"], {"chomp": chomp}))
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$$('String'), 'to_str');

      var a, i, n, length, chomped, trailing, splitted, value;

      if (separator.length === 0) {
        for (a = self.split(/((?:\r?\n){2})(?:(?:\r?\n)*)/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            value = (a[i] || "") + (a[i + 1] || "");
            if (chomp) {
              value = (value).$chomp("\n");
            }
            Opal.yield1(block, value);
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        value = splitted[i];
        if (i < length - 1 || trailing) {
          value += separator;
        }
        if (chomp) {
          value = (value).$chomp(separator);
        }
        Opal.yield1(block, value);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$empty?', function $String_empty$ques$11() {
      var self = this;

      return self.length === 0;
    });
    
    $def(self, '$end_with?', function $String_end_with$ques$12($a) {
      var $post_args, suffixes, self = this;

      
      $post_args = $slice(arguments);
      suffixes = $post_args;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$$('String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, -1);
    
    $def(self, '$gsub', function $$gsub(pattern, replacement) {
      var block = $$gsub.$$p || nil, self = this;

      $$gsub.$$p = null;
      
      ;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$$('MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$$('String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return result;
    ;
    }, -2);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.toString();
    });
    
    $def(self, '$hex', function $$hex() {
      var self = this;

      return self.$to_i(16)
    });
    
    $def(self, '$include?', function $String_include$ques$13(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$$('String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    });
    
    $def(self, '$index', function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = $global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$$('MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, -2);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      /* eslint-disable no-misleading-character-class */
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
              return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
      /* eslint-enable no-misleading-character-class */
    
    });
    
    $def(self, '$intern', function $$intern() {
      var self = this;

      return self.toString();
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    });
    $alias(self, "size", "length");
    
    $def(self, '$lines', function $$lines($a, $b) {
      var block = $$lines.$$p || nil, $post_args, $kwargs, separator, chomp, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$lines.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $kwargs.$$smap["chomp"];if (chomp == null) chomp = false;
      e = $send(self, 'each_line', [separator, $hash2(["chomp"], {"chomp": chomp})], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, -1);
    
    $def(self, '$ljust', function $$ljust(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self + result.slice(0, width);
    ;
    }, -2);
    
    $def(self, '$lstrip', function $$lstrip() {
      var self = this;

      return self.replace(/^[\u0000\s]*/, '');
    });
    
    $def(self, '$ascii_only?', function $String_ascii_only$ques$14() {
      var self = this;

      
      if (!self.encoding.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    });
    
    $def(self, '$match', function $$match(pattern, pos) {
      var block = $$match.$$p || nil, self = this;

      $$match.$$p = null;
      
      ;
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, -2);
    
    $def(self, '$match?', function $String_match$ques$15(pattern, pos) {
      var self = this;

      
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, -2);
    
    $def(self, '$next', function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return '';
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return result;
    
    });
    
    $def(self, '$oct', function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    });
    
    $def(self, '$ord', function $$ord() {
      var self = this;

      
      if (typeof self.codePointAt === "function") {
        return self.codePointAt(0);
      }
      else {
        return self.charCodeAt(0);
      }
    
    });
    
    $def(self, '$partition', function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    });
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    });
    
    $def(self, '$rindex', function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, -2);
    
    $def(self, '$rjust', function $$rjust(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return result + padstr.slice(0, remaining) + self;
    ;
    }, -2);
    
    $def(self, '$rpartition', function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    });
    
    $def(self, '$rstrip', function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    });
    
    $def(self, '$scan', function $$scan(pattern, $kwargs) {
      var block = $$scan.$$p || nil, no_matchdata, self = this;

      $$scan.$$p = null;
      
      ;
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];if (no_matchdata == null) no_matchdata = false;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$$('MatchData').$new(pattern, match, $hash2(["no_matchdata"], {"no_matchdata": no_matchdata}));
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? Opal.yield1(block, match[0]) : Opal.yield1(block, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      if (!no_matchdata) ($gvars["~"] = match_data);

      return (block !== nil ? self : result);
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    });
    
    $def(self, '$split', function $$split(pattern, limit) {
      var self = this, $ret_or_1 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy(($ret_or_1 = $gvars[";"])) ? ($ret_or_1) : (" "));
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str').$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [result[0]];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        return result;
      }

      if (limit >= result.length) {
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      return result;
    ;
    }, -1);
    
    $def(self, '$squeeze', function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        return self.replace(/(.)\1+/g, '$1');
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1');
    ;
    }, -1);
    
    $def(self, '$start_with?', function $String_start_with$ques$16($a) {
      var $post_args, prefixes, self = this;

      
      $post_args = $slice(arguments);
      prefixes = $post_args;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$$('MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          var prefix = $coerce_to(prefixes[i], $$$('String'), 'to_str').$to_s();

          if (self.indexOf(prefix) === 0) {
            return true;
          }
        }
      }

      return false;
    ;
    }, -1);
    
    $def(self, '$strip', function $$strip() {
      var self = this;

      return self.replace(/^[\s\u0000]*|[\s\u0000]*$/g, '');
    });
    
    $def(self, '$sub', function $$sub(pattern, replacement) {
      var block = $$sub.$$p || nil, self = this;

      $$sub.$$p = null;
      
      ;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$$('MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$$('String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$sum', function $$sum(n) {
      var self = this;

      
      if (n == null) n = 16;
      
      n = $coerce_to(n, $$$('Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, -1);
    
    $def(self, '$swapcase', function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      return str;
    
    });
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    });
    
    $def(self, '$to_i', function $$to_i(base) {
      var self = this;

      
      if (base == null) base = 10;
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$$('Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, -1);
    
    $def(self, '$to_proc', function $$to_proc() {
      var $yield = $$to_proc.$$p || nil, self = this, method_name = nil, jsid = nil, proc = nil;

      $$to_proc.$$p = null;
      
      method_name = self.valueOf();
      jsid = Opal.jsid(method_name);
      proc = $send($Kernel, 'proc', [], function $$17($a){var block = $$17.$$p || nil, $post_args, args;

        $$17.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        
        if (args.length === 0) {
          $Kernel.$raise($$$('ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[jsid];

        if (!body) {
          body = recv.$method_missing;
          args[0] = method_name;
        } else {
          args = args.slice(1);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 0) {
          return body.call(recv);
        } else {
          return body.apply(recv, args);
        }
      ;}, -1);
      proc.$$source_location = nil;
      return proc;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.toString();
    });
    
    $def(self, '$tr', function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return new_str;
    
    });
    
    $def(self, '$tr_s', function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return new_str;
    
    });
    
    $def(self, '$upcase', function $$upcase() {
      var self = this;

      return self.toUpperCase();
    });
    
    $def(self, '$upto', function $$upto(stop, excl) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (excl == null) excl = false;
      if (!(block !== nil)) {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$$('String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$$('String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$$('Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$$('Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    });
    $defs(self, '$_load', function $$_load($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$unicode_normalize', function $$unicode_normalize(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      if (!$truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
        $Kernel.$raise($$$('ArgumentError'), "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, -1);
    
    $def(self, '$unicode_normalized?', function $String_unicode_normalized$ques$18(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      return self.$unicode_normalize(form)['$=='](self);
    }, -1);
    
    $def(self, '$unpack', function $$unpack(format) {
      
      return $Kernel.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    });
    
    $def(self, '$unpack1', function $$unpack1(format) {
      
      return $Kernel.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    });
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') { return self; }
      $prop(self, "$$frozen", true);
      return self;
    
    });
    
    $def(self, '$-@', function $String_$minus$$19() {
      var self = this;

      
      if (typeof self === 'string') return self;
      if (self.$$frozen) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    });
    
    $def(self, '$frozen?', function $String_frozen$ques$20() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    });
    $alias(self, "+@", "dup");
    $alias(self, "===", "==");
    $alias(self, "byteslice", "[]");
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "===");
    $alias(self, "object_id", "__id__");
    $alias(self, "slice", "[]");
    $alias(self, "succ", "next");
    $alias(self, "to_str", "to_s");
    $alias(self, "to_sym", "intern");
    return $Opal.$pristine(self, "initialize");
  })('::', String, $nesting);
  return $const_set($nesting[0], 'Symbol', $$('String'));
};

Opal.modules["corelib/enumerable"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $module = Opal.module, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $Opal = Opal.Opal, $thrower = Opal.thrower, $def = Opal.def, $Kernel = Opal.Kernel, $return_val = Opal.return_val, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $rb_le = Opal.rb_le, $hash2 = Opal.hash2, $lambda = Opal.lambda, $not = Opal.not, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('each,public_send,destructure,to_enum,enumerator_size,new,yield,raise,slice_when,!,enum_for,flatten,map,to_proc,compact,to_a,warn,proc,==,nil?,respond_to?,coerce_to!,>,*,try_convert,<,+,-,ceil,/,size,select,__send__,length,<=,[],push,<<,[]=,===,inspect,<=>,first,reverse,sort,take,sort_by,compare,call,dup,sort!,map!,include?,-@,key?,values,transform_values,group_by,fetch,to_h,coerce_to?,class,zip,detect,find_all,collect_concat,collect,inject,entries');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    $def(self, '$all?', function $Enumerable_all$ques$1(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_all$ques$1.$$p || nil, self = this;

      $Enumerable_all$ques$1.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$2($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            return nil
          } else {
            $t_return.$throw(false)
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$3($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          } else {
            $t_return.$throw(false)
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$4($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            return nil
          } else {
            $t_return.$throw(false)
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$any?', function $Enumerable_any$ques$5(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_any$ques$5.$$p || nil, self = this;

      $Enumerable_any$ques$5.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$6($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(true)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$7($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(true)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$8($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            $t_return.$throw(true)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$chunk', function $$chunk() {
      var block = $$chunk.$$p || nil, self = this;

      $$chunk.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["chunk"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      return $send($$$('Enumerator'), 'new', [], function $$10(yielder){var self = $$10.$$s == null ? this : $$10.$$s;

        
        if (yielder == null) yielder = nil;
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = $yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, {$$s: self});
    });
    
    $def(self, '$chunk_while', function $$chunk_while() {
      var block = $$chunk_while.$$p || nil, self = this;

      $$chunk_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], function $$11(before, after){
        
        if (before == null) before = nil;
        if (after == null) after = nil;
        return Opal.yieldX(block, [before, after])['$!']();});
    });
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = $yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$collect_concat', function $$collect_concat() {
      var block = $$collect_concat.$$p || nil, self = this;

      $$collect_concat.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect_concat"], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      return $send(self, 'map', [], block.$to_proc()).$flatten(1);
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      return self.$to_a().$compact()
    });
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this, result = nil;

      $$count.$$p = null;
      
      ;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send($Kernel, 'proc', [], function $$14($a){var $post_args, args;

          
          $post_args = $slice(arguments);
          args = $post_args;
          return $Opal.$destructure(args)['$=='](object);}, -1)
      } else if ($truthy(block['$nil?']())) {
        block = $send($Kernel, 'proc', [], $return_val(true))
      };
      $send(self, 'each', [], function $$15($a){var $post_args, args;

        
        $post_args = $slice(arguments);
        args = $post_args;
        if ($truthy($yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$$('Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil
        };
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, -1);
    
    $def(self, '$detect', function $$detect(ifnone) {try { var $t_return = $thrower('return'); 
      var block = $$detect.$$p || nil, self = this;

      $$detect.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], function $$17($a){var $post_args, args, value = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          $t_return.$throw(value)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');
      if ($truthy(number < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
      };
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($Opal.$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    });
    
    $def(self, '$drop_while', function $$drop_while() {
      var block = $$drop_while.$$p || nil, self = this;

      $$drop_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        if (dropping) {
          var value = $yield1(block, param);

          if (!$truthy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$each_cons', function $$each_cons(n) {
      var block = $$each_cons.$$p || nil, self = this;

      $$each_cons.$$p = null;
      
      ;
      if ($truthy(arguments.length != 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 1)")
      };
      n = $Opal.$try_convert(n, $$$('Integer'), "to_int");
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_cons", n], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s, enum_size = nil;

          
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if (($eqeq(enum_size, 0) || ($truthy($rb_lt(enum_size, n))))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, {$$s: self})
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          $yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return self;
    ;
    });
    
    $def(self, '$each_entry', function $$each_entry($a) {
      var block = $$each_entry.$$p || nil, $post_args, data, self = this;

      $$each_entry.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      data = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["each_entry"].concat($to_a(data)), function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      self.$each.$$p = function() {
        var item = $Opal.$destructure(arguments);

        $yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, -1);
    
    $def(self, '$each_slice', function $$each_slice(n) {
      var block = $$each_slice.$$p || nil, self = this;

      $$each_slice.$$p = null;
      
      ;
      n = $coerce_to(n, $$$('Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid slice size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_slice", n], function $$20(){var self = $$20.$$s == null ? this : $$20.$$s;

          if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, {$$s: self})
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          $yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        $yield1(block, slice);
      }
    ;
      return self;
    });
    
    $def(self, '$each_with_index', function $$each_with_index($a) {
      var block = $$each_with_index.$$p || nil, $post_args, args, self = this;

      $$each_with_index.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"].concat($to_a(args)), function $$21(){var self = $$21.$$s == null ? this : $$21.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, -1);
    
    $def(self, '$each_with_object', function $$each_with_object(object) {
      var block = $$each_with_object.$$p || nil, self = this;

      $$each_with_object.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_object", object], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    });
    
    $def(self, '$entries', function $$entries($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($Opal.$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, -1);
    
    $def(self, '$filter_map', function $$filter_map() {
      var block = $$filter_map.$$p || nil, self = this;

      $$filter_map.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["filter_map"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    });
    
    $def(self, '$find_all', function $$find_all() {
      var block = $$find_all.$$p || nil, self = this;

      $$find_all.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["find_all"], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$find_index', function $$find_index(object) {try { var $t_return = $thrower('return'); 
      var block = $$find_index.$$p || nil, self = this, index = nil;

      $$find_index.$$p = null;
      
      ;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")
      };
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], function $$25($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($eqeq($Opal.$destructure(value), object)) {
            $t_return.$throw(index)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$26($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(index)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      };
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$first', function $$first(number) {try { var $t_return = $thrower('return'); 
      var self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], function $$27(value){
          
          if (value == null) value = nil;
          $t_return.$throw(value);}, {$$ret: $t_return})
      } else {
        
        result = [];
        number = $coerce_to(number, $$$('Integer'), 'to_int');
        if ($truthy(number < 0)) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        if ($truthy(number == 0)) {
          return []
        };
        current = 0;
        $send(self, 'each', [], function $$28($a){var $post_args, args;

          
          $post_args = $slice(arguments);
          args = $post_args;
          result.push($Opal.$destructure(args));
          if ($truthy(number <= ++current)) {
            $t_return.$throw(result)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return});
        return result;
      };} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$grep', function $$grep(pattern) {
      var block = $$grep.$$p || nil, self = this, result = nil;

      $$grep.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$29($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if (!$truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    });
    
    $def(self, '$grep_v', function $$grep_v(pattern) {
      var block = $$grep_v.$$p || nil, self = this, result = nil;

      $$grep_v.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$30($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    });
    
    $def(self, '$group_by', function $$group_by() {
      var block = $$group_by.$$p || nil, $a, self = this, hash = nil, $ret_or_1 = nil;

      $$group_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["group_by"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        ($truthy(($ret_or_1 = hash['$[]'](value))) ? ($ret_or_1) : (($a = [value, []], $send(hash, '[]=', $a), $a[$a.length - 1])))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    });
    
    $def(self, '$include?', function $Enumerable_include$ques$32(obj) {try { var $t_return = $thrower('return'); 
      var self = this;

      
      $send(self, 'each', [], function $$33($a){var $post_args, args;

        
        $post_args = $slice(arguments);
        args = $post_args;
        if ($eqeq($Opal.$destructure(args), obj)) {
          $t_return.$throw(true)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    });
    
    $def(self, '$inject', function $$inject(object, sym) {
      var block = $$inject.$$p || nil, self = this;

      $$inject.$$p = null;
      
      ;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = $yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$$('Symbol')['$==='](object)) {
            $Kernel.$raise($$$('TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$lazy', function $$lazy() {
      var self = this;

      return $send($$$($$$('Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], function $$34(enum$, $a){var $post_args, args;

        
        if (enum$ == null) enum$ = nil;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        return $send(enum$, 'yield', $to_a(args));}, -2)
    });
    
    $def(self, '$enumerator_size', function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    });
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = $yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$$('Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, -1);
    
    $def(self, '$max_by', function $$max_by(n) {
      var block = $$max_by.$$p || nil, self = this;

      $$max_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["max_by", n], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min', function $$min(n) {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(n['$nil?']())) {
        if ((block !== nil)) {
          return $send(self, 'sort', [], function $$36(a, b){
            
            if (a == null) a = nil;
            if (b == null) b = nil;
            return Opal.yieldX(block, [a, b]);;}).$take(n)
        } else {
          return self.$sort().$take(n)
        }
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($Opal.$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min_by', function $$min_by(n) {
      var block = $$min_by.$$p || nil, self = this;

      $$min_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["min_by", n], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$minmax', function $$minmax() {
      var block = $$minmax.$$p || nil, self = this, $ret_or_1 = nil;

      $$minmax.$$p = null;
      
      ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($send($Kernel, 'proc', [], function $$38(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$<=>'](b);})));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    });
    
    $def(self, '$minmax_by', function $$minmax_by() {
      var block = $$minmax_by.$$p || nil, self = this;

      $$minmax_by.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["minmax_by"], function $$39(){var self = $$39.$$s == null ? this : $$39.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    });
    
    $def(self, '$none?', function $Enumerable_none$ques$40(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_none$ques$40.$$p || nil, self = this;

      $Enumerable_none$ques$40.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$41($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$42($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$43($a){var $post_args, value, item = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          item = $Opal.$destructure(value);
          if ($truthy(item)) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$one?', function $Enumerable_one$ques$44(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_one$ques$44.$$p || nil, self = this, count = nil;

      $Enumerable_one$ques$44.$$p = null;
      
      ;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$45($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              $t_return.$throw(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$46($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if (!$truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$47($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if (!$truthy($Opal.$destructure(value))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return count['$=='](1);} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$partition', function $$partition() {
      var block = $$partition.$$p || nil, self = this;

      $$partition.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["partition"], function $$48(){var self = $$48.$$s == null ? this : $$48.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (!$truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$50(){var self = $$50.$$s == null ? this : $$50.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        $yieldX(block, result[i]);
      }

      return result;
    ;
    });
    
    $def(self, '$slice_before', function $$slice_before(pattern) {
      var block = $$slice_before.$$p || nil, self = this;

      $$slice_before.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$51(e){var self = $$51.$$s == null ? this : $$51.$$s;

        
        if (e == null) e = nil;
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = $yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $Opal.$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, {$$s: self});
    }, -1);
    
    $def(self, '$slice_after', function $$slice_after(pattern) {
      var block = $$slice_after.$$p || nil, self = this;

      $$slice_after.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      if ($truthy(pattern !== undefined)) {
        block = $send($Kernel, 'proc', [], function $$52(e){
          
          if (e == null) e = nil;
          return pattern['$==='](e);})
      };
      return $send($$$('Enumerator'), 'new', [], function $$53(yielder){var self = $$53.$$s == null ? this : $$53.$$s;

        
        if (yielder == null) yielder = nil;
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $Opal.$destructure(arguments),
              end_chunk = $yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, {$$s: self});
    }, -1);
    
    $def(self, '$slice_when', function $$slice_when() {
      var block = $$slice_when.$$p || nil, self = this;

      $$slice_when.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$54(yielder){var self = $$54.$$s == null ? this : $$54.$$s;

        
        if (yielder == null) yielder = nil;
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $Opal.$destructure(arguments),
              before = params[0],
              after = params[1],
              match = $yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, {$$s: self});
    });
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this, ary = nil;

      $$sort.$$p = null;
      
      ;
      ary = self.$to_a();
      if (!(block !== nil)) {
        block = $lambda(function $$55(a, b){
          
          if (a == null) a = nil;
          if (b == null) b = nil;
          return a['$<=>'](b);})
      };
      return $send(ary, 'sort', [], block.$to_proc());
    });
    
    $def(self, '$sort_by', function $$sort_by() {
      var block = $$sort_by.$$p || nil, self = this, dup = nil;

      $$sort_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by"], function $$56(){var self = $$56.$$s == null ? this : $$56.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      dup = $send(self, 'map', [], function $$57(){var arg = nil;

        
        arg = $Opal.$destructure(arguments);
        return [Opal.yield1(block, arg), arg];});
      $send(dup, 'sort!', [], function $$58(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return (a[0])['$<=>'](b[0]);});
      return $send(dup, 'map!', [], function $$59(i){
        
        if (i == null) i = nil;
        return i[1];;});
    });
    
    $def(self, '$sum', function $$sum(initial) {
      var $yield = $$sum.$$p || nil, self = this, result = nil, compensation = nil;

      $$sum.$$p = null;
      
      if (initial == null) initial = 0;
      result = initial;
      compensation = 0;
      $send(self, 'each', [], function $$60($a){var $post_args, args, item = nil, y = nil, t = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        item = (($yield !== nil) ? (Opal.yieldX($yield, $to_a(args))) : ($Opal.$destructure(args)));
        if (($not([$$$($$$('Float'), 'INFINITY'), $$$($$$('Float'), 'INFINITY')['$-@']()]['$include?'](item)) && ($truthy(item['$respond_to?']("-"))))) {
          
          y = $rb_minus(item, compensation);
          t = $rb_plus(result, y);
          compensation = $rb_minus($rb_minus(t, result), y);
          return (result = t);
        } else {
          return (result = $rb_plus(result, item))
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$take', function $$take(num) {
      var self = this;

      return self.$first(num)
    });
    
    $def(self, '$take_while', function $$take_while() {try { var $t_return = $thrower('return'); 
      var block = $$take_while.$$p || nil, self = this, result = nil;

      $$take_while.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], function $$61($a){var $post_args, args, value = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if (!$truthy(Opal.yield1(block, value))) {
          $t_return.$throw(result)
        };
        return result.push(value);;}, {$$arity: -1, $$ret: $t_return});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    });
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this, hash = nil;

      $$uniq.$$p = null;
      
      ;
      hash = $hash2([], {});
      $send(self, 'each', [], function $$62($a){var $post_args, args, $b, value = nil, produced = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        produced = ((block !== nil) ? (Opal.yield1(block, value)) : (value));
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          return ($b = [produced, value], $send(hash, '[]=', $b), $b[$b.length - 1])
        };}, -1);
      return hash.$values();
    });
    
    $def(self, '$tally', function $$tally(hash) {
      var self = this, out = nil;

      
      ;
      if (hash && hash !== nil) { $deny_frozen_access(hash); };
      out = $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc());
      if ($truthy(hash)) {
        
        $send(out, 'each', [], function $$63(k, v){var $a;

          
          if (k == null) k = nil;
          if (v == null) v = nil;
          return ($a = [k, $rb_plus(hash.$fetch(k, 0), v)], $send(hash, '[]=', $a), $a[$a.length - 1]);});
        return hash;
      } else {
        return out
      };
    }, -1);
    
    $def(self, '$to_h', function $$to_h($a) {
      var block = $$to_h.$$p || nil, $post_args, args, self = this;

      $$to_h.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(args))
      };
      
      var hash = $hash2([], {});

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);
        var ary = $Opal['$coerce_to?'](param, $$$('Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, -1);
    
    $def(self, '$to_set', function $$to_set($a, $b) {
      var block = $$to_set.$$p || nil, $post_args, klass, args, self = this;

      $$to_set.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      
      if ($post_args.length > 0) klass = $post_args.shift();if (klass == null) klass = $$('Set');
      args = $post_args;
      return $send(klass, 'new', [self].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      return $send(self.$to_a(), 'zip', $to_a(others));
    }, -1);
    $alias(self, "find", "detect");
    $alias(self, "filter", "find_all");
    $alias(self, "flat_map", "collect_concat");
    $alias(self, "map", "collect");
    $alias(self, "member?", "include?");
    $alias(self, "reduce", "inject");
    $alias(self, "select", "find_all");
    return $alias(self, "to_a", "entries");
  })('::', $nesting)
};

Opal.modules["corelib/enumerator/arithmetic_sequence"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $to_a = Opal.to_a, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $def = Opal.def, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('is_a?,==,raise,respond_to?,class,attr_reader,begin,end,exclude_end?,>,step,<,<=,>=,-@,_lesser_than_end?,<<,+,-,===,%,_greater_than_begin?,reverse,!,include?,*,to_i,abs,/,hash,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.step_arg2 = $proto.receiver_num = $proto.step_arg1 = $proto.step = $proto.range = $proto.topfx = $proto.bypfx = $proto.creation_method = $proto.skipped_arg = nil;
      
      Opal.prop(self.$$prototype, '$$is_arithmetic_seq', true);
      var inf = Infinity;
      
      $def(self, '$initialize', function $$initialize(range, step, creation_method) {
        var $a, self = this, $ret_or_1 = nil;

        
        ;
        if (creation_method == null) creation_method = "step";
        self.creation_method = creation_method;
        if ($truthy(range['$is_a?']($$$('Array')))) {
          
          $a = [].concat($to_a(range)), (self.step_arg1 = ($a[0] == null ? nil : $a[0])), (self.step_arg2 = ($a[1] == null ? nil : $a[1])), (self.topfx = ($a[2] == null ? nil : $a[2])), (self.bypfx = ($a[3] == null ? nil : $a[3])), $a;
          self.receiver_num = step;
          self.step = 1;
          self.range = ($truthy(self.step_arg2) ? (((self.step = self.step_arg2), Opal.Range.$new(self.receiver_num, self.step_arg1, false))) : ($truthy(self.step_arg1) ? (Opal.Range.$new(self.receiver_num, self.step_arg1, false)) : (Opal.Range.$new(self.receiver_num, nil, false))));
        } else {
          
          if (!$truthy(step)) {
            self.skipped_arg = true
          };
          $a = [range, ($truthy(($ret_or_1 = step)) ? ($ret_or_1) : (1))], (self.range = $a[0]), (self.step = $a[1]), $a;
        };
        self.object = self;
        if ($eqeq(self.step, 0)) {
          $Kernel.$raise($$('ArgumentError'), "step can't be 0")
        };
        if ($truthy(self.step['$respond_to?']("to_int"))) {
          return nil
        } else {
          return $Kernel.$raise($$('ArgumentError'), "" + ("no implicit conversion of " + (self.step.$class()) + " ") + "into Integer")
        };
      }, -2);
      self.$attr_reader("step");
      
      $def(self, '$begin', function $$begin() {
        var self = this;

        return self.range.$begin()
      });
      
      $def(self, '$end', function $$end() {
        var self = this;

        return self.range.$end()
      });
      
      $def(self, '$exclude_end?', function $ArithmeticSequence_exclude_end$ques$1() {
        var self = this;

        return self.range['$exclude_end?']()
      });
      
      $def(self, '$_lesser_than_end?', function $ArithmeticSequence__lesser_than_end$ques$2(val) {
        var self = this, end_ = nil, $ret_or_1 = nil;

        
        end_ = ($truthy(($ret_or_1 = self.$end())) ? ($ret_or_1) : (inf));
        if ($truthy($rb_gt(self.$step(), 0))) {
          if ($truthy(self['$exclude_end?']())) {
            return $rb_lt(val, end_)
          } else {
            return $rb_le(val, end_)
          }
        } else if ($truthy(self['$exclude_end?']())) {
          return $rb_gt(val, end_)
        } else {
          return $rb_ge(val, end_)
        };
      });
      
      $def(self, '$_greater_than_begin?', function $ArithmeticSequence__greater_than_begin$ques$3(val) {
        var self = this, begin_ = nil, $ret_or_1 = nil;

        
        begin_ = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if ($truthy($rb_gt(self.$step(), 0))) {
          return $rb_gt(val, begin_)
        } else {
          return $rb_lt(val, begin_)
        };
      });
      
      $def(self, '$first', function $$first(count) {
        var self = this, iter = nil, $ret_or_1 = nil, out = nil;

        
        ;
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if (!$truthy(count)) {
          return ($truthy(self['$_lesser_than_end?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_lesser_than_end?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_plus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out;
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this, $ret_or_1 = nil, iter = nil;

        $$each.$$p = null;
        
        ;
        if (!(block !== nil)) {
          return self
        };
        if ($eqeqeq(nil, ($ret_or_1 = self.$begin()))) {
          $Kernel.$raise($$('TypeError'), "nil can't be coerced into Integer")
        } else {
          nil
        };
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        while ($truthy(self['$_lesser_than_end?'](iter))) {
        
          Opal.yield1(block, iter);
          iter = $rb_plus(iter, self.$step());
        };
        return self;
      });
      
      $def(self, '$last', function $$last(count) {
        var self = this, $ret_or_1 = nil, iter = nil, out = nil;

        
        ;
        if (($eqeqeq(inf, ($ret_or_1 = self.$end())) || ($eqeqeq((inf)['$-@'](), $ret_or_1)))) {
          $Kernel.$raise($$$('FloatDomainError'), self.$end())
        } else if ($eqeqeq(nil, $ret_or_1)) {
          $Kernel.$raise($$$('RangeError'), "cannot get the last element of endless arithmetic sequence")
        } else {
          nil
        };
        iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
        if (!$truthy(self['$_lesser_than_end?'](iter))) {
          iter = $rb_minus(iter, self.$step())
        };
        if (!$truthy(count)) {
          return ($truthy(self['$_greater_than_begin?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_greater_than_begin?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_minus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out.$reverse();
      }, -1);
      
      $def(self, '$size', function $$size() {
        var self = this, step_sign = nil, iter = nil;

        
        step_sign = ($truthy($rb_gt(self.$step(), 0)) ? (1) : (-1));
        if ($not(self['$_lesser_than_end?'](self.$begin()))) {
          return 0
        } else if ($truthy([(inf)['$-@'](), inf]['$include?'](self.$step()))) {
          return 1
        } else if (($truthy([$rb_times((inf)['$-@'](), step_sign), nil]['$include?'](self.$begin())) || ($truthy([$rb_times(inf, step_sign), nil]['$include?'](self.$end()))))) {
          return inf;
        } else {
          
          iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
          if (!$truthy(self['$_lesser_than_end?'](iter))) {
            iter = $rb_minus(iter, self.$step())
          };
          return $rb_plus($rb_divide($rb_minus(iter, self.$begin()), self.$step()).$abs().$to_i(), 1);
        };
      });
      
      $def(self, '$==', function $ArithmeticSequence_$eq_eq$4(other) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.$class()['$=='](other.$class()))) ? (self.$begin()['$=='](other.$begin())) : ($ret_or_4)))) ? (self.$end()['$=='](other.$end())) : ($ret_or_3)))) ? (self.$step()['$=='](other.$step())) : ($ret_or_2))))) {
          return self['$exclude_end?']()['$=='](other['$exclude_end?']())
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$hash', function $$hash() {
        var self = this;

        return [self.$begin(), self.$end(), self.$step(), self['$exclude_end?']()].$hash()
      });
      
      $def(self, '$inspect', function $$inspect() {
        var self = this, args = nil;

        if ($truthy(self.receiver_num)) {
          
          args = ($truthy(self.step_arg2) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ", " + (self.bypfx) + (self.step_arg2.$inspect()) + ")") : ($truthy(self.step_arg1) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ")") : nil));
          return "(" + (self.receiver_num.$inspect()) + "." + (self.creation_method) + (args) + ")";
        } else {
          
          args = ($truthy(self.skipped_arg) ? (nil) : ("(" + (self.step) + ")"));
          return "((" + (self.range.$inspect()) + ")." + (self.creation_method) + (args) + ")";
        }
      });
      $alias(self, "===", "==");
      return $alias(self, "eql?", "==");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/chain"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $thrower = Opal.thrower, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('to_enum,size,each,<<,to_proc,include?,+,reverse_each,respond_to?,rewind,inspect');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Enumerator');

    
    return (function($base, $super) {
      var self = $klass($base, $super, 'Chain');

      var $proto = self.$$prototype;

      $proto.enums = $proto.iterated = nil;
      
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, enums, self = this;

        
        $post_args = $slice(arguments);
        enums = $post_args;
        $deny_frozen_access(self);
        self.enums = enums;
        self.iterated = [];
        return (self.object = self);
      }, -1);
      
      $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this;

        $$each.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        if (!(block !== nil)) {
          return $send(self, 'to_enum', ["each"].concat($to_a(args)), function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$size()}, {$$s: self})
        };
        $send(self.enums, 'each', [], function $$2(enum$){var self = $$2.$$s == null ? this : $$2.$$s;
          if (self.iterated == null) self.iterated = nil;

          
          if (enum$ == null) enum$ = nil;
          self.iterated['$<<'](enum$);
          return $send(enum$, 'each', $to_a(args), block.$to_proc());}, {$$s: self});
        return self;
      }, -1);
      
      $def(self, '$size', function $$size($a) {try { var $t_return = $thrower('return'); 
        var $post_args, args, self = this, accum = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        accum = 0;
        $send(self.enums, 'each', [], function $$3(enum$){var size = nil;

          
          if (enum$ == null) enum$ = nil;
          size = $send(enum$, 'size', $to_a(args));
          if ($truthy([nil, $$$($$$('Float'), 'INFINITY')]['$include?'](size))) {
            $t_return.$throw(size)
          };
          return (accum = $rb_plus(accum, size));}, {$$ret: $t_return});
        return accum;} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        }
      }, -1);
      
      $def(self, '$rewind', function $$rewind() {
        var self = this;

        
        $send(self.iterated, 'reverse_each', [], function $$4(enum$){
          
          if (enum$ == null) enum$ = nil;
          if ($truthy(enum$['$respond_to?']("rewind"))) {
            return enum$.$rewind()
          } else {
            return nil
          };});
        self.iterated = [];
        return self;
      });
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<Enumerator::Chain: " + (self.enums.$inspect()) + ">"
      });
    })(self, self)
  })('::', null)
};

Opal.modules["corelib/enumerator/generator"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,raise,new,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = nil;
      
      self.$include($$$('Enumerable'));
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        $deny_frozen_access(self);
        if (!$truthy(block)) {
          $Kernel.$raise($$$('LocalJumpError'), "no block given")
        };
        return (self.block = block);
      });
      return $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this, yielder = nil;

        $$each.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        yielder = $send($$('Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e && e.$thrower_type == "breaker") {
            return e.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, -1);
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator/lazy"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $defs = Opal.defs, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $return_self = Opal.return_self, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,each,new,enumerator_size,yield,respond_to?,try_convert,<,===,+,for,class,to_proc,destructure,inspect,to_a,find_all,collect_concat,collect,enum_for');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.enumerator = nil;
      
      $klass(self, $$$('Exception'), 'StopLazyError');
      $defs(self, '$for', function $Lazy_for$1(object, $a) {
        var $post_args, $fwd_rest, $yield = $Lazy_for$1.$$p || nil, self = this, lazy = nil;

        $Lazy_for$1.$$p = null;
        
        $post_args = $slice(arguments, 1);
        $fwd_rest = $post_args;
        lazy = $send2(self, $find_super(self, 'for', $Lazy_for$1, false, true), 'for', [object].concat($to_a($fwd_rest)), $yield);
        lazy.enumerator = object;
        return lazy;
      }, -2);
      
      $def(self, '$initialize', function $$initialize(object, size) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        if (size == null) size = nil;
        $deny_frozen_access(self);
        if (!(block !== nil)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], function $$2(yielder, $a){var $post_args, each_args;

          
          if (yielder == null) yielder = nil;
          $post_args = $slice(arguments, 1);
          each_args = $post_args;
          try {
            return $send(object, 'each', $to_a(each_args), function $$3($b){var $post_args, args;

              
              $post_args = $slice(arguments);
              args = $post_args;
              
            args.unshift(yielder);

            $yieldX(block, args);
          ;}, -1)
          } catch ($err) {
            if (Opal.rescue($err, [$$('StopLazyError')])) {
              try {
                return nil
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };}, -2);
      }, -2);
      
      $def(self, '$lazy', $return_self);
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        $$collect.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, self.$enumerator_size()], function $$4(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          enum$.$yield(value);
        ;}, -2);
      });
      
      $def(self, '$collect_concat', function $$collect_concat() {
        var block = $$collect_concat.$$p || nil, self = this;

        $$collect_concat.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$5(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], function $$6(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);})
          }
          else {
            var array = $Opal.$try_convert(value, $$$('Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], function $$7(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);});
            }
          }
        ;}, -2);
      });
      
      $def(self, '$drop', function $$drop(n) {
        var self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        dropped = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$8(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      });
      
      $def(self, '$drop_while', function $$drop_while() {
        var block = $$drop_while.$$p || nil, self = this, succeeding = nil;

        $$drop_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$('Lazy'), 'new', [self, nil], function $$9(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy(succeeding)) {
            
            var value = $yieldX(block, args);

            if (!$truthy(value)) {
              succeeding = false;

              $send(enum$, 'yield', $to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      });
      
      $def(self, '$enum_for', function $$enum_for($a, $b) {
        var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

        $$enum_for.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        
        if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
        args = $post_args;
        return $send(self.$class(), 'for', [self, method].concat($to_a(args)), block.$to_proc());
      }, -1);
      
      $def(self, '$find_all', function $$find_all() {
        var block = $$find_all.$$p || nil, self = this;

        $$find_all.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$10(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      });
      
      $def(self, '$grep', function $$grep(pattern) {
        var block = $$grep.$$p || nil, self = this;

        $$grep.$$p = null;
        
        ;
        if ($truthy(block)) {
          return $send($$('Lazy'), 'new', [self, nil], function $$11(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = $yield1(block, param);

              enum$.$yield($yield1(block, param));
            }
          ;}, -2)
        } else {
          return $send($$('Lazy'), 'new', [self, nil], function $$12(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, -2)
        };
      });
      
      $def(self, '$reject', function $$reject() {
        var block = $$reject.$$p || nil, self = this;

        $$reject.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$13(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if (!$truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      });
      
      $def(self, '$take', function $$take(n) {
        var self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        taken = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$14(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', $to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return $Kernel.$raise($$('StopLazyError'))
          };}, -2);
      });
      
      $def(self, '$take_while', function $$take_while() {
        var block = $$take_while.$$p || nil, self = this;

        $$take_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$15(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
          else {
            $Kernel.$raise($$('StopLazyError'));
          }
        ;}, -2);
      });
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      });
      $alias(self, "force", "to_a");
      $alias(self, "filter", "find_all");
      $alias(self, "flat_map", "collect_concat");
      $alias(self, "map", "collect");
      $alias(self, "select", "find_all");
      return $alias(self, "to_enum", "enum_for");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/yielder"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('yield,proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Yielder');

      var $proto = self.$$prototype;

      $proto.block = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.block = block;
        return self;
      });
      
      $def(self, '$yield', function $Yielder_yield$1($a) {
        var $post_args, values, self = this;

        
        $post_args = $slice(arguments);
        values = $post_args;
        
        var value = Opal.yieldX(self.block, values);

        if (value && value.$thrower_type == "break") {
          throw value;
        }

        return value;
      ;
      }, -1);
      
      $def(self, '$<<', function $Yielder_$lt$lt$2(value) {
        var self = this;

        
        self.$yield(value);
        return self;
      });
      return $def(self, '$to_proc', function $$to_proc() {
        var self = this;

        return $send(self, 'proc', [], function $$3($a){var $post_args, values, self = $$3.$$s == null ? this : $$3.$$s;

          
          $post_args = $slice(arguments);
          values = $post_args;
          return $send(self, 'yield', $to_a(values));}, {$$arity: -1, $$s: self})
      });
    })($nesting[0], null)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $slice = Opal.slice, $coerce_to = Opal.coerce_to, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $def = Opal.def, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $Opal = Opal.Opal, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_ge = Opal.rb_ge, $Kernel = Opal.Kernel, $rb_le = Opal.rb_le, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,allocate,new,to_proc,!,respond_to?,empty?,nil?,+,class,__send__,call,enum_for,size,destructure,map,>=,length,raise,[],peek_values,<=,next_values,inspect,any?,each_with_object,autoload');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.size = $proto.args = $proto.object = $proto.method = $proto.values = $proto.cursor = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    $defs(self, '$for', function $Enumerator_for$1(object, $a, $b) {
      var block = $Enumerator_for$1.$$p || nil, $post_args, method, args, self = this;

      $Enumerator_for$1.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;
      obj.cursor = 0;

      return obj;
    ;
    }, -2);
    
    $def(self, '$initialize', function $$initialize($a) {
      var block = $$initialize.$$p || nil, $post_args, $fwd_rest, self = this;

      $$initialize.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      $deny_frozen_access(self);
      self.cursor = 0;
      if ($truthy(block)) {
        
        self.object = $send($$('Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if (($truthy(self.size) && ($not(self.size['$respond_to?']("call"))))) {
          return (self.size = $coerce_to(self.size, $$$('Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice(arguments, 2);
        return (self.size = nil);
      };
    }, -1);
    
    $def(self, '$each', function $$each($a) {
      var block = $$each.$$p || nil, $post_args, args, self = this;

      $$each.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(args['$empty?']())))) {
        return self
      };
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat($to_a(args)))
      };
      return $send(self.object, '__send__', [self.method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$size', function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', $to_a(self.args))
      } else {
        return self.size
      }
    });
    
    $def(self, '$with_index', function $$with_index(offset) {
      var block = $$with_index.$$p || nil, self = this;

      $$with_index.$$p = null;
      
      ;
      if (offset == null) offset = 0;
      offset = ($truthy(offset) ? ($coerce_to(offset, $$$('Integer'), 'to_int')) : (0));
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["with_index", offset], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, -1);
    
    $def(self, '$each_with_index', function $$each_with_index() {
      var block = $$each_with_index.$$p || nil, self = this;

      $$each_with_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$s: self})
      };
      $send2(self, $find_super(self, 'each_with_index', $$each_with_index, false, true), 'each_with_index', [], block);
      return self.object;
    });
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      
      self.cursor = 0;
      return self;
    });
    
    $def(self, '$peek_values', function $$peek_values() {
      var self = this, $ret_or_1 = nil;

      
      self.values = ($truthy(($ret_or_1 = self.values)) ? ($ret_or_1) : ($send(self, 'map', [], function $$4($a){var $post_args, i;

        
        $post_args = $slice(arguments);
        i = $post_args;
        return i;}, -1)));
      if ($truthy($rb_ge(self.cursor, self.values.$length()))) {
        $Kernel.$raise($$$('StopIteration'), "iteration reached an end")
      };
      return self.values['$[]'](self.cursor);
    });
    
    $def(self, '$peek', function $$peek() {
      var self = this, values = nil;

      
      values = self.$peek_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    });
    
    $def(self, '$next_values', function $$next_values() {
      var self = this, out = nil;

      
      out = self.$peek_values();
      self.cursor = $rb_plus(self.cursor, 1);
      return out;
    });
    
    $def(self, '$next', function $$next() {
      var self = this, values = nil;

      
      values = self.$next_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    });
    
    $def(self, '$feed', function $$feed(arg) {
      var self = this;

      return self.$raise($$('NotImplementedError'), "Opal doesn't support Enumerator#feed")
    });
    
    $def(self, '$+', function $Enumerator_$plus$5(other) {
      var self = this;

      return $$$($$$('Enumerator'), 'Chain').$new(self, other)
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      result = "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "(" + (self.args.$inspect()['$[]']($$$('Range').$new(1, -2))) + ")")
      };
      return $rb_plus(result, ">");
    });
    $alias(self, "with_object", "each_with_object");
    self.$autoload("ArithmeticSequence", "corelib/enumerator/arithmetic_sequence");
    self.$autoload("Chain", "corelib/enumerator/chain");
    self.$autoload("Generator", "corelib/enumerator/generator");
    self.$autoload("Lazy", "corelib/enumerator/lazy");
    return self.$autoload("Yielder", "corelib/enumerator/yielder");
  })('::', null, $nesting);
};

Opal.modules["corelib/numeric"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $to_ary = Opal.to_ary, $return_self = Opal.return_self, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $return_val = Opal.return_val, $Opal = Opal.Opal, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $not = Opal.not, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_le = Opal.rb_le, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,instance_of?,class,Float,respond_to?,coerce,__send__,raise,equal?,-,*,div,<,-@,ceil,to_f,denominator,to_r,==,floor,/,%,Complex,zero?,numerator,abs,arg,coerce_to!,round,<=>,compare,is_a?,!,new,enum_for,to_proc,negative?,>=,<=,+,to_i,truncate,>,angle,conj,imag,rect');
  
  self.$require("corelib/comparable");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    
    self.$include($$$('Comparable'));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]
      };
      return [$Kernel.$Float(other), $Kernel.$Float(self)];
    });
    
    $def(self, '$__coerced__', function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = $to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else 
      switch (method) {
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case "&":
        case "|":
        case "^":
        case "**":
          return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")
        case ">":
        case ">=":
        case "<":
        case "<=":
        case "<=>":
          return $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
        default:
          return nil
      }
    });
    
    $def(self, '$<=>', function $Numeric_$lt_eq_gt$1(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0
      };
      return nil;
    });
    
    $def(self, '$+@', $return_self);
    
    $def(self, '$-@', function $Numeric_$minus$$2() {
      var self = this;

      return $rb_minus(0, self)
    });
    
    $def(self, '$%', function $Numeric_$percent$3(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    });
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    });
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    });
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$$('Math'), 'PI')
      } else {
        return 0
      }
    });
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$ceil(ndigits);
    }, -1);
    
    $def(self, '$conj', $return_self);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    });
    
    $def(self, '$div', function $$div(other) {
      var self = this;

      
      if ($eqeq(other, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by o")
      };
      return $rb_divide(self, other).$floor();
    });
    
    $def(self, '$divmod', function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    });
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    });
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$floor(ndigits);
    }, -1);
    
    $def(self, '$i', function $$i() {
      var self = this;

      return $Kernel.$Complex(0, self)
    });
    
    $def(self, '$imag', $return_val(0));
    
    $def(self, '$integer?', $return_val(false));
    
    $def(self, '$nonzero?', function $Numeric_nonzero$ques$4() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    });
    
    $def(self, '$numerator', function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    });
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    });
    
    $def(self, '$quo', function $$quo(other) {
      var self = this;

      return $rb_divide($Opal['$coerce_to!'](self, $$$('Rational'), "to_r"), other)
    });
    
    $def(self, '$real', $return_self);
    
    $def(self, '$real?', $return_val(true));
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self, 0]
    });
    
    $def(self, '$round', function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, -1);
    
    $def(self, '$step', function $$step($a, $b, $c) {
      var block = $$step.$$p || nil, $post_args, $kwargs, limit, step, to, by, self = this, counter = nil;

      $$step.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) limit = $post_args.shift();;
      
      if ($post_args.length > 0) step = $post_args.shift();;
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          $Kernel.$raise($$$('TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          $Kernel.$raise($$$('ArgumentError'), "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$$('Float'), 'INFINITY') : $$$($$$('Float'), 'INFINITY')['$-@']();
        }

        $Opal.$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$$('Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if (!(block !== nil)) {
        if ((($not(limit) || ($truthy(limit['$is_a?']($$$('Numeric'))))) && (($not(step) || ($truthy(step['$is_a?']($$$('Numeric')))))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new([limit, step, ($truthy(to) ? ("to: ") : nil), ($truthy(by) ? ("by: ") : nil)], self)
        } else {
          return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
        }
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
      
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, -1);
    
    $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $Kernel.$Complex(self, 0)
    });
    
    $def(self, '$to_int', function $$to_int() {
      var self = this;

      return self.$to_i()
    });
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$truncate(ndigits);
    }, -1);
    
    $def(self, '$zero?', function $Numeric_zero$ques$5() {
      var self = this;

      return self['$=='](0)
    });
    
    $def(self, '$positive?', function $Numeric_positive$ques$6() {
      var self = this;

      return $rb_gt(self, 0)
    });
    
    $def(self, '$negative?', function $Numeric_negative$ques$7() {
      var self = this;

      return $rb_lt(self, 0)
    });
    
    $def(self, '$dup', $return_self);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$finite?', $return_val(true));
    
    $def(self, '$infinite?', $return_val(nil));
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "phase", "arg");
    return $alias(self, "rectangular", "rect");
  })('::', null);
};

Opal.modules["corelib/array"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $Kernel = Opal.Kernel, $def = Opal.def, $Opal = Opal.Opal, $eqeqeq = Opal.eqeqeq, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $to_a = Opal.to_a, $to_ary = Opal.to_ary, $gvars = Opal.gvars, $rb_ge = Opal.rb_ge, $assign_ivar = Opal.assign_ivar, $rb_lt = Opal.rb_lt, $return_self = Opal.return_self, $neqeq = Opal.neqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,to_a,warn,raise,replace,respond_to?,to_ary,coerce_to?,===,join,to_str,hash,<=>,==,object_id,inspect,enum_for,class,bsearch_index,to_proc,nil?,coerce_to!,>,*,enumerator_size,empty?,size,map,equal?,dup,each,reduce,-,[],dig,eql?,length,exclude_end?,flatten,frozen?,__id__,&,!,intersection,to_s,new,item,max,min,>=,**,delete_if,reverse,rotate,rand,at,keep_if,shuffle!,<,sort,sort_by,!=,times,[]=,<<,uniq,|,values,is_a?,end,begin,upto,reject,push,select,select!,collect,collect!,unshift,pristine,singleton_class');
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    Opal.prop(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
  ;
    $defs(self, '$[]', function $Array_$$$1($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments);
      objects = $post_args;
      return toArraySubclass(objects, self);;
    }, -1);
    
    $def(self, '$initialize', function $$initialize(size, obj) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if (size == null) size = nil;
      if (obj == null) obj = nil;
      
      $deny_frozen_access(self);

      if (obj !== nil && block !== nil) {
        $Kernel.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$$('Integer'), 'MAX')) {
        $Kernel.$raise($$$('ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$$('Integer'), 'to_int');

      if (size < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, -1);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Array'), "to_ary")
    });
    
    $def(self, '$&', function $Array_$$2(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    });
    
    $def(self, '$|', function $Array_$$3(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    });
    
    $def(self, '$*', function $Array_$$4(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())
      };
      other = $coerce_to(other, $$$('Integer'), 'to_int');
      if ($truthy(other < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      };
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    });
    
    $def(self, '$+', function $Array_$plus$5(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      return self.concat(other);;
    });
    
    $def(self, '$-', function $Array_$minus$6(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(other.length === 0)) {
        return self.slice()
      };
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    });
    
    $def(self, '$<<', function $Array_$lt$lt$7(object) {
      var self = this;

      
      $deny_frozen_access(self);
      self.push(object);
      return self;
    });
    
    $def(self, '$<=>', function $Array_$lt_eq_gt$8(other) {
      var self = this;

      
      if ($eqeqeq($$$('Array'), other)) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    });
    
    $def(self, '$==', function $Array_$eq_eq$9(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    });
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (index.excl_rev && index.begin !== nil) {
        from += 1;
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude || index.end === nil) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_arithmetic_seq(self, index) {
      var array, out = [], i = 0, pseudorange;

      if (index.step < 0) {
        pseudorange = {
          begin: index.range.end,
          end: index.range.begin,
          excl: false,
          excl_rev: index.range.excl
        };
        array = $array_slice_range(self, pseudorange).$reverse();
      }
      else {
        array = $array_slice_range(self, index.range);
      }

      while (i < array.length) {
        out.push(array[i]);
        i += Math.abs(index.step);
      }

      return out;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    $def(self, '$[]', function $Array_$$$10(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else if (index.$$is_arithmetic_seq) {
        return $array_slice_arithmetic_seq(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, -2);
    
    $def(self, '$[]=', function $Array_$$$eq$11(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
      $deny_frozen_access(self);
      data = nil;
      
      var i, size = self.length;

      if (index.$$is_range) {
        if (value.$$is_array)
          data = value.$to_a();
        else if (value['$respond_to?']("to_ary"))
          data = value.$to_ary().$to_a();
        else
          data = [value];

        var exclude = index.excl,
            from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int'),
            to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            $Kernel.$raise($$$('RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude || index.end === nil) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      } else {
        if (extra === undefined) {
          (length = 1)
        } else {
          length = value;
          value  = extra;

          if (value.$$is_array)
            data = value.$to_a();
          else if (value['$respond_to?']("to_ary"))
            data = value.$to_ary().$to_a();
          else
            data = [value];
        }

        var old;

        index  = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          $Kernel.$raise($$$('IndexError'), "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      }
    ;
    }, -3);
    
    $def(self, '$any?', function $Array_any$ques$12(pattern) {
      var block = $Array_any$ques$12.$$p || nil, self = this;

      $Array_any$ques$12.$$p = null;
      
      ;
      ;
      if (self.length === 0) return false;
      return $send2(self, $find_super(self, 'any?', $Array_any$ques$12, false, true), 'any?', [pattern], block);
    }, -1);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    });
    
    $def(self, '$at', function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$$('Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    });
    
    $def(self, '$bsearch_index', function $$bsearch_index() {
      var block = $$bsearch_index.$$p || nil, self = this;

      $$bsearch_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    });
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this, index = nil;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    });
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          if ($truthy(n['$nil?']())) {
            return $$$($$$('Float'), 'INFINITY')
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$s: self})
      };
      if (($truthy(self['$empty?']()) || ($eqeq(n, 0)))) {
        return nil
      };
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);
      self.splice(0, self.length);
      return self;
    });
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      ;
      if (($truthy(object !== undefined) || ($truthy(block)))) {
        return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [object], block)
      } else {
        return self.$size()
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    });
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    });
    
    $def(self, '$collect!', function $Array_collect$excl$15() {
      var block = $Array_collect$excl$15.$$p || nil, self = this;

      $Array_collect$excl$15.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect!"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    });
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    $def(self, '$combination', function $$combination(n) {
      var $yield = $$combination.$$p || nil, self = this, num = nil;

      $$combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["combination", num], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return binomial_coefficient(self.length, num)}, {$$s: self})
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    });
    
    $def(self, '$repeated_combination', function $$repeated_combination(n) {
      var $yield = $$repeated_combination.$$p || nil, self = this, num = nil;

      $$repeated_combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_combination", num], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return binomial_coefficient(self.length + num - 1, num);}, {$$s: self})
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    });
    
    $def(self, '$compact!', function $Array_compact$excl$19() {
      var self = this;

      
      $deny_frozen_access(self);

      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    });
    
    $def(self, '$concat', function $$concat($a) {
      var $post_args, others, self = this;

      
      $post_args = $slice(arguments);
      others = $post_args;
      $deny_frozen_access(self);
      others = $send(others, 'map', [], function $$20(other){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (other == null) other = nil;
        other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()
        };
        return other;}, {$$s: self});
      $send(others, 'each', [], function $$21(other){var self = $$21.$$s == null ? this : $$21.$$s;

        
        if (other == null) other = nil;
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, {$$s: self});
      return self;
    }, -1);
    
    $def(self, '$delete', function $Array_delete$22(object) {
      var $yield = $Array_delete$22.$$p || nil, self = this;

      $Array_delete$22.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          $deny_frozen_access(self);

          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    });
    
    $def(self, '$delete_at', function $$delete_at(index) {
      var self = this;

      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["delete_if"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $falsy, block)
    ;
      return self;
    });
    
    $def(self, '$difference', function $$difference($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$24(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return $rb_minus(a, b);});
    }, -1);
    
    $def(self, '$dig', function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      idxs = $post_args;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(idxs));
    }, -2);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');

      if (number < 0) {
        $Kernel.$raise($$$('ArgumentError'))
      }

      return self.slice(number);
    
    });
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this;

      $$dup.$$p = null;
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
      }
    ;
      return self;
    });
    
    $def(self, '$each_index', function $$each_index() {
      var block = $$each_index.$$p || nil, self = this;

      $$each_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_index"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, i);
      }
    ;
      return self;
    });
    
    $def(self, '$empty?', function $Array_empty$ques$27() {
      var self = this;

      return self.length === 0;
    });
    
    $def(self, '$eql?', function $Array_eql$ques$28(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    });
    
    $def(self, '$fetch', function $$fetch(index, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var original = index;

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, -2);
    
    $def(self, '$fill', function $$fill($a) {
      var block = $$fill.$$p || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      $$fill.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      $deny_frozen_access(self);

      var i, length, value;
    ;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 0..2)")
        };
        $c = args, $b = $to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 1..3)")
        };
        $c = args, $b = $to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($eqeqeq($$$('Range'), one)) {
        
        if ($truthy(two)) {
          $Kernel.$raise($$$('TypeError'), "length invalid with range")
        };
        left = one.begin === nil ? 0 : $coerce_to(one.begin, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          $Kernel.$raise($$$('RangeError'), "" + (one.$inspect()) + " out of range")
        };
        right = one.end === nil ? -1 : $coerce_to(one.end, $$$('Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length
        };
        if (!$truthy(one['$exclude_end?']())) {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self
        };
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          left = 0
        };
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$$('Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self
          };
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      
      };
      if ($truthy(right > this.length)) {
        this.length = right
      };
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, -1);
    
    $def(self, '$first', function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            $Kernel.$raise($$$('TypeError'));
          }

          if (ary === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$$('Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, -1);
    
    $def(self, '$flatten!', function $Array_flatten$excl$29(level) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          $hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if ($hash_ids[hash_id]) {
          return 'self';
        }

        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    });
    
    $def(self, '$include?', function $Array_include$ques$30(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    });
    
    $def(self, '$index', function $$index(object) {
      var block = $$index.$$p || nil, self = this;

      $$index.$$p = null;
      
      ;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$insert', function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments, 1);
      objects = $post_args;
      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, -2);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var result = [],
      id = self.$__id__(),
      pushed = true;
    ;
      
      return (function() { try {
      
      
        if (inspect_stack.indexOf(id) !== -1) {
          pushed = false;
          return '[...]';
        }
        inspect_stack.push(id)

        for (var i = 0, length = self.length; i < length; i++) {
          var item = self['$[]'](i);

          result.push($$('Opal').$inspect(item));
        }

        return '[' + result.join(', ') + ']';
      ;
      return nil;
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    });
    
    $def(self, '$intersection', function $$intersection($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$31(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$&'](b);});
    }, -1);
    
    $def(self, '$intersect?', function $Array_intersect$ques$32(other) {
      var self = this;

      return self.$intersection(other)['$empty?']()['$!']()
    });
    
    $def(self, '$join', function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      if (sep == null) sep = nil;
      if ($truthy(self.length === 0)) {
        return ""
      };
      if ($truthy(sep === nil)) {
        sep = $gvars[","]
      };
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        $Kernel.$raise($$$('NoMethodError').$new("" + ($$('Opal').$inspect(self.$item())) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($Opal['$coerce_to!'](sep, $$$('String'), "to_str").$to_s());
      }
    ;
    }, -1);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["keep_if"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $truthy, block)
    ;
      return self;
    });
    
    $def(self, '$last', function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    });
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, -1);
    
    $def(self, '$min', function $$min() {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      return $send(self.$each(), 'min', [], block.$to_proc());
    });
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    $def(self, '$permutation', function $$permutation(num) {
      var block = $$permutation.$$p || nil, self = this, perm = nil, used = nil;

      $$permutation.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["permutation", num], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          return descending_factorial(self.length, num === undefined ? self.length : num);}, {$$s: self})
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$$('Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$('Array').$new(num));
        (used = $$('Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$repeated_permutation', function $$repeated_permutation(n) {
      var $yield = $$repeated_permutation.$$p || nil, self = this, num = nil;

      $$repeated_permutation.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_permutation", num], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, {$$s: self})
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    });
    
    $def(self, '$pop', function $$pop(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return self.pop();
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, -1);
    
    $def(self, '$product', function $$product($a) {
      var block = $$product.$$p || nil, $post_args, args, self = this;

      $$product.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$$('Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          $Kernel.$raise($$$('RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, -1);
    
    $def(self, '$push', function $$push($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$36(){var self = $$36.$$s == null ? this : $$36.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    });
    
    $def(self, '$reject!', function $Array_reject$excl$37() {
      var block = $Array_reject$excl$37.$$p || nil, self = this, original = nil;

      $Array_reject$excl$37.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject!"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$s: self})
      };
      $deny_frozen_access(self);
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$length(), original)) {
        return nil
      } else {
        return self
      };
    });
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    });
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    });
    
    $def(self, '$reverse!', function $Array_reverse$excl$39() {
      var self = this;

      
      $deny_frozen_access(self);
      return self.reverse();;
    });
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$s: self})
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    });
    
    $def(self, '$rindex', function $$rindex(object) {
      var block = $$rindex.$$p || nil, self = this;

      $$rindex.$$p = null;
      
      ;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$rotate', function $$rotate(n) {
      var self = this;

      
      if (n == null) n = 1;
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$$('Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, -1);
    
    $def(self, '$rotate!', function $Array_rotate$excl$41(cnt) {
      var self = this, ary = nil;

      
      if (cnt == null) cnt = 1;
      
      $deny_frozen_access(self);

      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$$('Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, -1);
    (function($base, $super) {
      var self = $klass($base, $super, 'SampleRandom');

      var $proto = self.$$prototype;

      $proto.rng = nil;
      
      
      $def(self, '$initialize', $assign_ivar("rng"));
      return $def(self, '$rand', function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$$('Integer'), 'to_int');
        if ($truthy(random < 0)) {
          $Kernel.$raise($$$('RangeError'), "random value must be >= 0")
        };
        if (!$truthy(random < size)) {
          $Kernel.$raise($$$('RangeError'), "random value must be less than Array size")
        };
        return random;
      });
    })(self, null);
    
    $def(self, '$sample', function $$sample(count, options) {
      var self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($Kernel.$rand(self.length))
      };
      if ($truthy(options === undefined)) {
        if ($truthy((o = $Opal['$coerce_to?'](count, $$$('Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$$('Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$$('Integer'), 'to_int');
        options = $coerce_to(options, $$$('Hash'), 'to_hash');
      };
      if (($truthy(count) && ($truthy(count < 0)))) {
        $Kernel.$raise($$$('ArgumentError'), "count must be greater than 0")
      };
      if ($truthy(options)) {
        rng = options['$[]']("random")
      };
      rng = (($truthy(rng) && ($truthy(rng['$respond_to?']("rand")))) ? ($$('SampleRandom').$new(rng)) : ($Kernel));
      if (!$truthy(count)) {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length - 1);
          if (i <= j) {
            j++;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$('Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length - c) + c;
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, -1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select"], function $$42(){var self = $$42.$$s == null ? this : $$42.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    });
    
    $def(self, '$select!', function $Array_select$excl$43() {
      var block = $Array_select$excl$43.$$p || nil, self = this;

      $Array_select$excl$43.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select!"], function $$44(){var self = $$44.$$s == null ? this : $$44.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self)

      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    });
    
    $def(self, '$shift', function $$shift(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return shiftNoArg(self);
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      return self.splice(0, count);;
    }, -1);
    
    $def(self, '$shuffle', function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, -1);
    
    $def(self, '$shuffle!', function $Array_shuffle$excl$45(rng) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $Opal['$coerce_to?'](rng, $$$('Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            $Kernel.$raise($$$('RangeError'), "random number too small " + (j))
          }

          if (j >= i) {
            $Kernel.$raise($$$('RangeError'), "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$slice!', function $Array_slice$excl$46(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      $deny_frozen_access(self);
      result = nil;
      if ($truthy(length === undefined)) {
        if ($eqeqeq($$$('Range'), index)) {
          
          range = index;
          result = self['$[]'](range);
          range_start = range.begin === nil ? 0 : $coerce_to(range.begin, $$$('Integer'), 'to_int');
          range_end = range.end === nil ? -1 : $coerce_to(range.end, $$$('Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl && range.end !== nil) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, -2);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this;

      $$sort.$$p = null;
      
      ;
      if (!$truthy(self.length > 1)) {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    });
    
    $def(self, '$sort!', function $Array_sort$excl$47() {
      var block = $Array_sort$excl$47.$$p || nil, self = this;

      $Array_sort$excl$47.$$p = null;
      
      ;
      
      $deny_frozen_access(self)

      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    });
    
    $def(self, '$sort_by!', function $Array_sort_by$excl$48() {
      var block = $Array_sort_by$excl$48.$$p || nil, self = this;

      $Array_sort_by$excl$48.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by!"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$size()}, {$$s: self})
      };
      $deny_frozen_access(self);
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    });
    
    $def(self, '$take', function $$take(count) {
      var self = this;

      
      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'));
      }

      return self.slice(0, count);
    
    });
    
    $def(self, '$take_while', function $$take_while() {
      var block = $$take_while.$$p || nil, self = this;

      $$take_while.$$p = null;
      
      ;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    });
    
    $def(self, '$to_ary', $return_self);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this, array = nil;

      $$to_h.$$p = null;
      
      ;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())
      };
      
      var i, len = array.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $Opal['$coerce_to?'](array[i], $$$('Array'), "to_ary");
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    });
    
    $def(self, '$transpose', function $$transpose() {
      var self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []
      };
      result = [];
      max = nil;
      $send(self, 'each', [], function $$50(row){var $ret_or_1 = nil;

        
        if (row == null) row = nil;
        row = ($eqeqeq($$$('Array'), row) ? (row.$to_a()) : (($coerce_to(row, $$$('Array'), 'to_ary')).$to_a()));
        max = ($truthy(($ret_or_1 = max)) ? ($ret_or_1) : (row.length));
        if ($neqeq(row.length, max)) {
          $Kernel.$raise($$$('IndexError'), "element size differs (" + (row.length) + " should be " + (max) + ")")
        };
        return $send((row.length), 'times', [], function $$51(i){var $a, entry = nil;

          
          if (i == null) i = nil;
          entry = ($truthy(($ret_or_1 = result['$[]'](i))) ? ($ret_or_1) : (($a = [i, []], $send(result, '[]=', $a), $a[$a.length - 1])));
          return entry['$<<'](row.$at(i));});});
      return result;
    });
    
    $def(self, '$union', function $$union($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$uniq()], function $$52(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$|'](b);});
    }, -1);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this;

      $$uniq.$$p = null;
      
      ;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    });
    
    $def(self, '$uniq!', function $Array_uniq$excl$53() {
      var block = $Array_uniq$excl$53.$$p || nil, self = this;

      $Array_uniq$excl$53.$$p = null;
      
      ;
      
      $deny_frozen_access(self);

      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    });
    
    $def(self, '$unshift', function $$unshift($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, -1);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this, out = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      out = [];
      $send(args, 'each', [], function $$54(elem){var self = $$54.$$s == null ? this : $$54.$$s, finish = nil, start = nil, i = nil;

        
        if (elem == null) elem = nil;
        if ($truthy(elem['$is_a?']($$$('Range')))) {
          
          finish = elem.$end() === nil ? -1 : $coerce_to(elem.$end(), $$$('Integer'), 'to_int');
          start = elem.$begin() === nil ? 0 : $coerce_to(elem.$begin(), $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']() && elem.$end() !== nil) {
            finish--;
          }
          if (finish < start) {
            return nil;
          }
        ;
          return $send(start, 'upto', [finish], function $$55(i){var self = $$55.$$s == null ? this : $$55.$$s;

            
            if (i == null) i = nil;
            return out['$<<'](self.$at(i));}, {$$s: self});
        } else {
          
          i = $coerce_to(elem, $$$('Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, {$$s: self});
      return out;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this, $ret_or_1 = nil;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = ($truthy(($ret_or_1 = $Opal['$coerce_to?'](o, $$$('Array'), "to_ary"))) ? ($ret_or_1) : ($Opal['$coerce_to!'](o, $$$('Enumerator'), "to_enum", "each"))).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          Opal.yield1(block, result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, -1);
    $defs(self, '$inherited', function $$inherited(klass) {
      
      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var $yield = $$instance_variables.$$p || nil, self = this;

      $$instance_variables.$$p = null;
      return $send($send2(self, $find_super(self, 'instance_variables', $$instance_variables, false, true), 'instance_variables', [], $yield), 'reject', [], function $$56(ivar){var $ret_or_1 = nil;

        
        if (ivar == null) ivar = nil;
        if ($truthy(($ret_or_1 = /^@\d+$/.test(ivar)))) {
          return $ret_or_1
        } else {
          return ivar['$==']("@length")
        };})
    });
    
    $def(self, '$pack', function $$pack($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $Kernel.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, -1);
    $alias(self, "append", "push");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "map", "collect");
    $alias(self, "map!", "collect!");
    $alias(self, "prepend", "unshift");
    $alias(self, "size", "length");
    $alias(self, "slice", "[]");
    $alias(self, "to_s", "inspect");
    $Opal.$pristine(self.$singleton_class(), "allocate");
    return $Opal.$pristine(self, "copy_instance_variables", "initialize_dup");
  })('::', Array, $nesting);
};

Opal.modules["corelib/hash"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $yield1 = Opal.yield1, $hash = Opal.hash, $hash_init = Opal.hash_init, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $klass = Opal.klass, $slice = Opal.slice, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $hash2 = Opal.hash2, $truthy = Opal.truthy, $to_a = Opal.to_a, $return_self = Opal.return_self, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,[],merge!,allocate,raise,coerce_to!,each,fetch,>=,>,==,compare_by_identity,lambda?,abs,arity,enum_for,size,respond_to?,class,dig,except!,dup,delete,new,inspect,map,to_proc,flatten,frozen?,eql?,default,default_proc,default_proc=,default=,to_h,proc,clone,select,select!,has_key?,indexes,index,length,[]=,has_value?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_hash = true;
    $defs(self, '$[]', function $Hash_$$$1($a) {
      var $post_args, argv, self = this;

      
      $post_args = $slice(arguments);
      argv = $post_args;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Array'), "to_ary");
        if (argv === nil) {
          $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            $Kernel.$raise($$$('ArgumentError'), "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, -1);
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      $hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    });
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Hash'), "to_hash")
    });
    
    $def(self, '$initialize', function $$initialize(defaults) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (defaults !== undefined && block !== nil) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, -1);
    
    $def(self, '$==', function $Hash_$eq_eq$2(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = $hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    });
    
    $def(self, '$>=', function $Hash_$gt_eq$3(other) {
      var self = this, result = nil;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], function $$4(other_key, other_val){var self = $$4.$$s == null ? this : $$4.$$s, val = nil;

        
        if (other_key == null) other_key = nil;
        if (other_val == null) other_val = nil;
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, {$$s: self});
      return result;
    });
    
    $def(self, '$>', function $Hash_$gt$5(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    });
    
    $def(self, '$<', function $Hash_$lt$6(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_gt(other, self);
    });
    
    $def(self, '$<=', function $Hash_$lt_eq$7(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_ge(other, self);
    });
    
    $def(self, '$[]', function $Hash_$$$8(key) {
      var self = this;

      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    });
    
    $def(self, '$[]=', function $Hash_$$$eq$9(key, value) {
      var self = this;

      
      $deny_frozen_access(self);

      $hash_put(self, key, value);
      return value;
    
    });
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    });
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);

      $hash_init(self);
      return self;
    
    });
    
    $def(self, '$clone', function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    
    });
    
    $def(self, '$compact!', function $Hash_compact$excl$10() {
      var self = this;

      
      $deny_frozen_access(self);

      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    });
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      
      $deny_frozen_access(self);

      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        $hash_put(identity_hash, key, $hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    });
    
    $def(self, '$compare_by_identity?', function $Hash_compare_by_identity$ques$11() {
      var self = this;

      return self.$$by_identity === true;
    });
    
    $def(self, '$default', function $Hash_default$12(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, -1);
    
    $def(self, '$default=', function $Hash_default$eq$13(object) {
      var self = this;

      
      $deny_frozen_access(self);

      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    });
    
    $def(self, '$default_proc', function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    });
    
    $def(self, '$default_proc=', function $Hash_default_proc$eq$14(default_proc) {
      var self = this;

      
      $deny_frozen_access(self);

      var proc = default_proc;

      if (proc !== nil) {
        proc = $Opal['$coerce_to!'](proc, $$$('Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          $Kernel.$raise($$$('TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    });
    
    $def(self, '$delete', function $Hash_delete$15(key) {
      var block = $Hash_delete$15.$$p || nil, self = this;

      $Hash_delete$15.$$p = null;
      
      ;
      
      $deny_frozen_access(self);
      var value = $hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["delete_if"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    });
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      keys = $post_args;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each"], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $yield1(block, [key, value]);
      }

      return self;
    ;
    });
    
    $def(self, '$each_key', function $$each_key() {
      var block = $$each_key.$$p || nil, self = this;

      $$each_key.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_key"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    });
    
    $def(self, '$each_value', function $$each_value() {
      var block = $$each_value.$$p || nil, self = this;

      $$each_value.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_value"], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    });
    
    $def(self, '$empty?', function $Hash_empty$ques$20() {
      var self = this;

      return self.$$keys.length === 0;
    });
    
    $def(self, '$except', function $$except($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      return $send(self.$dup(), 'except!', $to_a(keys));
    }, -1);
    
    $def(self, '$except!', function $Hash_except$excl$21($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      $send(keys, 'each', [], function $$22(key){var self = $$22.$$s == null ? this : $$22.$$s;

        
        if (key == null) key = nil;
        return self.$delete(key);}, {$$s: self});
      return self;
    }, -1);
    
    $def(self, '$fetch', function $$fetch(key, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return $Kernel.$raise($$$('KeyError').$new("key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, -2);
    
    $def(self, '$fetch_values', function $$fetch_values($a) {
      var block = $$fetch_values.$$p || nil, $post_args, keys, self = this;

      $$fetch_values.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      keys = $post_args;
      return $send(keys, 'map', [], function $$23(key){var self = $$23.$$s == null ? this : $$23.$$s;

        
        if (key == null) key = nil;
        return $send(self, 'fetch', [key], block.$to_proc());}, {$$s: self});
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      if (level == null) level = 1;
      level = $Opal['$coerce_to!'](level, $$$('Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    });
    
    $def(self, '$has_key?', function $Hash_has_key$ques$24(key) {
      var self = this;

      return $hash_get(self, key) !== undefined;
    });
    
    $def(self, '$has_value?', function $Hash_has_value$ques$25(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    });
    
    $def(self, '$index', function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    });
    
    $def(self, '$indexes', function $$indexes($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = $hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    var inspect_ids;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];
    ;
      
      return (function() { try {
      
      
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          key = $$('Opal').$inspect(key)
          value = $$('Opal').$inspect(value)

          result.push(key + '=>' + value);
        }

        return '{' + result.join(', ') + '}';
      ;
      return nil;
      } finally {
        if (top) inspect_ids = undefined
      }; })();;
    });
    
    $def(self, '$invert', function $$invert() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $hash_put(hash, value, key);
      }

      return hash;
    
    });
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["keep_if"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    });
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$$keys.length;
    });
    
    $def(self, '$merge', function $$merge($a) {
      var block = $$merge.$$p || nil, $post_args, others, self = this;

      $$merge.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      return $send(self.$dup(), 'merge!', $to_a(others), block.$to_proc());
    }, -1);
    
    $def(self, '$merge!', function $Hash_merge$excl$27($a) {
      var block = $Hash_merge$excl$27.$$p || nil, $post_args, others, self = this;

      $Hash_merge$excl$27.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      
      $deny_frozen_access(self);
      var i, j, other, other_keys, length, key, value, other_value;
      for (i = 0; i < others.length; ++i) {
        other = $Opal['$coerce_to!'](others[i], $$$('Hash'), "to_hash");
        other_keys = other.$$keys, length = other_keys.length;

        if (block === nil) {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            $hash_put(self, key, other_value);
          }
        } else {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            value = $hash_get(self, key);

            if (value === undefined) {
              $hash_put(self, key, other_value);
              continue;
            }

            $hash_put(self, key, block(key, value, other_value));
          }
        }
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    });
    
    $def(self, '$rehash', function $$rehash() {
      var self = this;

      
      $deny_frozen_access(self);
      Opal.hash_rehash(self);
      return self;
    
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject"], function $$28(){var self = $$28.$$s == null ? this : $$28.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    });
    
    $def(self, '$reject!', function $Hash_reject$excl$29() {
      var block = $Hash_reject$excl$29.$$p || nil, self = this;

      $Hash_reject$excl$29.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject!"], function $$30(){var self = $$30.$$s == null ? this : $$30.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    });
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);;
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      $hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        $hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        self['$default_proc='](other.$default_proc())
      } else {
        self['$default='](other.$default())
      };
      return self;
    });
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    });
    
    $def(self, '$select!', function $Hash_select$excl$32() {
      var block = $Hash_select$excl$32.$$p || nil, self = this;

      $Hash_select$excl$32.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select!"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    });
    
    $def(self, '$shift', function $$shift() {
      var self = this;

      
      $deny_frozen_access(self);
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, $hash_delete(self, key)];
      }

      return nil;
    
    });
    
    $def(self, '$slice', function $$slice($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      
      var result = $hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = $hash_get(self, key);

        if (value !== undefined) {
          $hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    });
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()
      };
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    ;
    });
    
    $def(self, '$to_hash', $return_self);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return $send(self, 'proc', [], function $$34(key){var self = $$34.$$s == null ? this : $$34.$$s;

        
        ;
        
        if (key == null) {
          $Kernel.$raise($$$('ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$transform_keys', function $$transform_keys() {
      var block = $$transform_keys.$$p || nil, self = this;

      $$transform_keys.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = $yield1(block, key);

        $hash_put(result, key, value);
      }

      return result;
    ;
    });
    
    $def(self, '$transform_keys!', function $Hash_transform_keys$excl$36() {
      var block = $Hash_transform_keys$excl$36.$$p || nil, self = this;

      $Hash_transform_keys$excl$36.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var keys = Opal.slice(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = $yield1(block, key);

        $hash_delete(self, key);
        $hash_put(self, new_key, value);
      }

      return self;
    ;
    });
    
    $def(self, '$transform_values', function $$transform_values() {
      var block = $$transform_values.$$p || nil, self = this;

      $$transform_values.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(result, key, value);
      }

      return result;
    ;
    });
    
    $def(self, '$transform_values!', function $Hash_transform_values$excl$39() {
      var block = $Hash_transform_values$excl$39.$$p || nil, self = this;

      $Hash_transform_values$excl$39.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values!"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(self, key, value);
      }

      return self;
    ;
    });
    
    $def(self, '$values', function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    });
    $alias(self, "dup", "clone");
    $alias(self, "each_pair", "each");
    $alias(self, "eql?", "==");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "include?", "has_key?");
    $alias(self, "indices", "indexes");
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");
    $alias(self, "member?", "has_key?");
    $alias(self, "size", "length");
    $alias(self, "store", "[]=");
    $alias(self, "to_s", "inspect");
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    return $alias(self, "values_at", "indexes");
  })('::', null, $nesting);
};

Opal.modules["corelib/number"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $not = Opal.not, $rb_lt = Opal.rb_lt, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeq = Opal.eqeq, $return_self = Opal.return_self, $rb_divide = Opal.rb_divide, $to_ary = Opal.to_ary, $rb_times = Opal.rb_times, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $return_val = Opal.return_val, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,bridge,raise,name,class,Float,respond_to?,coerce_to!,__coerced__,===,>,!,**,new,<,to_f,==,nan?,infinite?,enum_for,+,-,gcd,lcm,%,/,frexp,to_i,ldexp,rationalize,*,<<,to_r,truncate,-@,size,<=,>=,inspect,angle,to_s,is_a?,abs,__id__,next,coerce_to?');
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting);

    
    $Opal.$bridge(Number, self);
    Opal.prop(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [$Kernel.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$Opal['$coerce_to!'](other, $$$('Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
    
    });
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    });
    
    $def(self, '$+', function $Number_$plus$1(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    });
    
    $def(self, '$-', function $Number_$minus$2(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    });
    
    $def(self, '$*', function $Number_$$3(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    });
    
    $def(self, '$/', function $Number_$slash$4(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    });
    
    $def(self, '$%', function $Number_$percent$5(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    });
    
    $def(self, '$&', function $Number_$$6(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    });
    
    $def(self, '$|', function $Number_$$7(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    });
    
    $def(self, '$^', function $Number_$$8(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    });
    
    $def(self, '$<', function $Number_$lt$9(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    });
    
    $def(self, '$<=', function $Number_$lt_eq$10(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    });
    
    $def(self, '$>', function $Number_$gt$11(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    });
    
    $def(self, '$>=', function $Number_$gt_eq$12(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    });
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    $def(self, '$<=>', function $Number_$lt_eq_gt$13(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    });
    
    $def(self, '$<<', function $Number_$lt$lt$14(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    });
    
    $def(self, '$>>', function $Number_$gt$gt$15(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    });
    
    $def(self, '$[]', function $Number_$$$16(bit) {
      var self = this;

      
      bit = $Opal['$coerce_to!'](bit, $$$('Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    });
    
    $def(self, '$+@', function $Number_$plus$$17() {
      var self = this;

      return +self;
    });
    
    $def(self, '$-@', function $Number_$minus$$18() {
      var self = this;

      return -self;
    });
    
    $def(self, '$~', function $Number_$$19() {
      var self = this;

      return ~self;
    });
    
    $def(self, '$**', function $Number_$$$20(other) {
      var self = this;

      if ($eqeqeq($$$('Integer'), other)) {
        if (($not($$$('Integer')['$==='](self)) || ($truthy($rb_gt(other, 0))))) {
          return Math.pow(self, other);
        } else {
          return $$$('Rational').$new(self, 1)['$**'](other)
        }
      } else if (($rb_lt(self, 0) && (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))))) {
        return $$$('Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    });
    
    $def(self, '$==', function $Number_$eq_eq$21(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    });
    $alias(self, "===", "==");
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return Math.abs(self);
    });
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    });
    
    $def(self, '$allbits?', function $Number_allbits$ques$22(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == mask;;
    });
    
    $def(self, '$anybits?', function $Number_anybits$ques$23(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) !== 0;;
    });
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self
      };
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    });
    
    $def(self, '$bit_length', function $$bit_length() {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), self)) {
        $Kernel.$raise($$$('NoMethodError').$new("undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    });
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$chr', function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCharCode(self), encoding || "BINARY");;
    }, -1);
    
    $def(self, '$denominator', function $$denominator() {
      var $yield = $$denominator.$$p || nil, self = this;

      $$denominator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return 1
      } else {
        return $send2(self, $find_super(self, 'denominator', $$denominator, false, true), 'denominator', [], $yield)
      }
    });
    
    $def(self, '$downto', function $$downto(stop) {
      var block = $$downto.$$p || nil, self = this;

      $$downto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["downto", stop], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, {$$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    });
    
    $def(self, '$equal?', function $Number_equal$ques$25(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$=='](other)))) {
        return $ret_or_1
      } else {
        return isNaN(self) && isNaN(other);
      }
    });
    
    $def(self, '$even?', function $Number_even$ques$26() {
      var self = this;

      return self % 2 === 0;
    });
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$gcd', function $$gcd(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    });
    
    $def(self, '$gcdlcm', function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    });
    
    $def(self, '$integer?', function $Number_integer$ques$27() {
      var self = this;

      return self % 1 === 0;
    });
    
    $def(self, '$is_a?', function $Number_is_a$ques$28(klass) {
      var $yield = $Number_is_a$ques$28.$$p || nil, self = this;

      $Number_is_a$ques$28.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'is_a?', $Number_is_a$ques$28, false, true), 'is_a?', [klass], $yield);
    });
    
    $def(self, '$instance_of?', function $Number_instance_of$ques$29(klass) {
      var $yield = $Number_instance_of$ques$29.$$p || nil, self = this;

      $Number_instance_of$ques$29.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'instance_of?', $Number_instance_of$ques$29, false, true), 'instance_of?', [klass], $yield);
    });
    
    $def(self, '$lcm', function $$lcm(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    });
    
    $def(self, '$next', function $$next() {
      var self = this;

      return self + 1;
    });
    
    $def(self, '$nobits?', function $Number_nobits$ques$30(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == 0;;
    });
    
    $def(self, '$nonzero?', function $Number_nonzero$ques$31() {
      var self = this;

      return self == 0 ? nil : self;
    });
    
    $def(self, '$numerator', function $$numerator() {
      var $yield = $$numerator.$$p || nil, self = this;

      $$numerator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return self
      } else {
        return $send2(self, $find_super(self, 'numerator', $$numerator, false, true), 'numerator', [], $yield)
      }
    });
    
    $def(self, '$odd?', function $Number_odd$ques$32() {
      var self = this;

      return self % 2 !== 0;
    });
    
    $def(self, '$ord', $return_self);
    
    $def(self, '$pow', function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$$('Integer')['$==='](b))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$$('Integer')['$==='](m))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, -2);
    
    $def(self, '$pred', function $$pred() {
      var self = this;

      return self - 1;
    });
    
    $def(self, '$quo', function $$quo(other) {
      var $yield = $$quo.$$p || nil, self = this;

      $$quo.$$p = null;
      if ($eqeqeq($$$('Integer'), self)) {
        return $send2(self, $find_super(self, 'quo', $$quo, false, true), 'quo', [other], $yield)
      } else {
        return $rb_divide(self, other)
      }
    });
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$$('Float'), 'MANT_DIG'));
        return $$$('Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$$('Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, -1);
    
    $def(self, '$remainder', function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    });
    
    $def(self, '$round', function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($eqeqeq($$$('Integer'), self)) {
        
        if ($truthy(ndigits == null)) {
          return self
        };
        if (($eqeqeq($$$('Float'), ndigits) && ($truthy(ndigits['$infinite?']())))) {
          $Kernel.$raise($$$('RangeError'), "Infinity")
        };
        ndigits = $Opal['$coerce_to!'](ndigits, $$$('Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$$('Integer'), 'MIN')))) {
          $Kernel.$raise($$$('RangeError'), "out of bounds")
        };
        if ($truthy(ndigits >= 0)) {
          return self
        };
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if (($truthy(self['$nan?']()) && ($truthy(ndigits == null)))) {
          $Kernel.$raise($$$('FloatDomainError'), "NaN")
        };
        ndigits = $Opal['$coerce_to!'](ndigits || 0, $$$('Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            $Kernel.$raise($$$('RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            $Kernel.$raise($$$('FloatDomainError'), "Infinity")
          }
        } else if ($eqeq(ndigits, 0)) {
          return Math.round(self)
        } else if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
          return self
        };
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$$('Float'), 'DIG'), 2), ($truthy($rb_gt(exp, 0)) ? ($rb_divide(exp, 4)) : ($rb_minus($rb_divide(exp, 3), 1))))))) {
          return self
        };
        if ($truthy($rb_lt(ndigits, ($truthy($rb_gt(exp, 0)) ? ($rb_plus($rb_divide(exp, 3), 1)) : ($rb_divide(exp, 4)))['$-@']()))) {
          return 0
        };
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, -1);
    
    $def(self, '$times', function $$times() {
      var block = $$times.$$p || nil, self = this;

      $$times.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["times"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self}, {$$s: self})
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    });
    
    $def(self, '$to_f', $return_self);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    });
    
    $def(self, '$to_r', function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$$('Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$$('Float'), 'RADIX')['$**'](e)).$to_r();
      }
    });
    
    $def(self, '$to_s', function $$to_s(base) {
      var self = this;

      
      if (base == null) base = 10;
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if (($truthy($rb_lt(base, 2)) || ($truthy($rb_gt(base, 36))))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      if (($eqeq(self, 0) && ($truthy(1/self === -Infinity)))) {
        return "-0.0"
      };
      return self.toString(base);;
    }, -1);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$digits', function $$digits(base) {
      var self = this;

      
      if (base == null) base = 10;
      if ($rb_lt(self, 0)) {
        $Kernel.$raise($$$($$$('Math'), 'DomainError'), "out of domain")
      };
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      
      if (self != parseInt(self)) $Kernel.$raise($$$('NoMethodError'), "undefined method `digits' for " + (self.$inspect()))

      var value = self, result = [];

      if (self == 0) {
        return [0];
      }

      while (value != 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var $yield = $$divmod.$$p || nil, self = this;

      $$divmod.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(other['$nan?']())))) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else {
        return $send2(self, $find_super(self, 'divmod', $$divmod, false, true), 'divmod', [other], $yield)
      }
    });
    
    $def(self, '$upto', function $$upto(stop) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["upto", stop], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, {$$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    });
    
    $def(self, '$zero?', function $Number_zero$ques$35() {
      var self = this;

      return self == 0;
    });
    
    $def(self, '$size', $return_val(4));
    
    $def(self, '$nan?', function $Number_nan$ques$36() {
      var self = this;

      return isNaN(self);
    });
    
    $def(self, '$finite?', function $Number_finite$ques$37() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    });
    
    $def(self, '$infinite?', function $Number_infinite$ques$38() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    });
    
    $def(self, '$positive?', function $Number_positive$ques$39() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    });
    
    $def(self, '$negative?', function $Number_negative$ques$40() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    });
    
    function numberToUint8Array(num) {
      var uint8array = new Uint8Array(8);
      new DataView(uint8array.buffer).setFloat64(0, num, true);
      return uint8array;
    }

    function uint8ArrayToNumber(arr) {
      return new DataView(arr.buffer).getFloat64(0, true);
    }

    function incrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0xff) {
          arr[i] = 0;
        } else {
          arr[i]++;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }

    function decrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0) {
          arr[i] = 0xff;
        } else {
          arr[i]--;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }
  ;
    
    $def(self, '$next_float', function $$next_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY'))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($rb_ge(self, 0)) {
        return incrementNumberBit(Math.abs(self));
      } else {
        return decrementNumberBit(self);
      };
    });
    
    $def(self, '$prev_float', function $$prev_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY')['$-@']())) {
        return $$$($$$('Float'), 'INFINITY')['$-@']()
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($rb_gt(self, 0)) {
        return decrementNumberBit(self);
      } else {
        return -incrementNumberBit(Math.abs(self));
      };
    });
    $alias(self, "arg", "angle");
    $alias(self, "eql?", "==");
    $alias(self, "fdiv", "/");
    $alias(self, "inspect", "to_s");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "object_id", "__id__");
    $alias(self, "phase", "angle");
    $alias(self, "succ", "next");
    return $alias(self, "to_int", "to_i");
  })('::', $$$('Numeric'), $nesting);
  $const_set('::', 'Fixnum', $$$('Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      Opal.udef(self, '$' + "new");;
      
      $def(self, '$sqrt', function $$sqrt(n) {
        
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        
        if (n < 0) {
          $Kernel.$raise($$$($$$('Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      });
      return $def(self, '$try_convert', function $$try_convert(object) {
        var self = this;

        return $$('Opal')['$coerce_to?'](object, self, "to_int")
      });
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'MAX', Math.pow(2, 30) - 1);
    return $const_set(self, 'MIN', -Math.pow(2, 30));
  })('::', $$$('Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      Opal.udef(self, '$' + "new");;
      return $def(self, '$===', function $eq_eq_eq$41(other) {
        
        return !!other.$$is_number;
      });
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'INFINITY', Infinity);
    $const_set(self, 'MAX', Number.MAX_VALUE);
    $const_set(self, 'MIN', Number.MIN_VALUE);
    $const_set(self, 'NAN', NaN);
    $const_set(self, 'DIG', 15);
    $const_set(self, 'MANT_DIG', 53);
    $const_set(self, 'RADIX', 2);
    return $const_set(self, 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/range"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $send = Opal.send, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $return_ivar = Opal.return_ivar, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $Opal = Opal.Opal, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $rb_times = Opal.rb_times, $rb_ge = Opal.rb_ge, $thrower = Opal.thrower, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,attr_reader,raise,nil?,<=>,include?,!,<,<=,enum_for,size,upto,to_proc,respond_to?,class,succ,==,===,exclude_end?,eql?,begin,end,last,to_a,>,-@,-,to_i,coerce_to!,ceil,/,is_a?,new,loop,+,*,>=,each_with_index,%,step,bsearch,inspect,[],hash,cover?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.begin = $proto.end = $proto.excl = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    $def(self, '$initialize', function $$initialize(first, last, exclude) {
      var self = this;

      
      if (exclude == null) exclude = false;
      if ($truthy(self.begin)) {
        $Kernel.$raise($$$('NameError'), "'initialize' called twice")
      };
      if (!(($truthy(first['$<=>'](last)) || ($truthy(first['$nil?']()))) || ($truthy(last['$nil?']())))) {
        $Kernel.$raise($$$('ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, -3);
    
    $def(self, '$===', function $Range_$eq_eq_eq$1(value) {
      var self = this;

      return self['$include?'](value)
    });
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    $def(self, '$count', function $$count() {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      if (($not((block !== nil)) && ($truthy(is_infinite(self))))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [], block);
    });
    
    $def(self, '$to_a', function $$to_a() {
      var $yield = $$to_a.$$p || nil, self = this;

      $$to_a.$$p = null;
      
      if ($truthy(is_infinite(self))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert endless range to an array")
      };
      return $send2(self, $find_super(self, 'to_a', $$to_a, false, true), 'to_a', [], $yield);
    });
    
    $def(self, '$cover?', function $Range_cover$ques$2(value) {
      var self = this, beg_cmp = nil, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, end_cmp = nil;

      
      beg_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.begin['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (self.begin['$<=>'](value))))) && ($ret_or_1));
      end_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.end['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (value['$<=>'](self.end))))) && ($ret_or_1));
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(self.excl) ? (($truthy(($ret_or_3 = end_cmp)) ? ($rb_lt(end_cmp, 0)) : ($ret_or_3))) : ($truthy(($ret_or_3 = end_cmp)) ? ($rb_le(end_cmp, 0)) : ($ret_or_3))))) ? (beg_cmp) : ($ret_or_2))))) {
        return $rb_le(beg_cmp, 0)
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this, current = nil, last = nil, $ret_or_1 = nil;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + ($truthy(self.excl) ? (0) : (1)); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if (!$truthy(current['$respond_to?']("succ"))) {
        $Kernel.$raise($$$('TypeError'), "can't iterate from " + (current.$class()))
      };
      while ($truthy(($truthy(($ret_or_1 = self.end['$nil?']())) ? ($ret_or_1) : ($rb_lt(current['$<=>'](last), 0))))) {
      
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if (($not(self.excl) && ($eqeq(current, last)))) {
        Opal.yield1(block, current)
      };
      return self;
    });
    
    $def(self, '$eql?', function $Range_eql$ques$4(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      if (!$eqeqeq($$$('Range'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.excl['$==='](other['$exclude_end?']()))) ? (self.begin['$eql?'](other.$begin())) : ($ret_or_2))))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$exclude_end?', $return_ivar("excl"));
    
    $def(self, '$first', function $$first(n) {
      var $yield = $$first.$$p || nil, self = this;

      $$first.$$p = null;
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      };
      if ($truthy(n == null)) {
        return self.begin
      };
      return $send2(self, $find_super(self, 'first', $$first, false, true), 'first', [n], $yield);
    }, -1);
    
    $def(self, '$last', function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      };
      if ($truthy(n == null)) {
        return self.end
      };
      return self.$to_a().$last(n);
    }, -1);
    
    $def(self, '$max', function $$max() {
      var $yield = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      if ($truthy(self.end['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'max', $$max, false, true), 'max', [], $yield)
      } else if (($not(self.begin['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    });
    
    $def(self, '$min', function $$min() {
      var $yield = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      if ($truthy(self.begin['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'min', $$min, false, true), 'min', [], $yield)
      } else if (($not(self.end['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.begin
      }
    });
    
    $def(self, '$size', function $$size() {
      var self = this, infinity = nil, range_begin = nil, range_end = nil;

      
      infinity = $$$($$$('Float'), 'INFINITY');
      if ((($eqeq(self.begin, infinity) && ($not(self.end['$nil?']()))) || (($eqeq(self.end, infinity['$-@']()) && ($not(self.begin['$nil?']())))))) {
        return 0
      };
      if ($truthy(is_infinite(self))) {
        return infinity
      };
      if (!($eqeqeq($$$('Numeric'), self.begin) && ($eqeqeq($$$('Numeric'), self.end)))) {
        return nil
      };
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)
      };
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0
      };
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    });
    
    $def(self, '$step', function $$step(n) {
      var $yield = $$step.$$p || nil, self = this, $ret_or_1 = nil, i = nil;

      $$step.$$p = null;
      
      ;
      
      function coerceStepSize() {
        if (n == null) {
          n = 1;
        }
        else if (!n.$$is_number) {
          n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int")
        }

        if (n < 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$$('Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (!($yield !== nil)) {
        if (((($truthy(self.begin['$is_a?']($$('Numeric'))) || ($truthy(self.begin['$nil?']()))) && (($truthy(self.end['$is_a?']($$('Numeric'))) || ($truthy(self.end['$nil?']()))))) && ($not(($truthy(($ret_or_1 = self.begin['$nil?']())) ? (self.end['$nil?']()) : ($ret_or_1)))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "step")
        } else {
          return $send(self, 'enum_for', ["step", n], function $$5(){
            
            coerceStepSize();
            return enumeratorSize();
          })
        }
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

          
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              $t_break.$throw()
            }
          } else if ($truthy($rb_gt(current, self.end))) {
            $t_break.$throw()
          };
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, {$$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], function $$7(value, idx){
          
          if (value == null) value = nil;
          if (idx == null) idx = nil;
          if ($eqeq(idx['$%'](n), 0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };});
      };
      return self;
    }, -1);
    
    $def(self, '$%', function $Range_$percent$8(n) {
      var self = this;

      if (($truthy(self.begin['$is_a?']($$('Numeric'))) && ($truthy(self.end['$is_a?']($$('Numeric')))))) {
        return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "%")
      } else {
        return self.$step(n)
      }
    });
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        $Kernel.$raise($$$('NotImplementedError'), "Can't #bsearch an infinite range")
      };
      if (!$truthy(self.begin.$$is_number && self.end.$$is_number)) {
        $Kernel.$raise($$$('TypeError'), "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? ($ret_or_1) : (""))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? ($ret_or_1) : ("")))
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? (self.begin.$inspect()) : ($ret_or_1))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? (self.end.$inspect()) : ($ret_or_1)))
    });
    
    $def(self, '$marshal_load', function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    });
    $alias(self, "==", "eql?");
    $alias(self, "include?", "cover?");
    return $alias(self, "member?", "cover?");
  })('::', null, $nesting);
};

Opal.modules["corelib/proc"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $return_self = Opal.return_self, $ensure_kwargs = Opal.ensure_kwargs, $Opal = Opal.Opal, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,proc,call,to_proc,new,source_location,coerce_to!,dup');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    Opal.prop(self.$$prototype, '$$is_proc', true);
    Opal.prop(self.$$prototype, '$$is_lambda', false);
    $defs(self, '$new', function $Proc_new$1() {
      var block = $Proc_new$1.$$p || nil;

      $Proc_new$1.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    });
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk, $ret = self.$$ret;

      if ($brk || ($ret && self.$$is_lambda)) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return err.$v;
          }
          else if (self.$$is_lambda && err === $ret) {
            return err.$v;
          }
          else {
            throw err;
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$>>', function $Proc_$gt$gt$2(other) {
      var $yield = $Proc_$gt$gt$2.$$p || nil, self = this;

      $Proc_$gt$gt$2.$$p = null;
      return $send($Kernel, 'proc', [], function $$3($a){var block = $$3.$$p || nil, $post_args, args, self = $$3.$$s == null ? this : $$3.$$s, out = nil;

        $$3.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        out = $send(self, 'call', $to_a(args), block.$to_proc());
        return other.$call(out);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$<<', function $Proc_$lt$lt$4(other) {
      var $yield = $Proc_$lt$lt$4.$$p || nil, self = this;

      $Proc_$lt$lt$4.$$p = null;
      return $send($Kernel, 'proc', [], function $$5($a){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, out = nil;

        $$5.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        out = $send(other, 'call', $to_a(args), block.$to_proc());
        return self.$call(out);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$to_proc', $return_self);
    
    $def(self, '$lambda?', function $Proc_lambda$ques$6() {
      var self = this;

      return !!self.$$is_lambda;
    });
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else if (self.$$arity != null) {
        return self.$$arity;
      } else {
        return self.length;
      }
    
    });
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      
      if (self.$$is_curried) { return nil; };
      if ($truthy(($ret_or_1 = self.$$source_location))) {
        return $ret_or_1
      } else {
        return nil
      };
    });
    
    $def(self, '$binding', function $$binding() {
      var $a, self = this;

      
      if (self.$$is_curried) { $Kernel.$raise($$$('ArgumentError'), "Can't create Binding") };
      if ($truthy((($a = $$$('::', 'Binding', 'skip_raise')) ? 'constant' : nil))) {
        return $$$('Binding').$new(nil, [], self.$$s, self.$source_location())
      } else {
        return nil
      };
    });
    
    $def(self, '$parameters', function $$parameters($kwargs) {
      var lambda, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      lambda = $kwargs.$$smap["lambda"];;
      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (lambda == null ? self.$$is_lambda : lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $Opal['$coerce_to!'](arity, $$$('Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    });
    $alias(self, "===", "call");
    $alias(self, "clone", "dup");
    $alias(self, "yield", "call");
    return $alias(self, "[]", "call");
  })('::', Function)
};

Opal.modules["corelib/method"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $slice = Opal.slice, $alias = Opal.alias, $Kernel = Opal.Kernel, $send = Opal.send, $to_a = Opal.to_a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,arity,curry,>>,<<,new,class,join,source_location,call,raise,bind,to_proc');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Method');

    var $proto = self.$$prototype;

    $proto.method = $proto.receiver = $proto.owner = $proto.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    $def(self, '$initialize', function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    });
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    });
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    });
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    });
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    });
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      return self.method.$curry(arity);
    }, -1);
    
    $def(self, '$>>', function $Method_$gt$gt$1(other) {
      var self = this;

      return self.method['$>>'](other)
    });
    
    $def(self, '$<<', function $Method_$lt$lt$2(other) {
      var self = this;

      return self.method['$<<'](other)
    });
    
    $def(self, '$unbind', function $$unbind() {
      var self = this;

      return $$$('UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    });
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity == null ? self.method.length : self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    });
    $alias(self, "[]", "call");
    return $alias(self, "===", "call");
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $proto = self.$$prototype;

    $proto.method = $proto.owner = $proto.name = $proto.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    $def(self, '$initialize', function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    });
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    });
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    });
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    });
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    });
    
    $def(self, '$bind', function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$$('Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    });
    
    $def(self, '$bind_call', function $$bind_call(object, $a) {
      var block = $$bind_call.$$p || nil, $post_args, args, self = this;

      $$bind_call.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      return $send(self.$bind(object), 'call', $to_a(args), block.$to_proc());
    }, -2);
    return $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    });
  })('::', null);
};

Opal.modules["corelib/variables"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $gvars = Opal.gvars, $const_set = Opal.const_set, $Object = Opal.Object, $hash2 = Opal.hash2, nil = Opal.nil;

  Opal.add_stubs('new');
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  $const_set('::', 'ARGV', []);
  $const_set('::', 'ARGF', $Object.$new());
  $const_set('::', 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

Opal.modules["corelib/io"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $not = Opal.not, $truthy = Opal.truthy, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $slice = Opal.slice, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $range = Opal.range, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $assign_ivar_val = Opal.assign_ivar_val, $alias = Opal.alias, $a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,attr_accessor,!,match?,include?,size,write,String,flatten,puts,sysread_noraise,+,!=,[],ord,getc,readchar,raise,gets,==,to_str,length,split,sub,sysread,>,to_a,each_line,enum_for,getbyte,closed_write?,closed_read?,each,eof,new,write_proc=,read_proc=');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'IO');

    var $proto = self.$$prototype;

    $proto.read_buffer = $proto.closed = nil;
    
    $const_set(self, 'SEEK_SET', 0);
    $const_set(self, 'SEEK_CUR', 1);
    $const_set(self, 'SEEK_END', 2);
    $const_set(self, 'SEEK_DATA', 3);
    $const_set(self, 'SEEK_HOLE', 4);
    $const_set(self, 'READABLE', 1);
    $const_set(self, 'WRITABLE', 4);
    self.$attr_reader("eof");
    self.$attr_accessor("read_proc", "sync", "tty", "write_proc");
    
    $def(self, '$initialize', function $$initialize(fd, flags) {
      var self = this;

      
      if (flags == null) flags = "r";
      self.fd = fd;
      self.flags = flags;
      self.eof = false;
      if (($truthy(flags['$include?']("r")) && ($not(flags['$match?'](/[wa+]/))))) {
        return (self.closed = "write")
      } else if (($truthy(flags['$match?'](/[wa]/)) && ($not(flags['$match?'](/[r+]/))))) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$fileno', $return_ivar("fd"));
    
    $def(self, '$tty?', function $IO_tty$ques$1() {
      var self = this;

      return self.tty == true;
    });
    
    $def(self, '$write', function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    });
    
    $def(self, '$flush', $return_val(nil));
    
    $def(self, '$<<', function $IO_$lt$lt$2(string) {
      var self = this;

      
      self.$write(string);
      return self;
    });
    
    $def(self, '$print', function $$print($a) {
      var $post_args, args, self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      for (var i = 0, ii = args.length; i < ii; i++) {
        args[i] = $Kernel.$String(args[i])
      }
      self.$write(args.join($gvars[","]));
    ;
      return nil;
    }, -1);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var line
      if (args.length === 0) {
        self.$write("\n");
        return nil;
      } else {
        for (var i = 0, ii = args.length; i < ii; i++) {
          if (args[i].$$is_array){
            var ary = (args[i]).$flatten()
            if (ary.length > 0) $send(self, 'puts', $to_a((ary)))
          } else {
            if (args[i].$$is_string) {
              line = args[i].valueOf();
            } else {
              line = $Kernel.$String(args[i]);
            }
            if (!line.endsWith("\n")) line += "\n"
            self.$write(line)
          }
        }
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$getc', function $$getc() {
      var self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if ($neqeq(self.read_buffer, "")) {
          
          ret = self.read_buffer['$[]'](0);
          self.read_buffer = self.read_buffer['$[]']($range(1, -1, false));
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(1))));;
      return nil;
    });
    
    $def(self, '$getbyte', function $$getbyte() {
      var $a, self = this;

      return ($a = self.$getc(), ($a === nil || $a == null) ? nil : $a.$ord())
    });
    
    $def(self, '$readbyte', function $$readbyte() {
      var self = this;

      return self.$readchar().$ord()
    });
    
    $def(self, '$readchar', function $$readchar() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$getc()))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      }
    });
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args, self = this, $ret_or_1 = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(($ret_or_1 = $send(self, 'gets', $to_a(args))))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      };
    }, -1);
    
    $def(self, '$gets', function $$gets(sep, limit, opts) {
      var $a, $b, self = this, orig_sep = nil, $ret_or_1 = nil, seplen = nil, data = nil, ret = nil, orig_buffer = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (sep == null) sep = false;
      if (limit == null) limit = nil;
      if (opts == null) opts = $hash2([], {});
      if (($truthy(sep.$$is_number) && ($not(limit)))) {
        $a = [false, sep, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      if ((($truthy(sep.$$is_hash) && ($not(limit))) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [false, nil, sep], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      } else if (($truthy(limit.$$is_hash) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [sep, nil, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      orig_sep = sep;
      if ($eqeq(sep, false)) {
        sep = $gvars["/"]
      };
      if ($eqeq(sep, "")) {
        sep = /\r?\n\r?\n/
      };
      sep = ($truthy(($ret_or_1 = sep)) ? ($ret_or_1) : (""));
      if (!$eqeq(orig_sep, "")) {
        sep = sep.$to_str()
      };
      seplen = ($eqeq(orig_sep, "") ? (2) : (sep.$length()));
      if ($eqeq(sep, " ")) {
        sep = / /
      };
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      data = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, data);
        if (($neqeq(sep, "") && ($truthy(($truthy(sep.$$is_regexp) ? (self.read_buffer['$match?'](sep)) : (self.read_buffer['$include?'](sep))))))) {
          
          orig_buffer = self.read_buffer;
          $b = self.read_buffer.$split(sep, 2), $a = $to_ary($b), (ret = ($a[0] == null ? nil : $a[0])), (self.read_buffer = ($a[1] == null ? nil : $a[1])), $b;
          if ($neqeq(ret, orig_buffer)) {
            ret = $rb_plus(ret, orig_buffer['$[]'](ret.$length(), seplen))
          };
          break;
        };
      } while ($truthy((data = self.$sysread_noraise(($eqeq(sep, "") ? (65536) : (1))))));;
      if (!$truthy(ret)) {
        
        $a = [($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : ("")), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
        if ($eqeq(ret, "")) {
          ret = nil
        };
      };
      if ($truthy(ret)) {
        
        if ($truthy(limit)) {
          
          ret = ret['$[]'](Opal.Range.$new(0,limit, true));
          self.read_buffer = $rb_plus(ret['$[]'](Opal.Range.$new(limit, -1, false)), self.read_buffer);
        };
        if ($truthy(opts['$[]']("chomp"))) {
          ret = ret.$sub(/\r?\n$/, "")
        };
        if ($eqeq(orig_sep, "")) {
          ret = ret.$sub(/^[\r\n]+/, "")
        };
      };
      if ($eqeq(orig_sep, false)) {
        $gvars._ = ret
      };
      return ret;
    }, -1);
    
    $def(self, '$sysread', function $$sysread(integer) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.read_proc(integer)))) {
        return $ret_or_1
      } else {
        
        self.eof = true;
        return $Kernel.$raise($$$('EOFError'), "end of file reached");
      }
    });
    
    $def(self, '$sysread_noraise', function $$sysread_noraise(integer) {
      var self = this;

      try {
        return self.$sysread(integer)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('EOFError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    });
    
    $def(self, '$readpartial', function $$readpartial(integer) {
      var $a, self = this, $ret_or_1 = nil, part = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      part = self.$sysread(integer);
      $a = [$rb_plus(self.read_buffer, ($truthy(($ret_or_1 = part)) ? ($ret_or_1) : (""))), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      if ($eqeq(ret, "")) {
        ret = nil
      };
      return ret;
    });
    
    $def(self, '$read', function $$read(integer) {
      var $a, self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      if (integer == null) integer = nil;
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if (($truthy(integer) && ($truthy($rb_gt(self.read_buffer.$length(), integer))))) {
          
          $a = [self.read_buffer['$[]'](Opal.Range.$new(0,integer, true)), self.read_buffer['$[]'](Opal.Range.$new(integer, -1, false))], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(($truthy(($ret_or_1 = integer)) ? ($ret_or_1) : (65536))))));;
      $a = [self.read_buffer, ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      return ret;
    }, -1);
    
    $def(self, '$readlines', function $$readlines(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      return self.$each_line(separator).$to_a();
    }, -1);
    
    $def(self, '$each', function $$each($a, $b) {
      var block = $$each.$$p || nil, $post_args, sep, args, self = this, s = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      
      if ($post_args.length > 0) sep = $post_args.shift();if (sep == null) sep = $gvars["/"];
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each", sep].concat($to_a(args)))
      };
      while ($truthy((s = $send(self, 'gets', [sep].concat($to_a(args)))))) {
      Opal.yield1(block, s)
      };
      return self;
    }, -1);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this, s = nil;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_byte")
      };
      while ($truthy((s = self.$getbyte()))) {
      Opal.yield1(block, s)
      };
      return self;
    });
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this, s = nil;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_char")
      };
      while ($truthy((s = self.$getc()))) {
      Opal.yield1(block, s)
      };
      return self;
    });
    
    $def(self, '$close', $assign_ivar_val("closed", "both"));
    
    $def(self, '$close_read', function $$close_read() {
      var self = this;

      if ($eqeq(self.closed, "write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    });
    
    $def(self, '$close_write', function $$close_write() {
      var self = this;

      if ($eqeq(self.closed, "read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    });
    
    $def(self, '$closed?', function $IO_closed$ques$3() {
      var self = this;

      return self.closed['$==']("both")
    });
    
    $def(self, '$closed_read?', function $IO_closed_read$ques$4() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("read")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    });
    
    $def(self, '$closed_write?', function $IO_closed_write$ques$5() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("write")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    });
    
    $def(self, '$check_writable', function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for writing")
      } else {
        return nil
      }
    });
    
    $def(self, '$check_readable', function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for reading")
      } else {
        return nil
      }
    });
    $alias(self, "each_line", "each");
    return $alias(self, "eof?", "eof");
  })('::', null);
  $const_set('::', 'STDIN', ($gvars.stdin = $$$('IO').$new(0, "r")));
  $const_set('::', 'STDOUT', ($gvars.stdout = $$$('IO').$new(1, "w")));
  $const_set('::', 'STDERR', ($gvars.stderr = $$$('IO').$new(2, "w")));
  var console = Opal.global.console;
  $$$('STDOUT')['$write_proc='](typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)});
  $$$('STDERR')['$write_proc='](typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)});
  return ($a = [function(s) { var p = prompt(); if (p !== null) return p + "\n"; return nil; }], $send($$$('STDIN'), 'read_proc=', $a), $a[$a.length - 1]);
};

Opal.modules["opal/regexp_anchors"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'REGEXP_START', "^");
    $const_set(self, 'REGEXP_END', "$");
    $const_set(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'INLINE_IDENTIFIER_REGEXP', $$('Regexp').$new("[^" + ($$$(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$$(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    $const_set(self, 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return $const_set(self, 'CONST_NAME_REGEXP', $$('Regexp').$new("" + ($$$(self, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$$(self, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$$(self, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

Opal.modules["opal/mini"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("opal/base");
  $Object.$require("corelib/nil");
  $Object.$require("corelib/boolean");
  $Object.$require("corelib/string");
  $Object.$require("corelib/comparable");
  $Object.$require("corelib/enumerable");
  $Object.$require("corelib/enumerator");
  $Object.$require("corelib/array");
  $Object.$require("corelib/hash");
  $Object.$require("corelib/number");
  $Object.$require("corelib/range");
  $Object.$require("corelib/proc");
  $Object.$require("corelib/method");
  $Object.$require("corelib/regexp");
  $Object.$require("corelib/variables");
  $Object.$require("corelib/io");
  return $Object.$require("opal/regexp_anchors");
};

Opal.modules["corelib/kernel/format"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $coerce_to = Opal.coerce_to, $module = Opal.module, $slice = Opal.slice, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $def = Opal.def, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,[],==,length,coerce_to?,nil?,to_a,raise,to_int,fetch,Integer,Float,to_ary,to_str,inspect,to_s,format');
  return (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$format', function $$format(format_string, $a) {
      var $post_args, args, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      $post_args = $slice(arguments, 1);
      args = $post_args;
      if (($eqeq(args.$length(), 1) && ($truthy(args['$[]'](0)['$respond_to?']("to_ary"))))) {
        
        ary = $Opal['$coerce_to?'](args['$[]'](0), $$$('Array'), "to_ary");
        if (!$truthy(ary['$nil?']())) {
          args = ary.$to_a()
        };
      };
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "flag after width") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "width given twice") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { $Kernel.$raise($$$('ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with numbered") // raise
        case -2: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with named") // raise
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          $Kernel.$raise($$$('ArgumentError'), "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              $Kernel.$raise($$$('ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
          // no-break
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                $Kernel.$raise($$$('ArgumentError'), "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                $Kernel.$raise($$$('ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  $Kernel.$raise($$$('ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }
            // raise

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              $Kernel.$raise($$$('ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = $Kernel.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            $Kernel.$raise($$$('NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")
            // raise

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$$('Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              $Kernel.$raise($$$('ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        $Kernel.$raise($$$('ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, -2);
    return $alias(self, "sprintf", "format");
  })('::')
};

Opal.modules["corelib/string/encoding"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $send = Opal.send, $defs = Opal.defs, $eqeq = Opal.eqeq, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $slice = Opal.slice, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $a, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,+,[],clone,initialize,new,instance_eval,to_proc,each,const_set,tr,==,default_external,attr_accessor,singleton_class,attr_reader,raise,register,length,bytes,force_encoding,dup,bytesize,enum_for,each_byte,to_a,each_char,each_codepoint,coerce_to!,find,<,default_external=');
  
  self.$require("corelib/string");
  (function($base, $super) {
    var self = $klass($base, $super, 'Encoding');

    var $proto = self.$$prototype;

    $proto.name = $proto.dummy = nil;
    
    $defs(self, '$register', function $$register(name, options) {
      var block = $$register.$$p || nil, self = this, names = nil, $ret_or_1 = nil, ascii = nil, dummy = nil, encoding = nil, register = nil;

      $$register.$$p = null;
      
      ;
      if (options == null) options = $hash2([], {});
      names = $rb_plus([name], ($truthy(($ret_or_1 = options['$[]']("aliases"))) ? ($ret_or_1) : ([])));
      ascii = ($truthy(($ret_or_1 = options['$[]']("ascii"))) && ($ret_or_1));
      dummy = ($truthy(($ret_or_1 = options['$[]']("dummy"))) && ($ret_or_1));
      if ($truthy(options['$[]']("inherits"))) {
        
        encoding = options['$[]']("inherits").$clone();
        encoding.$initialize(name, names, ascii, dummy);
      } else {
        encoding = self.$new(name, names, ascii, dummy)
      };
      if ((block !== nil)) {
        $send(encoding, 'instance_eval', [], block.$to_proc())
      };
      register = Opal.encodings;
      return $send(names, 'each', [], function $$1(encoding_name){var self = $$1.$$s == null ? this : $$1.$$s;

        
        if (encoding_name == null) encoding_name = nil;
        self.$const_set(encoding_name.$tr("-", "_"), encoding);
        return register[encoding_name] = encoding;}, {$$s: self});
    }, -2);
    $defs(self, '$find', function $$find(name) {
      var self = this;

      
      if ($eqeq(name, "default_external")) {
        return self.$default_external()
      };
      return Opal.find_encoding(name);;
    });
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    $def(self, '$initialize', function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    });
    
    $def(self, '$ascii_compatible?', $return_ivar("ascii"));
    
    $def(self, '$dummy?', $return_ivar("dummy"));
    
    $def(self, '$binary?', $return_val(false));
    
    $def(self, '$to_s', $return_ivar("name"));
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Encoding:" + (self.name) + (($truthy(self.dummy) ? (" (dummy)") : nil)) + ">"
    });
    
    $def(self, '$charsize', function $$charsize(string) {
      
      
      var len = 0;
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
          len++;
        }
      }
      return len;
    
    });
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      $$each_char.$$p = null;
      
      ;
      
      var low_surrogate = "";
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        var chr = string.charAt(i);
        if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
          low_surrogate = chr;
          continue;
        }
        else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
          chr = low_surrogate + chr;
        }
        if (string.encoding.name != "UTF-8") {
          chr = new String(chr);
          chr.encoding = string.encoding;
        }
        Opal.yield1(block, chr);
      }
    ;
    });
    
    $def(self, '$each_byte', function $$each_byte($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    
    $def(self, '$bytesize', function $$bytesize($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    $klass('::', $$$('StandardError'), 'EncodingError');
    return ($klass('::', $$$('EncodingError'), 'CompatibilityError'), nil);
  })('::', null);
  $send($$$('Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            }

            // valid lead
            leadSurrogate = codePoint;

            continue;
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint;
            continue;
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    });
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.$bytes().$length()
    });}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16LE"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    });
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 2;
    });}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_16LE')})], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    })}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32LE"], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    });
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 4;
    });}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_32LE')})], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    })}, {$$s: self});
  $send($$$('Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii"], {"aliases": ["BINARY"], "ascii": true})], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

    
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      $$each_char.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var chr = new String(string.charAt(i));
        chr.encoding = string.encoding;
        Opal.yield1(block, chr);
      }
    ;
    });
    
    $def(self, '$charsize', function $$charsize(string) {
      
      return string.length;
    });
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
      }
    ;
    });
    
    $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length;
    });
    return $def(self, '$binary?', $return_val(true));}, {$$s: self});
  $$$('Encoding').$register("ISO-8859-1", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ISO8859-1"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  $$$('Encoding').$register("US-ASCII", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ASCII"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    var $proto = self.$$prototype;

    $proto.internal_encoding = $proto.bytes = $proto.encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.prop(String.prototype, 'bytes', nil);
    Opal.prop(String.prototype, 'encoding', $$$($$$('Encoding'), 'UTF_8'));
    Opal.prop(String.prototype, 'internal_encoding', $$$($$$('Encoding'), 'UTF_8'));
    
    $def(self, '$b', function $$b() {
      var self = this;

      return self.$dup().$force_encoding("binary")
    });
    
    $def(self, '$bytesize', function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    });
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_byte"], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

          return self.$bytesize()}, {$$s: self})
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    });
    
    $def(self, '$bytes', function $$bytes() {
      var self = this, $ret_or_1 = nil;

      
      
      if (typeof self === 'string') {
        return (new String(self)).$each_byte().$to_a();
      }
    ;
      self.bytes = ($truthy(($ret_or_1 = self.bytes)) ? ($ret_or_1) : (self.$each_byte().$to_a()));
      return self.bytes.$dup();
    });
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_char"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$length()}, {$$s: self})
      };
      $send(self.encoding, 'each_char', [self], block.$to_proc());
      return self;
    });
    
    $def(self, '$chars', function $$chars() {
      var block = $$chars.$$p || nil, self = this;

      $$chars.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    });
    
    $def(self, '$each_codepoint', function $$each_codepoint() {
      var block = $$each_codepoint.$$p || nil, self = this;

      $$each_codepoint.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    });
    
    $def(self, '$codepoints', function $$codepoints() {
      var block = $$codepoints.$$p || nil, self = this;

      $$codepoints.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())
      };
      return self.$each_codepoint().$to_a();
    });
    
    $def(self, '$encode', function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    });
    
    $def(self, '$force_encoding', function $$force_encoding(encoding) {
      var self = this;

      
      var str = self;

      if (encoding === str.encoding) { return str; }

      encoding = $Opal['$coerce_to!'](encoding, $$$('String'), "to_s");
      encoding = $$$('Encoding').$find(encoding);

      if (encoding === str.encoding) { return str; }

      str = Opal.set_encoding(str, encoding);

      return str;
    
    });
    
    $def(self, '$getbyte', function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $Opal['$coerce_to!'](idx, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil
      };
      return string_bytes['$[]'](idx);
    });
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      
      return "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    "
    });
    return $def(self, '$valid_encoding?', $return_val(true));
  })('::', null);
  return ($a = [$$$($$('Encoding'), 'UTF_8')], $send($$$('Encoding'), 'default_external=', $a), $a[$a.length - 1]);
};

Opal.modules["corelib/math"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $type_error = Opal.type_error, $module = Opal.module, $const_set = Opal.const_set, $Class = Opal.Class, $slice = Opal.slice, $Kernel = Opal.Kernel, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_divide = Opal.rb_divide, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,raise,Float,Integer,module_function,each,define_method,checked,float!,===,gamma,-,integer!,/,infinite?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'E', Math.E);
    $const_set(self, 'PI', Math.PI);
    $const_set(self, 'DomainError', $Class.$new($$$('StandardError')));
    $defs(self, '$checked', function $$checked(method, $a) {
      var $post_args, args;

      
      $post_args = $slice(arguments, 1);
      args = $post_args;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, -2);
    $defs(self, '$float!', function $Math_float$excl$1(value) {
      
      try {
        return $Kernel.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Float')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    });
    $defs(self, '$integer!', function $Math_integer$excl$2(value) {
      
      try {
        return $Kernel.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Integer')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    });
    self.$module_function();
    if (!$truthy((typeof(Math.erf) !== "undefined"))) {
      
      Opal.prop(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    if (!$truthy((typeof(Math.erfc) !== "undefined"))) {
      
      Opal.prop(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    $send(["acos", "acosh", "asin", "asinh", "atan", "atanh", "cbrt", "cos", "cosh", "erf", "erfc", "exp", "sin", "sinh", "sqrt", "tanh"], 'each', [], function $Math$3(method){var self = $Math$3.$$s == null ? this : $Math$3.$$s;

      
      if (method == null) method = nil;
      return $send(self, 'define_method', [method], function $$4(x){
        
        if (x == null) x = nil;
        return $$$('Math').$checked(method, $$$('Math')['$float!'](x));});}, {$$s: self});
    
    $def(self, '$atan2', function $$atan2(y, x) {
      
      return $$$('Math').$checked("atan2", $$$('Math')['$float!'](y), $$$('Math')['$float!'](x))
    });
    
    $def(self, '$hypot', function $$hypot(x, y) {
      
      return $$$('Math').$checked("hypot", $$$('Math')['$float!'](x), $$$('Math')['$float!'](y))
    });
    
    $def(self, '$frexp', function $$frexp(x) {
      
      
      x = $$('Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    });
    
    $def(self, '$gamma', function $$gamma(n) {
      
      
      n = $$('Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$('Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$$('Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    });
    
    $def(self, '$ldexp', function $$ldexp(mantissa, exponent) {
      
      
      mantissa = $$('Math')['$float!'](mantissa);
      exponent = $$('Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        $Kernel.$raise($$$('RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    });
    
    $def(self, '$lgamma', function $$lgamma(n) {
      
      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$$('Math').$gamma(n))), $$$('Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    });
    
    $def(self, '$log', function $$log(x, base) {
      
      
      ;
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      if ($truthy(base == null)) {
        return $$$('Math').$checked("log", $$$('Math')['$float!'](x))
      } else {
        
        if ($eqeqeq($$$('String'), base)) {
          $Kernel.$raise($type_error(base, $$$('Float')))
        };
        return $rb_divide($$$('Math').$checked("log", $$$('Math')['$float!'](x)), $$$('Math').$checked("log", $$$('Math')['$float!'](base)));
      };
    }, -2);
    
    $def(self, '$log10', function $$log10(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log10", $$$('Math')['$float!'](x));
    });
    
    $def(self, '$log2', function $$log2(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log2", $$$('Math')['$float!'](x));
    });
    return $def(self, '$tan', function $$tan(x) {
      
      
      x = $$$('Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      return $$$('Math').$checked("tan", $$$('Math')['$float!'](x));
    });
  })('::', $nesting)
};

Opal.modules["corelib/complex/base"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,from_string');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Complex', function $$Complex(real, imag) {
      
      
      if (imag == null) imag = nil;
      if ($truthy(imag)) {
        return $$('Complex').$new(real, imag)
      } else {
        return $$('Complex').$new(real, 0)
      };
    }, -2)
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $$('Complex').$from_string(self)
    })
  })('::', null, $nesting);
};

Opal.modules["corelib/complex"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $defs = Opal.defs, $rb_times = Opal.rb_times, $def = Opal.def, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $return_val = Opal.return_val, $const_set = Opal.const_set, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,real?,===,raise,new,*,cos,sin,attr_reader,freeze,class,==,real,imag,Complex,-@,+,__coerced__,-,nan?,/,conj,abs2,quo,polar,exp,log,>,!=,divmod,**,hypot,atan2,lcm,denominator,finite?,infinite?,numerator,abs,arg,rationalize,to_f,to_i,to_r,inspect,zero?,positive?,Rational,rect,angle');
  
  self.$require("corelib/numeric");
  self.$require("corelib/complex/base");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.real = $proto.imag = nil;
    
    $defs(self, '$rect', function $$rect(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      if (!((($eqeqeq($$$('Numeric'), real) && ($truthy(real['$real?']()))) && ($eqeqeq($$$('Numeric'), imag))) && ($truthy(imag['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, -2);
    $defs(self, '$polar', function $$polar(r, theta) {
      var self = this;

      
      if (theta == null) theta = 0;
      if (!((($eqeqeq($$$('Numeric'), r) && ($truthy(r['$real?']()))) && ($eqeqeq($$$('Numeric'), theta))) && ($truthy(theta['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$$('Math').$cos(theta)), $rb_times(r, $$$('Math').$sin(theta)));
    }, -2);
    self.$attr_reader("real", "imag");
    
    $def(self, '$initialize', function $$initialize(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      self.real = real;
      self.imag = imag;
      return self.$freeze();
    }, -2);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return [other, self]
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return [$$$('Complex').$new(other, 0), self]
      } else {
        return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    });
    
    $def(self, '$==', function $Complex_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Complex'), other)) {
        if ($truthy(($ret_or_1 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_1
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        if ($truthy(($ret_or_1 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_1
        }
      } else {
        return other['$=='](self)
      }
    });
    
    $def(self, '$-@', function $Complex_$minus$$2() {
      var self = this;

      return $Kernel.$Complex(self.real['$-@'](), self.imag['$-@']())
    });
    
    $def(self, '$+', function $Complex_$plus$3(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    });
    
    $def(self, '$-', function $Complex_$minus$4(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    });
    
    $def(self, '$*', function $Complex_$$5(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    });
    
    $def(self, '$/', function $Complex_$slash$6(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        if ((((($eqeqeq($$$('Number'), self.real) && ($truthy(self.real['$nan?']()))) || (($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$real()) && ($truthy(other.$real()['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$imag()) && ($truthy(other.$imag()['$nan?']())))))) {
          return $$$('Complex').$new($$$($$$('Float'), 'NAN'), $$$($$$('Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    });
    
    $def(self, '$**', function $Complex_$$$7(other) {
      var $a, $b, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if ($eqeq(other, 0)) {
        return $$$('Complex').$new(1, 0)
      };
      if ($eqeqeq($$$('Complex'), other)) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$$('Math').$exp($rb_minus($rb_times(ore, $$$('Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$$('Math').$log(r)));
        return $$$('Complex').$polar(nr, ntheta);
      } else if ($eqeqeq($$$('Integer'), other)) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($neqeq(n, 0)) {
          
            $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            while ($eqeq(mod, 0)) {
            
              x = $Kernel.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$$('Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$$('Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    });
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $$$('Math').$hypot(self.real, self.imag)
    });
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    });
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      return $$$('Math').$atan2(self.imag, self.real)
    });
    
    $def(self, '$conj', function $$conj() {
      var self = this;

      return $Kernel.$Complex(self.real, self.imag['$-@']())
    });
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    });
    
    $def(self, '$eql?', function $Complex_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $$('Complex')['$==='](other))) ? (self.real.$class()['$=='](self.imag.$class())) : ($ret_or_2))))) {
        return self['$=='](other)
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Numeric'), other)) {
        $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    });
    
    $def(self, '$finite?', function $Complex_finite$ques$9() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Complex:" + (self.real) + ":" + (self.imag)
    });
    
    $def(self, '$infinite?', function $Complex_infinite$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$infinite?']()))) {
        return $ret_or_1
      } else {
        return self.imag['$infinite?']()
      }
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    });
    
    $def(self, '$numerator', function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return $Kernel.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    });
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    });
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($neqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.$real().$rationalize(eps);
    }, -1);
    
    $def(self, '$real?', $return_val(false));
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self.real, self.imag]
    });
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    });
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    });
    
    $def(self, '$to_r', function $$to_r() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, result = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (((($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))) || ($truthy(self.imag['$positive?']()))) || ($truthy(self.imag['$zero?']()))) ? ("+") : ("-")));
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if (($eqeqeq($$$('Number'), self.imag) && (($truthy(self.imag['$nan?']()) || ($truthy(self.imag['$infinite?']())))))) {
        result = $rb_plus(result, "*")
      };
      return $rb_plus(result, "i");
    });
    $const_set($nesting[0], 'I', self.$new(0, 1));
    $defs(self, '$from_string', function $$from_string(str) {
      
      
      var re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return $Kernel.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return $Kernel.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return $Kernel.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return $Kernel.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return $Kernel.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return $Kernel.$Complex(real, imag);
      }
    
    });
    (function(self, $parent_nesting) {
      
      return $alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "divide", "/");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "phase", "arg");
    $alias(self, "quo", "/");
    $alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.udef(self, '$' + "positive?");;
    
    
    Opal.udef(self, '$' + "step");;
    return nil;;
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/rational/base"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $def = Opal.def, $klass = Opal.klass, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('convert,from_string');
  
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$Rational', function $$Rational(numerator, denominator) {
      
      
      if (denominator == null) denominator = 1;
      return $$$('Rational').$convert(numerator, denominator);
    }, -2)
  })('::');
  return (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_r', function $$to_r() {
      var self = this;

      return $$$('Rational').$from_string(self)
    })
  })('::', null);
};

Opal.modules["corelib/rational"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_divide = Opal.rb_divide, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $Opal = Opal.Opal, $def = Opal.def, $return_ivar = Opal.return_ivar, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le, $return_self = Opal.return_self, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,to_i,==,raise,<,-@,new,gcd,/,nil?,===,reduce,to_r,!,equal?,coerce_to!,freeze,to_f,numerator,denominator,<=>,-,*,__coerced__,+,Rational,>,**,abs,ceil,with_precision,floor,<=,truncate,send');
  
  self.$require("corelib/numeric");
  self.$require("corelib/rational/base");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Rational');

    var $proto = self.$$prototype;

    $proto.num = $proto.den = nil;
    
    $defs(self, '$reduce', function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if ($eqeq(den, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if ($eqeq(den, 1)) {
        return self.$new(num, den)
      };
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    });
    $defs(self, '$convert', function $$convert(num, den) {
      var self = this;

      
      if (($truthy(num['$nil?']()) || ($truthy(den['$nil?']())))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert nil into Rational")
      };
      if (($eqeqeq($$$('Integer'), num) && ($eqeqeq($$$('Integer'), den)))) {
        return self.$reduce(num, den)
      };
      if ((($eqeqeq($$$('Float'), num) || ($eqeqeq($$$('String'), num))) || ($eqeqeq($$$('Complex'), num)))) {
        num = num.$to_r()
      };
      if ((($eqeqeq($$$('Float'), den) || ($eqeqeq($$$('String'), den))) || ($eqeqeq($$$('Complex'), den)))) {
        den = den.$to_r()
      };
      if (($truthy(den['$equal?'](1)) && ($not($$$('Integer')['$==='](num))))) {
        return $Opal['$coerce_to!'](num, $$$('Rational'), "to_r")
      } else if (($eqeqeq($$$('Numeric'), num) && ($eqeqeq($$$('Numeric'), den)))) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    });
    
    $def(self, '$initialize', function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      self.den = den;
      return self.$freeze();
    });
    
    $def(self, '$numerator', $return_ivar("num"));
    
    $def(self, '$denominator', $return_ivar("den"));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return [other, self]
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return [other.$to_r(), self]
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return [other, self.$to_f()]
      } else {
        return nil
      }
    });
    
    $def(self, '$==', function $Rational_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        if ($truthy(($ret_or_2 = self.num['$=='](other.$numerator())))) {
          return self.den['$=='](other.$denominator())
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($truthy(($ret_or_2 = self.num['$=='](other)))) {
          return self.den['$=='](1)
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$=='](other)
      } else {
        return other['$=='](self)
      }
    });
    
    $def(self, '$<=>', function $Rational_$lt_eq_gt$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$<=>'](other)
      } else {
        return self.$__coerced__("<=>", other)
      }
    });
    
    $def(self, '$+', function $Rational_$plus$3(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_plus(self.$to_f(), other)
      } else {
        return self.$__coerced__("+", other)
      }
    });
    
    $def(self, '$-', function $Rational_$minus$4(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_minus(self.$to_f(), other)
      } else {
        return self.$__coerced__("-", other)
      }
    });
    
    $def(self, '$*', function $Rational_$$5(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$numerator());
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_times(self.num, other), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_times(self.$to_f(), other)
      } else {
        return self.$__coerced__("*", other)
      }
    });
    
    $def(self, '$/', function $Rational_$slash$6(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$denominator());
        den = $rb_times(self.den, other.$numerator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $rb_divide(self.$to_f(), 0.0)
        } else {
          return $Kernel.$Rational(self.num, $rb_times(self.den, other))
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_divide(self.$to_f(), other)
      } else {
        return self.$__coerced__("/", other)
      }
    });
    
    $def(self, '$**', function $Rational_$$$7(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Integer'), ($ret_or_1 = other))) {
        if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $$$($$$('Float'), 'INFINITY')
        } else if ($truthy($rb_gt(other, 0))) {
          return $Kernel.$Rational(self.num['$**'](other), self.den['$**'](other))
        } else if ($truthy($rb_lt(other, 0))) {
          return $Kernel.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
        } else {
          return $Kernel.$Rational(1, 1)
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$**'](other)
      } else if ($eqeqeq($$$('Rational'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $Kernel.$Rational(1, 1)
        } else if ($eqeq(other.$denominator(), 1)) {
          if ($truthy($rb_lt(other, 0))) {
            return $Kernel.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
          } else {
            return $Kernel.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
          }
        } else if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        } else {
          return self.$to_f()['$**'](other)
        }
      } else {
        return self.$__coerced__("**", other)
      }
    });
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $Kernel.$Rational(self.num.$abs(), self.den.$abs())
    });
    
    $def(self, '$ceil', function $$ceil(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, -1);
    
    $def(self, '$floor', function $$floor(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Rational:" + (self.num) + ":" + (self.den)
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    });
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return $Kernel.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, -1);
    
    $def(self, '$round', function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      if (precision == null) precision = 0;
      if (!$eqeq(precision, 0)) {
        return self.$with_precision("round", precision)
      };
      if ($eqeq(self.num, 0)) {
        return 0
      };
      if ($eqeq(self.den, 1)) {
        return self.num
      };
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, -1);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    });
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self.$truncate()
    });
    
    $def(self, '$to_r', $return_self);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    });
    
    $def(self, '$truncate', function $$truncate(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, -1);
    
    $def(self, '$with_precision', function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if (!$eqeqeq($$$('Integer'), precision)) {
        $Kernel.$raise($$$('TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return $Kernel.$Rational(s.$send(method), p)
      };
    });
    $defs(self, '$from_string', function $$from_string(string) {
      
      
      var str = string.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return $Kernel.$Rational(numerator, denominator);
          } else {
            return $Kernel.$Rational(numerator, 1);
          }
        } else {
          return $Kernel.$Rational(numerator, 1);
        }
      } else {
        return $Kernel.$Rational(0, 1);
      }
    
    });
    $alias(self, "divide", "/");
    return $alias(self, "quo", "/");
  })('::', $$$('Numeric'));
};

Opal.modules["corelib/time"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $slice = Opal.slice, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_divide = Opal.rb_divide, $rb_minus = Opal.rb_minus, $range = Opal.range, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $eqeq = Opal.eqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,===,raise,coerce_to!,respond_to?,to_str,to_i,_parse_offset,new,<=>,to_f,nil?,>,<,strftime,each,define_method,year,month,day,+,round,/,-,copy_instance_variables,initialize_dup,is_a?,zero?,wday,utc?,mon,yday,hour,min,sec,rjust,ljust,zone,to_s,[],cweek_cyear,jd,to_date,format,isdst,!=,<=,==,ceil,local,gm,asctime,getgm,gmt_offset,inspect,usec,gmtime,gmt?');
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    $defs(self, '$at', function $$at(seconds, frac) {
      
      
      ;
      
      var result;

      if ($$$('Time')['$==='](seconds)) {
        if (frac !== undefined) {
          $Kernel.$raise($$$('TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.timezone = seconds.timezone;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $Opal['$coerce_to!'](seconds, $$$('Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $Opal['$coerce_to!'](frac, $$$('Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $Opal['$coerce_to!'](year, $$$('Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $Opal['$coerce_to!'](month, $$$('Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        $Kernel.$raise($$$('ArgumentError'), "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $Opal['$coerce_to!'](day, $$$('Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        $Kernel.$raise($$$('ArgumentError'), "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $Opal['$coerce_to!'](hour, $$$('Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        $Kernel.$raise($$$('ArgumentError'), "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $Opal['$coerce_to!'](min, $$$('Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        $Kernel.$raise($$$('ArgumentError'), "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $Opal['$coerce_to!'](sec, $$$('Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        $Kernel.$raise($$$('ArgumentError'), "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    $defs(self, '$new', function $Time_new$1(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (utc_offset == null) utc_offset = nil;
      
      var args, result, timezone, utc_date;

      if (year === undefined) {
        return new Date();
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      if (utc_offset === nil) {
        result = new Date(year, month, day, hour, min, 0, sec * 1000);
        if (year < 100) {
          result.setFullYear(year);
        }
        return result;
      }

      timezone = self.$_parse_offset(utc_offset);
      utc_date = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        utc_date.setUTCFullYear(year);
      }

      result = new Date(utc_date.getTime() - timezone * 3600000);
      result.timezone = timezone;

      return result;
    ;
    }, -1);
    $defs(self, '$_parse_offset', function $$_parse_offset(utc_offset) {
      
      
      var timezone;
      if (utc_offset.$$is_string) {
        if (utc_offset == 'UTC') {
          timezone = 0;
        }
        else if(/^[+-]\d\d:[0-5]\d$/.test(utc_offset)) {
          var sign, hours, minutes;
          sign = utc_offset[0];
          hours = +(utc_offset[1] + utc_offset[2]);
          minutes = +(utc_offset[4] + utc_offset[5]);

          timezone = (sign == '-' ? -1 : 1) * (hours + minutes / 60);
        }
        else {
          // Unsupported: "A".."I","K".."Z"
          $Kernel.$raise($$$('ArgumentError'), "\"+HH:MM\", \"-HH:MM\", \"UTC\" expected for utc_offset: " + (utc_offset))
        }
      }
      else if (utc_offset.$$is_number) {
        timezone = utc_offset / 3600;
      }
      else {
        $Kernel.$raise($$$('ArgumentError'), "Opal doesn't support other types for a timezone argument than Integer and String")
      }
      return timezone;
    
    });
    $defs(self, '$local', function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, -2);
    $defs(self, '$gm', function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.timezone = 0;
      return result;
    ;
    }, -2);
    $defs(self, '$now', function $$now() {
      var self = this;

      return self.$new()
    });
    
    $def(self, '$+', function $Time_$plus$2(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        $Kernel.$raise($$$('TypeError'), "time + time?")
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    });
    
    $def(self, '$-', function $Time_$minus$3(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        return (self.getTime() - other.getTime()) / 1000
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    });
    
    $def(self, '$<=>', function $Time_$lt_eq_gt$4(other) {
      var self = this, r = nil;

      if ($eqeqeq($$$('Time'), other)) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    });
    
    $def(self, '$==', function $Time_$eq_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$$('Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$asctime', function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    });
    $send([["year", "getFullYear", "getUTCFullYear"], ["mon", "getMonth", "getUTCMonth", 1], ["wday", "getDay", "getUTCDay"], ["day", "getDate", "getUTCDate"], ["hour", "getHours", "getUTCHours"], ["min", "getMinutes", "getUTCMinutes"], ["sec", "getSeconds", "getUTCSeconds"]], 'each', [], function $Time$6(method, getter, utcgetter, difference){var self = $Time$6.$$s == null ? this : $Time$6.$$s;

      
      if (method == null) method = nil;
      if (getter == null) getter = nil;
      if (utcgetter == null) utcgetter = nil;
      if (difference == null) difference = 0;
      return $send(self, 'define_method', [method], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        
        return difference + ((self.timezone != null) ?
          (new Date(self.getTime() + self.timezone * 3600000))[utcgetter]() :
          self[getter]())
      }, {$$s: self});}, {$$arity: -4, $$s: self});
    
    $def(self, '$yday', function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$('Time').$new(self.$year()).$to_i();
      start_of_day = $$('Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    });
    
    $def(self, '$isdst', function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    });
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$eql?', function $Time_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = other['$is_a?']($$$('Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_1
      }
    });
    $send([["sunday?", 0], ["monday?", 1], ["tuesday?", 2], ["wednesday?", 3], ["thursday?", 4], ["friday?", 5], ["saturday?", 6]], 'each', [], function $Time$9(method, weekday){var self = $Time$9.$$s == null ? this : $Time$9.$$s;

      
      if (method == null) method = nil;
      if (weekday == null) weekday = nil;
      return $send(self, 'define_method', [method], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$wday() === weekday}, {$$s: self});}, {$$s: self});
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    });
    
    $def(self, '$succ', function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.timezone = self.timezone;
      return result;
    
    });
    
    $def(self, '$usec', function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    });
    
    $def(self, '$zone', function $$zone() {
      var self = this;

      
      if (self.timezone === 0) return "UTC";
      else if (self.timezone != null) return nil;

      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    });
    
    $def(self, '$getgm', function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.timezone = 0;
      return result;
    
    });
    
    $def(self, '$gmtime', function $$gmtime() {
      var self = this;

      
      if (self.timezone !== 0) {
        $deny_frozen_access(self);
        self.timezone = 0;
      }
      return self;
    
    });
    
    $def(self, '$gmt?', function $Time_gmt$ques$11() {
      var self = this;

      return self.timezone === 0;
    });
    
    $def(self, '$gmt_offset', function $$gmt_offset() {
      var self = this;

      return (self.timezone != null) ? self.timezone * 60 : -self.getTimezoneOffset() * 60;
    });
    
    $def(self, '$strftime', function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "", jd, c, s,
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = (self.timezone == null) ? self.getTimezoneOffset() : (-self.timezone * 60),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          // Non-standard: JIS X 0301 date format
          case 'J':
            jd = self.$to_date().$jd();
            if (jd < 2405160) {
              result += self.$strftime("%Y-%m-%d");
              break;
            }
            else if (jd < 2419614)
              c = 'M', s = 1867;
            else if (jd < 2424875)
              c = 'T', s = 1911;
            else if (jd < 2447535)
              c = 'S', s = 1925;
            else if (jd < 2458605)
              c = 'H', s = 1988;
            else
              c = 'R', s = 2018;

            result += self.$format("%c%02d", c, $rb_minus(self.$year(), s));
            result += self.$strftime("-%m-%d");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    });
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    });
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    });
    
    $def(self, '$cweek_cyear', function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = $$$('Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if (($truthy($rb_le(jan01_wday, 4)) && ($neqeq(jan01_wday, 0)))) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if ($eqeq(offset, -8)) {
          offset = -1
        };
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$$('Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if ($eqeq(week, 53)) {
        
        dec31 = $$$('Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if (($truthy($rb_le(dec31_wday, 3)) && ($neqeq(dec31_wday, 0)))) {
          
          week = 1;
          year = $rb_plus(year, 1);
        };
      };
      return [week, year];
    });
    (function(self, $parent_nesting) {
      
      
      $alias(self, "mktime", "local");
      return $alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "ctime", "asctime");
    $alias(self, "dst?", "isdst");
    $alias(self, "getutc", "getgm");
    $alias(self, "gmtoff", "gmt_offset");
    $alias(self, "mday", "day");
    $alias(self, "month", "mon");
    $alias(self, "to_s", "inspect");
    $alias(self, "tv_sec", "to_i");
    $alias(self, "tv_usec", "usec");
    $alias(self, "utc", "gmtime");
    $alias(self, "utc?", "gmt?");
    return $alias(self, "utc_offset", "gmt_offset");
  })('::', Date, $nesting);
};

Opal.modules["corelib/struct"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $send = Opal.send, $Class = Opal.Class, $to_a = Opal.to_a, $def = Opal.def, $defs = Opal.defs, $Kernel = Opal.Kernel, $hash2 = Opal.hash2, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,!=,upcase,[],==,class,unshift,const_name!,map,coerce_to!,new,each,define_struct_attribute,allocate,initialize,alias_method,module_eval,to_proc,const_set,raise,<<,members,define_method,instance_eval,last,>,length,-,keys,any?,join,[]=,each_with_index,hash,===,<,-@,size,>=,include?,to_sym,instance_of?,__id__,eql?,enum_for,+,name,each_pair,inspect,to_h,args,each_with_object,flatten,to_a,respond_to?,dig');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    $defs(self, '$new', function $Struct_new$1(const_name, $a, $b) {
      var block = $Struct_new$1.$$p || nil, $post_args, $kwargs, args, keyword_init, self = this, klass = nil;

      $Struct_new$1.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      args = $post_args;
      
      keyword_init = $kwargs.$$smap["keyword_init"];if (keyword_init == null) keyword_init = false;
      if ($truthy(const_name)) {
        if (($eqeq(const_name.$class(), $$$('String')) && ($neqeq(const_name['$[]'](0).$upcase(), const_name['$[]'](0))))) {
          
          args.$unshift(const_name);
          const_name = nil;
        } else {
          
          try {
            const_name = $Opal['$const_name!'](const_name)
          } catch ($err) {
            if (Opal.rescue($err, [$$$('TypeError'), $$$('NameError')])) {
              try {
                
                args.$unshift(const_name);
                const_name = nil;
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };
        }
      };
      $send(args, 'map', [], function $$2(arg){
        
        if (arg == null) arg = nil;
        return $Opal['$coerce_to!'](arg, $$$('String'), "to_str");});
      klass = $send($Class, 'new', [self], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

        
        $send(args, 'each', [], function $$4(arg){var self = $$4.$$s == null ? this : $$4.$$s;

          
          if (arg == null) arg = nil;
          return self.$define_struct_attribute(arg);}, {$$s: self});
        return (function(self, $parent_nesting) {
          
          
          
          $def(self, '$new', function $new$5($a) {
            var $post_args, args, self = this, instance = nil;

            
            $post_args = $slice(arguments);
            args = $post_args;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', $to_a(args));
            return instance;
          }, -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, {$$s: self});
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())
      };
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$$('Struct').$const_set(const_name, klass)
      };
      return klass;
    }, -2);
    $defs(self, '$define_struct_attribute', function $$define_struct_attribute(name) {
      var self = this;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "you cannot define attributes to the Struct class")
      };
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$$data[name];}, {$$s: self});
      return $send(self, 'define_method', ["" + (name) + "="], function $$7(value){var self = $$7.$$s == null ? this : $$7.$$s;

        
        if (value == null) value = nil;
        return self.$$data[name] = value;;}, {$$s: self});
    });
    $defs(self, '$members', function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "the Struct class has no members")
      };
      return (self.members = ($truthy(($ret_or_1 = self.members)) ? ($ret_or_1) : ([])));
    });
    $defs(self, '$inherited', function $$inherited(klass) {
      var self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

        return (self.members = members)}, {$$s: self});
    });
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this, kwargs = nil, $ret_or_1 = nil, extra = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy(($ret_or_1 = args.$last())) ? ($ret_or_1) : ($hash2([], {})));
        if (($truthy($rb_gt(args.$length(), 1)) || ($truthy((args.length === 1 && !kwargs.$$is_hash))))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given " + (args.$length()) + ", expected 0)")
        };
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          $Kernel.$raise($$$('ArgumentError'), "unknown keywords: " + (extra.$join(", ")))
        };
        return $send(self.$class().$members(), 'each', [], function $$9(name){var $b, self = $$9.$$s == null ? this : $$9.$$s;

          
          if (name == null) name = nil;
          return ($b = [name, kwargs['$[]'](name)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          $Kernel.$raise($$$('ArgumentError'), "struct size differs")
        };
        return $send(self.$class().$members(), 'each_with_index', [], function $$10(name, index){var $b, self = $$10.$$s == null ? this : $$10.$$s;

          
          if (name == null) name = nil;
          if (index == null) index = nil;
          return ($b = [name, args['$[]'](index)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    });
    $defs(self, '$keyword_init?', function $Struct_keyword_init$ques$11() {
      var self = this;

      return self.$$keyword_init;
    });
    
    $def(self, '$members', function $$members() {
      var self = this;

      return self.$class().$members()
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return $$('Hash').$new(self.$$data).$hash()
    });
    
    $def(self, '$[]', function $Struct_$$$12(name) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name];;
    });
    
    $def(self, '$[]=', function $Struct_$$$eq$13(name, value) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        if (!$truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name] = value;;
    });
    
    $def(self, '$==', function $Struct_$eq_eq$14(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    });
    
    $def(self, '$eql?', function $Struct_eql$ques$15(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    });
    
    $def(self, '$each', function $$each() {
      var $yield = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$17(name){var self = $$17.$$s == null ? this : $$17.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, self['$[]'](name));;}, {$$s: self});
      return self;
    });
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      $$each_pair.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each_pair"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$19(name){var self = $$19.$$s == null ? this : $$19.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, {$$s: self});
      return self;
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$class().$members().$length()
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return $send(self.$class().$members(), 'map', [], function $$20(name){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (name == null) name = nil;
        return self['$[]'](name);}, {$$s: self})
    });
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, pushed = nil;

      return (function() { try {
      
      result = "#<struct ";
      if ($truthy((inspect_stack)['$include?'](self.$__id__()))) {
        return $rb_plus(result, ":...>")
      } else {
        
        (inspect_stack)['$<<'](self.$__id__());
        pushed = true;
        if (($eqeqeq($$$('Struct'), self) && ($truthy(self.$class().$name())))) {
          result = $rb_plus(result, "" + (self.$class()) + " ")
        };
        result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$21(name, value){
          
          if (name == null) name = nil;
          if (value == null) value = nil;
          return "" + (name) + "=" + ($$('Opal').$inspect(value));}).$join(", "));
        result = $rb_plus(result, ">");
        return result;
      };
      } finally {
        ($truthy(pushed) ? (inspect_stack.pop()) : nil)
      }; })()
    });
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(self.$args()))
      };
      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], function $$22(name, h){var $a, self = $$22.$$s == null ? this : $$22.$$s;

        
        if (name == null) name = nil;
        if (h == null) h = nil;
        return ($a = [name, self['$[]'](name)], $send(h, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
    });
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      args = $send(args, 'map', [], function $$23(arg){
        
        if (arg == null) arg = nil;
        return arg.$$is_range ? arg.$to_a() : arg;}).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, -1);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      keys = $post_args;
      item = ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key)) ? (self.$$data[key] || nil) : nil);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    $alias(self, "size", "length");
    $alias(self, "to_s", "inspect");
    return $alias(self, "values", "to_a");
  })('::', null, $nesting);
};

Opal.modules["corelib/set"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $freeze = Opal.freeze, $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $hash2 = Opal.hash2, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,new,nil?,===,raise,each,add,merge,class,respond_to?,subtract,dup,join,to_a,equal?,instance_of?,==,instance_variable_get,size,is_a?,all?,include?,[]=,enum_for,[],<<,replace,compare_by_identity,name,compare_by_identity?,delete,select,frozen?,freeze,reject,delete_if,to_proc,keep_if,each_key,empty?,eql?,instance_eval,clear,<,<=,any?,!,intersect?,keys,|,proper_subset?,subset?,proper_superset?,superset?,-,select!,collect!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Set');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $ret_or_1 = nil, $proto = self.$$prototype;

    $proto.hash = nil;
    
    self.$include($$$('Enumerable'));
    $defs(self, '$[]', function $Set_$$$1($a) {
      var $post_args, ary, self = this;

      
      $post_args = $slice(arguments);
      ary = $post_args;
      return self.$new(ary);
    }, -1);
    
    $def(self, '$initialize', function $$initialize(enum$) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if (enum$ == null) enum$ = nil;
      self.hash = $hash2([], {});
      if ($truthy(enum$['$nil?']())) {
        return nil
      };
      if (!$eqeqeq($$$('Enumerable'), enum$)) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      if ($truthy(block)) {
        return $send(enum$, 'each', [], function $$2(item){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (item == null) item = nil;
          return self.$add(Opal.yield1(block, item));}, {$$s: self})
      } else {
        return self.$merge(enum$)
      };
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, result = nil;

      
      result = self.$class().$new();
      return result.$merge(self);
    });
    
    $def(self, '$-', function $Set_$minus$3(enum$) {
      var self = this;

      
      if (!$truthy(enum$['$respond_to?']("each"))) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$subtract(enum$);
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Set: {" + (self.$to_a().$join(",")) + "}>"
    });
    
    $def(self, '$==', function $Set_$eq_eq$4(other) {
      var self = this;

      if ($truthy(self['$equal?'](other))) {
        return true
      } else if ($truthy(other['$instance_of?'](self.$class()))) {
        return self.hash['$=='](other.$instance_variable_get("@hash"))
      } else if (($truthy(other['$is_a?']($$$('Set'))) && ($eqeq(self.$size(), other.$size())))) {
        return $send(other, 'all?', [], function $$5(o){var self = $$5.$$s == null ? this : $$5.$$s;
          if (self.hash == null) self.hash = nil;

          
          if (o == null) o = nil;
          return self.hash['$include?'](o);}, {$$s: self})
      } else {
        return false
      }
    });
    
    $def(self, '$add', function $$add(o) {
      var self = this;

      
      self.hash['$[]='](o, true);
      return self;
    });
    
    $def(self, '$classify', function $$classify() {
      var block = $$classify.$$p || nil, self = this, result = nil;

      $$classify.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("classify")
      };
      result = $send($$$('Hash'), 'new', [], function $$6(h, k){var $a, self = $$6.$$s == null ? this : $$6.$$s;

        
        if (h == null) h = nil;
        if (k == null) k = nil;
        return ($a = [k, self.$class().$new()], $send(h, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
      $send(self, 'each', [], function $$7(item){
        
        if (item == null) item = nil;
        return result['$[]'](Opal.yield1(block, item)).$add(item);});
      return result;
    });
    
    $def(self, '$collect!', function $Set_collect$excl$8() {
      var block = $Set_collect$excl$8.$$p || nil, self = this, result = nil;

      $Set_collect$excl$8.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("collect!")
      };
      result = self.$class().$new();
      $send(self, 'each', [], function $$9(item){
        
        if (item == null) item = nil;
        return result['$<<'](Opal.yield1(block, item));});
      return self.$replace(result);
    });
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      if ($truthy(self.hash['$respond_to?']("compare_by_identity"))) {
        
        self.hash.$compare_by_identity();
        return self;
      } else {
        return self.$raise($$('NotImplementedError'), "" + (self.$class().$name()) + "#" + ("compare_by_identity") + " is not implemented")
      }
    });
    
    $def(self, '$compare_by_identity?', function $Set_compare_by_identity$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.hash['$respond_to?']("compare_by_identity?")))) {
        return self.hash['$compare_by_identity?']()
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$delete', function $Set_delete$11(o) {
      var self = this;

      
      self.hash.$delete(o);
      return self;
    });
    
    $def(self, '$delete?', function $Set_delete$ques$12(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        
        self.$delete(o);
        return self;
      } else {
        return nil
      }
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var $yield = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      if (!($yield !== nil)) {
        return self.$enum_for("delete_if")
      };
      $send($send(self, 'select', [], function $$13(o){
        
        if (o == null) o = nil;
        return Opal.yield1($yield, o);;}), 'each', [], function $$14(o){var self = $$14.$$s == null ? this : $$14.$$s;
        if (self.hash == null) self.hash = nil;

        
        if (o == null) o = nil;
        return self.hash.$delete(o);}, {$$s: self});
      return self;
    });
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      self.hash.$freeze();
      return $freeze(self);;
    });
    
    $def(self, '$keep_if', function $$keep_if() {
      var $yield = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      if (!($yield !== nil)) {
        return self.$enum_for("keep_if")
      };
      $send($send(self, 'reject', [], function $$15(o){
        
        if (o == null) o = nil;
        return Opal.yield1($yield, o);;}), 'each', [], function $$16(o){var self = $$16.$$s == null ? this : $$16.$$s;
        if (self.hash == null) self.hash = nil;

        
        if (o == null) o = nil;
        return self.hash.$delete(o);}, {$$s: self});
      return self;
    });
    
    $def(self, '$reject!', function $Set_reject$excl$17() {
      var block = $Set_reject$excl$17.$$p || nil, self = this, before = nil;

      $Set_reject$excl$17.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("reject!")
      };
      before = self.$size();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$size(), before)) {
        return nil
      } else {
        return self
      };
    });
    
    $def(self, '$select!', function $Set_select$excl$18() {
      var block = $Set_select$excl$18.$$p || nil, self = this, before = nil;

      $Set_select$excl$18.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("select!")
      };
      before = self.$size();
      $send(self, 'keep_if', [], block.$to_proc());
      if ($eqeq(self.$size(), before)) {
        return nil
      } else {
        return self
      };
    });
    
    $def(self, '$add?', function $Set_add$ques$19(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        return nil
      } else {
        return self.$add(o)
      }
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each")
      };
      $send(self.hash, 'each_key', [], block.$to_proc());
      return self;
    });
    
    $def(self, '$empty?', function $Set_empty$ques$20() {
      var self = this;

      return self.hash['$empty?']()
    });
    
    $def(self, '$eql?', function $Set_eql$ques$21(other) {
      var self = this;

      return self.hash['$eql?']($send(other, 'instance_eval', [], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;
        if (self.hash == null) self.hash = nil;

        return self.hash}, {$$s: self}))
    });
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      self.hash.$clear();
      return self;
    });
    
    $def(self, '$include?', function $Set_include$ques$23(o) {
      var self = this;

      return self.hash['$include?'](o)
    });
    
    $def(self, '$merge', function $$merge(enum$) {
      var self = this;

      
      $send(enum$, 'each', [], function $$24(item){var self = $$24.$$s == null ? this : $$24.$$s;

        
        if (item == null) item = nil;
        return self.$add(item);}, {$$s: self});
      return self;
    });
    
    $def(self, '$replace', function $$replace(enum$) {
      var self = this;

      
      self.$clear();
      self.$merge(enum$);
      return self;
    });
    
    $def(self, '$size', function $$size() {
      var self = this;

      return self.hash.$size()
    });
    
    $def(self, '$subtract', function $$subtract(enum$) {
      var self = this;

      
      $send(enum$, 'each', [], function $$25(item){var self = $$25.$$s == null ? this : $$25.$$s;

        
        if (item == null) item = nil;
        return self.$delete(item);}, {$$s: self});
      return self;
    });
    
    $def(self, '$|', function $Set_$$26(enum$) {
      var self = this;

      
      if (!$truthy(enum$['$respond_to?']("each"))) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$merge(enum$);
    });
    
    function is_set(set) {
      ($truthy(($ret_or_1 = (set)['$is_a?']($$$('Set')))) ? ($ret_or_1) : ($Kernel.$raise($$$('ArgumentError'), "value must be a set")))
    }
  ;
    
    $def(self, '$superset?', function $Set_superset$ques$27(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return false
      };
      return $send(set, 'all?', [], function $$28(o){var self = $$28.$$s == null ? this : $$28.$$s;

        
        if (o == null) o = nil;
        return self['$include?'](o);}, {$$s: self});
    });
    
    $def(self, '$proper_superset?', function $Set_proper_superset$ques$29(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_le(self.$size(), set.$size()))) {
        return false
      };
      return $send(set, 'all?', [], function $$30(o){var self = $$30.$$s == null ? this : $$30.$$s;

        
        if (o == null) o = nil;
        return self['$include?'](o);}, {$$s: self});
    });
    
    $def(self, '$subset?', function $Set_subset$ques$31(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(set.$size(), self.$size()))) {
        return false
      };
      return $send(self, 'all?', [], function $$32(o){
        
        if (o == null) o = nil;
        return set['$include?'](o);});
    });
    
    $def(self, '$proper_subset?', function $Set_proper_subset$ques$33(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_le(set.$size(), self.$size()))) {
        return false
      };
      return $send(self, 'all?', [], function $$34(o){
        
        if (o == null) o = nil;
        return set['$include?'](o);});
    });
    
    $def(self, '$intersect?', function $Set_intersect$ques$35(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return $send(self, 'any?', [], function $$36(o){
          
          if (o == null) o = nil;
          return set['$include?'](o);})
      } else {
        return $send(set, 'any?', [], function $$37(o){var self = $$37.$$s == null ? this : $$37.$$s;

          
          if (o == null) o = nil;
          return self['$include?'](o);}, {$$s: self})
      };
    });
    
    $def(self, '$disjoint?', function $Set_disjoint$ques$38(set) {
      var self = this;

      return self['$intersect?'](set)['$!']()
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return self.hash.$keys()
    });
    $alias(self, "+", "|");
    $alias(self, "<", "proper_subset?");
    $alias(self, "<<", "add");
    $alias(self, "<=", "subset?");
    $alias(self, ">", "proper_superset?");
    $alias(self, ">=", "superset?");
    $alias(self, "difference", "-");
    $alias(self, "filter!", "select!");
    $alias(self, "length", "size");
    $alias(self, "map!", "collect!");
    $alias(self, "member?", "include?");
    return $alias(self, "union", "|");
  })('::', null, $nesting)
};

Opal.modules["corelib/dir"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('[],pwd');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      
      
      
      $def(self, '$chdir', function $$chdir(dir) {
        var $yield = $$chdir.$$p || nil, prev_cwd = nil;

        $$chdir.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      });
      
      $def(self, '$pwd', function $$pwd() {
        
        return Opal.current_dir || '.';
      });
      
      $def(self, '$home', function $$home() {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$$('ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      });
      return $alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/file"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $truthy = Opal.truthy, $klass = Opal.klass, $const_set = Opal.const_set, $Opal = Opal.Opal, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $def = Opal.def, $Kernel = Opal.Kernel, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_minus = Opal.rb_minus, $range = Opal.range, $send = Opal.send, $slice = Opal.slice, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,to_path,coerce_to!,pwd,split,sub,+,unshift,join,home,raise,start_with?,absolute_path,==,<,dirname,-,basename,empty?,rindex,[],length,nil?,gsub,find,=~,map,each_with_index,flatten,reject,to_proc,end_with?,expand_path,exist?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    $const_set($nesting[0], 'Separator', $const_set($nesting[0], 'SEPARATOR', "/"));
    $const_set($nesting[0], 'ALT_SEPARATOR', nil);
    $const_set($nesting[0], 'PATH_SEPARATOR', ":");
    $const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$absolute_path', function $$absolute_path(path, basedir) {
        var sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = ($truthy(path['$respond_to?']("to_path")) ? (path.$to_path()) : (path));
        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");
        basedir = ($truthy(($ret_or_1 = basedir)) ? ($ret_or_1) : ($$$('Dir').$pwd()));
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split($regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split($regexp(["[", sep_chars, "]"])), path.$split($regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)
        };
        return new_path;
      }, -2);
      
      $def(self, '$expand_path', function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$('Dir').$home();
          if (!$truthy(home)) {
            $Kernel.$raise($$$('ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if (!$truthy(home['$start_with?'](leading_sep))) {
            $Kernel.$raise($$$('ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = $regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)
          };
        };
        return self.$absolute_path(path, basedir);
      }, -2);
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$('ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$('SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$('SEPARATOR'), $$('ALT_SEPARATOR')));
        }
      }
    ;
      
      $def(self, '$dirname', function $$dirname(path, level) {
        var self = this, sep_chars = nil;

        
        if (level == null) level = 1;
        if ($eqeq(level, 0)) {
          return path
        };
        if ($truthy($rb_lt(level, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "level can't be negative")
        };
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("^[" + (sep_chars) + "]")), out;

        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          out = absolute ? '/' : '.';
        }
        else {
          out = path;
        }

        if (level == 1) {
          return out;
        }
        else {
          return self.$dirname(out, $rb_minus(level, 1))
        }
      ;
      }, -2);
      
      $def(self, '$basename', function $$basename(name, suffix) {
        var sep_chars = nil;

        
        if (suffix == null) suffix = nil;
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $Opal['$coerce_to!'](suffix, $$$('String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, -2);
      
      $def(self, '$extname', function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""
        };
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if (($truthy(last_dot_idx['$nil?']()) || ($eqeq($rb_plus(last_dot_idx, 1), $rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      });
      
      $def(self, '$exist?', function $exist$ques$1(path) {
        
        return Opal.modules[path] != null
      });
      
      $def(self, '$directory?', function $directory$ques$2(path) {
        var files = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub($regexp(["(^.", $$('SEPARATOR'), "+|", $$('SEPARATOR'), "+$)"]));
        return $send(files, 'find', [], function $$3(f){
          
          if (f == null) f = nil;
          return f['$=~']($regexp(["^", path]));});
      });
      
      $def(self, '$join', function $$join($a) {
        var $post_args, paths, result = nil;

        
        $post_args = $slice(arguments);
        paths = $post_args;
        if ($truthy(paths['$empty?']())) {
          return ""
        };
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], function $$4(item, index){
          
          if (item == null) item = nil;
          if (index == null) index = nil;
          if (($eqeq(index, 0) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else if (($eqeq(paths.$length(), $rb_plus(index, 1)) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else {
            return item
          };});
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], function $$5(item, index){var next_item = nil;

          
          if (item == null) item = nil;
          if (index == null) index = nil;
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if (($truthy(item['$end_with?']($$('SEPARATOR'))) && ($truthy(next_item['$start_with?']($$('SEPARATOR')))))) {
              item = item.$sub($regexp([$$('SEPARATOR'), "+$"]), "")
            };
            return (result = (($truthy(item['$end_with?']($$('SEPARATOR'))) || ($truthy(next_item['$start_with?']($$('SEPARATOR'))))) ? ("" + (result) + (item)) : ("" + (result) + (item) + ($$('SEPARATOR')))));
          };});
        return result;
      }, -1);
      
      $def(self, '$split', function $$split(path) {
        
        return path.$split($$('SEPARATOR'))
      });
      $alias(self, "realpath", "expand_path");
      return $alias(self, "exists?", "exist?");
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('IO'), $nesting)
};

Opal.modules["corelib/process/base"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $return_val = Opal.return_val, nil = Opal.nil;

  
  (function($base, $super) {
    var self = $klass($base, $super, 'Signal');

    
    return $defs(self, '$trap', function $$trap($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1)
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'GC');

    
    return $defs(self, '$start', $return_val(nil))
  })('::', null);
};

Opal.modules["corelib/process"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $defs = Opal.defs, $truthy = Opal.truthy, $return_val = Opal.return_val, $Kernel = Opal.Kernel, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('const_set,size,<<,__register_clock__,to_f,now,new,[],raise');
  return (function($base) {
    var self = $module($base, 'Process');

    var monotonic = nil;

    
    self.__clocks__ = [];
    $defs(self, '$__register_clock__', function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    });
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)
    };
    $defs(self, '$pid', $return_val(0));
    $defs(self, '$times', function $$times() {
      var t = nil;

      
      t = $$$('Time').$now().$to_f();
      return $$$($$$('Benchmark'), 'Tms').$new(t, t, t, t, t);
    });
    return $defs(self, '$clock_gettime', function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      if (unit == null) unit = "float_second";
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        $Kernel.$raise($$$($$$('Errno'), 'EINVAL'), "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: $Kernel.$raise($$$('ArgumentError'), "unexpected unit: " + (unit))
      }
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/random/formatter"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $module = Opal.module, $def = Opal.def, $range = Opal.range, $send = Opal.send, $rb_divide = Opal.rb_divide, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('_verify_count,bytes,encode,strict_encode64,random_bytes,urlsafe_encode64,split,hex,[]=,[],map,to_proc,join,times,<<,|,ord,/,abs,random_float,raise,coerce_to!,flatten,new,random_number,length,include,extend');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$hex', function $$hex(count) {
        var self = this;

        
        if (count == null) count = nil;
        count = $$$('Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, -1);
      
      $def(self, '$random_bytes', function $$random_bytes(count) {
        var self = this;

        
        if (count == null) count = nil;
        return self.$bytes(count);
      }, -1);
      
      $def(self, '$base64', function $$base64(count) {
        var self = this;

        
        if (count == null) count = nil;
        return $$$('Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$urlsafe_base64', function $$urlsafe_base64(count, padding) {
        var self = this;

        
        if (count == null) count = nil;
        if (padding == null) padding = false;
        return $$$('Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$uuid', function $$uuid() {
        var self = this, str = nil;

        
        str = self.$hex(16).$split("");
        str['$[]='](12, "4");
        str['$[]='](16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16));
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      });
      
      $def(self, '$random_float', function $$random_float() {
        var self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], function $$1(i){
          
          if (i == null) i = nil;
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));});
        return $rb_divide(num.$abs(), 2147483647);
      });
      
      $def(self, '$random_number', function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");

          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          return randomInt(limit);
        }
      ;
      }, -1);
      return $def(self, '$alphanumeric', function $$alphanumeric(count) {
        var self = this, map = nil;

        
        if (count == null) count = nil;
        count = $$('Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$$('Array'), 'new', [count], function $$2(i){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (i == null) i = nil;
          return map['$[]'](self.$random_number(map.$length()));}, {$$s: self}).$join();
      }, -1);
    })(self, $nesting);
    self.$include($$$($$$('Random'), 'Formatter'));
    return self.$extend($$$($$$('Random'), 'Formatter'));
  })('::', null, $nesting)
};

Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, nil = Opal.nil, $$$ = Opal.$$$, mersenne_twister = nil;

  Opal.add_stubs('generator=');
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    var $a;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    $const_set(self, 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    return ($a = [$$$(self, 'MERSENNE_TWISTER_GENERATOR')], $send(self, 'generator=', $a), $a[$a.length - 1]);
  })('::', null);
};

Opal.modules["corelib/random"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $truthy = Opal.truthy, $klass = Opal.klass, $Kernel = Opal.Kernel, $defs = Opal.defs, $Opal = Opal.Opal, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $send = Opal.send, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,attr_reader,to_int,raise,new_seed,coerce_to!,reseed,rand,seed,bytes,===,==,state,_verify_count,encode,join,new,chr,random_number,random_float,const_defined?,const_set');
  
  self.$require("corelib/random/formatter");
  (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    
    
    self.$attr_reader("seed", "state");
    $defs(self, '$_verify_count', function $$_verify_count(count) {
      
      
      if (!$truthy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) $Kernel.$raise($$$('ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    });
    
    $def(self, '$initialize', function $$initialize(seed) {
      var self = this;

      
      if (seed == null) seed = $$$('Random').$new_seed();
      seed = $Opal['$coerce_to!'](seed, $$$('Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, -1);
    
    $def(self, '$reseed', function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    });
    $defs(self, '$new_seed', function $$new_seed() {
      
      return Opal.$$rand.new_seed();
    });
    $defs(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return $$$(self, 'DEFAULT').$rand(limit);
    }, -1);
    $defs(self, '$srand', function $$srand(n) {
      var self = this, previous_seed = nil;

      
      if (n == null) n = $$$('Random').$new_seed();
      n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      previous_seed = $$$(self, 'DEFAULT').$seed();
      $$$(self, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, -1);
    $defs(self, '$urandom', function $$urandom(size) {
      
      return $$$('SecureRandom').$bytes(size)
    });
    
    $def(self, '$==', function $Random_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      
      if (!$eqeqeq($$$('Random'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$bytes', function $$bytes(length) {
      var self = this;

      
      length = $$$('Random').$_verify_count(length);
      return $send($$$('Array'), 'new', [length], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        return self.$rand(255).$chr()}, {$$s: self}).$join().$encode("ASCII-8BIT");
    });
    $defs(self, '$bytes', function $$bytes(length) {
      var self = this;

      return $$$(self, 'DEFAULT').$bytes(length)
    });
    
    $def(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, -1);
    
    $def(self, '$random_float', function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    });
    $defs(self, '$random_float', function $$random_float() {
      var self = this;

      return $$$(self, 'DEFAULT').$random_float()
    });
    return $defs(self, '$generator=', function $Random_generator$eq$3(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$$(self, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    });
  })('::', null);
  return self.$require("corelib/random/mersenne_twister");
};

Opal.modules["corelib/unsupported"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $Kernel = Opal.Kernel, $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $module = Opal.module, $def = Opal.def, $return_val = Opal.return_val, $alias = Opal.alias, $defs = Opal.defs, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,warn,each,define_method,%,public,private_method_defined?,private_class_method,instance_method,instance_methods,method_defined?,private_methods');
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $Kernel.$raise($$$('NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    return $send(["<<", "capitalize!", "chomp!", "chop!", "downcase!", "gsub!", "lstrip!", "next!", "reverse!", "slice!", "squeeze!", "strip!", "sub!", "succ!", "swapcase!", "tr!", "tr_s!", "upcase!", "prepend", "[]=", "clear", "encode!", "unicode_normalize!"], 'each', [], function $String$1(method_name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      if (method_name == null) method_name = nil;
      return $send(self, 'define_method', [method_name], function $$2($a){var $post_args, $fwd_rest;

        
        $post_args = $slice(arguments);
        $fwd_rest = $post_args;
        return $Kernel.$raise($$$('NotImplementedError'), (ERROR)['$%'](method_name));}, -1);}, {$$s: self});
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    var ERROR = "Object tainting is not supported by Opal";
    
    $def(self, '$taint', function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    });
    
    $def(self, '$untaint', function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    });
    return $def(self, '$tainted?', function $Kernel_tainted$ques$3() {
      
      
      handle_unsupported_feature(ERROR);
      return false;
    });
  })('::');
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    
    
    $def(self, '$public', function $Module_public$4($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      
      if (methods.length === 0) {
        self.$$module_function = false;
        return nil;
      }
      return (methods.length === 1) ? methods[0] : methods;
    ;
    }, -1);
    
    $def(self, '$private_class_method', function $$private_class_method($a) {
      var $post_args, methods;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      return (methods.length === 1) ? methods[0] : methods;;
    }, -1);
    
    $def(self, '$private_method_defined?', $return_val(false));
    
    $def(self, '$private_constant', function $$private_constant($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    $alias(self, "nesting", "public");
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_class_method", "private_class_method");
    $alias(self, "public_instance_method", "instance_method");
    $alias(self, "public_instance_methods", "instance_methods");
    return $alias(self, "public_method_defined?", "method_defined?");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$private_methods', function $$private_methods($a) {
      var $post_args, methods;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      return [];
    }, -1);
    $alias(self, "protected_methods", "private_methods");
    $alias(self, "private_instance_methods", "private_methods");
    return $alias(self, "protected_instance_methods", "private_methods");
  })('::');
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$eval', function $Kernel_eval$5($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'), "To use Kernel#eval, you must first require 'opal-parser'. " + ("See https://github.com/opal/opal/blob/" + ($$('RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, -1)
  })('::', $nesting);
  $defs(self, '$public', function $public$6($a) {
    var $post_args, methods;

    
    $post_args = $slice(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
  return $defs(self, '$private', function $private$7($a) {
    var $post_args, methods;

    
    $post_args = $slice(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
};

Opal.modules["corelib/binding"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $Kernel = Opal.Kernel, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $module = Opal.module, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('js_eval,call,raise,inspect,include?,==,receiver,eval,attr_reader,new');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Binding');

    var $proto = self.$$prototype;

    $proto.jseval = $proto.scope_variables = nil;
    
    
    $def(self, '$initialize', function $$initialize(jseval, scope_variables, receiver, source_location) {
      var $a, self = this;

      
      if (scope_variables == null) scope_variables = [];
      ;
      if (source_location == null) source_location = nil;
      $a = [jseval, scope_variables, receiver, source_location], (self.jseval = $a[0]), (self.scope_variables = $a[1]), (self.receiver = $a[2]), (self.source_location = $a[3]), $a;
      if ($truthy(typeof receiver !== undefined)) {
        return nil
      } else {
        return (receiver = self.$js_eval("self"))
      };
    }, -2);
    
    $def(self, '$js_eval', function $$js_eval($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(self.jseval)) {
        return $send(self.jseval, 'call', $to_a(args))
      } else {
        return $Kernel.$raise("Evaluation on a Proc#binding is not supported")
      };
    }, -1);
    
    $def(self, '$local_variable_get', function $$local_variable_get(symbol) {
      var self = this;

      try {
        return self.$js_eval(symbol)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {
          try {
            return $Kernel.$raise($$$('NameError'), "local variable `" + (symbol) + "' is not defined for " + (self.$inspect()))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    });
    
    $def(self, '$local_variable_set', function $$local_variable_set(symbol, value) {
      var self = this;

      
      Opal.Binding.tmp_value = value;
      self.$js_eval("" + (symbol) + " = Opal.Binding.tmp_value");
      delete Opal.Binding.tmp_value;
      return value;
    });
    
    $def(self, '$local_variables', $return_ivar("scope_variables"));
    
    $def(self, '$local_variable_defined?', function $Binding_local_variable_defined$ques$1(value) {
      var self = this;

      return self.scope_variables['$include?'](value)
    });
    
    $def(self, '$eval', function $Binding_eval$2(str, file, line) {try { var $t_eval_return = $thrower('eval_return'); 
      var self = this;

      
      if (file == null) file = nil;
      if (line == null) line = nil;
      if ($eqeq(str, "self")) {
        return self.$receiver()
      };
      return $Kernel.$eval(str, self, file, line);} catch($e) {
        if ($e === Opal.t_eval_return) return $e.$v;
        throw $e;
      }
    }, -2);
    return self.$attr_reader("receiver", "source_location");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$binding', function $$binding() {
      
      return $Kernel.$raise("Opal doesn't support dynamic calls to binding")
    })
  })('::');
  return $const_set($nesting[0], 'TOPLEVEL_BINDING', $$$('Binding').$new(
    function(js) {
      return (new Function("self", "return " + js))(self);
    }
  , [], self, ["<main>", 0]));
};

Opal.modules["corelib/irb"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $hash = Opal.hash, $gvars = Opal.gvars, $lambda = Opal.lambda, $send = Opal.send, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $range = Opal.range, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include?,raise,attr_accessor,singleton_class,output=,browser?,each,dup,write_proc=,proc,+,output,join,last,split,end_with?,call,write_proc,tty=,read_proc,read_proc=,freeze,new,string,ensure_loaded,prepare_console,loop,print,gets,puts,start_with?,[],==,silence,message,empty?,warnings,warn,full_message,eval_and_print,irb');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'IRB');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$ensure_loaded', function $$ensure_loaded(library) {
        var version = nil, url = nil;

        
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        };
        version = ($truthy($$('RUBY_ENGINE_VERSION')['$include?']("dev")) ? ("master") : ($$('RUBY_ENGINE_VERSION')));
        url = "https://cdn.opalrb.com/opal/" + (version) + "/" + (library) + ".js";
        
        var libcode;

        if (typeof XMLHttpRequest !== 'undefined') { // Browser
          var r = new XMLHttpRequest();
          r.open("GET", url, false);
          r.send('');
          libcode = r.responseText;
        }
        else {
          $Kernel.$raise("You need to provision " + (library) + " yourself in this environment")
        }

        (new Function('Opal', libcode))(Opal);

        Opal.require(library);
      ;
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        } else {
          return $Kernel.$raise("Could not load " + (library) + " for some reason")
        };
      });
      self.$singleton_class().$attr_accessor("output");
      $defs(self, '$prepare_console', function $$prepare_console() {
        var block = $$prepare_console.$$p || nil, $a, self = this, original = nil, original_read_proc = nil;
        if ($gvars.stdout == null) $gvars.stdout = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;
        if ($gvars.stdin == null) $gvars.stdin = nil;

        $$prepare_console.$$p = null;
        
        ;
        return (function() { try {
        
        self['$output=']("");
        original = $hash($gvars.stdout, $lambda(function $$1(i){
          
          if (i == null) i = nil;
          return ($gvars.stdout = i);}), $gvars.stderr, $lambda(function $$2(i){
          
          if (i == null) i = nil;
          return ($gvars.stderr = i);}));
        if ($truthy(self['$browser?']())) {
          
          $send(original, 'each', [], function $$3(pipe, pipe_setter){var self = $$3.$$s == null ? this : $$3.$$s, new_pipe = nil;

            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            new_pipe = pipe.$dup();
            new_pipe['$write_proc=']($send(self, 'proc', [], function $$4(str){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (str == null) str = nil;
              self['$output=']($rb_plus(self.$output(), str));
              self['$output='](self.$output().$split("\n").$last(30).$join("\n"));
              if ($truthy(str['$end_with?']("\n"))) {
                self['$output=']($rb_plus(self.$output(), "\n"))
              };
              return pipe.$write_proc().$call(str);}, {$$s: self}));
            new_pipe['$tty='](false);
            return pipe_setter.$call(new_pipe);}, {$$s: self});
          original_read_proc = $gvars.stdin.$read_proc();
          $gvars.stdin['$read_proc='](function(s) { var p = prompt(self.$output()); if (p !== null) return p + "\n"; return nil; });
        };
        return Opal.yieldX(block, []);;
        } finally {
          ($send(original, 'each', [], function $$5(pipe, pipe_setter){
            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            return pipe_setter.$call(pipe);}), ($a = [original_read_proc], $send($gvars.stdin, 'read_proc=', $a), $a[$a.length - 1]), ($a = [""], $send(self, 'output=', $a), $a[$a.length - 1]))
        }; })();
      });
      $defs(self, '$browser?', function $IRB_browser$ques$6() {
        
        return typeof(document) !== 'undefined' && typeof(prompt) !== 'undefined';
      });
      $const_set($nesting[0], 'LINEBREAKS', ["unexpected token $end", "unterminated string meets end of file"].$freeze());
      return (function($base, $super) {
        var self = $klass($base, $super, 'Silencer');

        var $proto = self.$$prototype;

        $proto.collector = $proto.stderr = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var self = this;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          return (self.stderr = $gvars.stderr)
        });
        
        $def(self, '$silence', function $$silence() {
          var $yield = $$silence.$$p || nil, self = this;

          $$silence.$$p = null;
          return (function() { try {
          
          self.collector = $$$('StringIO').$new();
          $gvars.stderr = self.collector;
          return Opal.yieldX($yield, []);;
          } finally {
            ($gvars.stderr = self.stderr)
          }; })()
        });
        return $def(self, '$warnings', function $$warnings() {
          var self = this;

          return self.collector.$string()
        });
      })($nesting[0], null);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Binding');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$irb', function $$irb() {try { var $t_return = $thrower('return'); 
      var self = this, silencer = nil;

      
      $$$($Opal, 'IRB').$ensure_loaded("opal-replutils");
      silencer = $$$($$$($Opal, 'IRB'), 'Silencer').$new();
      return $send($$$($Opal, 'IRB'), 'prepare_console', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        return (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s, line = nil, code = nil, mode = nil, js_code = nil, e = nil;

          
          self.$print(">> ");
          line = self.$gets();
          if (!$truthy(line)) {
            $t_break.$throw()
          };
          code = "";
          if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
            self.$puts(line)
          };
          if ($truthy(line['$start_with?']("ls "))) {
            
            code = line['$[]']($range(3, -1, false));
            mode = "ls";
          } else if ($eqeq(line, "ls\n")) {
            
            code = "self";
            mode = "ls";
          } else if ($truthy(line['$start_with?']("show "))) {
            
            code = line['$[]']($range(5, -1, false));
            mode = "show";
          } else {
            
            code = line;
            mode = "inspect";
          };
          js_code = nil;
          
          do { try {
            $send(silencer, 'silence', [], function $$9(){
              return (js_code = Opal.compile(code, {irb: true}))})
          } catch ($err) {
            if (Opal.rescue($err, [$$('SyntaxError')])) {(e = $err)
              try {
                if ($truthy($$$($$$($Opal, 'IRB'), 'LINEBREAKS')['$include?'](e.$message()))) {
                  
                  self.$print(".. ");
                  line = self.$gets();
                  if (!$truthy(line)) {
                    $t_return.$throw()
                  };
                  if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
                    self.$puts(line)
                  };
                  code = $rb_plus(code, line);
                  continue;
                } else if ($truthy(silencer.$warnings()['$empty?']())) {
                  self.$warn(e.$full_message())
                } else {
                  self.$warn(silencer.$warnings())
                }
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          } break; } while(1);;
          if ($eqeq(mode, "show")) {
            
            self.$puts(js_code);
            $t_return.$throw();
          };
          return self.$puts($$$('REPLUtils').$eval_and_print(js_code, mode, false, self));}, {$$s: self, $$ret: $t_return})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})()}, {$$s: self});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    })
  })('::', null, $nesting);
  
  // Run in WebTools console with: Opal.irb(c => eval(c))
  Opal.irb = function(fun) {
    $$$('Binding').$new(fun).$irb()
  }

  Opal.load_parser = function() {
    Opal.Opal.IRB.$ensure_loaded('opal-parser');
  }

  if (typeof Opal.eval === 'undefined') {
    Opal.eval = function(str) {
      Opal.load_parser();
      return Opal.eval(str);
    }
  }

  if (typeof Opal.compile === 'undefined') {
    Opal.compile = function(str, options) {
      Opal.load_parser();
      return Opal.compile(str, options);
    }
  }
;
};

Opal.modules["opal"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Set", "corelib/set");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
};

Opal.modules["js"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $def = Opal.def, $truthy = Opal.truthy, $slice = Opal.slice, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('insert,<<,global,call,extend');
  return (function($base) {
    var self = $module($base, 'JS');

    
    
    
    $def(self, '$delete', function $JS_delete$1(object, property) {
      
      return delete object[property]
    });
    
    $def(self, '$global', function $$global() {
      
      return Opal.global;
    });
    
    $def(self, '$in', function $JS_in$2(property, object) {
      
      return property in object
    });
    
    $def(self, '$instanceof', function $JS_instanceof$3(value, func) {
      
      return value instanceof func
    });
    if ($truthy(typeof Function.prototype.bind == 'function')) {
      
      $def(self, '$new', function $JS_new$4(func, $a) {
        var block = $JS_new$4.$$p || nil, $post_args, args;

        $JS_new$4.$$p = null;
        
        ;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        args.$insert(0, this);
        if ($truthy(block)) {
          args['$<<'](block)
        };
        return new (func.bind.apply(func, args))();
      }, -2)
    } else {
      
      $def(self, '$new', function $JS_new$5(func, $a) {
        var block = $JS_new$5.$$p || nil, $post_args, args, f = nil;

        $JS_new$5.$$p = null;
        
        ;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        if ($truthy(block)) {
          args['$<<'](block)
        };
        f = function(){return func.apply(this, args)};
        f["prototype"] = func["prototype"];
        return new f();;
      }, -2)
    };
    
    $def(self, '$typeof', function $JS_typeof$6(value) {
      
      return typeof value
    });
    
    $def(self, '$void', function $JS_void$7(expr) {
      
      return void expr
    });
    
    $def(self, '$call', function $$call(func, $a) {
      var block = $$call.$$p || nil, $post_args, args, self = this, g = nil;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      g = self.$global();
      if ($truthy(block)) {
        args['$<<'](block)
      };
      return g[func].apply(g, args);
    }, -2);
    
    $def(self, '$[]', function $JS_$$$8(name) {
      
      return Opal.global[name]
    });
    $alias(self, "method_missing", "call");
    return self.$extend(self);
  })($nesting[0])
};

Opal.modules["native"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $defs = Opal.defs, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send, $Kernel = Opal.Kernel, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $range = Opal.range, $to_a = Opal.to_a, $def = Opal.def, $return_ivar = Opal.return_ivar, $alias = Opal.alias, $klass = Opal.klass, $rb_minus = Opal.rb_minus, $return_val = Opal.return_val, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeqeq = Opal.eqeqeq, $rb_ge = Opal.rb_ge, $return_self = Opal.return_self, $gvars = Opal.gvars, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('try_convert,native?,respond_to?,to_n,raise,inspect,Native,proc,map!,end_with?,define_method,[],convert,call,to_proc,new,each,native_reader,native_writer,extend,warn,include,is_a?,map,Array,to_a,_Array,method_missing,bind,instance_method,[]=,slice,-,length,has_key?,enum_for,===,>=,<<,each_pair,method_defined?,initialize,_initialize,name,native_module');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Native');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$is_a?', function $Native_is_a$ques$1(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    });
    $defs(self, '$try_convert', function $$try_convert(value, default$) {
      var self = this;

      
      if (default$ == null) default$ = nil;
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    ;
    }, -2);
    $defs(self, '$convert', function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise($$('ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    });
    $defs(self, '$call', function $$call(obj, key, $a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments, 2);
      args = $post_args;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    ;
    }, -3);
    $defs(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil, self = this;

      $$proc.$$p = null;
      
      ;
      if (!$truthy(block)) {
        self.$raise($$('LocalJumpError'), "no block given")
      };
      return $send($Kernel, 'proc', [], function $$2($a){var $post_args, args, self = $$2.$$s == null ? this : $$2.$$s, instance = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        $send(args, 'map!', [], function $$3(arg){var self = $$3.$$s == null ? this : $$3.$$s;

          
          if (arg == null) arg = nil;
          return self.$Native(arg);}, {$$s: self});
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, {$$arity: -1, $$s: self});
    });
    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$alias_native', function $$alias_native(new$, $a, $b) {
        var $post_args, $kwargs, old, as, $yield = $$alias_native.$$p || nil, self = this;

        $$alias_native.$$p = null;
        
        $post_args = $slice(arguments, 1);
        $kwargs = $extract_kwargs($post_args);
        $kwargs = $ensure_kwargs($kwargs);
        
        if ($post_args.length > 0) old = $post_args.shift();if (old == null) old = new$;
        
        as = $kwargs.$$smap["as"];if (as == null) as = nil;
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], function $$4(value){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (value == null) value = nil;
            self["native"][old['$[]']($range(0, -2, false))] = $$('Native').$convert(value);
            return value;}, {$$s: self})
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], function $$5($c){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, value = nil;
            if (self["native"] == null) self["native"] = nil;

            $$5.$$p = null;
            
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            value = $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());
            if ($truthy(value)) {
              return as.$new(value.$to_n())
            } else {
              return nil
            };}, {$$arity: -1, $$s: self})
        } else {
          return $send(self, 'define_method', [new$], function $$6($c){var block = $$6.$$p || nil, $post_args, args, self = $$6.$$s == null ? this : $$6.$$s;
            if (self["native"] == null) self["native"] = nil;

            $$6.$$p = null;
            
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());}, {$$arity: -1, $$s: self})
        };
      }, -2);
      
      $def(self, '$native_reader', function $$native_reader($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice(arguments);
        names = $post_args;
        return $send(names, 'each', [], function $$7(name){var self = $$7.$$s == null ? this : $$7.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;
            if (self["native"] == null) self["native"] = nil;

            return self.$Native(self["native"][name])}, {$$s: self});}, {$$s: self});
      }, -1);
      
      $def(self, '$native_writer', function $$native_writer($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice(arguments);
        names = $post_args;
        return $send(names, 'each', [], function $$9(name){var self = $$9.$$s == null ? this : $$9.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', ["" + (name) + "="], function $$10(value){var self = $$10.$$s == null ? this : $$10.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (value == null) value = nil;
            return self.$Native(self["native"][name] = value);}, {$$s: self});}, {$$s: self});
      }, -1);
      return $def(self, '$native_accessor', function $$native_accessor($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice(arguments);
        names = $post_args;
        $send(self, 'native_reader', $to_a(names));
        return $send(self, 'native_writer', $to_a(names));
      }, -1);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Wrapper');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$initialize', function $$initialize(native$) {
        var self = this;

        
        if (!$truthy($Kernel['$native?'](native$))) {
          $Kernel.$raise($$('ArgumentError'), "" + (native$.$inspect()) + " isn't native")
        };
        return (self["native"] = native$);
      });
      
      $def(self, '$to_n', $return_ivar("native"));
      return $defs(self, '$included', function $$included(klass) {
        
        return klass.$extend($$('Helpers'))
      });
    })($nesting[0], $nesting);
    return $defs(self, '$included', function $$included(base) {
      var self = this;

      
      self.$warn("Including ::Native is deprecated. Please include Native::Wrapper instead.");
      return base.$include($$('Wrapper'));
    });
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native?', function $Kernel_native$ques$11(value) {
      
      return value == null || !value.$$class;
    });
    
    $def(self, '$Native', function $$Native(obj) {
      var $yield = $$Native.$$p || nil, self = this;

      $$Native.$$p = null;
      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return $$$($$('Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?']($$('Array')))) {
        return $send(obj, 'map', [], function $$12(o){var self = $$12.$$s == null ? this : $$12.$$s;

          
          if (o == null) o = nil;
          return self.$Native(o);}, {$$s: self})
      } else if ($truthy(obj['$is_a?']($$('Proc')))) {
        return $send(self, 'proc', [], function $$13($a){var block = $$13.$$p || nil, $post_args, args, self = $$13.$$s == null ? this : $$13.$$s;

          $$13.$$p = null;
          
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          return self.$Native($send(obj, 'call', $to_a(args), block.$to_proc()));}, {$$arity: -1, $$s: self})
      } else {
        return obj
      }
    });
    $alias(self, "_Array", "Array");
    return $def(self, '$Array', function $$Array(object, $a) {
      var block = $$Array.$$p || nil, $post_args, args, self = this;

      $$Array.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      if ($truthy(self['$native?'](object))) {
        return $send($$$($$('Native'), 'Array'), 'new', [object].concat($to_a(args)), block.$to_proc()).$to_a()
      };
      return self.$_Array(object);
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    var $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$$('Native'), 'Wrapper'));
    
    $def(self, '$==', function $Object_$eq_eq$14(other) {
      var self = this;

      return self["native"] === $$$('Native').$try_convert(other)
    });
    
    $def(self, '$has_key?', function $Object_has_key$ques$15(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    });
    
    $def(self, '$each', function $$each($a) {
      var $post_args, args, $yield = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      $post_args = $slice(arguments);
      args = $post_args;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
      } else {
        return $send(self, 'method_missing', ["each"].concat($to_a(args)))
      };
    }, -1);
    
    $def(self, '$[]', function $Object_$$$16(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return $$$('Native').$call(self["native"], key)
      }
    
    });
    
    $def(self, '$[]=', function $Object_$$$eq$17(key, value) {
      var self = this, native$ = nil;

      
      native$ = $$$('Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
      } else {
        return self["native"][key] = native$
      };
    });
    
    $def(self, '$merge!', function $Object_merge$excl$18(other) {
      var self = this;

      
      
      other = $$$('Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    });
    
    $def(self, '$respond_to?', function $Object_respond_to$ques$19(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      return $Kernel.$instance_method("respond_to?").$bind(self).$call(name, include_all);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Object_respond_to_missing$ques$20(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      return Opal.hasOwnProperty.call(self["native"], name);
    }, -2);
    
    $def(self, '$method_missing', function $$method_missing(mid, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, $b, self = this;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return ($b = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)], $send(self, '[]=', $b), $b[$b.length - 1]);
      }
      else {
        return $send($$$('Native'), 'call', [self["native"], mid].concat($to_a(args)), block.$to_proc());
      }
    ;
    }, -2);
    
    $def(self, '$nil?', $return_val(false));
    
    $def(self, '$is_a?', function $Object_is_a$ques$21(klass) {
      var self = this;

      return Opal.is_a(self, klass);
    });
    
    $def(self, '$instance_of?', function $Object_instance_of$ques$22(klass) {
      var self = this;

      return self.$$class === klass;
    });
    
    $def(self, '$class', function $Object_class$23() {
      var self = this;

      return self.$$class;
    });
    
    $def(self, '$to_a', function $$to_a(options) {
      var block = $$to_a.$$p || nil, self = this;

      $$to_a.$$p = null;
      
      ;
      if (options == null) options = $hash2([], {});
      return $send($$$($$$('Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a();
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Native:" + (String(self["native"])) + ">"
    });
    $alias(self, "include?", "has_key?");
    $alias(self, "key?", "has_key?");
    $alias(self, "kind_of?", "is_a?");
    return $alias(self, "member?", "has_key?");
  })($$('Native'), $$('BasicObject'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.named = $proto["native"] = $proto.get = $proto.block = $proto.set = $proto.length = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    self.$include($$('Enumerable'));
    
    $def(self, '$initialize', function $$initialize(native$, options) {
      var block = $$initialize.$$p || nil, self = this, $ret_or_1 = nil;

      $$initialize.$$p = null;
      
      ;
      if (options == null) options = $hash2([], {});
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [native$], null);
      self.get = ($truthy(($ret_or_1 = options['$[]']("get"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.named = options['$[]']("named");
      self.set = ($truthy(($ret_or_1 = options['$[]']("set"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.length = ($truthy(($ret_or_1 = options['$[]']("length"))) ? ($ret_or_1) : ("length"));
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise($$('ArgumentError'), "no length found on the array-like object")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    });
    
    $def(self, '$[]', function $Array_$$$24(index) {
      var self = this, result = nil, $ret_or_1 = nil;

      
      result = (($eqeqeq($$('String'), ($ret_or_1 = index)) || ($eqeqeq($$('Symbol'), $ret_or_1))) ? (($truthy(self.named) ? (self["native"][self.named](index)) : (self["native"][index]))) : ($eqeqeq($$('Integer'), $ret_or_1) ? (($truthy(self.get) ? (self["native"][self.get](index)) : (self["native"][index]))) : (nil)));
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
        } else {
          return self.$Native(result)
        }
      } else {
        return nil
      };
    });
    
    $def(self, '$[]=', function $Array_$$$eq$25(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, $$('Native').$convert(value))
      } else {
        return self["native"][index] = $$('Native').$convert(value)
      }
    });
    
    $def(self, '$last', function $$last(count) {
      var self = this, index = nil, result = nil;

      
      if (count == null) count = nil;
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
        
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
      } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      };
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self["native"][self.length]
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    });
    return $alias(self, "to_ary", "to_a");
  })($$('Native'), null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    return $def(self, '$to_n', $return_self)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Regexp');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'MatchData');

    
    return $def(self, '$to_n', $return_ivar("matches"))
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], function $$26(name, value){
        
        if (name == null) name = nil;
        if (value == null) value = nil;
        return result[name] = $$('Native').$try_convert(value, value);});
      return result;
    })
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push($$('Native').$try_convert(obj, obj));
      }

      return result;
    
    })
  })($nesting[0], null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_n', $return_self)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_n', function $$to_n() {
      
      return null;
    })
  })($nesting[0], null);
  if (!$truthy($$('Hash')['$method_defined?']("_initialize"))) {
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Hash');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $alias(self, "_initialize", "initialize");
      
      $def(self, '$initialize', function $$initialize(defaults) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        ;
        
        if (defaults != null &&
             (defaults.constructor === undefined ||
               defaults.constructor === Object)) {
          var smap = self.$$smap,
              keys = self.$$keys,
              key, value;

          for (key in defaults) {
            value = defaults[key];

            if (value &&
                 (value.constructor === undefined ||
                   value.constructor === Object)) {
              smap[key] = $$('Hash').$new(value);
            } else if (value && value.$$is_array) {
              value = value.map(function(item) {
                if (item &&
                     (item.constructor === undefined ||
                       item.constructor === Object)) {
                  return $$('Hash').$new(item);
                }

                return self.$Native(item);
              });
              smap[key] = value
            } else {
              smap[key] = self.$Native(value);
            }

            keys.push(key);
          }

          return self;
        }

        return $send(self, '_initialize', [defaults], block.$to_proc());
      ;
      }, -1);
      return $def(self, '$to_n', function $$to_n() {
        var self = this;

        
        var result = {},
            keys = self.$$keys,
            smap = self.$$smap,
            key, value;

        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = smap[key];
          } else {
            key = key.key;
            value = key.value;
          }

          result[key] = $$('Native').$try_convert(value, value);
        }

        return result;
      
      });
    })($nesting[0], null, $nesting)
  };
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    return $def(self, '$native_module', function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    })
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native_alias', function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.prototype[Opal.jsid(existing_mid)];
      if (!aliased) {
        self.$raise($$('NameError').$new("undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", existing_mid));
      }
      self.prototype[new_jsid] = aliased;
    
    });
    return $def(self, '$native_class', function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    });
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

Opal.modules["console"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $send = Opal.send, $gvars = Opal.gvars, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,raise,==,arity,instance_exec,to_proc,new');
  
  self.$require("native");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Console');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      return self["native"].clear()
    });
    
    $def(self, '$trace', function $$trace() {
      var self = this;

      return self["native"].trace()
    });
    
    $def(self, '$log', function $$log($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self["native"].log.apply(self["native"], args);
    }, -1);
    
    $def(self, '$info', function $$info($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self["native"].info.apply(self["native"], args);
    }, -1);
    
    $def(self, '$warn', function $$warn($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self["native"].warn.apply(self["native"], args);
    }, -1);
    
    $def(self, '$error', function $$error($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self["native"].error.apply(self["native"], args);
    }, -1);
    
    $def(self, '$time', function $$time(label) {
      var block = $$time.$$p || nil, self = this;

      $$time.$$p = null;
      
      ;
      if (!$truthy(block)) {
        self.$raise($$('ArgumentError'), "no block given")
      };
      self["native"].time(label);
      
      return (function() { try {
      if ($eqeq(block.$arity(), 0)) {
        return $send(self, 'instance_exec', [], block.$to_proc())
      } else {
        return Opal.yield1(block, self);
      }
      } finally {
        self["native"].timeEnd()
      }; })();;
    });
    
    $def(self, '$group', function $$group($a) {
      var block = $$group.$$p || nil, $post_args, args, self = this;

      $$group.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!$truthy(block)) {
        self.$raise($$('ArgumentError'), "no block given")
      };
      self["native"].group.apply(self["native"], args);
      
      return (function() { try {
      if ($eqeq(block.$arity(), 0)) {
        return $send(self, 'instance_exec', [], block.$to_proc())
      } else {
        return Opal.yield1(block, self);
      }
      } finally {
        self["native"].groupEnd()
      }; })();;
    }, -1);
    return $def(self, '$group!', function $Console_group$excl$1($a) {
      var block = $Console_group$excl$1.$$p || nil, $post_args, args, self = this;

      $Console_group$excl$1.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!(block !== nil)) {
        return nil
      };
      self["native"].groupCollapsed.apply(self["native"], args);
      
      return (function() { try {
      if ($eqeq(block.$arity(), 0)) {
        return $send(self, 'instance_exec', [], block.$to_proc())
      } else {
        return Opal.yield1(block, self);
      }
      } finally {
        self["native"].groupEnd()
      }; })();;
    }, -1);
  })($nesting[0], null, $nesting);
  if ($truthy((typeof(Opal.global.console) !== "undefined"))) {
    return ($gvars.console = $$('Console').$new(Opal.global.console))
  } else {
    return nil
  };
};

!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.virtualDom=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var createElement = require("./vdom/create-element.js")

module.exports = createElement

},{"./vdom/create-element.js":15}],2:[function(require,module,exports){
var diff = require("./vtree/diff.js")

module.exports = diff

},{"./vtree/diff.js":35}],3:[function(require,module,exports){
var h = require("./virtual-hyperscript/index.js")

module.exports = h

},{"./virtual-hyperscript/index.js":22}],4:[function(require,module,exports){
var diff = require("./diff.js")
var patch = require("./patch.js")
var h = require("./h.js")
var create = require("./create-element.js")
var VNode = require('./vnode/vnode.js')
var VText = require('./vnode/vtext.js')

module.exports = {
    diff: diff,
    patch: patch,
    h: h,
    create: create,
    VNode: VNode,
    VText: VText
}

},{"./create-element.js":1,"./diff.js":2,"./h.js":3,"./patch.js":13,"./vnode/vnode.js":31,"./vnode/vtext.js":33}],5:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],6:[function(require,module,exports){

},{}],7:[function(require,module,exports){
'use strict';

var OneVersionConstraint = require('individual/one-version');

var MY_VERSION = '7';
OneVersionConstraint('ev-store', MY_VERSION);

var hashKey = '__EV_STORE_KEY@' + MY_VERSION;

module.exports = EvStore;

function EvStore(elem) {
    var hash = elem[hashKey];

    if (!hash) {
        hash = elem[hashKey] = {};
    }

    return hash;
}

},{"individual/one-version":9}],8:[function(require,module,exports){
(function (global){
'use strict';

/*global window, global*/

var root = typeof window !== 'undefined' ?
    window : typeof global !== 'undefined' ?
    global : {};

module.exports = Individual;

function Individual(key, value) {
    if (key in root) {
        return root[key];
    }

    root[key] = value;

    return value;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],9:[function(require,module,exports){
'use strict';

var Individual = require('./index.js');

module.exports = OneVersion;

function OneVersion(moduleName, version, defaultValue) {
    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
    var enforceKey = key + '_ENFORCE_SINGLETON';

    var versionValue = Individual(enforceKey, version);

    if (versionValue !== version) {
        throw new Error('Can only have one copy of ' +
            moduleName + '.\n' +
            'You already have version ' + versionValue +
            ' installed.\n' +
            'This means you cannot install version ' + version);
    }

    return Individual(key, defaultValue);
}

},{"./index.js":8}],10:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"min-document":6}],11:[function(require,module,exports){
"use strict";

module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

},{}],12:[function(require,module,exports){
var nativeIsArray = Array.isArray
var toString = Object.prototype.toString

module.exports = nativeIsArray || isArray

function isArray(obj) {
    return toString.call(obj) === "[object Array]"
}

},{}],13:[function(require,module,exports){
var patch = require("./vdom/patch.js")

module.exports = patch

},{"./vdom/patch.js":18}],14:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook.js")

module.exports = applyProperties

function applyProperties(node, props, previous) {
    for (var propName in props) {
        var propValue = props[propName]

        if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
        } else if (isHook(propValue)) {
            removeProperty(node, propName, propValue, previous)
            if (propValue.hook) {
                propValue.hook(node,
                    propName,
                    previous ? previous[propName] : undefined)
            }
        } else {
            if (isObject(propValue)) {
                patchObject(node, props, previous, propName, propValue);
            } else {
                node[propName] = propValue
            }
        }
    }
}

function removeProperty(node, propName, propValue, previous) {
    if (previous) {
        var previousValue = previous[propName]

        if (!isHook(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName)
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = ""
                }
            } else if (typeof previousValue === "string") {
                node[propName] = ""
            } else {
                node[propName] = null
            }
        } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue)
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName]

            if (attrValue === undefined) {
                node.removeAttribute(attrName)
            } else {
                node.setAttribute(attrName, attrValue)
            }
        }

        return
    }

    if(previousValue && isObject(previousValue) &&
        getPrototype(previousValue) !== getPrototype(propValue)) {
        node[propName] = propValue
        return
    }

    if (!isObject(node[propName])) {
        node[propName] = {}
    }

    var replacer = propName === "style" ? "" : undefined

    for (var k in propValue) {
        var value = propValue[k]
        node[propName][k] = (value === undefined) ? replacer : value
    }
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

},{"../vnode/is-vhook.js":26,"is-object":11}],15:[function(require,module,exports){
var document = require("global/document")

var applyProperties = require("./apply-properties")

var isVNode = require("../vnode/is-vnode.js")
var isVText = require("../vnode/is-vtext.js")
var isWidget = require("../vnode/is-widget.js")
var handleThunk = require("../vnode/handle-thunk.js")

module.exports = createElement

function createElement(vnode, opts) {
    var doc = opts ? opts.document || document : document
    var warn = opts ? opts.warn : null

    vnode = handleThunk(vnode).a

    if (isWidget(vnode)) {
        return vnode.init()
    } else if (isVText(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode)
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName) :
        doc.createElementNS(vnode.namespace, vnode.tagName)

    var props = vnode.properties
    applyProperties(node, props)

    var children = vnode.children

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts)
        if (childNode) {
            node.appendChild(childNode)
        }
    }

    return node
}

},{"../vnode/handle-thunk.js":24,"../vnode/is-vnode.js":27,"../vnode/is-vtext.js":28,"../vnode/is-widget.js":29,"./apply-properties":14,"global/document":10}],16:[function(require,module,exports){
// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {}

module.exports = domIndex

function domIndex(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode
        }

        var vChildren = tree.children

        if (vChildren) {

            var childNodes = rootNode.childNodes

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i] || noChild
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],17:[function(require,module,exports){
var applyProperties = require("./apply-properties")

var isWidget = require("../vnode/is-widget.js")
var VPatch = require("../vnode/vpatch.js")

var updateWidget = require("./update-widget")

module.exports = applyPatch

function applyPatch(vpatch, domNode, renderOptions) {
    var type = vpatch.type
    var vNode = vpatch.vNode
    var patch = vpatch.patch

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch.ORDER:
            reorderChildren(domNode, patch)
            return domNode
        case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties)
            return domNode
        case VPatch.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode

    if (parentNode) {
        parentNode.removeChild(domNode)
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = renderOptions.render(vNode, renderOptions)

    if (parentNode) {
        parentNode.appendChild(newNode)
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text)
        newNode = domNode
    } else {
        var parentNode = domNode.parentNode
        newNode = renderOptions.render(vText, renderOptions)

        if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode)
        }
    }

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    var updating = updateWidget(leftVNode, widget)
    var newNode

    if (updating) {
        newNode = widget.update(leftVNode, domNode) || domNode
    } else {
        newNode = renderOptions.render(widget, renderOptions)
    }

    var parentNode = domNode.parentNode

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    if (!updating) {
        destroyWidget(domNode, leftVNode)
    }

    return newNode
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode
    var newNode = renderOptions.render(vNode, renderOptions)

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget(w)) {
        w.destroy(domNode)
    }
}

function reorderChildren(domNode, moves) {
    var childNodes = domNode.childNodes
    var keyMap = {}
    var node
    var remove
    var insert

    for (var i = 0; i < moves.removes.length; i++) {
        remove = moves.removes[i]
        node = childNodes[remove.from]
        if (remove.key) {
            keyMap[remove.key] = node
        }
        domNode.removeChild(node)
    }

    var length = childNodes.length
    for (var j = 0; j < moves.inserts.length; j++) {
        insert = moves.inserts[j]
        node = keyMap[insert.key]
        // this is the weirdest bug i've ever seen in webkit
        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
    }

    return newRoot;
}

},{"../vnode/is-widget.js":29,"../vnode/vpatch.js":32,"./apply-properties":14,"./update-widget":19}],18:[function(require,module,exports){
var document = require("global/document")
var isArray = require("x-is-array")

var render = require("./create-element")
var domIndex = require("./dom-index")
var patchOp = require("./patch-op")
module.exports = patch

function patch(rootNode, patches, renderOptions) {
    renderOptions = renderOptions || {}
    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch
        ? renderOptions.patch
        : patchRecursive
    renderOptions.render = renderOptions.render || render

    return renderOptions.patch(rootNode, patches, renderOptions)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches)

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices)
    var ownerDocument = rootNode.ownerDocument

    if (!renderOptions.document && ownerDocument !== document) {
        renderOptions.document = ownerDocument
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i]
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions)
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode

    if (isArray(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions)

            if (domNode === rootNode) {
                rootNode = newNode
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions)

        if (domNode === rootNode) {
            rootNode = newNode
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = []

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key))
        }
    }

    return indices
}

},{"./create-element":15,"./dom-index":16,"./patch-op":17,"global/document":10,"x-is-array":12}],19:[function(require,module,exports){
var isWidget = require("../vnode/is-widget.js")

module.exports = updateWidget

function updateWidget(a, b) {
    if (isWidget(a) && isWidget(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

},{"../vnode/is-widget.js":29}],20:[function(require,module,exports){
'use strict';

var EvStore = require('ev-store');

module.exports = EvHook;

function EvHook(value) {
    if (!(this instanceof EvHook)) {
        return new EvHook(value);
    }

    this.value = value;
}

EvHook.prototype.hook = function (node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = this.value;
};

EvHook.prototype.unhook = function(node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = undefined;
};

},{"ev-store":7}],21:[function(require,module,exports){
'use strict';

module.exports = SoftSetHook;

function SoftSetHook(value) {
    if (!(this instanceof SoftSetHook)) {
        return new SoftSetHook(value);
    }

    this.value = value;
}

SoftSetHook.prototype.hook = function (node, propertyName) {
    if (node[propertyName] !== this.value) {
        node[propertyName] = this.value;
    }
};

},{}],22:[function(require,module,exports){
'use strict';

var isArray = require('x-is-array');

var VNode = require('../vnode/vnode.js');
var VText = require('../vnode/vtext.js');
var isVNode = require('../vnode/is-vnode');
var isVText = require('../vnode/is-vtext');
var isWidget = require('../vnode/is-widget');
var isHook = require('../vnode/is-vhook');
var isVThunk = require('../vnode/is-thunk');

var parseTag = require('./parse-tag.js');
var softSetHook = require('./hooks/soft-set-hook.js');
var evHook = require('./hooks/ev-hook.js');

module.exports = h;

function h(tagName, properties, children) {
    var childNodes = [];
    var tag, props, key, namespace;

    if (!children && isChildren(properties)) {
        children = properties;
        props = {};
    }

    props = props || properties || {};
    tag = parseTag(tagName, props);

    // support keys
    if (props.hasOwnProperty('key')) {
        key = props.key;
        props.key = undefined;
    }

    // support namespace
    if (props.hasOwnProperty('namespace')) {
        namespace = props.namespace;
        props.namespace = undefined;
    }

    // fix cursor bug
    if (tag === 'INPUT' &&
        !namespace &&
        props.hasOwnProperty('value') &&
        props.value !== undefined &&
        !isHook(props.value)
    ) {
        props.value = softSetHook(props.value);
    }

    transformProperties(props);

    if (children !== undefined && children !== null) {
        addChild(children, childNodes, tag, props);
    }


    return new VNode(tag, props, childNodes, key, namespace);
}

function addChild(c, childNodes, tag, props) {
    if (typeof c === 'string') {
        childNodes.push(new VText(c));
    } else if (typeof c === 'number') {
        childNodes.push(new VText(String(c)));
    } else if (isChild(c)) {
        childNodes.push(c);
    } else if (isArray(c)) {
        for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props);
        }
    } else if (c === null || c === undefined) {
        return;
    } else {
        throw UnexpectedVirtualElement({
            foreignObject: c,
            parentVnode: {
                tagName: tag,
                properties: props
            }
        });
    }
}

function transformProperties(props) {
    for (var propName in props) {
        if (props.hasOwnProperty(propName)) {
            var value = props[propName];

            if (isHook(value)) {
                continue;
            }

            if (propName.substr(0, 3) === 'ev-') {
                // add ev-foo support
                props[propName] = evHook(value);
            }
        }
    }
}

function isChild(x) {
    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
}

function isChildren(x) {
    return typeof x === 'string' || isArray(x) || isChild(x);
}

function UnexpectedVirtualElement(data) {
    var err = new Error();

    err.type = 'virtual-hyperscript.unexpected.virtual-element';
    err.message = 'Unexpected virtual child passed to h().\n' +
        'Expected a VNode / Vthunk / VWidget / string but:\n' +
        'got:\n' +
        errorString(data.foreignObject) +
        '.\n' +
        'The parent vnode is:\n' +
        errorString(data.parentVnode)
        '\n' +
        'Suggested fix: change your `h(..., [ ... ])` callsite.';
    err.foreignObject = data.foreignObject;
    err.parentVnode = data.parentVnode;

    return err;
}

function errorString(obj) {
    try {
        return JSON.stringify(obj, null, '    ');
    } catch (e) {
        return String(obj);
    }
}

},{"../vnode/is-thunk":25,"../vnode/is-vhook":26,"../vnode/is-vnode":27,"../vnode/is-vtext":28,"../vnode/is-widget":29,"../vnode/vnode.js":31,"../vnode/vtext.js":33,"./hooks/ev-hook.js":20,"./hooks/soft-set-hook.js":21,"./parse-tag.js":23,"x-is-array":12}],23:[function(require,module,exports){
'use strict';

var split = require('browser-split');

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

module.exports = parseTag;

function parseTag(tag, props) {
    if (!tag) {
        return 'DIV';
    }

    var noId = !(props.hasOwnProperty('id'));

    var tagParts = split(tag, classIdSplit);
    var tagName = null;

    if (notClassId.test(tagParts[1])) {
        tagName = 'DIV';
    }

    var classes, part, type, i;

    for (i = 0; i < tagParts.length; i++) {
        part = tagParts[i];

        if (!part) {
            continue;
        }

        type = part.charAt(0);

        if (!tagName) {
            tagName = part;
        } else if (type === '.') {
            classes = classes || [];
            classes.push(part.substring(1, part.length));
        } else if (type === '#' && noId) {
            props.id = part.substring(1, part.length);
        }
    }

    if (classes) {
        if (props.className) {
            classes.push(props.className);
        }

        props.className = classes.join(' ');
    }

    return props.namespace ? tagName : tagName.toUpperCase();
}

},{"browser-split":5}],24:[function(require,module,exports){
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")

module.exports = handleThunk

function handleThunk(a, b) {
    var renderedA = a
    var renderedB = b

    if (isThunk(b)) {
        renderedB = renderThunk(b, a)
    }

    if (isThunk(a)) {
        renderedA = renderThunk(a, null)
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous)
    }

    if (!(isVNode(renderedThunk) ||
            isVText(renderedThunk) ||
            isWidget(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

},{"./is-thunk":25,"./is-vnode":27,"./is-vtext":28,"./is-widget":29}],25:[function(require,module,exports){
module.exports = isThunk

function isThunk(t) {
    return t && t.type === "Thunk"
}

},{}],26:[function(require,module,exports){
module.exports = isHook

function isHook(hook) {
    return hook &&
      (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") ||
       typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"))
}

},{}],27:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualNode

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version
}

},{"./version":30}],28:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualText

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version
}

},{"./version":30}],29:[function(require,module,exports){
module.exports = isWidget

function isWidget(w) {
    return w && w.type === "Widget"
}

},{}],30:[function(require,module,exports){
module.exports = "2"

},{}],31:[function(require,module,exports){
var version = require("./version")
var isVNode = require("./is-vnode")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")
var isVHook = require("./is-vhook")

module.exports = VirtualNode

var noProperties = {}
var noChildren = []

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName
    this.properties = properties || noProperties
    this.children = children || noChildren
    this.key = key != null ? String(key) : undefined
    this.namespace = (typeof namespace === "string") ? namespace : null

    var count = (children && children.length) || 0
    var descendants = 0
    var hasWidgets = false
    var hasThunks = false
    var descendantHooks = false
    var hooks

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName]
            if (isVHook(property) && property.unhook) {
                if (!hooks) {
                    hooks = {}
                }

                hooks[propName] = property
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i]
        if (isVNode(child)) {
            descendants += child.count || 0

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true
            }

            if (!hasThunks && child.hasThunks) {
                hasThunks = true
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true
            }
        } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true
            }
        } else if (!hasThunks && isThunk(child)) {
            hasThunks = true;
        }
    }

    this.count = count + descendants
    this.hasWidgets = hasWidgets
    this.hasThunks = hasThunks
    this.hooks = hooks
    this.descendantHooks = descendantHooks
}

VirtualNode.prototype.version = version
VirtualNode.prototype.type = "VirtualNode"

},{"./is-thunk":25,"./is-vhook":26,"./is-vnode":27,"./is-widget":29,"./version":30}],32:[function(require,module,exports){
var version = require("./version")

VirtualPatch.NONE = 0
VirtualPatch.VTEXT = 1
VirtualPatch.VNODE = 2
VirtualPatch.WIDGET = 3
VirtualPatch.PROPS = 4
VirtualPatch.ORDER = 5
VirtualPatch.INSERT = 6
VirtualPatch.REMOVE = 7
VirtualPatch.THUNK = 8

module.exports = VirtualPatch

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type)
    this.vNode = vNode
    this.patch = patch
}

VirtualPatch.prototype.version = version
VirtualPatch.prototype.type = "VirtualPatch"

},{"./version":30}],33:[function(require,module,exports){
var version = require("./version")

module.exports = VirtualText

function VirtualText(text) {
    this.text = String(text)
}

VirtualText.prototype.version = version
VirtualText.prototype.type = "VirtualText"

},{"./version":30}],34:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook")

module.exports = diffProps

function diffProps(a, b) {
    var diff

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {}
            diff[aKey] = undefined
        }

        var aValue = a[aKey]
        var bValue = b[aKey]

        if (aValue === bValue) {
            continue
        } else if (isObject(aValue) && isObject(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
                diff = diff || {}
                diff[aKey] = bValue
            } else if (isHook(bValue)) {
                 diff = diff || {}
                 diff[aKey] = bValue
            } else {
                var objectDiff = diffProps(aValue, bValue)
                if (objectDiff) {
                    diff = diff || {}
                    diff[aKey] = objectDiff
                }
            }
        } else {
            diff = diff || {}
            diff[aKey] = bValue
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {}
            diff[bKey] = b[bKey]
        }
    }

    return diff
}

function getPrototype(value) {
  if (Object.getPrototypeOf) {
    return Object.getPrototypeOf(value)
  } else if (value.__proto__) {
    return value.__proto__
  } else if (value.constructor) {
    return value.constructor.prototype
  }
}

},{"../vnode/is-vhook":26,"is-object":11}],35:[function(require,module,exports){
var isArray = require("x-is-array")

var VPatch = require("../vnode/vpatch")
var isVNode = require("../vnode/is-vnode")
var isVText = require("../vnode/is-vtext")
var isWidget = require("../vnode/is-widget")
var isThunk = require("../vnode/is-thunk")
var handleThunk = require("../vnode/handle-thunk")

var diffProps = require("./diff-props")

module.exports = diff

function diff(a, b) {
    var patch = { a: a }
    walk(a, b, patch, 0)
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        return
    }

    var apply = patch[index]
    var applyClear = false

    if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index)
    } else if (b == null) {

        // If a is a widget we will add a remove patch for it
        // Otherwise any child widgets/hooks must be destroyed.
        // This prevents adding two remove patches for a widget.
        if (!isWidget(a)) {
            clearState(a, patch, index)
            apply = patch[index]
        }

        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties)
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch))
                }
                apply = diffChildren(a, b, patch, apply, index)
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
                applyClear = true
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
            applyClear = true
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
            applyClear = true
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
        }
    } else if (isWidget(b)) {
        if (!isWidget(a)) {
            applyClear = true
        }

        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))
    }

    if (apply) {
        patch[index] = apply
    }

    if (applyClear) {
        clearState(a, patch, index)
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children
    var orderedSet = reorder(aChildren, b.children)
    var bChildren = orderedSet.children

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i]
        var rightNode = bChildren[i]
        index += 1

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode))
            }
        } else {
            walk(leftNode, rightNode, patch, index)
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count
        }
    }

    if (orderedSet.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(
            VPatch.ORDER,
            a,
            orderedSet.moves
        ))
    }

    return apply
}

function clearState(vNode, patch, index) {
    // TODO: Make this a single walk, not two
    unhook(vNode, patch, index)
    destroyWidgets(vNode, patch, index)
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(VPatch.REMOVE, vNode, null)
            )
        }
    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
        var children = vNode.children
        var len = children.length
        for (var i = 0; i < len; i++) {
            var child = children[i]
            index += 1

            destroyWidgets(child, patch, index)

            if (isVNode(child) && child.count) {
                index += child.count
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b)
    var thunkPatch = diff(nodes.a, nodes.b)
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true
        }
    }

    return false
}

// Execute hooks when two nodes are identical
function unhook(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(
                    VPatch.PROPS,
                    vNode,
                    undefinedKeys(vNode.hooks)
                )
            )
        }

        if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children
            var len = children.length
            for (var i = 0; i < len; i++) {
                var child = children[i]
                index += 1

                unhook(child, patch, index)

                if (isVNode(child) && child.count) {
                    index += child.count
                }
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

function undefinedKeys(obj) {
    var result = {}

    for (var key in obj) {
        result[key] = undefined
    }

    return result
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {
    // O(M) time, O(M) memory
    var bChildIndex = keyIndex(bChildren)
    var bKeys = bChildIndex.keys
    var bFree = bChildIndex.free

    if (bFree.length === bChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(N) time, O(N) memory
    var aChildIndex = keyIndex(aChildren)
    var aKeys = aChildIndex.keys
    var aFree = aChildIndex.free

    if (aFree.length === aChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(MAX(N, M)) memory
    var newChildren = []

    var freeIndex = 0
    var freeCount = bFree.length
    var deletedItems = 0

    // Iterate through a and match a node in b
    // O(N) time,
    for (var i = 0 ; i < aChildren.length; i++) {
        var aItem = aChildren[i]
        var itemIndex

        if (aItem.key) {
            if (bKeys.hasOwnProperty(aItem.key)) {
                // Match up the old keys
                itemIndex = bKeys[aItem.key]
                newChildren.push(bChildren[itemIndex])

            } else {
                // Remove old keyed items
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        } else {
            // Match the item in a with the next free item in b
            if (freeIndex < freeCount) {
                itemIndex = bFree[freeIndex++]
                newChildren.push(bChildren[itemIndex])
            } else {
                // There are no free items in b to match with
                // the free items in a, so the extra free nodes
                // are deleted.
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        }
    }

    var lastFreeIndex = freeIndex >= bFree.length ?
        bChildren.length :
        bFree[freeIndex]

    // Iterate through b and append any new keys
    // O(M) time
    for (var j = 0; j < bChildren.length; j++) {
        var newItem = bChildren[j]

        if (newItem.key) {
            if (!aKeys.hasOwnProperty(newItem.key)) {
                // Add any new keyed items
                // We are adding new items to the end and then sorting them
                // in place. In future we should insert new items in place.
                newChildren.push(newItem)
            }
        } else if (j >= lastFreeIndex) {
            // Add any leftover non-keyed items
            newChildren.push(newItem)
        }
    }

    var simulate = newChildren.slice()
    var simulateIndex = 0
    var removes = []
    var inserts = []
    var simulateItem

    for (var k = 0; k < bChildren.length;) {
        var wantedItem = bChildren[k]
        simulateItem = simulate[simulateIndex]

        // remove items
        while (simulateItem === null && simulate.length) {
            removes.push(remove(simulate, simulateIndex, null))
            simulateItem = simulate[simulateIndex]
        }

        if (!simulateItem || simulateItem.key !== wantedItem.key) {
            // if we need a key in this position...
            if (wantedItem.key) {
                if (simulateItem && simulateItem.key) {
                    // if an insert doesn't put this key in place, it needs to move
                    if (bKeys[simulateItem.key] !== k + 1) {
                        removes.push(remove(simulate, simulateIndex, simulateItem.key))
                        simulateItem = simulate[simulateIndex]
                        // if the remove didn't put the wanted item in place, we need to insert it
                        if (!simulateItem || simulateItem.key !== wantedItem.key) {
                            inserts.push({key: wantedItem.key, to: k})
                        }
                        // items are matching, so skip ahead
                        else {
                            simulateIndex++
                        }
                    }
                    else {
                        inserts.push({key: wantedItem.key, to: k})
                    }
                }
                else {
                    inserts.push({key: wantedItem.key, to: k})
                }
                k++
            }
            // a key in simulate has no matching wanted key, remove it
            else if (simulateItem && simulateItem.key) {
                removes.push(remove(simulate, simulateIndex, simulateItem.key))
            }
        }
        else {
            simulateIndex++
            k++
        }
    }

    // remove all the remaining nodes from simulate
    while(simulateIndex < simulate.length) {
        simulateItem = simulate[simulateIndex]
        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))
    }

    // If the only moves we have are deletes then we can just
    // let the delete patch remove these items.
    if (removes.length === deletedItems && !inserts.length) {
        return {
            children: newChildren,
            moves: null
        }
    }

    return {
        children: newChildren,
        moves: {
            removes: removes,
            inserts: inserts
        }
    }
}

function remove(arr, index, key) {
    arr.splice(index, 1)

    return {
        from: index,
        key: key
    }
}

function keyIndex(children) {
    var keys = {}
    var free = []
    var length = children.length

    for (var i = 0; i < length; i++) {
        var child = children[i]

        if (child.key) {
            keys[child.key] = i
        } else {
            free.push(i)
        }
    }

    return {
        keys: keys,     // A hash of key name to index
        free: free      // An array of unkeyed item indices
    }
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray(apply)) {
            apply.push(patch)
        } else {
            apply = [apply, patch]
        }

        return apply
    } else {
        return patch
    }
}

},{"../vnode/handle-thunk":24,"../vnode/is-thunk":25,"../vnode/is-vnode":27,"../vnode/is-vtext":28,"../vnode/is-widget":29,"../vnode/vpatch":32,"./diff-props":34,"x-is-array":12}]},{},[4])(4)
});
Opal.loaded(["vendor/virtual-dom.js"]);
Opal.modules["virtual_dom/dom"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $const_set = Opal.const_set, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $def = Opal.def, $range = Opal.range, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,define_method,is_a?,process_tag,call,new,process_params,zero?,count,<<,to_n,pop,delete,params,end_with?,[],merge_string,gsub,merge,name,split,join,dup,===,[]=,event_callback,proc,wrap_event,to_s,one?,first');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'VirtualDOM');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $const_set($nesting[0], 'HTML_TAGS', Opal.large_array_unpack("a,abbr,address,area,article,aside,audio,b,base,bdi,bdo,big,blockquote,body,br,button,canvas,caption,cite,code,col,colgroup,data,datalist,dd,del,details,dfn,dialog,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hr,html,i,iframe,img,input,ins,kbd,keygen,label,legend,li,link,main,map,mark,menu,menuitem,meta,meter,nav,noscript,object,ol,optgroup,option,output,p,param,picture,pre,progress,q,rp,rt,ruby,s,samp,script,section,select,small,source,span,strong,style,sub,summary,sup,table,tbody,td,textarea,tfoot,th,thead,time,title,tr,track,u,ul,var,video,wbr"));
      $send($$('HTML_TAGS'), 'each', [], function $DOM$1(tag){var self = $DOM$1.$$s == null ? this : $DOM$1.$$s;

        
        if (tag == null) tag = nil;
        return $send(self, 'define_method', [tag], function $$2(params){var block = $$2.$$p || nil, self = $$2.$$s == null ? this : $$2.$$s;

          $$2.$$p = null;
          
          ;
          if (params == null) params = $hash2([], {});
          if ($truthy(params['$is_a?']($$('String')))) {
            return self.$process_tag(tag, $hash2([], {}), block, params)
          } else if ($truthy(params['$is_a?']($$('Hash')))) {
            return self.$process_tag(tag, params, block)
          } else {
            return nil
          };}, {$$arity: -1, $$s: self});}, {$$s: self});
      
      $def(self, '$process_tag', function $$process_tag(tag, params, block, children) {
        var self = this, $ret_or_1 = nil, current = nil, result = nil, vnode = nil;
        if (self.__virtual_nodes__ == null) self.__virtual_nodes__ = nil;
        if (self.__last_virtual_node__ == null) self.__last_virtual_node__ = nil;

        
        if (children == null) children = [];
        self.__virtual_nodes__ = ($truthy(($ret_or_1 = self.__virtual_nodes__)) ? ($ret_or_1) : ([]));
        if ($truthy(block)) {
          
          current = self.__virtual_nodes__;
          self.__virtual_nodes__ = [];
          result = ($truthy(($ret_or_1 = block.$call())) ? ($ret_or_1) : (children));
          vnode = $$('VirtualNode').$new(tag, self.$process_params(params), ($truthy(self.__virtual_nodes__.$count()['$zero?']()) ? (result) : (self.__virtual_nodes__)));
          self.__virtual_nodes__ = current;
        } else {
          vnode = $$('VirtualNode').$new(tag, self.$process_params(params), children)
        };
        self.__last_virtual_node__ = vnode;
        self.__virtual_nodes__['$<<'](self.__last_virtual_node__.$to_n());
        return self;
      }, -4);
      
      $def(self, '$method_missing', function $$method_missing(clazz, params) {
        var block = $$method_missing.$$p || nil, self = this, children = nil, class_params = nil, method_params = nil;
        if (self.__last_virtual_node__ == null) self.__last_virtual_node__ = nil;
        if (self.__virtual_nodes__ == null) self.__virtual_nodes__ = nil;

        $$method_missing.$$p = null;
        
        ;
        if (params == null) params = $hash2([], {});
        if (!$truthy(self.__last_virtual_node__)) {
          return nil
        };
        if (!$truthy(self.__virtual_nodes__)) {
          return nil
        };
        self.__virtual_nodes__.$pop();
        children = [];
        if ($truthy(params['$is_a?']($$('String')))) {
          
          children = [params];
          params = $hash2([], {});
        };
        class_params = self.__last_virtual_node__.$params().$delete("className");
        method_params = ($truthy(clazz['$end_with?']("!")) ? ($hash2(["id", "class"], {"id": clazz['$[]']($range(0, -2, false)), "class": self.$merge_string(class_params, params['$[]']("class"))})) : ($hash2(["class"], {"class": self.$merge_string(class_params, params['$[]']("class"), clazz.$gsub("_", "-").$gsub("--", "_"))})));
        params = self.__last_virtual_node__.$params().$merge(params).$merge(method_params);
        return self.$process_tag(self.__last_virtual_node__.$name(), params, block, children);
      }, -2);
      
      $def(self, '$merge_string', function $$merge_string($a) {
        var $post_args, params, arr = nil;

        
        $post_args = $slice(arguments);
        params = $post_args;
        arr = [];
        $send(params, 'each', [], function $$4(string){
          
          if (string == null) string = nil;
          if (!$truthy(string)) {
            return nil
          };
          return arr['$<<'](string.$split(" "));});
        return arr.$join(" ");
      }, -1);
      
      $def(self, '$process_params', function $$process_params(params) {
        var self = this;

        
        $send(params.$dup(), 'each', [], function $$5(k, v){var $a, self = $$5.$$s == null ? this : $$5.$$s, $ret_or_1 = nil;

          
          if (k == null) k = nil;
          if (v == null) v = nil;
          if ($eqeqeq("for", ($ret_or_1 = k))) {
            return ($a = ["htmlFor", params.$delete("for")], $send(params, '[]=', $a), $a[$a.length - 1])
          } else if ($eqeqeq("class", $ret_or_1)) {
            return ($a = ["className", params.$delete("class")], $send(params, '[]=', $a), $a[$a.length - 1])
          } else if ($eqeqeq("data", $ret_or_1)) {
            return ($a = ["dataset", params.$delete("data")], $send(params, '[]=', $a), $a[$a.length - 1])
          } else if ($eqeqeq("default", $ret_or_1)) {
            return ($a = ["defaultValue", params.$delete("default")], $send(params, '[]=', $a), $a[$a.length - 1])
          } else if ($eqeqeq(/^on/, $ret_or_1)) {
            return ($a = [k, self.$event_callback(v)], $send(params, '[]=', $a), $a[$a.length - 1])
          } else {
            return nil
          };}, {$$s: self});
        return params;
      });
      
      $def(self, '$event_callback', function $$event_callback(v) {
        var self = this;

        return $send(self, 'proc', [], function $$6(e){
          
          if (e == null) e = nil;
          return v.$call($$('Support').$wrap_event(e));})
      });
      
      $def(self, '$text', function $$text(string) {
        var self = this;
        if (self.__virtual_nodes__ == null) self.__virtual_nodes__ = nil;

        return self.__virtual_nodes__['$<<'](string.$to_s())
      });
      
      $def(self, '$to_vnode', function $$to_vnode() {
        var self = this;
        if (self.__virtual_nodes__ == null) self.__virtual_nodes__ = nil;

        if ($truthy(self.__virtual_nodes__['$one?']())) {
          return self.__virtual_nodes__.$first()
        } else {
          return $$('VirtualNode').$new("div", $hash2([], {}), self.__virtual_nodes__).$to_n()
        }
      });
      return $def(self, '$class_names', function $$class_names(hash) {
        var class_names = nil;

        
        class_names = [];
        $send(hash, 'each', [], function $$7(key, value){
          
          if (key == null) key = nil;
          if (value == null) value = nil;
          if ($truthy(value)) {
            return class_names['$<<'](key)
          } else {
            return nil
          };});
        return class_names.$join(" ");
      });
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["virtual_dom/virtual_node"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $def = Opal.def, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,to_n,to_s_params,to_s_children,any?,+,join,map,is_a?,to_proc');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'VirtualDOM');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'VirtualNode');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.name = $proto.params = $proto.children = nil;
      
      self.$attr_reader("name", "params", "children");
      
      $def(self, '$initialize', function $$initialize(name, params, children) {
        var self = this;

        
        if (params == null) params = $hash2([], {});
        if (children == null) children = [];
        self.name = name;
        self.params = params;
        return (self.children = children);
      }, -2);
      
      $def(self, '$to_n', function $$to_n() {
        var self = this;

        return virtualDom.h(self.name, self.params.$to_n(), self.children)
      });
      
      $def(self, '$to_s', function $$to_s() {
        var self = this;

        return "<" + (self.name) + (self.$to_s_params()) + ">" + (self.$to_s_children()) + "</" + (self.name) + ">"
      });
      
      $def(self, '$to_s_params', function $$to_s_params() {
        var self = this;

        
        if (!$truthy(self.params['$any?']())) {
          return nil
        };
        return $rb_plus(" ", $send(self.params, 'map', [], function $$1(k, v){
          
          if (k == null) k = nil;
          if (v == null) v = nil;
          return "" + (k) + "=\"" + (v) + "\"";}).$join(" "));
      });
      return $def(self, '$to_s_children', function $$to_s_children() {
        var self = this;

        
        if ($truthy(self.children['$is_a?']($$('String')))) {
          return self.children
        };
        if (!$truthy(self.children['$any?']())) {
          return nil
        };
        return $send(self.children, 'map', [], "to_s".$to_proc()).$join();
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["virtual_dom/wrapper"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $def = Opal.def, $nesting = [], nil = Opal.nil;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'VirtualDOM');

    var $nesting = [self].concat($parent_nesting);

    return (function($base) {
      var self = $module($base, 'Wrapper');

      
      
      
      $def(self, '$create', function $$create(vnode) {
        
        return virtualDom.create(vnode)
      });
      
      $def(self, '$diff', function $$diff(old, new$) {
        
        return virtualDom.diff(old, new$)
      });
      return $def(self, '$patch', function $$patch(dom, diff) {
        
        return virtualDom.patch(dom, diff)
      });
    })($nesting[0])
  })($nesting[0], $nesting)
};

Opal.modules["virtual_dom/hook"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $return_self = Opal.return_self, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,call,wrap_node,Native,call_block');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'VirtualDOM');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CommonHook');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = nil;
      
      $defs(self, '$method', function $$method(mthd) {
        var self = this;

        return $send(self, 'new', [], function $$1(node, name, previous){
          
          if (node == null) node = nil;
          if (name == null) name = nil;
          if (previous == null) previous = nil;
          return mthd.$call(node, name, previous);})
      });
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        return (self.block = block);
      });
      
      $def(self, '$to_n', $return_self);
      return $def(self, '$call_block', function $$call_block(node, name, previous) {
        var self = this;

        
        node = $$('Support').$wrap_node(node);
        name = self.$Native(name);
        previous = self.$Native(previous);
        return self.block.$call(node, name, previous);
      });
    })($nesting[0], null, $nesting);
    (function($base, $super) {
      var self = $klass($base, $super, 'Hook');

      
      
      Opal.defn(self, 'hook', function(node, name, previous) {
        var self = this;
        self.$call_block(node, name, previous);
      });
      Opal.defn(self, 'unhook', function(node, name, previous) {});
    
    })($nesting[0], $$('CommonHook'));
    return (function($base, $super) {
      var self = $klass($base, $super, 'UnHook');

      
      
      Opal.defn(self, 'unhook', function(node, name, previous) {
        var self = this;
        self.$call_block(node, name, previous);
      });
      Opal.defn(self, 'hook', function(node, name, previous) {});
    
    })($nesting[0], $$('CommonHook'));
  })($nesting[0], $nesting)
};

Opal.modules["virtual_dom/support"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('module_function,Native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'VirtualDOM');

    var $nesting = [self].concat($parent_nesting);

    return (function($base) {
      var self = $module($base, 'Support');

      
      
      self.$module_function();
      
      $def(self, '$wrap_node', function $$wrap_node(node) {
        var self = this;

        return self.$Native(node)
      });
      return $def(self, '$wrap_event', function $$wrap_event(event) {
        var self = this;

        return self.$Native(event)
      });
    })($nesting[0])
  })($nesting[0], $nesting)
};

Opal.modules["virtual_dom"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,extend');
  
  self.$require("vendor/virtual-dom");
  self.$require("virtual_dom/dom");
  self.$require("virtual_dom/virtual_node");
  self.$require("virtual_dom/wrapper");
  self.$require("virtual_dom/hook");
  self.$require("virtual_dom/support");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'VirtualDOM');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('VirtualDOM'), 'DOM'));
    return self.$extend($$$($$('VirtualDOM'), 'Wrapper'));
  })($nesting[0], $nesting);
};

Opal.modules["inesita/browser"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $const_set = Opal.const_set, $truthy = Opal.truthy, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('module_function,global,Native,call,native?,to_n');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Browser');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$module_function();
      $const_set($nesting[0], 'Window', $$('JS').$global());
      $const_set($nesting[0], 'Document', $$('Window')["document"]);
      $const_set($nesting[0], 'AddEventListener', $$('Window')["addEventListener"]);
      if ($truthy(self.$Native($$('Window')["requestAnimationFrame"]))) {
        
        $def(self, '$animation_frame', function $$animation_frame() {
          var block = $$animation_frame.$$p || nil;

          $$animation_frame.$$p = null;
          
          ;
          return $$('Window').requestAnimationFrame(block);
        })
      } else {
        
        $def(self, '$animation_frame', function $$animation_frame() {
          var block = $$animation_frame.$$p || nil;

          $$animation_frame.$$p = null;
          
          ;
          return block.$call();
        })
      };
      
      $def(self, '$ready?', function $Browser_ready$ques$1() {
        var block = $Browser_ready$ques$1.$$p || nil;

        $Browser_ready$ques$1.$$p = null;
        
        ;
        return $$('AddEventListener').$call("load", block);
      });
      
      $def(self, '$body', function $$body() {
        
        return $$('Document')["body"]
      });
      
      $def(self, '$append_child', function $$append_child(node, new_node) {
        var self = this;

        
        if (!$truthy(self['$native?'](node))) {
          node = node.$to_n()
        };
        if (!$truthy(self['$native?'](new_node))) {
          new_node = new_node.$to_n()
        };
        return node.appendChild(new_node);
      });
      return $def(self, '$query_element', function $$query_element(css) {
        
        return $$('Document').querySelector(css)
      });
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita/error"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $nesting = [], nil = Opal.nil;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return ($klass($nesting[0], $$('StandardError'), 'Error'), nil)
  })($nesting[0], $nesting)
};

Opal.modules["inesita/injection"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $return_val = Opal.return_val, $def = Opal.def, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('each,injections,define_singleton_method,attr_reader,class,include?,included_modules,[]=,with_root_component,new,raise,inject,init,animation_frame,render_if_root');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Injection');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$init', $return_val(nil));
      
      $def(self, '$with_root_component', function $$with_root_component(component) {
        var self = this;

        
        self.root_component = component;
        return self;
      });
      
      $def(self, '$inject', function $$inject() {
        var self = this;
        if (self.root_component == null) self.root_component = nil;

        
        $send(self.root_component.$injections(), 'each', [], function $$1(name, instance){var self = $$1.$$s == null ? this : $$1.$$s;

          
          if (name == null) name = nil;
          if (instance == null) instance = nil;
          return $send(self, 'define_singleton_method', [name], function $$2(){
            return instance});}, {$$s: self});
        return self;
      });
      self.$attr_reader("injections");
      
      $def(self, '$init_injections', function $$init_injections() {
        var self = this, $ret_or_1 = nil;
        if (self.injections == null) self.injections = nil;

        
        self.injections = ($truthy(($ret_or_1 = self.injections)) ? ($ret_or_1) : ($hash2([], {})));
        $send(self.$class().$injections(), 'each', [], function $$3(name, clazz){var $a, self = $$3.$$s == null ? this : $$3.$$s;
          if (self.root_component == null) self.root_component = nil;
          if (self.injections == null) self.injections = nil;

          
          if (name == null) name = nil;
          if (clazz == null) clazz = nil;
          if ($truthy(clazz.$included_modules()['$include?']($$$($$('Inesita'), 'Injection')))) {
            return ($a = [name, clazz.$new().$with_root_component(self.root_component)], $send(self.injections, '[]=', $a), $a[$a.length - 1])
          } else {
            return self.$raise($$('Error'), "Invalid " + (clazz) + " class, should mixin Inesita::Injection")
          };}, {$$s: self});
        return $send(self.injections, 'each', [], function $$4(key, instance){
          
          if (key == null) key = nil;
          if (instance == null) instance = nil;
          instance.$inject();
          return instance.$init();});
      });
      return $def(self, '$render!', function $Injection_render$excl$5() {
        var self = this;

        return $send($$('Browser'), 'animation_frame', [], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;
          if (self.root_component == null) self.root_component = nil;

          return self.root_component.$render_if_root()}, {$$s: self})
      });
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita/component/class_methods"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $def = Opal.def, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('mount_to,new,[],downcase,to_s,[]=');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Component');

      var $nesting = [self].concat($parent_nesting);

      return (function($base) {
        var self = $module($base, 'ClassMethods');

        
        
        
        $def(self, '$mount_to', function $$mount_to(element) {
          var self = this;

          return self.$new().$mount_to(element)
        });
        
        $def(self, '$inject', function $$inject(clazz, opts) {
          var $a, self = this, method_name = nil, $ret_or_1 = nil;
          if (self.injections == null) self.injections = nil;

          
          if (opts == null) opts = $hash2([], {});
          method_name = ($truthy(($ret_or_1 = opts['$[]']("as"))) ? ($ret_or_1) : (clazz.$to_s().$downcase()));
          self.injections = ($truthy(($ret_or_1 = self.injections)) ? ($ret_or_1) : ($hash2([], {})));
          return ($a = [method_name, clazz], $send(self.injections, '[]=', $a), $a[$a.length - 1]);
        }, -2);
        return $def(self, '$injections', function $$injections() {
          var self = this, $ret_or_1 = nil;
          if (self.injections == null) self.injections = nil;

          if ($truthy(($ret_or_1 = self.injections))) {
            return $ret_or_1
          } else {
            return $hash2([], {})
          }
        });
      })($nesting[0])
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita/component/virtual_dom"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('nil?,raise,class,<<,render_virtual_dom,with_props,cache_component,inject,with_root_component,is_a?,new,init,[],method');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Component');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'VirtualDom');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$component', function $$component(comp, opts) {
          var self = this, $ret_or_1 = nil;
          if (self.__virtual_nodes__ == null) self.__virtual_nodes__ = nil;

          
          if (opts == null) opts = $hash2([], {});
          if ($truthy(comp['$nil?']())) {
            self.$raise($$('Error'), "Component is nil in " + (self.$class()) + " class")
          };
          self.__virtual_nodes__ = ($truthy(($ret_or_1 = self.__virtual_nodes__)) ? ($ret_or_1) : ([]));
          self.__virtual_nodes__['$<<']($send(self, 'cache_component', [comp], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;
            if (self.root_component == null) self.root_component = nil;

            
            comp = ($truthy(comp['$is_a?']($$('Class'))) ? (comp.$new()) : (comp)).$with_root_component(self.root_component).$inject();
            comp.$init();
            return comp;}, {$$s: self}).$with_props(($truthy(($ret_or_1 = opts['$[]']("props"))) ? ($ret_or_1) : ($hash2([], {})))).$render_virtual_dom());
          return self;
        }, -2);
        
        $def(self, '$hook', function $$hook(mthd) {
          var self = this;

          return $$$($$('VirtualDOM'), 'Hook').$method(self.$method(mthd))
        });
        return $def(self, '$unhook', function $$unhook(mthd) {
          var self = this;

          return $$$($$('VirtualDOM'), 'UnHook').$method(self.$method(mthd))
        });
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita/component/render"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $def = Opal.def, $truthy = Opal.truthy, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('raise,class,render_virtual_dom,diff,patch,before_render,render,to_vnode');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Component');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Render');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$render', function $$render() {
          var self = this;

          return self.$raise($$('Error'), "Implement #render in " + (self.$class()) + " component")
        });
        
        $def(self, '$render_if_root', function $$render_if_root() {
          var self = this, new_virtual_dom = nil, diff = nil;
          if (self.root_node == null) self.root_node = nil;
          if (self.virtual_dom == null) self.virtual_dom = nil;

          
          if (!($truthy(self.virtual_dom) && ($truthy(self.root_node)))) {
            return nil
          };
          new_virtual_dom = self.$render_virtual_dom();
          diff = $$('VirtualDOM').$diff(self.virtual_dom, new_virtual_dom);
          $$('VirtualDOM').$patch(self.root_node, diff);
          return (self.virtual_dom = new_virtual_dom);
        });
        
        $def(self, '$before_render', $return_val(nil));
        return $def(self, '$render_virtual_dom', function $$render_virtual_dom() {
          var self = this;

          
          self.$before_render();
          self.cache_component_counter = 0;
          self.__virtual_nodes__ = [];
          self.$render();
          return self.$to_vnode();
        });
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita/component/cache"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $truthy = Opal.truthy, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $send = Opal.send, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('+,[],[]=,call');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Component');

      var $nesting = [self].concat($parent_nesting);

      return (function($base) {
        var self = $module($base, 'Cache');

        
        return $def(self, '$cache_component', function $$cache_component(component) {
          var block = $$cache_component.$$p || nil, $a, self = this, $ret_or_1 = nil;
          if (self.cache_component == null) self.cache_component = nil;
          if (self.cache_component_counter == null) self.cache_component_counter = nil;

          $$cache_component.$$p = null;
          
          ;
          self.cache_component = ($truthy(($ret_or_1 = self.cache_component)) ? ($ret_or_1) : ($hash2([], {})));
          self.cache_component_counter = ($truthy(($ret_or_1 = self.cache_component_counter)) ? ($ret_or_1) : (0));
          self.cache_component_counter = $rb_plus(self.cache_component_counter, 1);
          if ($truthy(($ret_or_1 = self.cache_component['$[]']("" + (component) + "-" + (self.cache_component_counter))))) {
            return $ret_or_1
          } else {
            return ($a = ["" + (component) + "-" + (self.cache_component_counter), block.$call()], $send(self.cache_component, '[]=', $a), $a[$a.length - 1])
          };
        })
      })($nesting[0])
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita/component"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $defs = Opal.defs, $truthy = Opal.truthy, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,extend,raise,class,init_injections,inject,render_virtual_dom,create,append_child,attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Component');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$include($$$($$('VirtualDOM'), 'DOM'));
      self.$include($$('VirtualDom'));
      self.$include($$('Render'));
      self.$include($$('Cache'));
      self.$include($$('Injection'));
      $defs(self, '$included', function $$included(base) {
        
        return base.$extend($$$($$$($$('Inesita'), 'Component'), 'ClassMethods'))
      });
      
      $def(self, '$mount_to', function $$mount_to(element) {
        var self = this;
        if (self.virtual_dom == null) self.virtual_dom = nil;
        if (self.root_node == null) self.root_node = nil;

        
        if (!$truthy(element)) {
          self.$raise($$('Error'), "Can't mount " + (self.$class()) + ", target element not found!")
        };
        self.root_component = self;
        self.$init_injections();
        self.$inject();
        self.virtual_dom = self.$render_virtual_dom();
        self.root_node = $$('VirtualDOM').$create(self.virtual_dom);
        $$('Browser').$append_child(element, self.root_node);
        return self;
      });
      self.$attr_reader("props");
      return $def(self, '$with_props', function $$with_props(props) {
        var self = this;

        
        self.props = props;
        return self;
      });
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("opal");
  self.$require("js");
  self.$require("console");
  self.$require("virtual_dom");
  self.$require("inesita/browser");
  self.$require("inesita/error");
  self.$require("inesita/injection");
  self.$require("inesita/component/class_methods");
  self.$require("inesita/component/virtual_dom");
  self.$require("inesita/component/render");
  self.$require("inesita/component/cache");
  return self.$require("inesita/component");
};

Opal.modules["inesita-router/browser"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $const_set = Opal.const_set, $def = Opal.def, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('module_function,decodeURIComponent,call');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Browser');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$module_function();
      $const_set($nesting[0], 'Location', $$('Document')["location"]);
      $const_set($nesting[0], 'History', $$('Window')["history"]);
      
      $def(self, '$path', function $$path() {
        
        return $$('Location')["pathname"]
      });
      
      $def(self, '$query', function $$query() {
        
        return $$('Location')["search"]
      });
      
      $def(self, '$decode_uri_component', function $$decode_uri_component(value) {
        
        return $$('JS').$decodeURIComponent(value)
      });
      
      $def(self, '$push_state', function $$push_state(path) {
        
        return $$('History').pushState($hash2([], {}), nil, path)
      });
      
      $def(self, '$on_pop_state', function $$on_pop_state() {
        var block = $$on_pop_state.$$p || nil;

        $$on_pop_state.$$p = null;
        
        ;
        return $$('Window')["onpopstate"] = block;
      });
      return $def(self, '$hash_change', function $$hash_change() {
        var block = $$hash_change.$$p || nil;

        $$hash_change.$$p = null;
        
        ;
        return $$('AddEventListener').$call("hashchange", block);
      });
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita-router/routes"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $eqeqeq = Opal.eqeqeq, $range = Opal.range, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,gsub,first,add_subroutes,to_proc,[],last,add_redirect,add_route,raise,include?,<<,merge,build_params_and_regex,validate_component,downcase,to_s,new,instance_exec,+,routes,split,empty?,each,===,join');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Routes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.parent = $proto.routes = nil;
      
      self.$attr_reader("routes");
      
      $def(self, '$initialize', function $$initialize(parent) {
        var self = this;

        
        if (parent == null) parent = nil;
        self.parent = parent;
        return (self.routes = []);
      }, -1);
      
      $def(self, '$route', function $$route($a) {
        var block = $$route.$$p || nil, $post_args, params, self = this, path = nil;

        $$route.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        params = $post_args;
        path = params.$first().$gsub(/^\//, "");
        path = ($truthy(self.parent) ? ("" + (self.parent) + "/" + (path)) : ("/" + (path)));
        if ((block !== nil)) {
          $send(self, 'add_subroutes', [path], block.$to_proc())
        };
        if ($truthy(params.$last()['$[]']("redirect_to"))) {
          return self.$add_redirect(path, params.$last()['$[]']("redirect_to"))
        } else {
          return self.$add_route(params.$last()['$[]']("as"), path, params.$last()['$[]']("to"), params.$last()['$[]']("props"), params.$last()['$[]']("on_enter"))
        };
      }, -1);
      
      $def(self, '$validate_component', function $$validate_component(component) {
        var self = this;

        
        if (!$truthy(component)) {
          self.$raise($$('Error'), "Component not exists")
        };
        if ($truthy(component['$include?']($$$($$('Inesita'), 'Component')))) {
          return nil
        } else {
          return self.$raise($$('Error'), "Invalid " + (component) + " class, should mixin Inesita::Component")
        };
      });
      
      $def(self, '$add_redirect', function $$add_redirect(path, redirect_to) {
        var self = this;

        return self.routes['$<<']($hash2(["path", "redirect_to"], {"path": path, "redirect_to": redirect_to}).$merge(self.$build_params_and_regex(path)))
      });
      
      $def(self, '$add_route', function $$add_route(name, path, component, component_props, on_enter) {
        var self = this, $ret_or_1 = nil;

        
        self.$validate_component(component);
        return self.routes['$<<']($hash2(["path", "component", "component_props", "on_enter", "name"], {"path": path, "component": component, "component_props": component_props, "on_enter": on_enter, "name": ($truthy(($ret_or_1 = name)) ? ($ret_or_1) : (component.$to_s().$gsub(/(.)([A-Z])/, "\\1_\\2").$downcase()))}).$merge(self.$build_params_and_regex(path)));
      });
      
      $def(self, '$add_subroutes', function $$add_subroutes(path) {
        var block = $$add_subroutes.$$p || nil, self = this, subroutes = nil;

        $$add_subroutes.$$p = null;
        
        ;
        subroutes = $$('Routes').$new(path);
        $send(subroutes, 'instance_exec', [], block.$to_proc());
        return (self.routes = $rb_plus(self.routes, subroutes.$routes()));
      });
      return $def(self, '$build_params_and_regex', function $$build_params_and_regex(path) {
        var regex = nil, params = nil, parts = nil;

        
        regex = ["^"];
        params = [];
        parts = path.$split("/");
        if ($truthy(parts['$empty?']())) {
          regex['$<<']("\\/")
        };
        (function(){try { var $t_break = $thrower('break'); return $send(parts, 'each', [], function $$1(part){var $ret_or_1 = nil;

          
          if (part == null) part = nil;
          if ($truthy(part['$empty?']())) {
            return nil
          };
          regex['$<<']("\\/");
          if ($eqeqeq(":", ($ret_or_1 = part['$[]'](0)))) {
            
            params['$<<'](part['$[]']($range(1, -1, false)));
            return regex['$<<']("([^\\/]+)");
          } else if ($eqeqeq("*", $ret_or_1)) {
            
            params['$<<'](part['$[]']($range(1, -1, false)));
            regex['$<<']("(.*)");
            $t_break.$throw();
          } else {
            return regex['$<<'](part)
          };})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})();
        regex['$<<']("$");
        return $hash2(["regex", "params"], {"regex": $$('Regexp').$new(regex.$join()), "params": params});
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita-router/router"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda, $eqeq = Opal.eqeq, $defs = Opal.defs, $slice = Opal.slice, $to_a = Opal.to_a, $thrower = Opal.thrower, $range = Opal.range, $to_ary = Opal.to_ary, $eqeqeq = Opal.eqeqeq, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,new,respond_to?,raise,routes,empty?,find_route,parse_url_params,add_listeners,extend,module_eval,alias_method,define_method,merge,==,[],go_to,router,pathname,target,__a,to_proc,on_pop_state,render!,hash_change,route,each,match,path,url_for,call_on_enter_callback,component,find_component,call,push_state,compotent_url_params,query,split,[]=,decode_uri_component,zip,find,===,url_with_params,params,gsub');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Inesita');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Router');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$include($$$($$('Inesita'), 'Component'));
      self.$attr_reader("params");
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;
        if (self.routes == null) self.routes = nil;

        
        self.routes = $$('Routes').$new();
        if (!$truthy(self['$respond_to?']("routes"))) {
          self.$raise($$('Error'), "Add #routes method to router!")
        };
        self.$routes();
        if ($truthy(self.routes.$routes()['$empty?']())) {
          self.$raise($$('Error'), "Add #route to your #routes method!")
        };
        self.$find_route();
        self.$parse_url_params();
        return self.$add_listeners();
      });
      $defs(self, '$included', function $$included(base) {
        var $yield = $$included.$$p || nil, self = this;

        $$included.$$p = null;
        
        base.$extend($$$($$$($$('Inesita'), 'Component'), 'ClassMethods'));
        return $send($$('Component'), 'module_eval', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

          if ($truthy(self['$respond_to?']("__a"))) {
            return nil
          } else {
            
            self.$alias_method("__a", "a");
            return $send(self, 'define_method', ["a"], function $$2(params){var block = $$2.$$p || nil, self = $$2.$$s == null ? this : $$2.$$s;

              $$2.$$p = null;
              
              ;
              if (params == null) params = $hash2([], {});
              params = $hash2(["onclick"], {"onclick": $lambda(function $$3(e){var self = $$3.$$s == null ? this : $$3.$$s;

                
                if (e == null) e = nil;
                if ($eqeq(params['$[]']("target"), "_blank")) {
                  return nil
                } else {
                  return self.$router().$go_to(e.$target().$pathname())
                };}, {$$s: self})}).$merge(params);
              return $send(self, '__a', [params], block.$to_proc());}, {$$arity: -1, $$s: self});
          }}, {$$s: self});
      });
      
      $def(self, '$add_listeners', function $$add_listeners() {
        var self = this;

        
        $send($$('Browser'), 'on_pop_state', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          
          self.$find_route();
          self.$parse_url_params();
          return self['$render!']();}, {$$s: self});
        return $send($$('Browser'), 'hash_change', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

          
          self.$find_route();
          self.$parse_url_params();
          return self['$render!']();}, {$$s: self});
      });
      
      $def(self, '$route', function $$route($a) {
        var block = $$route.$$p || nil, $post_args, params, self = this;
        if (self.routes == null) self.routes = nil;

        $$route.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        params = $post_args;
        return $send(self.routes, 'route', $to_a(params), block.$to_proc());
      }, -1);
      
      $def(self, '$find_route', function $$find_route() {try { var $t_return = $thrower('return'); 
        var self = this;
        if (self.routes == null) self.routes = nil;

        
        $send(self.routes.$routes(), 'each', [], function $$6(route){var self = $$6.$$s == null ? this : $$6.$$s;

          
          if (route == null) route = nil;
          if (!$truthy(self.$path().$match(route['$[]']("regex")))) {
            return nil
          };
          if ($truthy(route['$[]']("redirect_to"))) {
            $t_return.$throw(self.$go_to(self.$url_for(route['$[]']("redirect_to"))))
          };
          $t_return.$throw((self.route = route));}, {$$s: self, $$ret: $t_return});
        return self.$raise($$('Error'), "Can't find route for url");} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        }
      });
      
      $def(self, '$find_component', function $$find_component(route) {
        var self = this;

        
        self.$call_on_enter_callback(route);
        self.component_props = route['$[]']("component_props");
        return route['$[]']("component");
      });
      
      $def(self, '$render', function $$render() {
        var self = this;
        if (self.route == null) self.route = nil;
        if (self.component_props == null) self.component_props = nil;

        if ($truthy(self.route)) {
          return self.$component(self.$find_component(self.route), $hash2(["props"], {"props": self.component_props}))
        } else {
          return nil
        }
      });
      
      $def(self, '$call_on_enter_callback', function $$call_on_enter_callback(route) {
        
        
        if (!$truthy(route['$[]']("on_enter"))) {
          return nil
        };
        if ($truthy(route['$[]']("on_enter")['$respond_to?']("call"))) {
          return route['$[]']("on_enter").$call()
        } else {
          return nil
        };
      });
      
      $def(self, '$go_to', function $$go_to(path) {
        var self = this;

        
        $$('Browser').$push_state(path);
        self.$find_route();
        self.$parse_url_params();
        self['$render!']();
        return false;
      });
      
      $def(self, '$parse_url_params', function $$parse_url_params() {
        var self = this;

        
        self.params = self.$compotent_url_params();
        if ($truthy(self.$query()['$empty?']())) {
          return nil
        } else {
          return $send(self.$query()['$[]']($range(1, -1, false)).$split("&"), 'each', [], function $$7(param){var $a, $b, self = $$7.$$s == null ? this : $$7.$$s, key = nil, value = nil;
            if (self.params == null) self.params = nil;

            
            if (param == null) param = nil;
            $b = param.$split("="), $a = $to_ary($b), (key = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $b;
            return ($a = [$$('Browser').$decode_uri_component(key), $$('Browser').$decode_uri_component(value)], $send(self.params, '[]=', $a), $a[$a.length - 1]);}, {$$s: self})
        };
      });
      
      $def(self, '$compotent_url_params', function $$compotent_url_params() {
        var self = this;
        if (self.route == null) self.route = nil;

        return $$('Hash')['$[]'](self.route['$[]']("params").$zip(self.$path().$match(self.route['$[]']("regex"))['$[]']($range(1, -1, false))))
      });
      
      $def(self, '$url_for', function $$url_for(name, params) {
        var self = this, route = nil;
        if (self.routes == null) self.routes = nil;

        
        if (params == null) params = nil;
        route = $send(self.routes.$routes(), 'find', [], function $$8(r){var $ret_or_1 = nil, $ret_or_2 = nil;

          
          if (r == null) r = nil;
          if ($eqeqeq($$('String'), ($ret_or_1 = name))) {
            if ($truthy(($ret_or_2 = r['$[]']("name")['$=='](name)))) {
              return $ret_or_2
            } else {
              return r['$[]']("path")['$=='](name)
            }
          } else if ($eqeqeq($$('Object'), $ret_or_1)) {
            return r['$[]']("component")['$=='](name)
          } else {
            return false
          };});
        if ($truthy(route)) {
          return self.$url_with_params(route, params)
        } else {
          return self.$raise($$('Error'), "Route '" + (name) + "' not found.")
        };
      }, -2);
      
      $def(self, '$query', function $$query() {
        
        return $$('Browser').$query()
      });
      
      $def(self, '$path', function $$path() {
        
        return $$('Browser').$path()
      });
      
      $def(self, '$current_url?', function $Router_current_url$ques$9(name) {
        var self = this;

        return self.$path()['$=='](self.$url_for(name, self.$params()))
      });
      return $def(self, '$url_with_params', function $$url_with_params(route, params) {
        var path = nil;

        
        path = route['$[]']("path");
        if ($truthy(params)) {
          $send(params, 'each', [], function $$10(key, value){
            
            if (key == null) key = nil;
            if (value == null) value = nil;
            return (path = path.$gsub(":" + (key), "" + (value)));})
        };
        return path;
      });
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["inesita-router"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("inesita-router/browser");
  self.$require("inesita-router/routes");
  return self.$require("inesita-router/router");
};

Opal.modules["router"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $hash2 = Opal.hash2, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,route');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Router');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Router'));
    return $def(self, '$routes', function $$routes() {
      var self = this;

      
      self.$route("/", $hash2(["to"], {"to": $$('About')}));
      self.$route("/help", $hash2(["to"], {"to": $$('Help')}));
      self.$route("/disc", $hash2(["to"], {"to": $$('Disc')}));
      self.$route("/examples", $hash2(["to"], {"to": $$('Examples')}));
      self.$route("/roadmap", $hash2(["to"], {"to": $$('Roadmap')}));
      return self.$route("/patreons", $hash2(["to"], {"to": $$('Patreons')}));
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["store"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_accessor,fetch_commnads,fetch_programs,each,storage_length,storage_key,end_with?,storage_value,<<,[],Native,filename,!,nil?,upcase');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Store');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Injection'));
    self.$attr_accessor("commands", "programs");
    $const_set($nesting[0], 'BAS_EXT', ".BAS");
    
    $def(self, '$commands', function $$commands() {
      
      return $$$($$('Commands'), 'COMMANDS')
    });
    
    $def(self, '$examples', function $$examples() {
      
      return $$$($$('Examples'), 'EXAMPLES')
    });
    
    $def(self, '$init', function $$init() {
      var self = this;

      
      self.$fetch_commnads();
      return self.$fetch_programs();
    });
    
    $def(self, '$fetch_commnads', function $$fetch_commnads() {
      var self = this;

      return (self.commands = [])
    });
    
    $def(self, '$fetch_programs', function $$fetch_programs() {
      var self = this;

      
      self.programs = [];
      return $send(Opal.Range.$new(0,self.$storage_length(), true), 'each', [], function $$1(i){var self = $$1.$$s == null ? this : $$1.$$s, name = nil, code = nil;
        if (self.programs == null) self.programs = nil;

        
        if (i == null) i = nil;
        name = self.$storage_key(i);
        if ($truthy(name['$end_with?']($$('BAS_EXT')))) {
          
          code = self.$storage_value(i);
          return self.programs['$<<']($hash2(["id", "name", "code", "show"], {"id": i, "name": name['$[]']($range(0, -5, false)), "code": code, "show": false}));
        } else {
          return nil
        };}, {$$s: self});
    });
    
    $def(self, '$storage_length', function $$storage_length() {
      
      return localStorage.length;
    });
    
    $def(self, '$storage_key', function $$storage_key(i) {
      var self = this;

      return self.$Native(localStorage.key(i))
    });
    
    $def(self, '$storage_value', function $$storage_value(i) {
      var self = this;

      return self.$Native(localStorage.getItem(localStorage.key(i)))
    });
    
    $def(self, '$exist?', function $Store_exist$ques$2(name) {
      var self = this;

      
      name = self.$filename(name);
      return self.$Native(localStorage.getItem(name))['$nil?']()['$!']();
    });
    
    $def(self, '$copy_program', function $$copy_program(name, code) {
      var self = this;

      
      name = self.$filename(name);
      return localStorage.setItem(name, code);;
    });
    return $def(self, '$filename', function $$filename(name) {
      
      return (("" + (name)) + ($$('BAS_EXT'))).$upcase()
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["components/about"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $return_val = Opal.return_val, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,h3,p,a,img,span,url_for,router,social,div');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'About');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    return $def(self, '$render', function $$render() {
      var self = this;

      
      self.$h3("What is this?");
      $send(self, 'p', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

        
        $send(self, 'p', [$hash2(["class"], {"class": "image"})], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          return $send(self, 'a', [$hash2(["href"], {"href": "/fazic"})], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

            return self.$img($hash2(["src"], {"src": "/static/images/fazic.jpg"}))}, {$$s: self})}, {$$s: self});
        $send(self, 'a', [$hash2(["href"], {"href": "/fazic"})], $return_val("FAZIC "));
        return self.$span("is a fantasy retro computer. You can create, share, and play tiny games or programs. You have the built-in BASIC interpreter, so you can start now like it's the 80s.");}, {$$s: self});
      $send(self, 'a', [$hash2(["href"], {"href": "/fazic"})], $return_val("CLICK HERE TO START"));
      self.$h3("What now?");
      $send(self, 'p', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

        
        self.$span("When you will see READY prompt it's time to write your first basic program. Don't know basic? Go to");
        $send(self, 'a', [$hash2(["href"], {"href": self.$router().$url_for("help")})], $return_val(" HELP "));
        return self.$span("section. You'll see how to write your first basic program, available commands, and everything you need to start.");}, {$$s: self});
      $send(self, 'a', [$hash2(["href"], {"href": self.$router().$url_for("help")})], $return_val("I NEED HELP"));
      self.$h3("Can I save or load my programs?");
      $send(self, 'p', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

        
        self.$span("Yes. Any time you want. Just type SAVE \"NAME\" and thats it. You can go to");
        $send(self, 'a', [$hash2(["href"], {"href": self.$router().$url_for("disc")})], $return_val(" DISC "));
        return self.$span("section to see you programs or copy them. Of course you can load them by typing LOAD \"NAME\".");}, {$$s: self});
      $send(self, 'a', [$hash2(["href"], {"href": self.$router().$url_for("disc")})], $return_val("SHOW MY FLOPPY DISC"));
      self.$h3("Is it everything?");
      $send(self, 'p', [], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

        
        self.$span("No. If you want to see what is planned go to");
        $send(self, 'a', [$hash2(["href"], {"href": self.$router().$url_for("roadmap")})], $return_val(" ROADMAP "));
        return self.$span("section. You'll find there all things that will happen in the future. ");}, {$$s: self});
      $send(self, 'a', [$hash2(["href"], {"href": self.$router().$url_for("roadmap")})], $return_val("SHOW ME THE ROADMAP"));
      self.$h3("How can I thank you?");
      $send(self, 'p', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        
        self.$span("If you like it, check");
        $send(self, 'a', [$hash2(["href"], {"href": self.$router().$url_for("roadmap")})], $return_val(" PATREONS "));
        return self.$span("section now. Or follow us on twitter!");}, {$$s: self});
      $send(self.$div(), 'social', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

        
        self.$a($hash2(["class", "href"], {"class": "fa fa-twitter", "href": "https://twitter.com/fazic1"}));
        $send(self, 'a', [$hash2(["class", "href"], {"class": "bold", "href": "https://www.patreon.com/fazic"})], $return_val("P"));
        $send(self, 'a', [$hash2(["class", "href"], {"class": "bold", "href": "https://fazibear.itch.io/fazic"})], $return_val("i"));
        return self.$a($hash2(["class", "href"], {"class": "fa fa-github", "href": "https://github.com/fazibear/fazic"}));}, {$$s: self});
      self.$h3("Found a bug?");
      return $send(self, 'p', [], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

        
        self.$span("That great, please report it into ");
        $send(self, 'a', [$hash2(["href"], {"href": "https://github.com/fazibear/fazic/issues"})], $return_val("github issue tracker"));
        return self.$span(". Thanks!");}, {$$s: self});
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["components/disc"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,[]=,!,[],render!,to_n,h3,any?,programs,store,p,ul,each,program,li,a,toggle,pre,span,url_for,router,current_url?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Disc');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    
    $def(self, '$toggle', function $$toggle(program) {
      var self = this;

      
      program['$[]=']("show", program['$[]']("show")['$!']());
      return self['$render!']();
    });
    
    $def(self, '$go_to_program', function $$go_to_program(name) {
      
      
      name = (("program_") + (name)).$to_n();
      return window.location.hash = name;
    });
    return $def(self, '$render', function $$render() {
      var self = this;

      
      self.$h3("Your private floppy disc");
      if ($truthy(self.$store().$programs()['$any?']())) {
        
        self.$p("List of all your saved programs. Click to show the code.");
        return $send(self.$ul(), 'programs', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

          return $send(self.$store().$programs(), 'each', [], function $$2(program){var self = $$2.$$s == null ? this : $$2.$$s;

            
            if (program == null) program = nil;
            return $send(self.$li(), 'program', [$hash2(["id"], {"id": "program_" + (program['$[]']("id"))})], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

              
              $send(self, 'a', [$hash2(["href", "onclick"], {"href": "#", "onclick": $lambda(function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

                return self.$toggle(program)}, {$$s: self})})], function $$5(){
                return program['$[]']("name")});
              if ($truthy(program['$[]']("show"))) {
                return self.$pre(program['$[]']("code"))
              } else {
                return nil
              };}, {$$s: self});}, {$$s: self})}, {$$s: self});
      } else {
        return $send(self, 'p', [], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

          
          self.$span("You don't have any programs. You can copy from ");
          $send(self, 'a', [$hash2(["href", "class"], {"href": self.$router().$url_for("examples"), "class": "" + (($truthy(self.$router()['$current_url?']("examples")) ? ("active") : nil))})], $return_val("EXAMPLES"));
          return self.$span(" section, or save you own using save command!");}, {$$s: self})
      };
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["components/examples"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,copy_program,store,[],fetch_programs,render!,h3,p,examples,ul,each,command,li,a,copy,exist?,name,span,description,div,pre');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Examples');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    
    $def(self, '$copy', function $$copy(program) {
      var self = this;

      
      self.$store().$copy_program(program['$[]']("name"), program['$[]']("code"));
      self.$store().$fetch_programs();
      self['$render!']();
      return false;
    });
    return $def(self, '$render', function $$render() {
      var self = this;

      
      self.$h3("Program Examples");
      self.$p("If you want to try few programs, on this page, you can find some of basic programs. Click disc icon to copy into your disc.");
      return $send(self.$ul(), 'examples', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

        return $send(self.$store().$examples(), 'each', [], function $$2(program){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (program == null) program = nil;
          return $send(self.$li(), 'command', [$hash2(["id"], {"id": "program_" + (program['$[]']("name"))})], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

            
            $send(self, 'a', [$hash2(["class", "href", "onclick"], {"class": "copy", "href": "#", "onclick": $lambda(function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

              return self.$copy(program)}, {$$s: self})})], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

              if ($truthy(self.$store()['$exist?'](program['$[]']("name")))) {
                return "✅"
              } else {
                return "💾"
              }}, {$$s: self});
            self.$span().$name(program['$[]']("name"));
            self.$div().$description(program['$[]']("description"));
            return self.$pre(program['$[]']("code"));}, {$$s: self});}, {$$s: self})}, {$$s: self});
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["components/footer"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,footer');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Footer');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    return $def(self, '$render', function $$render() {
      var self = this;

      return self.$footer("Copyright Michal Kalbarczyk ® 2018")
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["components/help"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,h3,p,commands_toc,ul,each,commands,store,command,li,a,to_n,[],name,div,description,pre');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Help');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    return $def(self, '$render', function $$render() {
      var self = this;

      
      self.$h3("Available Commands");
      self.$p("List of all commands with example that are supported.");
      $send(self.$ul(), 'commands_toc', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

        return $send(self.$store().$commands(), 'each', [], function $$2(command){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (command == null) command = nil;
          return $send(self.$li(), 'command', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

            return $send(self, 'a', [$hash2(["href", "onclick"], {"href": "#", "onclick": $lambda(function $$4(){
              
              window.location.hash = "command_" + (command['$[]']("name").$to_n());
              return false;})})], function $$5(){
              return command['$[]']("name")})}, {$$s: self});}, {$$s: self})}, {$$s: self});
      return $send(self.$ul(), 'commands', [], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

        return $send(self.$store().$commands(), 'each', [], function $$7(command){var self = $$7.$$s == null ? this : $$7.$$s;

          
          if (command == null) command = nil;
          return $send(self.$li(), 'command', [$hash2(["id"], {"id": "command_" + (command['$[]']("name"))})], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

            
            self.$div().$name(command['$[]']("name"));
            self.$div().$description(command['$[]']("description"));
            return self.$pre(command['$[]']("code"));}, {$$s: self});}, {$$s: self})}, {$$s: self});
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["components/navbar"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $return_val = Opal.return_val, $truthy = Opal.truthy, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,nav,ul,li,a,url_for,router,current_url?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NavBar');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    return $def(self, '$render', function $$render() {
      var self = this;

      return $send(self, 'nav', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

        return $send(self, 'ul', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          
          $send(self, 'li', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

            return $send(self, 'a', [$hash2(["href"], {"href": "/fazic"})], $return_val("Fazic"))}, {$$s: self});
          $send(self, 'li', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            return $send(self, 'a', [$hash2(["href", "class"], {"href": self.$router().$url_for("disc"), "class": "" + (($truthy(self.$router()['$current_url?']("disc")) ? ("active") : nil))})], $return_val("Disc"))}, {$$s: self});
          $send(self, 'li', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

            return $send(self, 'a', [$hash2(["href", "class"], {"href": self.$router().$url_for("examples"), "class": "" + (($truthy(self.$router()['$current_url?']("examples")) ? ("active") : nil))})], $return_val("Examples"))}, {$$s: self});
          $send(self, 'li', [], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

            return $send(self, 'a', [$hash2(["href", "class"], {"href": self.$router().$url_for("about"), "class": "" + (($truthy(self.$router()['$current_url?']("about")) ? ("active") : nil))})], $return_val("About"))}, {$$s: self});
          $send(self, 'li', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

            return $send(self, 'a', [$hash2(["href", "class"], {"href": self.$router().$url_for("help"), "class": "" + (($truthy(self.$router()['$current_url?']("help")) ? ("active") : nil))})], $return_val("Help"))}, {$$s: self});
          $send(self, 'li', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

            return $send(self, 'a', [$hash2(["href", "class"], {"href": self.$router().$url_for("roadmap"), "class": "" + (($truthy(self.$router()['$current_url?']("roadmap")) ? ("active") : nil))})], $return_val("Roadmap"))}, {$$s: self});
          return $send(self, 'li', [], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

            return $send(self, 'a', [$hash2(["href", "class"], {"href": self.$router().$url_for("patreons"), "class": "" + (($truthy(self.$router()['$current_url?']("patreons")) ? ("active") : nil))})], $return_val("Patreons"))}, {$$s: self});}, {$$s: self})}, {$$s: self})
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["components/patreons"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $return_val = Opal.return_val, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,h3,p,a');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Patreons');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    return $def(self, '$render', function $$render() {
      var self = this;

      
      self.$h3("Patreon");
      self.$p("If you like it. Want more. You can support me on patreon!");
      $send(self, 'a', [$hash2(["href"], {"href": "https://www.patreon.com/fazibear"})], $return_val("https://www.patreon.com/fazibear"));
      self.$p("Thanks!");
      self.$h3("itch.io");
      self.$p("You can also check out itch.io page.");
      $send(self, 'a', [$hash2(["href"], {"href": "https://fazibear.itch.io/fazic"})], $return_val("https://fazibear.itch.io/fazic"));
      self.$p("Thanks!");
      return self.$h3("Who support this project?");
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["components/roadmap"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $send = Opal.send, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,h3,h4,ul,li');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Roadmap');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    return $def(self, '$render', function $$render() {
      var self = this;

      
      self.$h3("Things to do!");
      self.$h4("BASIC");
      $send(self, 'ul', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

        
        self.$li("PET ASCII Support");
        self.$li("User Input Commands");
        self.$li("Graphic Commands");
        self.$li("Sprites Support");
        self.$li("Sound");
        self.$li("Arrays Support");
        self.$li("Hashes Support");
        return self.$li("Networking Support");}, {$$s: self});
      self.$h4("Infrastructure");
      $send(self, 'ul', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        
        self.$li("Upload you programs");
        self.$li("Save programs in the cloud");
        self.$li("Share programs with other clients");
        self.$li("Share programs with other users");
        return self.$li("Load other users programs");}, {$$s: self});
      self.$h4("Native clients");
      return $send(self, 'ul', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

        
        self.$li("OSX");
        self.$li("Windows");
        self.$li("Linux");
        self.$li("iOS");
        return self.$li("Android");}, {$$s: self});
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["components/stripes"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $send = Opal.send, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,stripes,div,s1l,s2l,s3l,s3r,s2r,s1r');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Stripes');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    return $def(self, '$render', function $$render() {
      var self = this;

      return $send(self.$div(), 'stripes', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

        
        self.$div().$s1l("");
        self.$div().$s2l("");
        self.$div().$s3l("");
        self.$div().$s3r("");
        self.$div().$s2r("");
        return self.$div().$s1r("");}, {$$s: self})
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["store/commands"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $module = Opal.module, $const_set = Opal.const_set, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Store');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Commands');

      var $nesting = [self].concat($parent_nesting);

      return $const_set($nesting[0], 'COMMANDS', [$hash2(["name", "description", "code"], {"name": "ABS", "description": "Evaluates to the absolute value (value without the sign) of the given numeric term.", "code": "PRINT ABS(-10)\n10"}), $hash2(["name", "description", "code"], {"name": "AND", "description": "Boolean AND or bitwise AND operation depending on arguments", "code": "PRINT 3>2 AND 5<6\ntrue\nPRINT 199 AND 64\n64"}), $hash2(["name", "description", "code"], {"name": "ASC", "description": "Evaluates the first char of a string as a numeric index.", "code": "PRINT ASC(\"A\")\n65"}), $hash2(["name", "description", "code"], {"name": "ATN", "description": "A mathematical function that returns the arc tangent of a numeric value (the inverse function of TAN). The resulting value is the angle in radians of the given tangent.", "code": "PRINT ATN(1)\n0.7854"}), $hash2(["name", "description", "code"], {"name": "CHR", "description": "Can be used to convert a number between 0 and 255 into an ASCII-char and is the inverse of the function ASC.", "code": "PRINT CHR(49)\n1"}), $hash2(["name", "description", "code"], {"name": "CLR", "description": "Deletes all variables.", "code": "A=10\nPRINT A\n10\nCLR\nPRINT A\nnull"}), $hash2(["name", "description", "code"], {"name": "COS", "description": "Is a mathematical function which evaluates to the cosine for a given angle, a number regarded as being in radians.", "code": "PRINT COS(0)\n1.0000"}), $hash2(["name", "description", "code"], {"name": "DOT", "description": "Drapws a pixel on x, y position", "code": "DOT 1,5"}), $hash2(["name", "description", "code"], {"name": "END", "description": "Ends a BASIC-program and the BASIC-Interpreter writes READY. ", "code": "10 PRINT \"START\"\n20 END\n30 PRINT \"NEVER HAPPENED\""}), $hash2(["name", "description", "code"], {"name": "EXP", "description": "Is a mathemathical function that evaluates the inverse natural LOG of the argument.", "code": "PRINT EXP(1)\n2.7183"}), $hash2(["name", "description", "code"], {"name": "FLIP", "description": "When MODE 1 is used, draw current screen buffer", "code": "FLIP"}), $hash2(["name", "description", "code"], {"name": "FOR", "description": "is the start command of a FOR…TO…STEP…NEXT loop. This FOR...NEXT loop is executed until counter variable equals the value in the TO clause. With the step-size-number, the counter variable value is either increased (positive) or decreased (negative). When the STEP command isn't used then the step-size-number defaults to 1.", "code": "FOR X=1 TO 5:PRINT X:NEXT\n1\n2\n3\n4\n5"}), $hash2(["name", "description", "code"], {"name": "GOSUB", "description": "Jumps to a subroutine at the indicated line number. The subroutine finalizes using a RETURN command.", "code": "10 GOSUB 40\n20 PRINT \"HELLO\"\n30 END\n40 PRINT \"HELLO GOSUB\"\n50 RETURN"}), $hash2(["name", "description", "code"], {"name": "GOTO", "description": "Makes the BASIC interpreter jump to the indicated line and the execution of the BASIC program is continued at that line.", "code": "10 PRINT \"HELLO\"\n20 GOTO 10"}), $hash2(["name", "description", "code"], {"name": "IF", "description": "Is used together with the BASIC command THEN or with the BASIC command GOTO by condition.", "code": "IF A>0 THEN PRINT \"A is positive\""}), $hash2(["name", "description", "code"], {"name": "INT", "description": "Is used to round numbers, whereas rounding is different from its common mathematical definition.", "code": "PRINT INT(1.53)\n1"}), $hash2(["name", "description", "code"], {"name": "LEN", "description": "Views the number of all chars in a string.", "code": "PRINT LEN(\"just and example\")\n16"}), $hash2(["name", "description", "code"], {"name": "LET", "description": "Is for assign numerical values or chars in the right type of variable. Assignment of variables can also be done without LET.", "code": "LET A=\"TEST\"\nB=\"COMMODORE\""}), $hash2(["name", "description", "code"], {"name": "LIST", "description": "Displays the BASIC program currently in memory.", "code": "LIST"}), $hash2(["name", "description", "code"], {"name": "LOAD", "description": "Load a program into memory", "code": "LOAD \"MYPROG\""}), $hash2(["name", "description", "code"], {"name": "LOG", "description": "Is a natural logarithm with the basis e(E).", "code": "PRINT LOG(1)\n0"}), $hash2(["name", "description", "code"], {"name": "MODE", "description": "Sets display mode: 0 - text mode, 1 - Graphic mode with frame buffer, use FLIP to show, 2 - Graphic direct mode", "code": "MODE 1"}), $hash2(["name", "description", "code"], {"name": "NEXT", "description": "Is used with the BASIC-Command FOR.", "code": ""}), $hash2(["name", "description", "code"], {"name": "NOT", "description": "Reverse the boolean true into false.", "code": ""}), $hash2(["name", "description", "code"], {"name": "OR", "description": "Boolean OR or bitwise OR operation depending on arguments", "code": "PRINT 3<2 OR 5<6\ntrue\nPRINT 0 OR 0\n0"}), $hash2(["name", "description", "code"], {"name": "PRINT", "description": "Is used to print data onto the screen.", "code": "PRINT 12+2\n14"}), $hash2(["name", "description", "code"], {"name": "REM", "description": "Is used to place remarks into BASIC-programs.", "code": "10 REM NICE COMMENT"}), $hash2(["name", "description", "code"], {"name": "RETURN", "description": "Finishes a subroutine, which is called with the BASIC-command GOSUB.", "code": ""}), $hash2(["name", "description", "code"], {"name": "RUN", "description": "Starts a BASIC program.", "code": "RUN"}), $hash2(["name", "description", "code"], {"name": "SAVE", "description": "Save current program", "code": "SAVE"}), $hash2(["name", "description", "code"], {"name": "SGN", "description": "Gives autonomous of the algebraic sign the number (-1; 0; 1) of a numerical argument.", "code": "PRINT SGN(-11)\n-1"}), $hash2(["name", "description", "code"], {"name": "SIN", "description": "Is a mathematical function which evaluates to the sine for a given angle, a number regarded as being in radians.", "code": "PRINT SIN(1)"}), $hash2(["name", "description", "code"], {"name": "SQR", "description": " Is a mathemathical function for square root of a number.", "code": "PRINT SQL(4)\n2"}), $hash2(["name", "description", "code"], {"name": "STOP", "description": "Breaks a program.", "code": "STOP"}), $hash2(["name", "description", "code"], {"name": "STR", "description": "Is for converting numerical values or varibales into a string.", "code": "PRINT STR(12)\n12"}), $hash2(["name", "description", "code"], {"name": "TAN", "description": "Is a mathematical function which evaluates to the tangent for a given angle, a number regarded as being in radians.", "code": "PRINT TAN(1)"}), $hash2(["name", "description", "code"], {"name": "VAL", "description": "Finds a numerical value in a string.", "code": "PRINT VAL(\"10\")\n10"})])
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["store/examples"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $module = Opal.module, $const_set = Opal.const_set, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Store');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Examples');

      var $nesting = [self].concat($parent_nesting);

      return $const_set($nesting[0], 'EXAMPLES', [$hash2(["name", "description", "code"], {"name": "HELLO", "description": "Simple 'hello world' basic program", "code": "10 PRINT \"Hello\"\n" + "20 GOTO 10\n"}), $hash2(["name", "description", "code"], {"name": "COLORS", "description": "Fill all screen with pixel and show it.", "code": "5 mode 1\n" + "10 for c=0 to 15\n" + "20 for y=0 to 240\n" + "30 for x=0 to 320\n" + "40 dot x,y\n" + "50 next\n" + "60 next\n" + "70 flip\n" + "80 color c\n" + "90 next\n"})])
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

Opal.queue(function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $return_val = Opal.return_val, $def = Opal.def, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,require_tree,include,inject,component,container,div,content,h1,h2,social,a,router,ready?,mount_to,body');
  
  self.$require("inesita");
  self.$require("inesita-router");
  self.$require("router");
  self.$require("store");
  self.$require_tree("components");
  self.$require_tree("store");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Application');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$('Inesita'), 'Component'));
    self.$inject($$('Router'));
    self.$inject($$('Store'));
    return $def(self, '$render', function $$render() {
      var self = this;

      
      self.$component($$('NavBar'));
      $send(self.$div(), 'container', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

        
        self.$component($$('Stripes'));
        return $send(self.$div(), 'content', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          
          self.$h1("FAZIC");
          self.$h2("fantasy retro computer");
          $send(self.$div(), 'social', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

            
            self.$a($hash2(["class", "href"], {"class": "fa fa-twitter", "href": "https://twitter.com/fazic1"}));
            $send(self, 'a', [$hash2(["class", "href"], {"class": "bold", "href": "https://www.patreon.com/fazibear"})], $return_val("P"));
            $send(self, 'a', [$hash2(["class", "href"], {"class": "bold", "href": "https://fazibear.itch.io/fazic"})], $return_val("i"));
            return self.$a($hash2(["class", "href"], {"class": "fa fa-github", "href": "https://github.com/fazibear/fazic"}));}, {$$s: self});
          return self.$component(self.$router());}, {$$s: self});}, {$$s: self});
      return self.$component($$('Footer'));
    });
  })($nesting[0], null, $nesting);
  return $send($$$($$('Inesita'), 'Browser'), 'ready?', [], function $$4(){
    return $$('Application').$mount_to($$$($$('Inesita'), 'Browser').$body())});
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKGdsb2JhbF9vYmplY3QuY29uc29sZSA9PSBudWxsKSB7XG4gICAgZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuY29uc29sZSkgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbF9vYmplY3QuY29uc29sZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlID0ge307XG4gIH1cblxuICBpZiAoISgnbG9nJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uICgpIHt9OyB9XG4gIGlmICghKCd3YXJuJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLndhcm4gPSBjb25zb2xlLmxvZzsgfVxuXG4gIGlmICh0eXBlb2YoZ2xvYmFsX29iamVjdC5PcGFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ09wYWwgYWxyZWFkeSBsb2FkZWQuIExvYWRpbmcgdHdpY2UgY2FuIGNhdXNlIHRyb3VibGVzLCBwbGVhc2UgZml4IHlvdXIgc2V0dXAuJyk7XG4gICAgcmV0dXJuIGdsb2JhbF9vYmplY3QuT3BhbDtcbiAgfVxuXG4gIHZhciBuaWw7XG5cbiAgLy8gVGhlIGFjdHVhbCBjbGFzcyBmb3IgQmFzaWNPYmplY3RcbiAgdmFyIEJhc2ljT2JqZWN0O1xuXG4gIC8vIFRoZSBhY3R1YWwgT2JqZWN0IGNsYXNzLlxuICAvLyBUaGUgbGVhZGluZyB1bmRlcnNjb3JlIGlzIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoIHdpbmRvdy5PYmplY3QoKVxuICB2YXIgX09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE1vZHVsZSBjbGFzc1xuICB2YXIgTW9kdWxlO1xuXG4gIC8vIFRoZSBhY3R1YWwgQ2xhc3MgY2xhc3NcbiAgdmFyIENsYXNzO1xuXG4gIC8vIFRoZSBPcGFsLk9wYWwgY2xhc3MgKGhlbHBlcnMgZXRjLilcbiAgdmFyIF9PcGFsO1xuXG4gIC8vIFRoZSBLZXJuZWwgbW9kdWxlXG4gIHZhciBLZXJuZWw7XG5cbiAgLy8gVGhlIE9wYWwgb2JqZWN0IHRoYXQgaXMgZXhwb3NlZCBnbG9iYWxseVxuICB2YXIgT3BhbCA9IGdsb2JhbF9vYmplY3QuT3BhbCA9IHt9O1xuXG4gIC8vIFRoaXMgaXMgYSB1c2VmdWwgcmVmZXJlbmNlIHRvIGdsb2JhbCBvYmplY3QgaW5zaWRlIHJ1YnkgZmlsZXNcbiAgT3BhbC5nbG9iYWwgPSBnbG9iYWxfb2JqZWN0O1xuXG4gIC8vIENvbmZpZ3VyZSBydW50aW1lIGJlaGF2aW9yIHdpdGggcmVnYXJkcyB0byByZXF1aXJlIGFuZCB1bnN1cHBvcnRlZCBmZWF0dXJlc1xuICBPcGFsLmNvbmZpZyA9IHtcbiAgICBtaXNzaW5nX3JlcXVpcmVfc2V2ZXJpdHk6ICdlcnJvcicsICAgICAgICAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXG4gICAgdW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHk6ICd3YXJuaW5nJywgLy8gZXJyb3IsIHdhcm5pbmcsIGlnbm9yZVxuICAgIGV4cGVyaW1lbnRhbF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLC8vIHdhcm5pbmcsIGlnbm9yZVxuICAgIGVuYWJsZV9zdGFja190cmFjZTogdHJ1ZSAgICAgICAgICAgICAgICAgIC8vIHRydWUsIGZhbHNlXG4gIH07XG5cbiAgLy8gTWluaWZ5IGNvbW1vbiBmdW5jdGlvbiBjYWxsc1xuICB2YXIgJGNhbGwgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuICB2YXIgJGJpbmQgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuICB2YXIgJGhhc19vd24gICA9IE9iamVjdC5oYXNPd24gfHwgJGNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiAgdmFyICRzZXRfcHJvdG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4gIHZhciAkc2xpY2UgICAgID0gJGNhbGwuYmluZChBcnJheS5wcm90b3R5cGUuc2xpY2UpO1xuICB2YXIgJHNwbGljZSAgICA9ICRjYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG5cbiAgLy8gTmlsIG9iamVjdCBpZCBpcyBhbHdheXMgNFxuICB2YXIgbmlsX2lkID0gNDtcblxuICAvLyBHZW5lcmF0ZXMgZXZlbiBzZXF1ZW50aWFsIG51bWJlcnMgZ3JlYXRlciB0aGFuIDRcbiAgLy8gKG5pbF9pZCkgdG8gc2VydmUgYXMgdW5pcXVlIGlkcyBmb3IgcnVieSBvYmplY3RzXG4gIHZhciB1bmlxdWVfaWQgPSBuaWxfaWQ7XG5cbiAgLy8gUmV0dXJuIG5leHQgdW5pcXVlIGlkXG4gIGZ1bmN0aW9uICR1aWQoKSB7XG4gICAgdW5pcXVlX2lkICs9IDI7XG4gICAgcmV0dXJuIHVuaXF1ZV9pZDtcbiAgfTtcbiAgT3BhbC51aWQgPSAkdWlkO1xuXG4gIC8vIFJldHJpZXZlIG9yIGFzc2lnbiB0aGUgaWQgb2YgYW4gb2JqZWN0XG4gIE9wYWwuaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XG4gICAgaWYgKG9iai4kJGlkID09IG51bGwpIHtcbiAgICAgICRwcm9wKG9iaiwgJyQkaWQnLCAkdWlkKCkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLiQkaWQ7XG4gIH07XG5cbiAgLy8gR2xvYmFscyB0YWJsZVxuICB2YXIgJGd2YXJzID0gT3BhbC5ndmFycyA9IHt9O1xuXG4gIC8vIEV4aXQgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IHBsYXRmb3JtIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gIC8vIChTZWUgbm9kZWpzIGFuZCBjaHJvbWUgZm9yIGV4YW1wbGVzKVxuICBPcGFsLmV4aXQgPSBmdW5jdGlvbihzdGF0dXMpIHsgaWYgKCRndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgZXhjZXB0aW9ucyBmb3IgJCFcbiAgT3BhbC5leGNlcHRpb25zID0gW107XG5cbiAgLy8gQHByaXZhdGVcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cbiAgT3BhbC5wb3BfZXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IE9wYWwuZXhjZXB0aW9ucy5wb3AoKTtcbiAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAkZ3ZhcnNbXCIhXCJdID0gZXhjZXB0aW9uO1xuICAgICAgJGd2YXJzW1wiQFwiXSA9IGV4Y2VwdGlvbi4kYmFja3RyYWNlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJGd2YXJzW1wiIVwiXSA9ICRndmFyc1tcIkBcIl0gPSBuaWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIEEgaGVscGVyIGZ1bmN0aW9uIGZvciByYWlzaW5nIHRoaW5ncywgdGhhdCBncmFjZWZ1bGx5IGRlZ3JhZGVzIGlmIG5lY2Vzc2FyeVxuICAvLyBmdW5jdGlvbmFsaXR5IGlzIG5vdCB5ZXQgbG9hZGVkLlxuICBmdW5jdGlvbiAkcmFpc2Uoa2xhc3MsIG1lc3NhZ2UpIHtcbiAgICAvLyBSYWlzZSBFeGNlcHRpb24sIHNvIHdlIGNhbiBrbm93IHRoYXQgc29tZXRoaW5nIHdyb25nIGlzIGdvaW5nIG9uLlxuICAgIGlmICgha2xhc3MpIGtsYXNzID0gT3BhbC5FeGNlcHRpb24gfHwgRXJyb3I7XG5cbiAgICBpZiAoS2VybmVsICYmIEtlcm5lbC4kcmFpc2UpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICBLZXJuZWwuJHJhaXNlKGtsYXNzLiRuZXcuYXBwbHkoa2xhc3MsICRzbGljZShhcmd1bWVudHMsIDEpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgS2VybmVsLiRyYWlzZShrbGFzcywgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFrbGFzcy4kbmV3KSB7XG4gICAgICB0aHJvdyBuZXcga2xhc3MobWVzc2FnZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cga2xhc3MuJG5ldyhtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiAkcHJvcChvYmplY3QsIG5hbWUsIGluaXRpYWxWYWx1ZSkge1xuICAgIGlmICh0eXBlb2Yob2JqZWN0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvcjpcbiAgICAgIC8vICAgcyA9IFwic3RyaW5nXCJcbiAgICAgIC8vICAgZGVmIHMubTsgZW5kXG4gICAgICAvLyBTdHJpbmcgY2xhc3MgaXMgdGhlIG9ubHkgY2xhc3MgdGhhdDpcbiAgICAgIC8vICsgY29tcGlsZXMgdG8gSlMgcHJpbWl0aXZlXG4gICAgICAvLyArIGFsbG93cyBtZXRob2QgZGVmaW5pdGlvbiBkaXJlY3RseSBvbiBpbnN0YW5jZXNcbiAgICAgIC8vIG51bWJlcnMsIHRydWUsIGZhbHNlIGFuZCBudWxsIGRvIG5vdCBzdXBwb3J0IGl0LlxuICAgICAgb2JqZWN0W25hbWVdID0gaW5pdGlhbFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgIHZhbHVlOiBpbml0aWFsVmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBPcGFsLnByb3AgPSAkcHJvcDtcblxuICAvLyBAZGVwcmVjYXRlZFxuICBPcGFsLmRlZmluZVByb3BlcnR5ID0gT3BhbC5wcm9wO1xuXG4gIE9wYWwuc2xpY2UgPSAkc2xpY2U7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLVxuXG4gIHZhciAkdHJ1dGh5ID0gT3BhbC50cnV0aHkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gZmFsc2UgIT09IHZhbCAmJiBuaWwgIT09IHZhbCAmJiB1bmRlZmluZWQgIT09IHZhbCAmJiBudWxsICE9PSB2YWwgJiYgKCEodmFsIGluc3RhbmNlb2YgQm9vbGVhbikgfHwgdHJ1ZSA9PT0gdmFsLnZhbHVlT2YoKSk7XG4gIH07XG5cbiAgT3BhbC5mYWxzeSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAhJHRydXRoeSh2YWwpO1xuICB9O1xuXG4gIE9wYWwudHlwZV9lcnJvciA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0LiQkY2xhc3M7XG5cbiAgICBpZiAoY29lcmNlZCAmJiBtZXRob2QpIHtcbiAgICAgIGNvZXJjZWQgPSBjb2VyY2VkLiQkY2xhc3M7XG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsXG4gICAgICAgIFwiY2FuJ3QgY29udmVydCBcIiArIG9iamVjdCArIFwiIGludG8gXCIgKyB0eXBlICtcbiAgICAgICAgXCIgKFwiICsgb2JqZWN0ICsgXCIjXCIgKyBtZXRob2QgKyBcIiBnaXZlcyBcIiArIGNvZXJjZWQgKyBcIilcIlxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsXG4gICAgICAgIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiBcIiArIG9iamVjdCArIFwiIGludG8gXCIgKyB0eXBlXG4gICAgICApXG4gICAgfVxuICB9O1xuXG4gIE9wYWwuY29lcmNlX3RvID0gZnVuY3Rpb24ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGFyZ3MpIHtcbiAgICB2YXIgYm9keTtcblxuICAgIGlmIChtZXRob2QgPT09ICd0b19pbnQnICYmIHR5cGUgPT09IE9wYWwuSW50ZWdlciAmJiBvYmplY3QuJCRpc19udW1iZXIpXG4gICAgICByZXR1cm4gb2JqZWN0IDwgMCA/IE1hdGguY2VpbChvYmplY3QpIDogTWF0aC5mbG9vcihvYmplY3QpO1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ3RvX3N0cicgJiYgdHlwZSA9PT0gT3BhbC5TdHJpbmcgJiYgb2JqZWN0LiQkaXNfc3RyaW5nKVxuICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgIGlmIChPcGFsLmlzX2Eob2JqZWN0LCB0eXBlKSkgcmV0dXJuIG9iamVjdDtcblxuICAgIC8vIEZhc3QgcGF0aCBmb3IgdGhlIG1vc3QgY29tbW9uIHNpdHVhdGlvblxuICAgIGlmIChvYmplY3RbJyRyZXNwb25kX3RvPyddLiQkcHJpc3RpbmUgJiYgb2JqZWN0LiRtZXRob2RfbWlzc2luZy4kJHByaXN0aW5lKSB7XG4gICAgICBib2R5ID0gb2JqZWN0WyRqc2lkKG1ldGhvZCldO1xuICAgICAgaWYgKGJvZHkgPT0gbnVsbCB8fCBib2R5LiQkc3R1YikgT3BhbC50eXBlX2Vycm9yKG9iamVjdCwgdHlwZSk7XG4gICAgICByZXR1cm4gYm9keS5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIGlmICghb2JqZWN0WyckcmVzcG9uZF90bz8nXShtZXRob2QpKSB7XG4gICAgICBPcGFsLnR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncyA9PSBudWxsKSBhcmdzID0gW107XG4gICAgcmV0dXJuIE9wYWwuc2VuZChvYmplY3QsIG1ldGhvZCwgYXJncyk7XG4gIH1cblxuICBPcGFsLnJlc3BvbmRfdG8gPSBmdW5jdGlvbihvYmosIGpzaWQsIGluY2x1ZGVfYWxsKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsIHx8ICFvYmouJCRjbGFzcykgcmV0dXJuIGZhbHNlO1xuICAgIGluY2x1ZGVfYWxsID0gISFpbmNsdWRlX2FsbDtcbiAgICB2YXIgYm9keSA9IG9ialtqc2lkXTtcblxuICAgIGlmIChvYmpbJyRyZXNwb25kX3RvPyddLiQkcHJpc3RpbmUpIHtcbiAgICAgIGlmICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIW9ialsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXS4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiBPcGFsLnNlbmQob2JqLCBvYmpbJyRyZXNwb25kX3RvX21pc3Npbmc/J10sIFtqc2lkLnN1YnN0cigxKSwgaW5jbHVkZV9hbGxdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9wYWwuc2VuZChvYmosIG9ialsnJHJlc3BvbmRfdG8/J10sIFtqc2lkLnN1YnN0cigxKSwgaW5jbHVkZV9hbGxdKTtcbiAgICB9XG4gIH1cblxuICAvLyBUcmFjZVBvaW50IHN1cHBvcnRcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIFN1cHBvcnQgZm9yIGBUcmFjZVBvaW50LnRyYWNlKDpjbGFzcykgZG8gLi4uIGVuZGBcbiAgT3BhbC50cmFjZV9jbGFzcyA9IGZhbHNlO1xuICBPcGFsLnRyYWNlcnNfZm9yX2NsYXNzID0gW107XG5cbiAgZnVuY3Rpb24gaW52b2tlX3RyYWNlcnNfZm9yX2NsYXNzKGtsYXNzX29yX21vZHVsZSkge1xuICAgIHZhciBpLCBpaSwgdHJhY2VyO1xuXG4gICAgZm9yKGkgPSAwLCBpaSA9IE9wYWwudHJhY2Vyc19mb3JfY2xhc3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdHJhY2VyID0gT3BhbC50cmFjZXJzX2Zvcl9jbGFzc1tpXTtcbiAgICAgIHRyYWNlci50cmFjZV9vYmplY3QgPSBrbGFzc19vcl9tb2R1bGU7XG4gICAgICB0cmFjZXIuYmxvY2suJGNhbGwodHJhY2VyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVfYXV0b2xvYWQoY3JlZiwgbmFtZSkge1xuICAgIGlmICghY3JlZi4kJGF1dG9sb2FkW25hbWVdLmxvYWRlZCkge1xuICAgICAgY3JlZi4kJGF1dG9sb2FkW25hbWVdLmxvYWRlZCA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBPcGFsLktlcm5lbC4kcmVxdWlyZShjcmVmLiQkYXV0b2xvYWRbbmFtZV0ucGF0aCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5leGNlcHRpb24gPSBlO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgY3JlZi4kJGF1dG9sb2FkW25hbWVdLnJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0uc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjcmVmLiQkYXV0b2xvYWRbbmFtZV0ubG9hZGVkICYmICFjcmVmLiQkYXV0b2xvYWRbbmFtZV0ucmVxdWlyZWQpIHtcbiAgICAgIGlmIChjcmVmLiQkYXV0b2xvYWRbbmFtZV0uZXhjZXB0aW9uKSB7IHRocm93IGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5leGNlcHRpb247IH1cbiAgICB9XG4gIH1cblxuICAvLyBDb25zdGFudHNcbiAgLy8gLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEZvciBmdXR1cmUgcmVmZXJlbmNlOlxuICAvLyAtIFRoZSBSYWlscyBhdXRvbG9hZGluZyBndWlkZSAoaHR0cDovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvdjUuMC9hdXRvbG9hZGluZ19hbmRfcmVsb2FkaW5nX2NvbnN0YW50cy5odG1sKVxuICAvLyAtIEBDb25yYWRJcndpbidzIDIwMTIgcG9zdCBvbiDigJxFdmVyeXRoaW5nIHlvdSBldmVyIHdhbnRlZCB0byBrbm93IGFib3V0IGNvbnN0YW50IGxvb2t1cCBpbiBSdWJ54oCdIChodHRwOi8vY2lydy5pbi9ibG9nL2NvbnN0YW50LWxvb2t1cC5odG1sKVxuICAvL1xuICAvLyBMZWdlbmQgb2YgTVJJIGNvbmNlcHRzL25hbWVzOlxuICAvLyAtIGNvbnN0YW50IHJlZmVyZW5jZSAoY3JlZik6IHRoZSBtb2R1bGUvY2xhc3MgdGhhdCBhY3RzIGFzIGEgbmFtZXNwYWNlXG4gIC8vIC0gbmVzdGluZzogdGhlIG5hbWVzcGFjZXMgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2NvcGUsIGUuZy4gbmVzdGluZyBpbnNpZGVcbiAgLy8gICAgICAgICAgICBgbW9kdWxlIEE7IG1vZHVsZSBCOjpDOyBlbmQ7IGVuZGAgaXMgYFtCOjpDLCBBXWBcblxuICAvLyBHZXQgdGhlIGNvbnN0YW50IGluIHRoZSBzY29wZSBvZiB0aGUgY3VycmVudCBjcmVmXG4gIGZ1bmN0aW9uIGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZikge1xuICAgICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7IHJldHVybiBjcmVmLiQkY29uc3RbbmFtZV07IH1cbiAgICAgIGlmIChjcmVmLiQkYXV0b2xvYWQgJiYgY3JlZi4kJGF1dG9sb2FkW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVfYXV0b2xvYWQoY3JlZiwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgbmVzdGluZyBhcnJheSBsb29raW5nIGZvciB0aGUgY29uc3RhbnRcbiAgZnVuY3Rpb24gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkge1xuICAgIHZhciBpLCBpaSwgY29uc3RhbnQ7XG5cbiAgICBpZiAobmVzdGluZy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIC8vIElmIHRoZSBuZXN0aW5nIGlzIG5vdCBlbXB0eSB0aGUgY29uc3RhbnQgaXMgbG9va2VkIHVwIGluIGl0cyBlbGVtZW50c1xuICAgIC8vIGFuZCBpbiBvcmRlci4gVGhlIGFuY2VzdG9ycyBvZiB0aG9zZSBlbGVtZW50cyBhcmUgaWdub3JlZC5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IG5lc3RpbmcubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3RhbnQgPSBuZXN0aW5nW2ldLiQkY29uc3RbbmFtZV07XG4gICAgICBpZiAoY29uc3RhbnQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgICB9IGVsc2UgaWYgKG5lc3RpbmdbaV0uJCRhdXRvbG9hZCAmJiBuZXN0aW5nW2ldLiQkYXV0b2xvYWRbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZV9hdXRvbG9hZChuZXN0aW5nW2ldLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSBhbmNlc3RvcnMgY2hhaW4gbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkge1xuICAgIHZhciBpLCBpaSwgYW5jZXN0b3JzO1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhjcmVmKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmIChhbmNlc3RvcnNbaV0uJCRjb25zdCAmJiAkaGFzX293bihhbmNlc3RvcnNbaV0uJCRjb25zdCwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgfSBlbHNlIGlmIChhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZCAmJiBhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlX2F1dG9sb2FkKGFuY2VzdG9yc1tpXSwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2FsayB1cCBPYmplY3QncyBhbmNlc3RvcnMgY2hhaW4gbG9va2luZyBmb3IgdGhlIGNvbnN0YW50LFxuICAvLyBidXQgb25seSBpZiBjcmVmIGlzIG1pc3Npbmcgb3IgYSBtb2R1bGUuXG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkge1xuICAgIGlmIChjcmVmID09IG51bGwgfHwgY3JlZi4kJGlzX21vZHVsZSkge1xuICAgICAgcmV0dXJuIGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbCBjb25zdF9taXNzaW5nIGlmIG5vdGhpbmcgZWxzZSB3b3JrZWRcbiAgZnVuY3Rpb24gY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lKSB7XG4gICAgcmV0dXJuIChjcmVmIHx8IF9PYmplY3QpLiRjb25zdF9taXNzaW5nKG5hbWUpO1xuICB9XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGp1c3QgaW4gdGhlIGN1cnJlbnQgY3JlZiBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2BcbiAgT3BhbC5jb25zdF9nZXRfbG9jYWwgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcbiAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvciwgY3JlZi50b1N0cmluZygpICsgXCIgaXMgbm90IGEgY2xhc3MvbW9kdWxlXCIpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpO1xuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCB8fCBza2lwX21pc3NpbmcgPyByZXN1bHQgOiBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUpO1xuICB9O1xuXG4gIC8vIExvb2sgZm9yIHRoZSBjb25zdGFudCByZWxhdGl2ZSB0byBhIGNyZWYgb3IgY2FsbCBgI2NvbnN0X21pc3NpbmdgICh3aGVuIHRoZVxuICAvLyBjb25zdGFudCBpcyBwcmVmaXhlZCBieSBgOjpgKS5cbiAgT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIHJlc3VsdCwgY2FjaGUsIGNhY2hlZCwgY3VycmVudF92ZXJzaW9uID0gT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uO1xuXG4gICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgLy8gQSBzaG9ydHBhdGggZm9yIGNhbGxzIGxpa2UgOjpTdHJpbmcgPT4gJCQkKFwiU3RyaW5nXCIpXG4gICAgICByZXN1bHQgPSBjb25zdF9nZXRfbmFtZShfT2JqZWN0LCBjcmVmKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZChfT2JqZWN0LCBjcmVmLCBza2lwX21pc3NpbmcpO1xuICAgIH1cblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGlmIChjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICghY3JlZi4kJGlzX21vZHVsZSAmJiAhY3JlZi4kJGlzX2NsYXNzKSB7XG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIGNyZWYudG9TdHJpbmcoKSArIFwiIGlzIG5vdCBhIGNsYXNzL21vZHVsZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoKGNhY2hlID0gY3JlZi4kJGNvbnN0X2NhY2hlKSA9PSBudWxsKSB7XG4gICAgICAkcHJvcChjcmVmLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSkgICAgICAhPSBudWxsKTtcbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCB8fCBza2lwX21pc3NpbmcgPyByZXN1bHQgOiBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUpO1xuICB9O1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHRvcCBsZXZlbCBjb25zdGFudCBjYWNoZSBnZW5lcmF0aW9uIGNvdW50ZXJcbiAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uID0gMTtcblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQgaW4gdGhlIG9wZW4gdXNpbmcgdGhlIGN1cnJlbnQgbmVzdGluZyBhbmQgdGhlIG5lYXJlc3RcbiAgLy8gY3JlZiBhbmNlc3RvcnMgb3IgY2FsbCBgI2NvbnN0X21pc3NpbmdgICh3aGVuIHRoZSBjb25zdGFudCBoYXMgbm8gOjogcHJlZml4KS5cbiAgT3BhbC5jb25zdF9nZXRfcmVsYXRpdmUgPSBmdW5jdGlvbihuZXN0aW5nLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgY3JlZiA9IG5lc3RpbmdbMF0sIHJlc3VsdCwgY3VycmVudF92ZXJzaW9uID0gT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uLCBjYWNoZSwgY2FjaGVkO1xuXG4gICAgaWYgKChjYWNoZSA9IG5lc3RpbmcuJCRjb25zdF9jYWNoZSkgPT0gbnVsbCkge1xuICAgICAgJHByb3AobmVzdGluZywgJyQkY29uc3RfY2FjaGUnLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgIGNhY2hlID0gbmVzdGluZy4kJGNvbnN0X2NhY2hlO1xuICAgIH1cbiAgICBjYWNoZWQgPSBjYWNoZVtuYW1lXTtcblxuICAgIGlmIChjYWNoZWQgPT0gbnVsbCB8fCBjYWNoZWRbMF0gIT09IGN1cnJlbnRfdmVyc2lvbikge1xuICAgICAgKChyZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKSkgICAgICAgICAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpKSAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSkgICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfT2JqZWN0KGNyZWYsIG5hbWUpKSAgICAgICAgICE9IG51bGwpO1xuXG4gICAgICBjYWNoZVtuYW1lXSA9IFtjdXJyZW50X3ZlcnNpb24sIHJlc3VsdF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNhY2hlZFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICE9IG51bGwgfHwgc2tpcF9taXNzaW5nID8gcmVzdWx0IDogY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgY29uc3RhbnQgb24gYSBjcmVmIGFuZCBvcHBvcnR1bmlzdGljYWxseSBzZXQgdGhlIG5hbWUgb2ZcbiAgLy8gdW5uYW1lZCBjbGFzc2VzL21vZHVsZXMuXG4gIGZ1bmN0aW9uICRjb25zdF9zZXQoY3JlZiwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbmV3X2NvbnN0ID0gdHJ1ZTtcblxuICAgIGlmIChjcmVmID09IG51bGwgfHwgY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XG5cbiAgICBpZiAodmFsdWUuJCRpc19hX21vZHVsZSkge1xuICAgICAgaWYgKHZhbHVlLiQkbmFtZSA9PSBudWxsIHx8IHZhbHVlLiQkbmFtZSA9PT0gbmlsKSB2YWx1ZS4kJG5hbWUgPSBuYW1lO1xuICAgICAgaWYgKHZhbHVlLiQkYmFzZV9tb2R1bGUgPT0gbnVsbCkgdmFsdWUuJCRiYXNlX21vZHVsZSA9IGNyZWY7XG4gICAgfVxuXG4gICAgY3JlZi4kJGNvbnN0ID0gKGNyZWYuJCRjb25zdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgIGlmIChuYW1lIGluIGNyZWYuJCRjb25zdCB8fCAoXCIkJGF1dG9sb2FkXCIgaW4gY3JlZiAmJiBuYW1lIGluIGNyZWYuJCRhdXRvbG9hZCkpIHtcbiAgICAgIG5ld19jb25zdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNyZWYuJCRjb25zdFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gQWRkIGEgc2hvcnQgaGVscGVyIHRvIG5hdmlnYXRlIGNvbnN0YW50cyBtYW51YWxseS5cbiAgICAvLyBAZXhhbXBsZVxuICAgIC8vICAgT3BhbC4kJC5SZWdleHAuJCQuSUdOT1JFQ0FTRVxuICAgIGNyZWYuJCQgPSBjcmVmLiQkY29uc3Q7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcblxuICAgIC8vIEV4cG9zZSB0b3AgbGV2ZWwgY29uc3RhbnRzIG9udG8gdGhlIE9wYWwgb2JqZWN0XG4gICAgaWYgKGNyZWYgPT09IF9PYmplY3QpIE9wYWxbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIE5hbWUgbmV3IGNsYXNzIGRpcmVjdGx5IG9udG8gY3VycmVudCBzY29wZSAoT3BhbC5Gb28uQmF6ID0ga2xhc3MpXG4gICAgJHByb3AoY3JlZiwgbmFtZSwgdmFsdWUpO1xuXG4gICAgaWYgKG5ld19jb25zdCAmJiBjcmVmLiRjb25zdF9hZGRlZCAmJiAhY3JlZi4kY29uc3RfYWRkZWQuJCRwcmlzdGluZSkge1xuICAgICAgY3JlZi4kY29uc3RfYWRkZWQobmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIE9wYWwuY29uc3Rfc2V0ID0gJGNvbnN0X3NldDtcblxuICAvLyBHZXQgYWxsIHRoZSBjb25zdGFudHMgcmVhY2hhYmxlIGZyb20gYSBnaXZlbiBjcmVmLCBieSBkZWZhdWx0IHdpbGwgaW5jbHVkZVxuICAvLyBpbmhlcml0ZWQgY29uc3RhbnRzLlxuICBPcGFsLmNvbnN0YW50cyA9IGZ1bmN0aW9uKGNyZWYsIGluaGVyaXQpIHtcbiAgICBpZiAoaW5oZXJpdCA9PSBudWxsKSBpbmhlcml0ID0gdHJ1ZTtcblxuICAgIHZhciBtb2R1bGUsIG1vZHVsZXMgPSBbY3JlZl0sIGksIGlpLCBjb25zdGFudHMgPSB7fSwgY29uc3RhbnQ7XG5cbiAgICBpZiAoaW5oZXJpdCkgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KCRhbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoJGFuY2VzdG9ycyhPcGFsLk9iamVjdCkpO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG1vZHVsZSA9IG1vZHVsZXNbaV07XG5cbiAgICAgIC8vIERvIG5vdCBzaG93IE9iamVjdHMgY29uc3RhbnRzIHVubGVzcyB3ZSdyZSBxdWVyeWluZyBPYmplY3QgaXRzZWxmXG4gICAgICBpZiAoY3JlZiAhPT0gX09iamVjdCAmJiBtb2R1bGUgPT0gX09iamVjdCkgYnJlYWs7XG5cbiAgICAgIGZvciAoY29uc3RhbnQgaW4gbW9kdWxlLiQkY29uc3QpIHtcbiAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobW9kdWxlLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgZm9yIChjb25zdGFudCBpbiBtb2R1bGUuJCRhdXRvbG9hZCkge1xuICAgICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbnN0YW50cyk7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGEgY29uc3RhbnQgZnJvbSBhIGNyZWYuXG4gIE9wYWwuY29uc3RfcmVtb3ZlID0gZnVuY3Rpb24oY3JlZiwgbmFtZSkge1xuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICB2YXIgb2xkID0gY3JlZi4kJGNvbnN0W25hbWVdO1xuICAgICAgZGVsZXRlIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIHJldHVybiBvbGQ7XG4gICAgfVxuXG4gICAgaWYgKGNyZWYuJCRhdXRvbG9hZCAmJiBjcmVmLiQkYXV0b2xvYWRbbmFtZV0pIHtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkYXV0b2xvYWRbbmFtZV07XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cblxuICAgICRyYWlzZShPcGFsLk5hbWVFcnJvciwgXCJjb25zdGFudCBcIitjcmVmK1wiOjpcIitjcmVmLiRuYW1lKCkrXCIgbm90IGRlZmluZWRcIik7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBhIGN1cnJpZWQgY29uc3RfZ2V0X3JlbGF0aXZlLlxuICBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZV9mYWN0b3J5ID0gZnVuY3Rpb24obmVzdGluZykge1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICAgIHJldHVybiBPcGFsLiQkKG5lc3RpbmcsIG5hbWUsIHNraXBfbWlzc2luZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0dXAgc29tZSBzaG9ydGN1dHMgdG8gcmVkdWNlIGNvbXBpbGVkIHNpemVcbiAgT3BhbC4kJCA9IE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlO1xuICBPcGFsLiQkJCA9IE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZDtcbiAgT3BhbC4kciA9IE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlX2ZhY3Rvcnk7XG5cbiAgLy8gTW9kdWxlcyAmIENsYXNzZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIGBjbGFzcyBGb287IGVuZGAgZXhwcmVzc2lvbiBpbiBydWJ5IGlzIGNvbXBpbGVkIHRvIGNhbGwgdGhpcyBydW50aW1lXG4gIC8vIG1ldGhvZCB3aGljaCBlaXRoZXIgcmV0dXJucyBhbiBleGlzdGluZyBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSwgb3IgY3JlYXRlc1xuICAvLyBhIG5ldyBjbGFzcyBpbiB0aGUgZ2l2ZW4gYGJhc2VgIHNjb3BlLlxuICAvL1xuICAvLyBJZiBhIGNvbnN0YW50IHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLCB0aGVuIHdlIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0XG4gIC8vIGl0IGlzIGEgY2xhc3MgYW5kIGFsc28gdGhhdCB0aGUgc3VwZXJjbGFzc2VzIG1hdGNoLiBJZiBlaXRoZXIgb2YgdGhlc2VcbiAgLy8gZmFpbCwgdGhlbiB3ZSByYWlzZSBhIGBUeXBlRXJyb3JgLiBOb3RlLCBgc3VwZXJjbGFzc2AgbWF5IGJlIG51bGwgaWYgb25lXG4gIC8vIHdhcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBydWJ5IGNvZGUuXG4gIC8vXG4gIC8vIFdlIHBhc3MgYSBjb25zdHJ1Y3RvciB0byB0aGlzIG1ldGhvZCBvZiB0aGUgZm9ybSBgZnVuY3Rpb24gQ2xhc3NOYW1lKCkge31gXG4gIC8vIHNpbXBseSBzbyB0aGF0IGNsYXNzZXMgc2hvdyB1cCB3aXRoIG5pY2VseSBmb3JtYXR0ZWQgbmFtZXMgaW5zaWRlIGRlYnVnZ2Vyc1xuICAvLyBpbiB0aGUgd2ViIGJyb3dzZXIgKG9yIG5vZGUvc3Byb2NrZXRzKS5cbiAgLy9cbiAgLy8gVGhlIGBzY29wZWAgaXMgdGhlIGN1cnJlbnQgYHNlbGZgIHZhbHVlIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIGZyb20uIFdlIHVzZSB0aGlzIHRvIGdldCB0aGUgc2NvcGUgZm9yIHdoZXJlIHRoZSBjbGFzcyBzaG91bGQgYmUgY3JlYXRlZC5cbiAgLy8gSWYgYHNjb3BlYCBpcyBhbiBvYmplY3QgKG5vdCBhIGNsYXNzL21vZHVsZSksIHdlIHNpbXBsZSBnZXQgaXRzIGNsYXNzIGFuZFxuICAvLyB1c2UgdGhhdCBhcyB0aGUgc2NvcGUgaW5zdGVhZC5cbiAgLy9cbiAgLy8gQHBhcmFtIHNjb3BlICAgICAgICBbT2JqZWN0XSB3aGVyZSB0aGUgY2xhc3MgaXMgYmVpbmcgY3JlYXRlZFxuICAvLyBAcGFyYW0gc3VwZXJjbGFzcyAgIFtDbGFzcyxudWxsXSBzdXBlcmNsYXNzIG9mIHRoZSBuZXcgY2xhc3MgKG1heSBiZSBudWxsKVxuICAvLyBAcGFyYW0gc2luZ2xldG9uICAgIFtCb29sZWFuLG51bGxdIGEgdHJ1ZSB2YWx1ZSBkZW5vdGVzIHdlIHdhbnQgdG8gYWxsb2NhdGVcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHNpbmdsZXRvblxuICAvL1xuICAvLyBAcmV0dXJuIG5ldyBbQ2xhc3NdICBvciBleGlzdGluZyBydWJ5IGNsYXNzXG4gIC8vXG4gIGZ1bmN0aW9uICRhbGxvY2F0ZV9jbGFzcyhuYW1lLCBzdXBlcmNsYXNzLCBzaW5nbGV0b24pIHtcbiAgICB2YXIga2xhc3M7XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsICYmIHN1cGVyY2xhc3MuJCRicmlkZ2UpIHtcbiAgICAgIC8vIEluaGVyaXRhbmNlIGZyb20gYnJpZGdlZCBjbGFzc2VzIHJlcXVpcmVzXG4gICAgICAvLyBjYWxsaW5nIG9yaWdpbmFsIEpTIGNvbnN0cnVjdG9yc1xuICAgICAga2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHNlbGYgPSBuZXcgKCRiaW5kLmFwcGx5KHN1cGVyY2xhc3MuJCRjb25zdHJ1Y3RvciwgW251bGxdLmNvbmNhdChhcmdzKSkpKCk7XG5cbiAgICAgICAgLy8gYW5kIHJlcGxhY2luZyBhIF9fcHJvdG9fXyBtYW51YWxseVxuICAgICAgICAkc2V0X3Byb3RvKHNlbGYsIGtsYXNzLiQkcHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtsYXNzID0gZnVuY3Rpb24oKXt9O1xuICAgIH1cblxuICAgIGlmIChuYW1lICYmIG5hbWUgIT09IG5pbCkge1xuICAgICAgJHByb3Aoa2xhc3MsICdkaXNwbGF5TmFtZScsICc6OicrbmFtZSk7XG4gICAgfVxuXG4gICAgJHByb3Aoa2xhc3MsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3RydWN0b3InLCBrbGFzcyk7XG4gICAgJHByb3Aoa2xhc3MsICckJHByb3RvdHlwZScsIGtsYXNzLnByb3RvdHlwZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGNvbnN0Jywge30pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRpc19jbGFzcycsIHRydWUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRpc19hX21vZHVsZScsIHRydWUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRzdXBlcicsIHN1cGVyY2xhc3MpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRjdmFycycsIHt9KTtcbiAgICAkcHJvcChrbGFzcywgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJHByb3Aoa2xhc3MsICckJG93bl9wcmVwZW5kZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkcHJvcChrbGFzcywgJyQkYW5jZXN0b3JzJywgW10pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRzdWJjbGFzc2VzJywgW10pO1xuXG4gICAgJHByb3Aoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuXG4gICAgLy8gQnkgZGVmYXVsdCBpZiB0aGVyZSBhcmUgbm8gc2luZ2xldG9uIGNsYXNzIG1ldGhvZHNcbiAgICAvLyBfX3Byb3RvX18gaXMgQ2xhc3MucHJvdG90eXBlXG4gICAgLy8gTGF0ZXIgc2luZ2xldG9uIG1ldGhvZHMgZ2VuZXJhdGUgYSBzaW5nbGV0b25fY2xhc3NcbiAgICAvLyBhbmQgaW5qZWN0IGl0IGludG8gYW5jZXN0b3JzIGNoYWluXG4gICAgaWYgKE9wYWwuQ2xhc3MpIHtcbiAgICAgICRzZXRfcHJvdG8oa2xhc3MsIE9wYWwuQ2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsKSB7XG4gICAgICAkc2V0X3Byb3RvKGtsYXNzLiQkcHJvdG90eXBlLCBzdXBlcmNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgaWYgKHNpbmdsZXRvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyBMZXQncyBub3QgZm9yYmlkIEdDIGZyb20gY2xlYW5pbmcgdXAgb3VyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMuXG4gICAgICAgIGlmICh0eXBlb2YgV2Vha1JlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBGaXJzdCwgbGV0J3MgY2xlYW4gdXAgb3VyIGFycmF5IGZyb20gZW1wdHkgb2JqZWN0cy5cbiAgICAgICAgICB2YXIgaSwgc3ViY2xhc3MsIHJlYnVpbHRfc3ViY2xhc3NlcyA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdXBlcmNsYXNzLiQkc3ViY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3ViY2xhc3MgPSBzdXBlcmNsYXNzLiQkc3ViY2xhc3Nlc1tpXTtcbiAgICAgICAgICAgIGlmIChzdWJjbGFzcy5kZXJlZigpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmVidWlsdF9zdWJjbGFzc2VzLnB1c2goc3ViY2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBOb3csIGxldCdzIGFkZCBvdXIgY2xhc3MuXG4gICAgICAgICAgcmVidWlsdF9zdWJjbGFzc2VzLnB1c2gobmV3IFdlYWtSZWYoa2xhc3MpKTtcbiAgICAgICAgICBzdXBlcmNsYXNzLiQkc3ViY2xhc3NlcyA9IHJlYnVpbHRfc3ViY2xhc3NlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdXBlcmNsYXNzLiQkc3ViY2xhc3Nlcy5wdXNoKGtsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwZXJjbGFzcy4kJG1ldGEpIHtcbiAgICAgICAgLy8gSWYgc3VwZXJjbGFzcyBoYXMgbWV0YWNsYXNzIHRoZW4gd2UgaGF2ZSBleHBsaWNpdGVseSBpbmhlcml0IGl0LlxuICAgICAgICBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhrbGFzcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtsYXNzO1xuICB9O1xuICBPcGFsLmFsbG9jYXRlX2NsYXNzID0gJGFsbG9jYXRlX2NsYXNzO1xuXG5cbiAgZnVuY3Rpb24gZmluZF9leGlzdGluZ19jbGFzcyhzY29wZSwgbmFtZSkge1xuICAgIC8vIFRyeSB0byBmaW5kIHRoZSBjbGFzcyBpbiB0aGUgY3VycmVudCBzY29wZVxuICAgIHZhciBrbGFzcyA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcblxuICAgIC8vIElmIHRoZSBjbGFzcyBleGlzdHMgaW4gdGhlIHNjb3BlLCB0aGVuIHdlIG11c3QgdXNlIHRoYXRcbiAgICBpZiAoa2xhc3MpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZXhpc3RpbmcgY29uc3RhbnQgaXMgYSBjbGFzcywgb3IgcmFpc2UgZXJyb3JcbiAgICAgIGlmICgha2xhc3MuJCRpc19jbGFzcykge1xuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIG5hbWUgKyBcIiBpcyBub3QgYSBjbGFzc1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVN1cGVyY2xhc3NNYXRjaChrbGFzcywgc3VwZXJjbGFzcykge1xuICAgIGlmIChrbGFzcy4kJHN1cGVyICE9PSBzdXBlcmNsYXNzKSB7XG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwic3VwZXJjbGFzcyBtaXNtYXRjaCBmb3IgY2xhc3MgXCIgKyBrbGFzcy4kJG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwua2xhc3MgPSBmdW5jdGlvbihzY29wZSwgc3VwZXJjbGFzcywgbmFtZSkge1xuICAgIHZhciBicmlkZ2VkO1xuXG4gICAgaWYgKHNjb3BlID09IG51bGwgfHwgc2NvcGUgPT0gJzo6Jykge1xuICAgICAgLy8gR2xvYmFsIHNjb3BlXG4gICAgICBzY29wZSA9IF9PYmplY3Q7XG4gICAgfSBlbHNlIGlmICghc2NvcGUuJCRpc19jbGFzcyAmJiAhc2NvcGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIC8vIFNjb3BlIGlzIGFuIG9iamVjdCwgdXNlIGl0cyBjbGFzc1xuICAgICAgc2NvcGUgPSBzY29wZS4kJGNsYXNzO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzdXBlcmNsYXNzIGlzIG5vdCBhbiBPcGFsLWdlbmVyYXRlZCBjbGFzcyB0aGVuIHdlJ3JlIGJyaWRnaW5nIGEgbmF0aXZlIEpTIGNsYXNzXG4gICAgaWYgKFxuICAgICAgc3VwZXJjbGFzcyAhPSBudWxsICYmICghc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSB8fCAoXG4gICAgICAgIHN1cGVyY2xhc3MuaGFzT3duUHJvcGVydHkgJiYgIXN1cGVyY2xhc3MuaGFzT3duUHJvcGVydHkoJyQkaXNfY2xhc3MnKVxuICAgICAgKSlcbiAgICApIHtcbiAgICAgIGlmIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yICYmIHN1cGVyY2xhc3MuY29uc3RydWN0b3IubmFtZSA9PSBcIkZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYnJpZGdlZCA9IHN1cGVyY2xhc3M7XG4gICAgICAgIHN1cGVyY2xhc3MgPSBfT2JqZWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBcInN1cGVyY2xhc3MgbXVzdCBiZSBhIENsYXNzIChcIiArIChcbiAgICAgICAgICAoc3VwZXJjbGFzcy5jb25zdHJ1Y3RvciAmJiAoc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5uYW1lIHx8IHN1cGVyY2xhc3MuY29uc3RydWN0b3IuJCRuYW1lKSkgfHxcbiAgICAgICAgICB0eXBlb2Yoc3VwZXJjbGFzcylcbiAgICAgICAgKSArIFwiIGdpdmVuKVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2xhc3MgPSBmaW5kX2V4aXN0aW5nX2NsYXNzKHNjb3BlLCBuYW1lKTtcblxuICAgIGlmIChrbGFzcyAhPSBudWxsKSB7XG4gICAgICBpZiAoc3VwZXJjbGFzcykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgZXhpc3RpbmcgY2xhc3MgaGFzIHNhbWUgc3VwZXJjbGFzc1xuICAgICAgICBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIENsYXNzIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCBnaXZlbiBzdXBlcmNsYXNzLi4uXG5cbiAgICAgIC8vIE5vdCBzcGVjaWZ5aW5nIGEgc3VwZXJjbGFzcyBtZWFucyB3ZSBjYW4gYXNzdW1lIGl0IHRvIGJlIE9iamVjdFxuICAgICAgaWYgKHN1cGVyY2xhc3MgPT0gbnVsbCkge1xuICAgICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHRoZSBjbGFzcyBvYmplY3QgKGluc3RhbmNlIG9mIENsYXNzKVxuICAgICAga2xhc3MgPSAkYWxsb2NhdGVfY2xhc3MobmFtZSwgc3VwZXJjbGFzcyk7XG4gICAgICAkY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBrbGFzcyk7XG5cbiAgICAgIC8vIENhbGwgLmluaGVyaXRlZCgpIGhvb2sgd2l0aCBuZXcgY2xhc3Mgb24gdGhlIHN1cGVyY2xhc3NcbiAgICAgIGlmIChzdXBlcmNsYXNzLiRpbmhlcml0ZWQpIHtcbiAgICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJyaWRnZWQpIHtcbiAgICAgICAgT3BhbC5icmlkZ2UoYnJpZGdlZCwga2xhc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhrbGFzcyk7IH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuICAvLyBEZWZpbmUgbmV3IG1vZHVsZSAob3IgcmV0dXJuIGV4aXN0aW5nIG1vZHVsZSkuIFRoZSBnaXZlbiBgc2NvcGVgIGlzIGJhc2ljYWxseVxuICAvLyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgdGhlIGBtb2R1bGVgIHN0YXRlbWVudCB3YXMgZGVmaW5lZCBpbi4gSWYgdGhpcyBpc1xuICAvLyBhIHJ1YnkgbW9kdWxlIG9yIGNsYXNzLCB0aGVuIGl0IGlzIHVzZWQsIG90aGVyd2lzZSBpZiB0aGUgc2NvcGUgaXMgYSBydWJ5XG4gIC8vIG9iamVjdCB0aGVuIHRoYXQgb2JqZWN0cyByZWFsIHJ1YnkgY2xhc3MgaXMgdXNlZCAoZS5nLiBpZiB0aGUgc2NvcGUgaXMgdGhlXG4gIC8vIG1haW4gb2JqZWN0LCB0aGVuIHRoZSB0b3AgbGV2ZWwgYE9iamVjdGAgY2xhc3MgaXMgdXNlZCBhcyB0aGUgc2NvcGUpLlxuICAvL1xuICAvLyBJZiBhIG1vZHVsZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIHNjb3BlLCB0aGVuIHRoYXRcbiAgLy8gaW5zdGFuY2UgaXMganVzdCByZXR1cm5lZC5cbiAgLy9cbiAgLy8gSWYgdGhlcmUgaXMgYSBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgc2NvcGUsIHRoZW4gYW4gZXJyb3IgaXNcbiAgLy8gZ2VuZXJhdGVkIGluc3RlYWQgKGNhbm5vdCBoYXZlIGEgY2xhc3MgYW5kIG1vZHVsZSBvZiBzYW1lIG5hbWUgaW4gc2FtZSBzY29wZSkuXG4gIC8vXG4gIC8vIE90aGVyd2lzZSwgYSBuZXcgbW9kdWxlIGlzIGNyZWF0ZWQgaW4gdGhlIHNjb3BlIHdpdGggdGhlIGdpdmVuIG5hbWUsIGFuZCB0aGF0XG4gIC8vIG5ldyBpbnN0YW5jZSBpcyByZXR1cm5lZCBiYWNrICh0byBiZSByZWZlcmVuY2VkIGF0IHJ1bnRpbWUpLlxuICAvL1xuICAvLyBAcGFyYW0gIHNjb3BlIFtNb2R1bGUsIENsYXNzXSBjbGFzcyBvciBtb2R1bGUgdGhpcyBkZWZpbml0aW9uIGlzIGluc2lkZVxuICAvLyBAcGFyYW0gIGlkICAgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG5ldyAob3IgZXhpc3RpbmcpIG1vZHVsZVxuICAvL1xuICAvLyBAcmV0dXJuIFtNb2R1bGVdXG4gIGZ1bmN0aW9uICRhbGxvY2F0ZV9tb2R1bGUobmFtZSkge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICB2YXIgbW9kdWxlID0gY29uc3RydWN0b3I7XG5cbiAgICBpZiAobmFtZSlcbiAgICAgICRwcm9wKGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuY29uc3RydWN0b3InKTtcblxuICAgICRwcm9wKG1vZHVsZSwgJyQkbmFtZScsIG5hbWUpO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkcHJvdG90eXBlJywgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAkcHJvcChtb2R1bGUsICckJGNvbnN0Jywge30pO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkaXNfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRpc19hX21vZHVsZScsIHRydWUpO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRpY2xhc3NlcycsIFtdKTtcbiAgICAkcHJvcChtb2R1bGUsICckJG93bl9pbmNsdWRlZF9tb2R1bGVzJywgW10pO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkb3duX3ByZXBlbmRlZF9tb2R1bGVzJywgW10pO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkYW5jZXN0b3JzJywgW21vZHVsZV0pO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24nLCBudWxsKTtcblxuICAgICRzZXRfcHJvdG8obW9kdWxlLCBPcGFsLk1vZHVsZS5wcm90b3R5cGUpO1xuXG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfTtcbiAgT3BhbC5hbGxvY2F0ZV9tb2R1bGUgPSAkYWxsb2NhdGVfbW9kdWxlO1xuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcbiAgICBpZiAobW9kdWxlID09IG51bGwgJiYgc2NvcGUgPT09IF9PYmplY3QpIG1vZHVsZSA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBpZiAoIW1vZHVsZS4kJGlzX21vZHVsZSAmJiBtb2R1bGUgIT09IF9PYmplY3QpIHtcbiAgICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBuYW1lICsgXCIgaXMgbm90IGEgbW9kdWxlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH1cblxuICBPcGFsLm1vZHVsZSA9IGZ1bmN0aW9uKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZTtcblxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICBtb2R1bGUgPSBmaW5kX2V4aXN0aW5nX21vZHVsZShzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlID09IG51bGwpIHtcbiAgICAgIC8vIE1vZHVsZSBkb2VzbnQgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUuLi5cbiAgICAgIG1vZHVsZSA9ICRhbGxvY2F0ZV9tb2R1bGUobmFtZSk7XG4gICAgICAkY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBtb2R1bGUpO1xuICAgIH1cblxuICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhtb2R1bGUpOyB9XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciB0aGUgcGFzc2VkIG9iamVjdC5cbiAgLy9cbiAgLy8gSWYgdGhlIGdpdmVuIG9iamVjdCBhbHJlZHkgaGFzIGEgc2luZ2xldG9uIGNsYXNzLCB0aGVuIGl0IHdpbGwgYmUgc3RvcmVkIG9uXG4gIC8vIHRoZSBvYmplY3QgYXMgdGhlIGAkJG1ldGFgIHByb3BlcnR5LiBJZiB0aGlzIGV4aXN0cywgdGhlbiBpdCBpcyBzaW1wbHlcbiAgLy8gcmV0dXJuZWQgYmFjay5cbiAgLy9cbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBzaW5nbGV0b24gb2JqZWN0IGZvciB0aGUgY2xhc3Mgb3Igb2JqZWN0IGlzIGNyZWF0ZWQsIHNldCBvblxuICAvLyB0aGUgb2JqZWN0IGF0IGAkJG1ldGFgIGZvciBmdXR1cmUgdXNlLCBhbmQgdGhlbiByZXR1cm5lZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSB0aGUgcnVieSBvYmplY3RcbiAgLy8gQHJldHVybiBbQ2xhc3NdIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIG9iamVjdFxuICBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdC4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBvYmplY3QuJCRtZXRhO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoJyQkaXNfY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoJyQkaXNfbW9kdWxlJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX21vZHVsZV9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9wYWwuYnVpbGRfb2JqZWN0X3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoZWxwZXIgdG8gc2V0ICQkbWV0YSBvbiBrbGFzcywgbW9kdWxlIG9yIGluc3RhbmNlXG4gIGZ1bmN0aW9uIHNldF9tZXRhKG9iaiwgbWV0YSkge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICBvYmouJCRtZXRhID0gbWV0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHByb3Aob2JqLCAnJCRtZXRhJywgbWV0YSk7XG4gICAgfVxuICAgIGlmIChvYmouJCRmcm96ZW4pIHtcbiAgICAgIC8vIElmIGEgb2JqZWN0IGlzIGZyb3plbiAoc2VhbGVkKSwgZnJlZXplICQkbWV0YSB0b28uXG4gICAgICAvLyBObyBuZWVkIHRvIGluamVjdCAkJG1ldGEuJCRwcm90b3R5cGUgaW4gdGhlIHByb3RvdHlwZSBjaGFpbixcbiAgICAgIC8vIGFzICQkbWV0YSBjYW5ub3QgYmUgbW9kaWZpZWQgYW55d2F5LlxuICAgICAgb2JqLiQkbWV0YS4kZnJlZXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzZXRfcHJvdG8ob2JqLCBtZXRhLiQkcHJvdG90eXBlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYW4gZXhpc3RpbmcgY2xhc3MuIENsYXNzIG9iamVjdCBhcmUgYnVpbHRcbiAgLy8gd2l0aCB0aGVpciBzaW5nbGV0b24gY2xhc3MgYWxyZWFkeSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBpbmhlcml0aW5nXG4gIC8vIGZyb20gdGhlaXIgc3VwZXJjbGFzcyBvYmplY3QgKHVwIHRvIGBDbGFzc2AgaXRzZWxmKS5cbiAgLy9cbiAgLy8gTk9URTogQWN0dWFsbHkgaW4gTVJJIGEgY2xhc3MnIHNpbmdsZXRvbiBjbGFzcyBpbmhlcml0cyBmcm9tIGl0c1xuICAvLyBzdXBlcmNsYXNzJyBzaW5nbGV0b24gY2xhc3Mgd2hpY2ggaW4gdHVybiBpbmhlcml0cyBmcm9tIENsYXNzLlxuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgW0NsYXNzXVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIGlmIChrbGFzcy4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBrbGFzcy4kJG1ldGE7XG4gICAgfVxuXG4gICAgLy8gVGhlIHNpbmdsZXRvbl9jbGFzcyBzdXBlcmNsYXNzIGlzIHRoZSBzaW5nbGV0b25fY2xhc3Mgb2YgaXRzIHN1cGVyY2xhc3M7XG4gICAgLy8gYnV0IEJhc2ljT2JqZWN0IGhhcyBubyBzdXBlcmNsYXNzIChpdHMgYCQkc3VwZXJgIGlzIG51bGwpLCB0aHVzIHdlXG4gICAgLy8gZmFsbGJhY2sgb24gYENsYXNzYC5cbiAgICB2YXIgc3VwZXJjbGFzcyA9IGtsYXNzID09PSBCYXNpY09iamVjdCA/IENsYXNzIDogT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKGtsYXNzLiQkc3VwZXIpO1xuXG4gICAgdmFyIG1ldGEgPSAkYWxsb2NhdGVfY2xhc3MobnVsbCwgc3VwZXJjbGFzcywgdHJ1ZSk7XG5cbiAgICAkcHJvcChtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkcHJvcChtZXRhLCAnJCRzaW5nbGV0b25fb2YnLCBrbGFzcyk7XG4gICAgc2V0X21ldGEoa2xhc3MsIG1ldGEpO1xuICAgIC8vIFJlc3RvcmluZyBDbGFzc05hbWUuY2xhc3NcbiAgICAkcHJvcChrbGFzcywgJyQkY2xhc3MnLCBPcGFsLkNsYXNzKTtcblxuICAgIHJldHVybiBtZXRhO1xuICB9O1xuXG4gIE9wYWwuYnVpbGRfbW9kdWxlX3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgIGlmIChtb2QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gbW9kLiQkbWV0YTtcbiAgICB9XG5cbiAgICB2YXIgbWV0YSA9ICRhbGxvY2F0ZV9jbGFzcyhudWxsLCBPcGFsLk1vZHVsZSwgdHJ1ZSk7XG5cbiAgICAkcHJvcChtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkcHJvcChtZXRhLCAnJCRzaW5nbGV0b25fb2YnLCBtb2QpO1xuICAgIHNldF9tZXRhKG1vZCwgbWV0YSk7XG4gICAgLy8gUmVzdG9yaW5nIE1vZHVsZU5hbWUuY2xhc3NcbiAgICAkcHJvcChtb2QsICckJGNsYXNzJywgT3BhbC5Nb2R1bGUpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYSBSdWJ5IChub24gY2xhc3MpIE9iamVjdC5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9vYmplY3Rfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIHN1cGVyY2xhc3MgPSBvYmplY3QuJCRjbGFzcyxcbiAgICAgICAga2xhc3MgPSAkYWxsb2NhdGVfY2xhc3MobmlsLCBzdXBlcmNsYXNzLCB0cnVlKTtcblxuICAgICRwcm9wKGtsYXNzLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkcHJvcChrbGFzcywgJyQkc2luZ2xldG9uX29mJywgb2JqZWN0KTtcblxuICAgIGRlbGV0ZSBrbGFzcy4kJHByb3RvdHlwZS4kJGNsYXNzO1xuXG4gICAgc2V0X21ldGEob2JqZWN0LCBrbGFzcyk7XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgT3BhbC5pc19tZXRob2QgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChwcm9wWzBdID09PSAnJCcgJiYgcHJvcFsxXSAhPT0gJyQnKTtcbiAgfTtcblxuICBPcGFsLmluc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgZXhjbHVkZSA9IFtdLCByZXN1bHRzID0gW10sIGFuY2VzdG9ycyA9ICRhbmNlc3RvcnMobW9kKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldLFxuICAgICAgICAgIHByb3RvID0gYW5jZXN0b3IuJCRwcm90b3R5cGU7XG5cbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgbGwgPSBwcm9wcy5sZW5ndGg7IGogPCBsbDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG5cbiAgICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKHByb3ApKSB7XG4gICAgICAgICAgdmFyIG1ldGhvZF9uYW1lID0gcHJvcC5zbGljZSgxKSxcbiAgICAgICAgICAgICAgbWV0aG9kID0gcHJvdG9bcHJvcF07XG5cbiAgICAgICAgICBpZiAobWV0aG9kLiQkc3R1YiAmJiBleGNsdWRlLmluZGV4T2YobWV0aG9kX25hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgZXhjbHVkZS5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW1ldGhvZC4kJHN0dWIgJiYgcmVzdWx0cy5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgIHZhciByZXN1bHRzID0gW10sXG4gICAgICAgIHByb3RvID0gbW9kLiQkcHJvdG90eXBlO1xuXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcHJvcHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG5cbiAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gcHJvdG9bcHJvcF07XG5cbiAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViKSB7XG4gICAgICAgICAgdmFyIG1ldGhvZF9uYW1lID0gcHJvcC5zbGljZSgxKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgT3BhbC5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIE9wYWwuaW5zdGFuY2VfbWV0aG9kcyhvYmouJCRtZXRhIHx8IG9iai4kJGNsYXNzKTtcbiAgfTtcblxuICBPcGFsLm93bl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iai4kJG1ldGEgPyBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG9iai4kJG1ldGEpIDogW107XG4gIH07XG5cbiAgT3BhbC5yZWNlaXZlcl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG1vZCA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopO1xuICAgIHZhciBzaW5nbGV0b25fbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kKTtcbiAgICB2YXIgaW5zdGFuY2VfbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kLiQkc3VwZXIpO1xuICAgIHJldHVybiBzaW5nbGV0b25fbWV0aG9kcy5jb25jYXQoaW5zdGFuY2VfbWV0aG9kcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgcGFpcnMgb2YgbmFtZXMvdmFsdWVzXG4gIC8vIGZvciBhbGwgY2xhc3MgdmFyaWFibGVzIGRlZmluZWQgaW4gcHJvdmlkZWQgK21vZHVsZStcbiAgLy8gYW5kIGl0cyBhbmNlc3RvcnMuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHJldHVybiBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSksXG4gICAgICAgIGksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yIChpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXTtcblxuICAgICAgZm9yICh2YXIgY3ZhciBpbiBhbmNlc3Rvci4kJGN2YXJzKSB7XG4gICAgICAgIHJlc3VsdFtjdmFyXSA9IGFuY2VzdG9yLiQkY3ZhcnNbY3Zhcl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTZXRzIGNsYXNzIHZhcmlhYmxlIHdpdGggc3BlY2lmaWVkICtuYW1lKyB0byArdmFsdWUrXG4gIC8vIGluIHByb3ZpZGVkICttb2R1bGUrXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHBhcmFtIG5hbWUgW1N0cmluZ11cbiAgLy8gQHBhcmFtIHZhbHVlIFtPYmplY3RdXG4gIE9wYWwuY2xhc3NfdmFyaWFibGVfc2V0ID0gZnVuY3Rpb24obW9kdWxlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSksXG4gICAgICAgIGksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXG4gICAgICBpZiAoJGhhc19vd24oYW5jZXN0b3IuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgYW5jZXN0b3IuJCRjdmFyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZXRzIGNsYXNzIHZhcmlhYmxlIHdpdGggc3BlY2lmaWVkICtuYW1lKyBmcm9tIHByb3ZpZGVkICttb2R1bGUrXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHBhcmFtIG5hbWUgW1N0cmluZ11cbiAgT3BhbC5jbGFzc192YXJpYWJsZV9nZXQgPSBmdW5jdGlvbihtb2R1bGUsIG5hbWUsIHRvbGVyYW50KSB7XG4gICAgaWYgKCRoYXNfb3duKG1vZHVsZS4kJGN2YXJzLCBuYW1lKSlcbiAgICAgIHJldHVybiBtb2R1bGUuJCRjdmFyc1tuYW1lXTtcblxuICAgIHZhciBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSksXG4gICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGlmICgkaGFzX293bihhbmNlc3Rvci4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3IuJCRjdmFyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRvbGVyYW50KVxuICAgICAgJHJhaXNlKE9wYWwuTmFtZUVycm9yLCAndW5pbml0aWFsaXplZCBjbGFzcyB2YXJpYWJsZSAnK25hbWUrJyBpbiAnK21vZHVsZS4kbmFtZSgpKTtcblxuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jvb3QocHJvdG8pIHtcbiAgICByZXR1cm4gcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX2luY2x1ZGVkX21vZHVsZXMobW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XG5cbiAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICAgIC8vIHN1cGVyY2xhc3NcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcbiAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgIH1cbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX3ByZXBlbmRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgICAgaWYgKHByb3RvID09PSBtb2R1bGUuJCRwcm90b3R5cGUuJCRkZWZpbmVfbWV0aG9kc19vbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8vIFRoZSBhY3R1YWwgaW5jbHVzaW9uIG9mIGEgbW9kdWxlIGludG8gYSBjbGFzcy5cbiAgLy9cbiAgLy8gIyMgQ2xhc3MgYCQkcGFyZW50YCBhbmQgYGljbGFzc2BcbiAgLy9cbiAgLy8gVG8gaGFuZGxlIGBzdXBlcmAgY2FsbHMsIGV2ZXJ5IGNsYXNzIGhhcyBhIGAkJHBhcmVudGAuIFRoaXMgcGFyZW50IGlzXG4gIC8vIHVzZWQgdG8gcmVzb2x2ZSB0aGUgbmV4dCBjbGFzcyBmb3IgYSBzdXBlciBjYWxsLiBBIG5vcm1hbCBjbGFzcyB3b3VsZFxuICAvLyBoYXZlIHRoaXMgcG9pbnQgdG8gaXRzIHN1cGVyY2xhc3MuIEhvd2V2ZXIsIGlmIGEgY2xhc3MgaW5jbHVkZXMgYSBtb2R1bGVcbiAgLy8gdGhlbiB0aGlzIHdvdWxkIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG1vZHVsZS4gVGhlIG1vZHVsZSB3b3VsZFxuICAvLyBhbHNvIGhhdmUgdG8gdGhlbiBwb2ludCBpdHMgYCQkcGFyZW50YCB0byB0aGUgYWN0dWFsIHN1cGVyY2xhc3MuIFdlXG4gIC8vIGNhbm5vdCBtb2RpZnkgbW9kdWxlcyBsaWtlIHRoaXMsIGJlY2F1c2UgaXQgbWlnaHQgYmUgaW5jbHVkZWQgaW4gbW9yZVxuICAvLyB0aGVuIG9uZSBjbGFzcy4gVG8gZml4IHRoaXMsIHdlIGFjdHVhbGx5IGluc2VydCBhbiBgaWNsYXNzYCBhcyB0aGUgY2xhc3MnXG4gIC8vIGAkJHBhcmVudGAgd2hpY2ggY2FuIHRoZW4gcG9pbnQgdG8gdGhlIHN1cGVyY2xhc3MuIFRoZSBgaWNsYXNzYCBhY3RzIGFzXG4gIC8vIGEgcHJveHkgdG8gdGhlIGFjdHVhbCBtb2R1bGUsIHNvIHRoZSBgc3VwZXJgIGNoYWluIGNhbiB0aGVuIHNlYXJjaCBpdCBmb3JcbiAgLy8gdGhlIHJlcXVpcmVkIG1ldGhvZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXSB0aGUgbW9kdWxlIHRvIGluY2x1ZGVcbiAgLy8gQHBhcmFtIGluY2x1ZGVyIFtNb2R1bGVdIHRoZSB0YXJnZXQgY2xhc3MgdG8gaW5jbHVkZSBtb2R1bGUgaW50b1xuICAvLyBAcmV0dXJuIFtudWxsXVxuICBPcGFsLmFwcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgaW5jbHVkZXIpIHtcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9ICRhbmNlc3RvcnMobW9kdWxlKTtcbiAgICB2YXIgaWNsYXNzZXMgPSBbXTtcblxuICAgIGlmIChtb2R1bGVfYW5jZXN0b3JzLmluZGV4T2YoaW5jbHVkZXIpICE9PSAtMSkge1xuICAgICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgJ2N5Y2xpYyBpbmNsdWRlIGRldGVjdGVkJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1vZHVsZV9hbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IG1vZHVsZV9hbmNlc3RvcnNbaV0sIGljbGFzcyA9IGNyZWF0ZV9pY2xhc3MoYW5jZXN0b3IpO1xuICAgICAgJHByb3AoaWNsYXNzLCAnJCRpbmNsdWRlZCcsIHRydWUpO1xuICAgICAgaWNsYXNzZXMucHVzaChpY2xhc3MpO1xuICAgIH1cbiAgICB2YXIgaW5jbHVkZXJfYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhpbmNsdWRlciksXG4gICAgICAgIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGluY2x1ZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIGluY2x1ZGVcblxuICAgICAgLy8gaW5jbHVkZXIgLT4gY2hhaW4uZmlyc3QgLT4gLi4uY2hhaW4uLi4gLT4gY2hhaW4ubGFzdCAtPiBpbmNsdWRlci5wYXJlbnRcbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGhhcyBiZWVuIGFscmVhZHkgaW5jbHVkZWQsXG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHB1dCBpdCBpbnRvIHRoZSBhbmNlc3RvcnMgY2hhaW4gYWdhaW4sXG4gICAgICAvLyBidXQgdGhpcyBtb2R1bGUgbWF5IGhhdmUgbmV3IGluY2x1ZGVkIG1vZHVsZXMuXG4gICAgICAvLyBJZiBpdCdzIHRydWUgd2UgbmVlZCB0byBjb3B5IHRoZW0uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHNpbXBsZXN0IHdheSBpcyB0byByZXBsYWNlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBgbW9kdWxlYCBpY2xhc3MgKGhhcyBhICQkcm9vdCBmbGFnKVxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIC4uLnByZXZpb3MgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXMgLi4uXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIHRvXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5yZWdlbmVyYXRlZCBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlc1xuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXG4gICAgICAvL1xuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBhcmUgbm8gaW50ZXJtZWRpYXRlIGNsYXNzZXMgYmV0d2VlbiBgcGFyZW50YCBhbmQgYG5leHQgYW5jZXN0b3JgLlxuICAgICAgLy8gSXQgZG9lc24ndCBicmVhayBhbnkgcHJvdG90eXBlcyBvZiBvdGhlciBvYmplY3RzIGFzIHdlIGRvbid0IGNoYW5nZSBjbGFzcyByZWZlcmVuY2VzLlxuXG4gICAgICB2YXIgcGFyZW50ID0gaW5jbHVkZXIuJCRwcm90b3R5cGUsIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcblxuICAgICAgd2hpbGUgKG1vZHVsZV9pY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAobW9kdWxlX2ljbGFzcy4kJG1vZHVsZSA9PT0gbW9kdWxlICYmIGlzUm9vdChtb2R1bGVfaWNsYXNzKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gbW9kdWxlX2ljbGFzcztcbiAgICAgICAgbW9kdWxlX2ljbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZHVsZV9pY2xhc3MpIHtcbiAgICAgICAgLy8gbW9kdWxlIGhhcyBiZWVuIGRpcmVjdGx5IGluY2x1ZGVkXG4gICAgICAgIHZhciBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9pY2xhc3MpO1xuXG4gICAgICAgIC8vIHNraXAgbm9uLXJvb3QgaWNsYXNzZXMgKHRoYXQgd2VyZSByZWN1cnNpdmVseSBpbmNsdWRlZClcbiAgICAgICAgd2hpbGUgKG5leHRfYW5jZXN0b3IuaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgIWlzUm9vdChuZXh0X2FuY2VzdG9yKSkge1xuICAgICAgICAgIG5leHRfYW5jZXN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV4dF9hbmNlc3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlciA9IHBhcmVudDtcbiAgICAgICAgZW5kX2NoYWluX29uID0gbmV4dF9hbmNlc3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vZHVsZSBoYXMgbm90IGJlZW4gZGlyZWN0bHkgaW5jbHVkZWQgYnV0IHdhcyBpbiBhbmNlc3RvciBjaGFpbiBiZWNhdXNlIGl0IHdhcyBpbmNsdWRlZCBieSBhbm90aGVyIG1vZHVsZVxuICAgICAgICAvLyBpbmNsdWRlIGl0IGRpcmVjdGx5XG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbmNsdWRlci4kJHByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9pbmNsdWRlZF9tb2R1bGVzIGNhY2hlXG4gICAgaW5jbHVkZXIuJCRvd25faW5jbHVkZWRfbW9kdWxlcyA9IG93bl9pbmNsdWRlZF9tb2R1bGVzKGluY2x1ZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIE9wYWwucHJlcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgcHJlcGVuZGVyKSB7XG4gICAgLy8gSGVyZSB3ZSBjaGFuZ2UgdGhlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgLy9cbiAgICAvLyAgIHByZXBlbmRlclxuICAgIC8vICAgICAgfFxuICAgIC8vICAgIHBhcmVudFxuICAgIC8vXG4gICAgLy8gdG86XG4gICAgLy9cbiAgICAvLyBkdW1teShwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gIGljbGFzcyhtb2R1bGUpXG4gICAgLy8gICAgICB8XG4gICAgLy8gaWNsYXNzKHByZXBlbmRlcilcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9ICRhbmNlc3RvcnMobW9kdWxlKTtcbiAgICB2YXIgaWNsYXNzZXMgPSBbXTtcblxuICAgIGlmIChtb2R1bGVfYW5jZXN0b3JzLmluZGV4T2YocHJlcGVuZGVyKSAhPT0gLTEpIHtcbiAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsICdjeWNsaWMgcHJlcGVuZCBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRwcm9wKGljbGFzcywgJyQkcHJlcGVuZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuXG4gICAgdmFyIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBkdW1teV9wcmVwZW5kZXIgPSBwcmVwZW5kZXIuJCRwcm90b3R5cGUsXG4gICAgICAgIHByZXZpb3VzX3BhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpLFxuICAgICAgICBwcmVwZW5kZXJfaWNsYXNzLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGR1bW15X3ByZXBlbmRlci5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGFscmVhZHkgaGFzIHNvbWUgcHJlcGVuZGVkIG1vZHVsZXNcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBtYWtlIGl0IFwiZHVtbXlcIlxuICAgICAgcHJlcGVuZGVyX2ljbGFzcyA9IGR1bW15X3ByZXBlbmRlci4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNYWtpbmcgdGhlIG1vZHVsZSBcImR1bW15XCJcbiAgICAgIHByZXBlbmRlcl9pY2xhc3MgPSBjcmVhdGVfZHVtbXlfaWNsYXNzKHByZXBlbmRlcik7XG4gICAgICBmbHVzaF9tZXRob2RzX2luKHByZXBlbmRlcik7XG4gICAgICAkcHJvcChkdW1teV9wcmVwZW5kZXIsICckJGR1bW15JywgdHJ1ZSk7XG4gICAgICAkcHJvcChkdW1teV9wcmVwZW5kZXIsICckJGRlZmluZV9tZXRob2RzX29uJywgcHJlcGVuZGVyX2ljbGFzcyk7XG5cbiAgICAgIC8vIENvbnZlcnRpbmdcbiAgICAgIC8vICAgZHVtbXkocHJlcGVuZGVyKSAtPiBwcmV2aW91c19wYXJlbnRcbiAgICAgIC8vIHRvXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gaWNsYXNzKHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAkc2V0X3Byb3RvKGR1bW15X3ByZXBlbmRlciwgcHJlcGVuZGVyX2ljbGFzcyk7XG4gICAgICAkc2V0X3Byb3RvKHByZXBlbmRlcl9pY2xhc3MsIHByZXZpb3VzX3BhcmVudCk7XG4gICAgfVxuXG4gICAgdmFyIHByZXBlbmRlcl9hbmNlc3RvcnMgPSAkYW5jZXN0b3JzKHByZXBlbmRlcik7XG5cbiAgICBpZiAocHJlcGVuZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIHByZXBlbmRcblxuICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBkdW1teV9wcmVwZW5kZXI7XG5cbiAgICAgIC8vIG5leHQgJCRyb290IG9yIHByZXBlbmRlcl9pY2xhc3Mgb3Igbm9uLSQkaWNsYXNzXG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZHVtbXlfcHJlcGVuZGVyKTtcbiAgICAgIHdoaWxlIChlbmRfY2hhaW5fb24gIT0gbnVsbCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZW5kX2NoYWluX29uLmhhc093blByb3BlcnR5KCckJHJvb3QnKSB8fFxuICAgICAgICAgIGVuZF9jaGFpbl9vbiA9PT0gcHJlcGVuZGVyX2ljbGFzcyB8fFxuICAgICAgICAgICFlbmRfY2hhaW5fb24uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZW5kX2NoYWluX29uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHJhaXNlKE9wYWwuUnVudGltZUVycm9yLCBcIlByZXBlbmRpbmcgYSBtb2R1bGUgbXVsdGlwbGUgdGltZXMgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG5cbiAgICAkc2V0X3Byb3RvKHN0YXJ0X2NoYWluX2FmdGVyLCBjaGFpbi5maXJzdCk7XG4gICAgJHNldF9wcm90byhjaGFpbi5sYXN0LCBlbmRfY2hhaW5fb24pO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgb3duX3ByZXBlbmRlZF9tb2R1bGVzIGNhY2hlXG4gICAgcHJlcGVuZGVyLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzID0gb3duX3ByZXBlbmRlZF9tb2R1bGVzKHByZXBlbmRlcik7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgfTtcblxuICBmdW5jdGlvbiBmbHVzaF9tZXRob2RzX2luKG1vZHVsZSkge1xuICAgIHZhciBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZSxcbiAgICAgICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKHByb3ApKSB7XG4gICAgICAgIGRlbGV0ZSBwcm90b1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVfaWNsYXNzKG1vZHVsZSkge1xuICAgIHZhciBpY2xhc3MgPSBjcmVhdGVfZHVtbXlfaWNsYXNzKG1vZHVsZSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBtb2R1bGUuJCRpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGljbGFzcztcbiAgfVxuXG4gIC8vIER1bW15IGljbGFzcyBkb2Vzbid0IHJlY2VpdmUgdXBkYXRlcyB3aGVuIHRoZSBtb2R1bGUgZ2V0cyBhIG5ldyBtZXRob2QuXG4gIGZ1bmN0aW9uIGNyZWF0ZV9kdW1teV9pY2xhc3MobW9kdWxlKSB7XG4gICAgdmFyIGljbGFzcyA9IHt9LFxuICAgICAgICBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAkcHJvcChpY2xhc3MsIHByb3AsIHByb3RvW3Byb3BdKTtcbiAgICB9XG5cbiAgICAkcHJvcChpY2xhc3MsICckJGljbGFzcycsIHRydWUpO1xuICAgICRwcm9wKGljbGFzcywgJyQkbW9kdWxlJywgbW9kdWxlKTtcblxuICAgIHJldHVybiBpY2xhc3M7XG4gIH1cblxuICBmdW5jdGlvbiBjaGFpbl9pY2xhc3NlcyhpY2xhc3Nlcykge1xuICAgIHZhciBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGgsIGZpcnN0ID0gaWNsYXNzZXNbMF07XG5cbiAgICAkcHJvcChmaXJzdCwgJyQkcm9vdCcsIHRydWUpO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBmaXJzdCB9O1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91cyA9IGZpcnN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpY2xhc3Nlc1tpXTtcbiAgICAgICRzZXRfcHJvdG8ocHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHsgZmlyc3Q6IGljbGFzc2VzWzBdLCBsYXN0OiBpY2xhc3Nlc1tsZW5ndGggLSAxXSB9O1xuICB9XG5cbiAgLy8gRm9yIHBlcmZvcm1hbmNlLCBzb21lIGNvcmUgUnVieSBjbGFzc2VzIGFyZSB0b2xsLWZyZWUgYnJpZGdlZCB0byB0aGVpclxuICAvLyBuYXRpdmUgSmF2YVNjcmlwdCBjb3VudGVycGFydHMgKGUuZy4gYSBSdWJ5IEFycmF5IGlzIGEgSmF2YVNjcmlwdCBBcnJheSkuXG4gIC8vXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0dXAgYSBuYXRpdmUgY29uc3RydWN0b3IgKGUuZy4gQXJyYXkpLCB0byBoYXZlXG4gIC8vIGl0cyBwcm90b3R5cGUgYWN0IGxpa2UgYSBub3JtYWwgUnVieSBjbGFzcy4gRmlyc3RseSwgYSBuZXcgUnVieSBjbGFzcyBpc1xuICAvLyBjcmVhdGVkIHVzaW5nIHRoZSBuYXRpdmUgY29uc3RydWN0b3Igc28gdGhhdCBpdHMgcHJvdG90eXBlIGlzIHNldCBhcyB0aGVcbiAgLy8gdGFyZ2V0IGZvciB0aGUgbmV3IGNsYXNzLiBOb3RlOiBhbGwgYnJpZGdlZCBjbGFzc2VzIGFyZSBzZXQgdG8gaW5oZXJpdFxuICAvLyBmcm9tIE9iamVjdC5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgT3BhbC5icmlkZ2Uoc2VsZiwgRnVuY3Rpb24pO1xuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgICAgICAgW0NsYXNzXSB0aGUgUnVieSBjbGFzcyB0byBicmlkZ2VcbiAgLy8gQHBhcmFtIGNvbnN0cnVjdG9yIFtKUy5GdW5jdGlvbl0gbmF0aXZlIEphdmFTY3JpcHQgY29uc3RydWN0b3IgdG8gdXNlXG4gIC8vIEByZXR1cm4gW0NsYXNzXSByZXR1cm5zIHRoZSBwYXNzZWQgUnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmJyaWRnZSA9IGZ1bmN0aW9uKG5hdGl2ZV9rbGFzcywga2xhc3MpIHtcbiAgICBpZiAobmF0aXZlX2tsYXNzLmhhc093blByb3BlcnR5KCckJGJyaWRnZScpKSB7XG4gICAgICAkcmFpc2UoT3BhbC5Bcmd1bWVudEVycm9yLCBcImFscmVhZHkgYnJpZGdlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBhIEpTIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUgY2hhaW4gbGlrZTpcbiAgICAvLyAtIGNvbnN0cnVjdG9yXG4gICAgLy8gICAtIHN1cGVyXG4gICAgLy9cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZG8gaXMgdG8gaW5qZWN0IG91ciBjbGFzcyAod2l0aCBpdHMgcHJvdG90eXBlIGNoYWluKVxuICAgIC8vIGJldHdlZW4gY29uc3RydWN0b3IgYW5kIHN1cGVyLiBGb3IgZXhhbXBsZSwgYWZ0ZXIgaW5qZWN0aW5nIDo6T2JqZWN0XG4gICAgLy8gaW50byBKUyBTdHJpbmcgd2UgZ2V0OlxuICAgIC8vXG4gICAgLy8gLSBjb25zdHJ1Y3RvciAod2luZG93LlN0cmluZylcbiAgICAvLyAgIC0gT3BhbC5PYmplY3RcbiAgICAvLyAgICAgLSBPcGFsLktlcm5lbFxuICAgIC8vICAgICAgIC0gT3BhbC5CYXNpY09iamVjdFxuICAgIC8vICAgICAgICAgLSBzdXBlciAod2luZG93Lk9iamVjdClcbiAgICAvLyAgICAgICAgICAgLSBudWxsXG4gICAgLy9cbiAgICAkcHJvcChuYXRpdmVfa2xhc3MsICckJGJyaWRnZScsIGtsYXNzKTtcbiAgICAkc2V0X3Byb3RvKG5hdGl2ZV9rbGFzcy5wcm90b3R5cGUsIChrbGFzcy4kJHN1cGVyIHx8IE9wYWwuT2JqZWN0KS4kJHByb3RvdHlwZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJHByb3RvdHlwZScsIG5hdGl2ZV9rbGFzcy5wcm90b3R5cGUpO1xuXG4gICAgJHByb3Aoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRjb25zdHJ1Y3RvcicsIG5hdGl2ZV9rbGFzcyk7XG4gICAgJHByb3Aoa2xhc3MsICckJGJyaWRnZScsIHRydWUpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHByb3RvVG9Nb2R1bGUocHJvdG8pIHtcbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykpIHtcbiAgICAgIHJldHVybiBwcm90by4kJG1vZHVsZTtcbiAgICB9IGVsc2UgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGNsYXNzJykpIHtcbiAgICAgIHJldHVybiBwcm90by4kJGNsYXNzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG93bl9hbmNlc3RvcnMobW9kdWxlKSB7XG4gICAgcmV0dXJuIG1vZHVsZS4kJG93bl9wcmVwZW5kZWRfbW9kdWxlcy5jb25jYXQoW21vZHVsZV0pLmNvbmNhdChtb2R1bGUuJCRvd25faW5jbHVkZWRfbW9kdWxlcyk7XG4gIH1cblxuICAvLyBUaGUgQXJyYXkgb2YgYW5jZXN0b3JzIGZvciBhIGdpdmVuIG1vZHVsZS9jbGFzc1xuICBmdW5jdGlvbiAkYW5jZXN0b3JzKG1vZHVsZSkge1xuICAgIGlmICghbW9kdWxlKSB7IHJldHVybiBbXTsgfVxuXG4gICAgaWYgKG1vZHVsZS4kJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uID09PSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24pIHtcbiAgICAgIHJldHVybiBtb2R1bGUuJCRhbmNlc3RvcnM7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IFtdLCBpLCBtb2RzLCBsZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwLCBtb2RzID0gb3duX2FuY2VzdG9ycyhtb2R1bGUpLCBsZW5ndGggPSBtb2RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChtb2RzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAobW9kdWxlLiQkc3VwZXIpIHtcbiAgICAgIGZvciAoaSA9IDAsIG1vZHMgPSAkYW5jZXN0b3JzKG1vZHVsZS4kJHN1cGVyKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChtb2RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcbiAgICBtb2R1bGUuJCRhbmNlc3RvcnMgPSByZXN1bHQ7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBPcGFsLmFuY2VzdG9ycyA9ICRhbmNlc3RvcnM7XG5cbiAgT3BhbC5pbmNsdWRlZF9tb2R1bGVzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QgPSBudWxsLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgZm9yICg7IHByb3RvICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSkge1xuICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICBpZiAobW9kICYmIG1vZC4kJGlzX21vZHVsZSAmJiBwcm90by4kJGljbGFzcyAmJiBwcm90by4kJGluY2x1ZGVkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuXG4gIC8vIE1ldGhvZCBNaXNzaW5nXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gTWV0aG9kcyBzdHVicyBhcmUgdXNlZCB0byBmYWNpbGl0YXRlIG1ldGhvZF9taXNzaW5nIGluIG9wYWwuIEEgc3R1YiBpcyBhXG4gIC8vIHBsYWNlaG9sZGVyIGZ1bmN0aW9uIHdoaWNoIGp1c3QgY2FsbHMgYG1ldGhvZF9taXNzaW5nYCBvbiB0aGUgcmVjZWl2ZXIuXG4gIC8vIElmIG5vIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIGFjdHVhbGx5IGRlZmluZWQgb24gYW4gb2JqZWN0LCB0aGVuIGl0XG4gIC8vIGlzIG9idmlvdXMgdG8gc2F5IHRoYXQgdGhlIHN0dWIgd2lsbCBiZSBjYWxsZWQgaW5zdGVhZCwgYW5kIHRoZW4gaW4gdHVyblxuICAvLyBtZXRob2RfbWlzc2luZyB3aWxsIGJlIGNhbGxlZC5cbiAgLy9cbiAgLy8gV2hlbiBhIGZpbGUgaW4gcnVieSBnZXRzIGNvbXBpbGVkIHRvIGphdmFzY3JpcHQsIGl0IGluY2x1ZGVzIGEgY2FsbCB0b1xuICAvLyB0aGlzIGZ1bmN0aW9uIHdoaWNoIGFkZHMgc3R1YnMgZm9yIGV2ZXJ5IG1ldGhvZCBuYW1lIGluIHRoZSBjb21waWxlZCBmaWxlLlxuICAvLyBJdCBzaG91bGQgdGhlbiBiZSBzYWZlIHRvIGFzc3VtZSB0aGF0IG1ldGhvZF9taXNzaW5nIHdpbGwgd29yayBmb3IgYW55XG4gIC8vIG1ldGhvZCBjYWxsIGRldGVjdGVkLlxuICAvL1xuICAvLyBNZXRob2Qgc3R1YnMgYXJlIGFkZGVkIHRvIHRoZSBCYXNpY09iamVjdCBwcm90b3R5cGUsIHdoaWNoIGV2ZXJ5IG90aGVyXG4gIC8vIHJ1Ynkgb2JqZWN0IGluaGVyaXRzLCBzbyBhbGwgb2JqZWN0cyBzaG91bGQgaGFuZGxlIG1ldGhvZCBtaXNzaW5nLiBBIHN0dWJcbiAgLy8gaXMgb25seSBhZGRlZCBpZiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZSAobWV0aG9kIG5hbWUpIGlzIG5vdCBhbHJlYWR5XG4gIC8vIGRlZmluZWQuXG4gIC8vXG4gIC8vIE5vdGU6IGFsbCBydWJ5IG1ldGhvZHMgaGF2ZSBhIGAkYCBwcmVmaXggaW4gamF2YXNjcmlwdCwgc28gYWxsIHN0dWJzIHdpbGxcbiAgLy8gaGF2ZSB0aGlzIHByZWZpeCBhcyB3ZWxsICh0byBtYWtlIHRoaXMgbWV0aG9kIG1vcmUgcGVyZm9ybWFudCkuXG4gIC8vXG4gIC8vICAgIE9wYWwuYWRkX3N0dWJzKFwiZm9vLGJhcixiYXo9XCIpO1xuICAvL1xuICAvLyBBbGwgc3R1YiBmdW5jdGlvbnMgd2lsbCBoYXZlIGEgcHJpdmF0ZSBgJCRzdHViYCBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZSBzb1xuICAvLyB0aGF0IG90aGVyIGludGVybmFsIG1ldGhvZHMgY2FuIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBqdXN0IGEgc3R1YiBvciBub3QuXG4gIC8vIGBLZXJuZWwjcmVzcG9uZF90bz9gIHVzZXMgdGhpcyBwcm9wZXJ0eSB0byBkZXRlY3QgYSBtZXRob2RzIHByZXNlbmNlLlxuICAvL1xuICAvLyBAcGFyYW0gc3R1YnMgW0FycmF5XSBhbiBhcnJheSBvZiBtZXRob2Qgc3R1YnMgdG8gYWRkXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1YnMgPSBmdW5jdGlvbihzdHVicykge1xuICAgIHZhciBwcm90byA9IE9wYWwuQmFzaWNPYmplY3QuJCRwcm90b3R5cGU7XG4gICAgdmFyIHN0dWIsIGV4aXN0aW5nX21ldGhvZDtcbiAgICBzdHVicyA9IHN0dWJzLnNwbGl0KCcsJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3R1YnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0dWIgPSAkanNpZChzdHVic1tpXSksIGV4aXN0aW5nX21ldGhvZCA9IHByb3RvW3N0dWJdO1xuXG4gICAgICBpZiAoZXhpc3RpbmdfbWV0aG9kID09IG51bGwgfHwgZXhpc3RpbmdfbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICBPcGFsLmFkZF9zdHViX2Zvcihwcm90bywgc3R1Yik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZCBhIG1ldGhvZF9taXNzaW5nIHN0dWIgZnVuY3Rpb24gdG8gdGhlIGdpdmVuIHByb3RvdHlwZSBmb3IgdGhlXG4gIC8vIGdpdmVuIG5hbWUuXG4gIC8vXG4gIC8vIEBwYXJhbSBwcm90b3R5cGUgW1Byb3RvdHlwZV0gdGhlIHRhcmdldCBwcm90b3R5cGVcbiAgLy8gQHBhcmFtIHN0dWIgW1N0cmluZ10gc3R1YiBuYW1lIHRvIGFkZCAoZS5nLiBcIiRmb29cIilcbiAgLy8gQHJldHVybiBbdW5kZWZpbmVkXVxuICBPcGFsLmFkZF9zdHViX2ZvciA9IGZ1bmN0aW9uKHByb3RvdHlwZSwgc3R1Yikge1xuICAgIC8vIE9wYWwuc3R1Yl9mb3Ioc3R1YikgaXMgdGhlIG1ldGhvZF9taXNzaW5nX3N0dWJcbiAgICAkcHJvcChwcm90b3R5cGUsIHN0dWIsIE9wYWwuc3R1Yl9mb3Ioc3R1YikpO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIHRoZSBtZXRob2RfbWlzc2luZyBzdHViIGZvciBhIGdpdmVuIG1ldGhvZCBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gbWV0aG9kX25hbWUgW1N0cmluZ10gVGhlIGpzLW5hbWUgb2YgdGhlIG1ldGhvZCB0byBzdHViIChlLmcuIFwiJGZvb1wiKVxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuc3R1Yl9mb3IgPSBmdW5jdGlvbihtZXRob2RfbmFtZSkge1xuXG4gICAgZnVuY3Rpb24gbWV0aG9kX21pc3Npbmdfc3R1YigpIHtcbiAgICAgIC8vIENvcHkgYW55IGdpdmVuIGJsb2NrIG9udG8gdGhlIG1ldGhvZF9taXNzaW5nIGRpc3BhdGNoZXJcbiAgICAgIHRoaXMuJG1ldGhvZF9taXNzaW5nLiQkcCA9IG1ldGhvZF9taXNzaW5nX3N0dWIuJCRwO1xuXG4gICAgICAvLyBTZXQgYmxvY2sgcHJvcGVydHkgdG8gbnVsbCByZWFkeSBmb3IgdGhlIG5leHQgY2FsbCAoc3RvcCBmYWxzZS1wb3NpdGl2ZXMpXG4gICAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkcCA9IG51bGw7XG5cbiAgICAgIC8vIGNhbGwgbWV0aG9kIG1pc3Npbmcgd2l0aCBjb3JyZWN0IGFyZ3MgKHJlbW92ZSAnJCcgcHJlZml4IG9uIG1ldGhvZCBuYW1lKVxuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3VtZW50c1tpXTsgfVxuXG4gICAgICByZXR1cm4gdGhpcy4kbWV0aG9kX21pc3NpbmcuYXBwbHkodGhpcywgW21ldGhvZF9uYW1lLnNsaWNlKDEpXS5jb25jYXQoYXJnc19hcnkpKTtcbiAgICB9XG5cbiAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkc3R1YiA9IHRydWU7XG5cbiAgICByZXR1cm4gbWV0aG9kX21pc3Npbmdfc3R1YjtcbiAgfTtcblxuXG4gIC8vIE1ldGhvZHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIG1ldGhvZHNcbiAgLy9cbiAgLy8gQHBhcmFtIGFjdHVhbCBbRml4bnVtXSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuIHRvIG1ldGhvZFxuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIG93bmVyIG9mIHRoZSBtZXRob2QgK21ldGgrXG4gIC8vIEBwYXJhbSBtZXRoIFtTdHJpbmddIG1ldGhvZCBuYW1lIHRoYXQgZ290IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHJhaXNlIFtBcmd1bWVudEVycm9yXVxuICBPcGFsLmFjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgb2JqZWN0LCBtZXRoKSB7XG4gICAgdmFyIGluc3BlY3QgPSAnJztcbiAgICBpZiAob2JqZWN0LiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGluc3BlY3QgKz0gb2JqZWN0LiQkbmFtZSArICcuJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJGNsYXNzLiQkbmFtZSArICcjJztcbiAgICB9XG4gICAgaW5zcGVjdCArPSBtZXRoO1xuXG4gICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgJ1snICsgaW5zcGVjdCArICddIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuICcgKyBhY3R1YWwgKyAnLCBleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnKScpO1xuICB9O1xuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIGJsb2Nrc1xuICAvL1xuICAvLyBAcGFyYW0gYWN0dWFsIFtGaXhudW1dIG51bWJlciBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gYmxvY2tcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIGNvbnRleHQgW09iamVjdF0gY29udGV4dCBvZiB0aGUgYmxvY2sgZGVmaW5pdGlvblxuICAvLyBAcmFpc2UgW0FyZ3VtZW50RXJyb3JdXG4gIE9wYWwuYmxvY2tfYWMgPSBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3BlY3QgPSBcImBibG9jayBpbiBcIiArIGNvbnRleHQgKyBcIidcIjtcblxuICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsIGluc3BlY3QgKyAnOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAnICsgYWN0dWFsICsgJywgZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJyknKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRfYW5jZXN0b3JzKG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpICYmIG9iai4kJG1ldGEgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiAkYW5jZXN0b3JzKG9iai4kJG1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJGFuY2VzdG9ycyhvYmouJCRjbGFzcyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFN1cGVyIGRpc3BhdGNoZXJcbiAgT3BhbC5maW5kX3N1cGVyID0gZnVuY3Rpb24ob2JqLCBtaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2ssIGFsbG93X3N0dWJzKSB7XG4gICAgdmFyIGpzaWQgPSAkanNpZChtaWQpLCBhbmNlc3RvcnMsIHN1cGVyX21ldGhvZDtcblxuICAgIGFuY2VzdG9ycyA9IGdldF9hbmNlc3RvcnMob2JqKTtcblxuICAgIHZhciBjdXJyZW50X2luZGV4ID0gYW5jZXN0b3JzLmluZGV4T2YoY3VycmVudF9mdW5jLiQkb3duZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnRfaW5kZXggKyAxOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV0sXG4gICAgICAgICAgcHJvdG8gPSBhbmNlc3Rvci4kJHByb3RvdHlwZTtcblxuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoanNpZCkpIHtcbiAgICAgICAgc3VwZXJfbWV0aG9kID0gcHJvdG9banNpZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGVmY2hlY2sgJiYgc3VwZXJfbWV0aG9kICYmIHN1cGVyX21ldGhvZC4kJHN0dWIgJiYgb2JqLiRtZXRob2RfbWlzc2luZy4kJHByaXN0aW5lKSB7XG4gICAgICAvLyBtZXRob2RfbWlzc2luZyBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgICRyYWlzZShPcGFsLk5vTWV0aG9kRXJyb3IsICdzdXBlcjogbm8gc3VwZXJjbGFzcyBtZXRob2QgYCcrbWlkK1wiJyBmb3IgXCIrb2JqLCBtaWQpO1xuICAgIH1cblxuICAgIHJldHVybiAoc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiAhYWxsb3dfc3R1YnMpID8gbnVsbCA6IHN1cGVyX21ldGhvZDtcbiAgfTtcblxuICAvLyBJdGVyIGRpc3BhdGNoZXIgZm9yIHN1cGVyIGluIGEgYmxvY2tcbiAgT3BhbC5maW5kX2Jsb2NrX3N1cGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xuICAgIHZhciBjYWxsX2pzaWQgPSBqc2lkO1xuXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcbiAgICAgICRyYWlzZShPcGFsLlJ1bnRpbWVFcnJvciwgXCJzdXBlciBjYWxsZWQgb3V0c2lkZSBvZiBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKGltcGxpY2l0ICYmIGN1cnJlbnRfZnVuYy4kJGRlZmluZV9tZXRoKSB7XG4gICAgICAkcmFpc2UoT3BhbC5SdW50aW1lRXJyb3IsXG4gICAgICAgIFwiaW1wbGljaXQgYXJndW1lbnQgcGFzc2luZyBvZiBzdXBlciBmcm9tIG1ldGhvZCBkZWZpbmVkIGJ5IGRlZmluZV9tZXRob2QoKSBpcyBub3Qgc3VwcG9ydGVkLiBcIiArXG4gICAgICAgIFwiU3BlY2lmeSBhbGwgYXJndW1lbnRzIGV4cGxpY2l0bHlcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudF9mdW5jLiQkZGVmKSB7XG4gICAgICBjYWxsX2pzaWQgPSBjdXJyZW50X2Z1bmMuJCRqc2lkO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmZpbmRfc3VwZXIob2JqLCBjYWxsX2pzaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2spO1xuICB9O1xuXG4gIC8vIEBkZXByZWNhdGVkXG4gIE9wYWwuZmluZF9zdXBlcl9kaXNwYXRjaGVyID0gT3BhbC5maW5kX3N1cGVyO1xuXG4gIC8vIEBkZXByZWNhdGVkXG4gIE9wYWwuZmluZF9pdGVyX3N1cGVyX2Rpc3BhdGNoZXIgPSBPcGFsLmZpbmRfYmxvY2tfc3VwZXI7XG5cbiAgLy8gaGFuZGxlcyB5aWVsZCBjYWxscyBmb3IgMSB5aWVsZGVkIGFyZ1xuICBPcGFsLnlpZWxkMSA9IGZ1bmN0aW9uKGJsb2NrLCBhcmcpIHtcbiAgICBpZiAodHlwZW9mKGJsb2NrKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAkcmFpc2UoT3BhbC5Mb2NhbEp1bXBFcnJvciwgXCJubyBibG9jayBnaXZlblwiKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzX21saHMgPSBibG9jay4kJGhhc190b3BfbGV2ZWxfbWxoc19hcmcsXG4gICAgICAgIGhhc190cmFpbGluZ19jb21tYSA9IGJsb2NrLiQkaGFzX3RyYWlsaW5nX2NvbW1hX2luX2FyZ3M7XG5cbiAgICBpZiAoYmxvY2subGVuZ3RoID4gMSB8fCAoKGhhc19tbGhzIHx8IGhhc190cmFpbGluZ19jb21tYSkgJiYgYmxvY2subGVuZ3RoID09PSAxKSkge1xuICAgICAgYXJnID0gT3BhbC50b19hcnkoYXJnKTtcbiAgICB9XG5cbiAgICBpZiAoKGJsb2NrLmxlbmd0aCA+IDEgfHwgKGhhc190cmFpbGluZ19jb21tYSAmJiBibG9jay5sZW5ndGggPT09IDEpKSAmJiBhcmcuJCRpc19hcnJheSkge1xuICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGJsb2NrKGFyZyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGhhbmRsZXMgeWllbGQgZm9yID4gMSB5aWVsZGVkIGFyZ1xuICBPcGFsLnlpZWxkWCA9IGZ1bmN0aW9uKGJsb2NrLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgJHJhaXNlKE9wYWwuTG9jYWxKdW1wRXJyb3IsIFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChhcmdzWzBdLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3NbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXJncy4kJGlzX2FycmF5KSB7XG4gICAgICB2YXIgYXJnc19hcnkgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3NbaV07IH1cblxuICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3NfYXJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2suYXBwbHkobnVsbCwgYXJncyk7XG4gIH07XG5cbiAgLy8gRmluZHMgdGhlIGNvcnJlc3BvbmRpbmcgZXhjZXB0aW9uIG1hdGNoIGluIGNhbmRpZGF0ZXMuICBFYWNoIGNhbmRpZGF0ZSBjYW5cbiAgLy8gYmUgYSB2YWx1ZSwgb3IgYW4gYXJyYXkgb2YgdmFsdWVzLiAgUmV0dXJucyBudWxsIGlmIG5vdCBmb3VuZC5cbiAgT3BhbC5yZXNjdWUgPSBmdW5jdGlvbihleGNlcHRpb24sIGNhbmRpZGF0ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW2ldO1xuXG4gICAgICBpZiAoY2FuZGlkYXRlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IE9wYWwucmVzY3VlKGV4Y2VwdGlvbiwgY2FuZGlkYXRlKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlID09PSBPcGFsLkpTLkVycm9yIHx8IGNhbmRpZGF0ZVsnJD09PSddKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBPcGFsLmlzX2EgPSBmdW5jdGlvbihvYmplY3QsIGtsYXNzKSB7XG4gICAgaWYgKGtsYXNzICE9IG51bGwgJiYgb2JqZWN0LiQkbWV0YSA9PT0ga2xhc3MgfHwgb2JqZWN0LiQkY2xhc3MgPT09IGtsYXNzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0LiQkaXNfbnVtYmVyICYmIGtsYXNzLiQkaXNfbnVtYmVyX2NsYXNzKSB7XG4gICAgICByZXR1cm4gKGtsYXNzLiQkaXNfaW50ZWdlcl9jbGFzcykgPyAob2JqZWN0ICUgMSkgPT09IDAgOiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG9iamVjdC4kJGlzX2NsYXNzID8gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iamVjdCkgOiAob2JqZWN0LiQkbWV0YSB8fCBvYmplY3QuJCRjbGFzcykpO1xuXG4gICAgcmV0dXJuIGFuY2VzdG9ycy5pbmRleE9mKGtsYXNzKSAhPT0gLTE7XG4gIH07XG5cbiAgLy8gSGVscGVycyBmb3IgZXh0cmFjdGluZyBrd3NwbGF0c1xuICAvLyBVc2VkIGZvcjogeyAqKmggfVxuICBPcGFsLnRvX2hhc2ggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19oYXNoJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBoYXNoID0gdmFsdWUuJHRvX2hhc2goKTtcbiAgICAgIGlmIChoYXNoLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEhhc2ggKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2hhc2ggZ2l2ZXMgXCIgKyBoYXNoLiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIgaW50byBIYXNoXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBpbXBsZW1lbnRpbmcgbXVsdGlwbGUgYXNzaWdubWVudFxuICAvLyBPdXIgY29kZSBmb3IgZXh0cmFjdGluZyB0aGUgdmFsdWVzIGFuZCBhc3NpZ25pbmcgdGhlbSBvbmx5IHdvcmtzIGlmIHRoZVxuICAvLyByZXR1cm4gdmFsdWUgaXMgYSBKUyBhcnJheS5cbiAgLy8gU28gaWYgd2UgZ2V0IGFuIEFycmF5IHN1YmNsYXNzLCBleHRyYWN0IHRoZSB3cmFwcGVkIEpTIGFycmF5IGZyb20gaXRcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9IHNvbWV0aGluZyAobm8gc3BsYXQpXG4gIE9wYWwudG9fYXJ5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2FyeScsIHRydWUpKSB7XG4gICAgICB2YXIgYXJ5ID0gdmFsdWUuJHRvX2FyeSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hcnkgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3I6IGEsIGIgPSAqc29tZXRoaW5nICh3aXRoIHNwbGF0KVxuICBPcGFsLnRvX2EgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICAvLyBBIHNwbGF0dGVkIGFycmF5IG11c3QgYmUgY29waWVkXG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19hJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hIGdpdmVzIFwiICsgYXJ5LiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgZm9yIGV4dHJhY3Rpbmcga2V5d29yZCBhcmd1bWVudHMgZnJvbSBhcmd1bWVudHMgcGFzc2VkIHRvXG4gIC8vIEpTIGZ1bmN0aW9uLiBJZiBwcm92aWRlZCArYXJndW1lbnRzKyBsaXN0IGRvZXNuJ3QgaGF2ZSBhIEhhc2hcbiAgLy8gYXMgYSBsYXN0IGl0ZW0sIHJldHVybnMgYSBibGFuayBIYXNoLlxuICAvL1xuICAvLyBAcGFyYW0gcGFyYW1ldGVycyBbQXJyYXldXG4gIC8vIEByZXR1cm4gW0hhc2hdXG4gIC8vXG4gIE9wYWwuZXh0cmFjdF9rd2FyZ3MgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIGt3YXJncyA9IHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXTtcbiAgICBpZiAoa3dhcmdzICE9IG51bGwgJiYgT3BhbC5yZXNwb25kX3RvKGt3YXJncywgJyR0b19oYXNoJywgdHJ1ZSkpIHtcbiAgICAgICRzcGxpY2UocGFyYW1ldGVycywgcGFyYW1ldGVycy5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiBrd2FyZ3M7XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgdG8gZ2V0IGEgbGlzdCBvZiByZXN0IGtleXdvcmQgYXJndW1lbnRzLiBNZXRob2QgdGFrZXMgdGhlIGdpdmVuXG4gIC8vIGtleXdvcmQgYXJncywgaS5lLiB0aGUgaGFzaCBsaXRlcmFsIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNvbnRhaW5pbmcgYWxsXG4gIC8vIGtleXdvcmQgYXJndWVtbnRzIHBhc3NlZCB0byBtZXRob2QsIGFzIHdlbGwgYXMgdGhlIHVzZWQgYXJncyB3aGljaCBhcmVcbiAgLy8gdGhlIG5hbWVzIG9mIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgZGVmaW5lZC4gVGhpcyBtZXRob2QgdGhlblxuICAvLyBqdXN0IHJldHVybnMgYWxsIGtleS92YWx1ZSBwYWlycyB3aGljaCBoYXZlIG5vdCBiZWVuIHVzZWQsIGluIGEgbmV3XG4gIC8vIGhhc2ggbGl0ZXJhbC5cbiAgLy9cbiAgLy8gQHBhcmFtIGdpdmVuX2FyZ3MgW0hhc2hdIGFsbCBrd2FyZ3MgZ2l2ZW4gdG8gbWV0aG9kXG4gIC8vIEBwYXJhbSB1c2VkX2FyZ3MgW09iamVjdDxTdHJpbmc6IHRydWU+XSBhbGwga2V5cyB1c2VkIGFzIG5hbWVkIGt3YXJnc1xuICAvLyBAcmV0dXJuIFtIYXNoXVxuICAvL1xuICBPcGFsLmt3cmVzdGFyZ3MgPSBmdW5jdGlvbihnaXZlbl9hcmdzLCB1c2VkX2FyZ3MpIHtcbiAgICB2YXIga2V5cyAgICAgID0gW10sXG4gICAgICAgIG1hcCAgICAgICA9IHt9LFxuICAgICAgICBrZXkgICAgICAgICAgICxcbiAgICAgICAgZ2l2ZW5fbWFwID0gZ2l2ZW5fYXJncy4kJHNtYXA7XG5cbiAgICBmb3IgKGtleSBpbiBnaXZlbl9tYXApIHtcbiAgICAgIGlmICghdXNlZF9hcmdzW2tleV0pIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIG1hcFtrZXldID0gZ2l2ZW5fbWFwW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuaGFzaDIoa2V5cywgbWFwKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhcHBseV9ibG9ja29wdHMoYmxvY2ssIGJsb2Nrb3B0cykge1xuICAgIGlmICh0eXBlb2YoYmxvY2tvcHRzKSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJsb2NrLiQkYXJpdHkgPSBibG9ja29wdHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZihibG9ja29wdHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmFzc2lnbihibG9jaywgYmxvY2tvcHRzKTtcbiAgICB9XG4gIH1cblxuICAvLyBPcHRpbWl6YXRpb24gZm9yIGEgY29zdGx5IG9wZXJhdGlvbiBvZiBwcmVwZW5kaW5nICckJyB0byBtZXRob2QgbmFtZXNcbiAgdmFyIGpzaWRfY2FjaGUgPSB7fVxuICBmdW5jdGlvbiAkanNpZChuYW1lKSB7XG4gICAgcmV0dXJuIGpzaWRfY2FjaGVbbmFtZV0gfHwgKGpzaWRfY2FjaGVbbmFtZV0gPSAnJCcgKyBuYW1lKTtcbiAgfVxuICBPcGFsLmpzaWQgPSAkanNpZDtcblxuICAvLyBDYWxscyBwYXNzZWQgbWV0aG9kIG9uIGEgcnVieSBvYmplY3Qgd2l0aCBhcmd1bWVudHMgYW5kIGJsb2NrOlxuICAvL1xuICAvLyBDYW4gdGFrZSBhIG1ldGhvZCBvciBhIG1ldGhvZCBuYW1lLlxuICAvL1xuICAvLyAxLiBXaGVuIG1ldGhvZCBuYW1lIGdldHMgcGFzc2VkIGl0IGludm9rZXMgaXQgYnkgaXRzIG5hbWVcbiAgLy8gICAgYW5kIGNhbGxzICdtZXRob2RfbWlzc2luZycgd2hlbiBvYmplY3QgZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgbWV0aG9kIHRoYXQgdGFrZXMgYSBibG9jayBvciBhIHNwbGF0LlxuICAvLyAyLiBXaGVuIG1ldGhvZCAoaS5lLiBtZXRob2QgYm9keSkgZ2V0cyBwYXNzZWQsIGl0IGRvZXNuJ3QgdHJpZ2dlciAnbWV0aG9kX21pc3NpbmcnXG4gIC8vICAgIGJlY2F1c2UgaXQgZG9lc24ndCBrbm93IHRoZSBuYW1lIG9mIHRoZSBhY3R1YWwgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgJ3N1cGVyJy5cbiAgLy9cbiAgLy8gQGV4YW1wbGVcbiAgLy8gICB2YXIgbXlfYXJyYXkgPSBbMSwgMiwgMywgNF1cbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksICdsZW5ndGgnKSAgICAgICAgICAgICAgICAgICAgIyA9PiA0XG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheS4kbGVuZ3RoKSAgICAgICAgICAgICMgPT4gNFxuICAvL1xuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ3JldmVyc2UhJykgICAgICAgICAgICAgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgbXlfYXJyYXlbJyRyZXZlcnNlISddJykgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvL1xuICAvLyBAcGFyYW0gcmVjdiBbT2JqZWN0XSBydWJ5IG9iamVjdFxuICAvLyBAcGFyYW0gbWV0aG9kIFtGdW5jdGlvbiwgU3RyaW5nXSBtZXRob2QgYm9keSBvciBuYW1lIG9mIHRoZSBtZXRob2RcbiAgLy8gQHBhcmFtIGFyZ3MgW0FycmF5XSBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNhbGxcbiAgLy8gQHBhcmFtIGJsb2NrIFtGdW5jdGlvbl0gcnVieSBibG9ja1xuICAvLyBAcGFyYW0gYmxvY2tvcHRzIFtPYmplY3QsIE51bWJlcl0gb3B0aW9uYWwgcHJvcGVydGllcyB0byBzZXQgb24gdGhlIGJsb2NrXG4gIC8vIEByZXR1cm4gW09iamVjdF0gcmV0dXJuaW5nIHZhbHVlIG9mIHRoZSBtZXRob2QgY2FsbFxuICBPcGFsLnNlbmQgPSBmdW5jdGlvbihyZWN2LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICB2YXIgYm9keTtcblxuICAgIGlmICh0eXBlb2YobWV0aG9kKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm9keSA9IG1ldGhvZDtcbiAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YobWV0aG9kKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJvZHkgPSByZWN2WyRqc2lkKG1ldGhvZCldO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcmFpc2UoT3BhbC5OYW1lRXJyb3IsIFwiUGFzc2VkIG1ldGhvZCBzaG91bGQgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5zZW5kMihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpO1xuICB9O1xuXG4gIE9wYWwuc2VuZDIgPSBmdW5jdGlvbihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICBpZiAoYm9keSA9PSBudWxsICYmIG1ldGhvZCAhPSBudWxsICYmIHJlY3YuJG1ldGhvZF9taXNzaW5nKSB7XG4gICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XG4gICAgICBhcmdzID0gW21ldGhvZF0uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIGFwcGx5X2Jsb2Nrb3B0cyhibG9jaywgYmxvY2tvcHRzKTtcblxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XG4gIH07XG5cbiAgT3BhbC5yZWZpbmVkX3NlbmQgPSBmdW5jdGlvbihyZWZpbmVtZW50X2dyb3VwcywgcmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKSB7XG4gICAgdmFyIGksIGosIGssIGFuY2VzdG9ycywgYW5jZXN0b3IsIHJlZmluZW1lbnRzLCByZWZpbmVtZW50LCByZWZpbmVfbW9kdWxlcywgcmVmaW5lX21vZHVsZSwgYm9keTtcblxuICAgIGFuY2VzdG9ycyA9IGdldF9hbmNlc3RvcnMocmVjdik7XG5cbiAgICAvLyBGb3IgYWxsIGFuY2VzdG9ycyB0aGF0IHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgY2xvc2VzdCB0byB0aGUgZnVydGhlc3QuLi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmNlc3RvciA9IE9wYWwuaWQoYW5jZXN0b3JzW2ldKTtcblxuICAgICAgLy8gRm9yIGFsbCByZWZpbmVtZW50IGdyb3VwcyB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGNsb3Nlc3Qgc2NvcGUgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICBmb3IgKGogPSAwOyBqIDwgcmVmaW5lbWVudF9ncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmVmaW5lbWVudHMgPSByZWZpbmVtZW50X2dyb3Vwc1tqXTtcblxuICAgICAgICAvLyBGb3IgYWxsIHJlZmluZW1lbnRzIHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgbGFzdCBgdXNpbmdgIGNhbGwgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICAgIGZvciAoayA9IHJlZmluZW1lbnRzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgcmVmaW5lbWVudCA9IHJlZmluZW1lbnRzW2tdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzID09PSAndW5kZWZpbmVkJykgY29udGludWU7XG5cbiAgICAgICAgICAvLyBBIHNpbmdsZSBtb2R1bGUgYmVpbmcgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgb2YgdGhlIGB1c2luZ2AgY2FsbCBjb250YWlucyBtdWx0aXBsZVxuICAgICAgICAgIC8vIHJlZmluZW1lbnQgbW9kdWxlc1xuICAgICAgICAgIHJlZmluZV9tb2R1bGVzID0gcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzO1xuXG4gICAgICAgICAgLy8gRG9lcyB0aGlzIG1vZHVsZSByZWZpbmUgYSBnaXZlbiBjYWxsIGZvciBhIGdpdmVuIGFuY2VzdG9yIG1vZHVsZT9cbiAgICAgICAgICBpZiAodHlwZW9mIHJlZmluZV9tb2R1bGVzW2FuY2VzdG9yXSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuICAgICAgICAgIHJlZmluZV9tb2R1bGUgPSByZWZpbmVfbW9kdWxlc1thbmNlc3Rvcl07XG5cbiAgICAgICAgICAvLyBEb2VzIHRoaXMgbW9kdWxlIGRlZmluZSBhIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGw/XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVfbW9kdWxlLiQkcHJvdG90eXBlWyRqc2lkKG1ldGhvZCldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYm9keSA9IHJlZmluZV9tb2R1bGUuJCRwcm90b3R5cGVbJGpzaWQobWV0aG9kKV07XG4gICAgICAgICAgICByZXR1cm4gT3BhbC5zZW5kMihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQocmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKTtcbiAgfTtcblxuICBPcGFsLmxhbWJkYSA9IGZ1bmN0aW9uKGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICBibG9jay4kJGlzX2xhbWJkYSA9IHRydWU7XG5cbiAgICBhcHBseV9ibG9ja29wdHMoYmxvY2ssIGJsb2Nrb3B0cyk7XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBkZWZpbmUgbWV0aG9kcyBvbiBhbiBvYmplY3QuIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kLCB1c2VkIGJ5IHRoZVxuICAvLyBjb21waWxlZCBzb3VyY2UgdG8gZGVmaW5lIG1ldGhvZHMgb24gc3BlY2lhbCBjYXNlIG9iamVjdHMgd2hlbiB0aGUgY29tcGlsZXJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxuICAvLyBpbnN0YW5jZS4gVGhpcyBjYW4gZ2V0IGNhbGxlZCBieSBgTW9kdWxlI2RlZmluZV9tZXRob2RgIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE1vZHVsZXNcbiAgLy9cbiAgLy8gQW55IG1ldGhvZCBkZWZpbmVkIG9uIGEgbW9kdWxlIHdpbGwgY29tZSB0aHJvdWdoIHRoaXMgcnVudGltZSBoZWxwZXIuXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcbiAgLy8gc2V0IHRvIGJlIHRoZSBtb2R1bGUgaXRzZWxmLiBUaGlzIGlzIHVzZWQgbGF0ZXIgd2hlbiBjaG9vc2luZyB3aGljaFxuICAvLyBtZXRob2Qgc2hvdWxkIHNob3cgb24gYSBjbGFzcyBpZiBtb3JlIHRoYW4gMSBpbmNsdWRlZCBtb2R1bGVzIGRlZmluZVxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcbiAgLy8gdGhlbiB0aGUgbWV0aG9kIGlzIGFsc28gZGVmaW5lZCBvbnRvIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAvL1xuICAvLyAjIyBDbGFzc2VzXG4gIC8vXG4gIC8vIFRoaXMgaGVscGVyIHdpbGwgb25seSBiZSBjYWxsZWQgZm9yIGNsYXNzZXMgd2hlbiBhIG1ldGhvZCBpcyBiZWluZ1xuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcbiAgLy8gbGl0ZXJhbCBgZGVmYCBtZXRob2QgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBvciBgY2xhc3NfZXZhbGAgYm9keS4gSW5cbiAgLy8gZWl0aGVyIGNhc2UsIHRoZSBtZXRob2QgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlLiBBIHNwZWNpYWxcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxuICAvLyBzcGVjaWFsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0b2xsLWZyZWUgYnJpZGdlZCBjbGFzc2VzLiBJbiBlYWNoIG9mXG4gIC8vIHRoZXNlIHR3byBjYXNlcywgZXh0cmEgd29yayBpcyByZXF1aXJlZCB0byBkZWZpbmUgdGhlIG1ldGhvZHMgb24gdG9sbC1mcmVlXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgT2JqZWN0c1xuICAvL1xuICAvLyBJZiBhIHNpbXBsZSBydWJ5IG9iamVjdCBpcyB0aGUgb2JqZWN0LCB0aGVuIHRoZSBtZXRob2QgaXMgc2ltcGx5IGp1c3RcbiAgLy8gZGVmaW5lZCBvbiB0aGUgb2JqZWN0IGFzIGEgc2luZ2xldG9uIG1ldGhvZC4gVGhpcyB3b3VsZCBiZSB0aGUgY2FzZSB3aGVuXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iaiAgW09iamVjdCwgQ2xhc3NdIHRoZSBhY3R1YWwgb2JqIHRvIGRlZmluZSBtZXRob2QgZm9yXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcbiAgLy8gQHBhcmFtIGJvZHkgW0pTLkZ1bmN0aW9uXSB0aGUgbGl0ZXJhbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHVzZWQgYXMgbWV0aG9kXG4gIC8vIEBwYXJhbSBibG9ja29wdHMgW09iamVjdCwgTnVtYmVyXSBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIHNldCBvbiB0aGUgYm9keVxuICAvLyBAcmV0dXJuIFtudWxsXVxuICAvL1xuICBPcGFsLmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSwgYmxvY2tvcHRzKSB7XG4gICAgYXBwbHlfYmxvY2tvcHRzKGJvZHksIGJsb2Nrb3B0cyk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgbWV0aG9kIGRlZmluaXRpb24gaW4gdGhlXG4gICAgLy8gdG9wLWxldmVsIG5hbWVzcGFjZVxuICAgIGlmIChvYmogPT09IE9wYWwudG9wKSB7XG4gICAgICByZXR1cm4gT3BhbC5kZWZuKE9wYWwuT2JqZWN0LCBqc2lkLCBib2R5KTtcbiAgICB9XG4gICAgLy8gaWYgaW5zdGFuY2VfZXZhbCBpcyBpbnZva2VkIG9uIGEgbW9kdWxlL2NsYXNzLCBpdCBzZXRzIGluc3RfZXZhbF9tb2RcbiAgICBlbHNlIGlmICghb2JqLiQkZXZhbCAmJiBvYmouJCRpc19hX21vZHVsZSkge1xuICAgICAgcmV0dXJuIE9wYWwuZGVmbihvYmosIGpzaWQsIGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIG1ldGhvZCBvbiBhIG1vZHVsZSBvciBjbGFzcyAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZuID0gZnVuY3Rpb24obW9kdWxlLCBqc2lkLCBib2R5KSB7XG4gICAgJGRlbnlfZnJvemVuX2FjY2Vzcyhtb2R1bGUpO1xuXG4gICAgYm9keS5kaXNwbGF5TmFtZSA9IGpzaWQ7XG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xuXG4gICAgdmFyIG5hbWUgPSBqc2lkLnN1YnN0cigxKTtcblxuICAgIHZhciBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZTtcbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cbiAgICAkcHJvcChwcm90bywganNpZCwgYm9keSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLiQkbW9kdWxlX2Z1bmN0aW9uKSB7XG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNsYXNzID0gaWNsYXNzZXNbaV07XG4gICAgICAgICRwcm9wKGljbGFzcywganNpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpbmdsZXRvbl9vZiA9IG1vZHVsZS4kJHNpbmdsZXRvbl9vZjtcbiAgICBpZiAobW9kdWxlLiRtZXRob2RfYWRkZWQgJiYgIW1vZHVsZS4kbWV0aG9kX2FkZGVkLiQkc3R1YiAmJiAhc2luZ2xldG9uX29mKSB7XG4gICAgICBtb2R1bGUuJG1ldGhvZF9hZGRlZChuYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2luZ2xldG9uX29mICYmIHNpbmdsZXRvbl9vZi4kc2luZ2xldG9uX21ldGhvZF9hZGRlZCAmJiAhc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkLiQkc3R1Yikge1xuICAgICAgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkKG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG4gIC8vIERlZmluZSBhIHNpbmdsZXRvbiBtZXRob2Qgb24gdGhlIGdpdmVuIG9iamVjdCAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZzID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5LCBibG9ja29wdHMpIHtcbiAgICBhcHBseV9ibG9ja29wdHMoYm9keSwgYmxvY2tvcHRzKTtcblxuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE9wYWwuZGVmbihPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwganNpZCwgYm9keSk7XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3JlbW92ZV9tZXRob2QuXG4gIE9wYWwucmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCkge1xuICAgIGlmICghJGhhc19vd24ob2JqLiQkcHJvdG90eXBlLCBqc2lkKSkge1xuICAgICAgJHJhaXNlKE9wYWwuTmFtZUVycm9yLCBcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb2JqLiQkcHJvdG90eXBlW2pzaWRdO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF9yZW1vdmVkICYmICFvYmouJG1ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3VuZGVmX21ldGhvZC5cbiAgT3BhbC51ZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xuICAgICAgJHJhaXNlKE9wYWwuTmFtZUVycm9yLCBcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBPcGFsLmFkZF9zdHViX2ZvcihvYmouJCRwcm90b3R5cGUsIGpzaWQpO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiRtZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfbWV0aG9kX2JvZHkoYm9keSkge1xuICAgIHJldHVybiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKTtcbiAgfVxuXG4gIE9wYWwuYWxpYXMgPSBmdW5jdGlvbihvYmosIG5hbWUsIG9sZCkge1xuICAgIHZhciBpZCAgICAgPSAkanNpZChuYW1lKSxcbiAgICAgICAgb2xkX2lkID0gJGpzaWQob2xkKSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgYWxpYXM7XG5cbiAgICAvLyBBbGlhc2luZyBvbiBtYWluIG1lYW5zIGFsaWFzaW5nIG9uIE9iamVjdC4uLlxuICAgIGlmICh0eXBlb2Ygb2JqLiQkcHJvdG90eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2JqID0gT3BhbC5PYmplY3Q7XG4gICAgfVxuXG4gICAgYm9keSA9IG9iai4kJHByb3RvdHlwZVtvbGRfaWRdO1xuXG4gICAgLy8gV2hlbiBydW5uaW5nIGluc2lkZSAjaW5zdGFuY2VfZXZhbCB0aGUgYWxpYXMgcmVmZXJzIHRvIGNsYXNzIG1ldGhvZHMuXG4gICAgaWYgKG9iai4kJGV2YWwpIHtcbiAgICAgIHJldHVybiBPcGFsLmFsaWFzKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopLCBuYW1lLCBvbGQpO1xuICAgIH1cblxuICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkpIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IG9iai4kJHN1cGVyO1xuXG4gICAgICB3aGlsZSAodHlwZW9mKGJvZHkpICE9PSBcImZ1bmN0aW9uXCIgJiYgYW5jZXN0b3IpIHtcbiAgICAgICAgYm9keSAgICAgPSBhbmNlc3RvcltvbGRfaWRdO1xuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLiQkc3VwZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkgJiYgb2JqLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgIC8vIHRyeSB0byBsb29rIGludG8gT2JqZWN0XG4gICAgICAgIGJvZHkgPSBPcGFsLk9iamVjdC4kJHByb3RvdHlwZVtvbGRfaWRdXG4gICAgICB9XG5cbiAgICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkpIHtcbiAgICAgICAgJHJhaXNlKE9wYWwuTmFtZUVycm9yLCBcInVuZGVmaW5lZCBtZXRob2QgYFwiICsgb2xkICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBib2R5IGlzIGl0c2VsZiBhbiBhbGlhcyB1c2UgdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAvLyB0byBrZWVwIHRoZSBtYXggZGVwdGggYXQgMS5cbiAgICBpZiAoYm9keS4kJGFsaWFzX29mKSBib2R5ID0gYm9keS4kJGFsaWFzX29mO1xuXG4gICAgLy8gV2UgbmVlZCBhIHdyYXBwZXIgYmVjYXVzZSBvdGhlcndpc2UgcHJvcGVydGllc1xuICAgIC8vIHdvdWxkIGJlIG92ZXJ3cml0dGVuIG9uIHRoZSBvcmlnaW5hbCBib2R5LlxuICAgIGFsaWFzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmxvY2sgPSBhbGlhcy4kJHAsIGFyZ3MsIGksIGlpO1xuXG4gICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgZm9yKGkgPSAwLCBpaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG5cbiAgICAgIGFsaWFzLiQkcCA9IG51bGw7XG5cbiAgICAgIHJldHVybiBPcGFsLnNlbmQodGhpcywgYm9keSwgYXJncywgYmxvY2spO1xuICAgIH07XG5cbiAgICAvLyBBc3NpZ24gdGhlICdsZW5ndGgnIHZhbHVlIHdpdGggZGVmaW5lUHJvcGVydHkgYmVjYXVzZVxuICAgIC8vIGluIHN0cmljdCBtb2RlIHRoZSBwcm9wZXJ0eSBpcyBub3Qgd3JpdGFibGUuXG4gICAgLy8gSXQgZG9lc24ndCB3b3JrIGluIG9sZGVyIGJyb3dzZXJzIChsaWtlIENocm9tZSAzOCksIHdoZXJlXG4gICAgLy8gYW4gZXhjZXB0aW9uIGlzIHRocm93biBicmVha2luZyBPcGFsIGFsdG9nZXRoZXIuXG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbGlhcywgJ2xlbmd0aCcsIHsgdmFsdWU6IGJvZHkubGVuZ3RoIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBUcnkgdG8gbWFrZSB0aGUgYnJvd3NlciBwaWNrIHRoZSByaWdodCBuYW1lXG4gICAgYWxpYXMuZGlzcGxheU5hbWUgICAgICAgPSBuYW1lO1xuXG4gICAgYWxpYXMuJCRhcml0eSAgICAgICAgICAgPSBib2R5LiQkYXJpdHkgPT0gbnVsbCA/IGJvZHkubGVuZ3RoIDogYm9keS4kJGFyaXR5O1xuICAgIGFsaWFzLiQkcGFyYW1ldGVycyAgICAgID0gYm9keS4kJHBhcmFtZXRlcnM7XG4gICAgYWxpYXMuJCRzb3VyY2VfbG9jYXRpb24gPSBib2R5LiQkc291cmNlX2xvY2F0aW9uO1xuICAgIGFsaWFzLiQkYWxpYXNfb2YgICAgICAgID0gYm9keTtcbiAgICBhbGlhcy4kJGFsaWFzX25hbWUgICAgICA9IG5hbWU7XG5cbiAgICBPcGFsLmRlZm4ob2JqLCBpZCwgYWxpYXMpO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICBPcGFsLmFsaWFzX2d2YXIgPSBmdW5jdGlvbihuZXdfbmFtZSwgb2xkX25hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoJGd2YXJzLCBuZXdfbmFtZSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkZ3ZhcnNbb2xkX25hbWVdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24obmV3X3ZhbHVlKSB7XG4gICAgICAgICRndmFyc1tvbGRfbmFtZV0gPSBuZXdfdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5pbDtcbiAgfVxuXG4gIE9wYWwuYWxpYXNfbmF0aXZlID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBuYXRpdmVfbmFtZSkge1xuICAgIHZhciBpZCAgID0gJGpzaWQobmFtZSksXG4gICAgICAgIGJvZHkgPSBvYmouJCRwcm90b3R5cGVbbmF0aXZlX25hbWVdO1xuXG4gICAgaWYgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiIHx8IGJvZHkuJCRzdHViKSB7XG4gICAgICAkcmFpc2UoT3BhbC5OYW1lRXJyb3IsIFwidW5kZWZpbmVkIG5hdGl2ZSBtZXRob2QgYFwiICsgbmF0aXZlX25hbWUgKyBcIicgZm9yIGNsYXNzIGBcIiArIG9iai4kbmFtZSgpICsgXCInXCIpXG4gICAgfVxuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGJvZHkpO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuXG4gIC8vIEhhc2hlc1xuICAvLyAtLS0tLS1cblxuICBPcGFsLmhhc2hfaW5pdCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLiQkc21hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaGFzaC4kJG1hcCAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRrZXlzID0gW107XG4gIH07XG5cbiAgT3BhbC5oYXNoX2Nsb25lID0gZnVuY3Rpb24oZnJvbV9oYXNoLCB0b19oYXNoKSB7XG4gICAgdG9faGFzaC4kJG5vbmUgPSBmcm9tX2hhc2guJCRub25lO1xuICAgIHRvX2hhc2guJCRwcm9jID0gZnJvbV9oYXNoLiQkcHJvYztcblxuICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gZnJvbV9oYXNoLiQka2V5cywgc21hcCA9IGZyb21faGFzaC4kJHNtYXAsIGxlbiA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgdmFsdWUgPSBzbWFwW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5oYXNoX3B1dCh0b19oYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX3B1dCA9IGZ1bmN0aW9uKGhhc2gsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICBpZiAoISRoYXNfb3duKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIGhhc2guJCRrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIGhhc2guJCRzbWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICghJGhhc19vd24oaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICBidWNrZXQgPSB7a2V5OiBrZXksIGtleV9oYXNoOiBrZXlfaGFzaCwgdmFsdWU6IHZhbHVlfTtcbiAgICAgIGhhc2guJCRrZXlzLnB1c2goYnVja2V0KTtcbiAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gYnVja2V0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuXG4gICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJ1Y2tldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICBidWNrZXQgPSB7a2V5OiBrZXksIGtleV9oYXNoOiBrZXlfaGFzaCwgdmFsdWU6IHZhbHVlfTtcbiAgICAgIGhhc2guJCRrZXlzLnB1c2goYnVja2V0KTtcbiAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQ7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9nZXQgPSBmdW5jdGlvbihoYXNoLCBrZXkpIHtcbiAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICBpZiAoJGhhc19vd24oaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGhhc2guJCRzbWFwW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleV9oYXNoLCBidWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICgkaGFzX293bihoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1Y2tldC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2RlbGV0ZSA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIHZhciBpLCBrZXlzID0gaGFzaC4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCB2YWx1ZSwga2V5X3RtcDtcblxuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSBrZXkgPSBrZXkudmFsdWVPZigpO1xuXG4gICAgICBpZiAoISRoYXNfb3duKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleV90bXAgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXlfdG1wLiQkaXNfc3RyaW5nICYmIHR5cGVvZiBrZXlfdG1wICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAga2V5X3RtcCA9IGtleV90bXAudmFsdWVPZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleV90bXAgPT09IGtleSkge1xuICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaGFzaC4kJHNtYXBba2V5XTtcbiAgICAgIGRlbGV0ZSBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCA9IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzX293bihoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF0sIGxhc3RfYnVja2V0O1xuXG4gICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgdmFsdWUgPSBidWNrZXQudmFsdWU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGtleXNbaV0gPT09IGJ1Y2tldCkge1xuICAgICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdF9idWNrZXQgJiYgYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgICBkZWxldGUgbGFzdF9idWNrZXQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChidWNrZXQubmV4dCkge1xuICAgICAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2guJCRtYXBba2V5X2hhc2hdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX3JlaGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaGFzaC4kJGtleXMubGVuZ3RoLCBrZXlfaGFzaCwgYnVja2V0LCBsYXN0X2J1Y2tldDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIGlmIChoYXNoLiQka2V5c1tpXS4kJGlzX3N0cmluZykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAga2V5X2hhc2ggPSBoYXNoLiQka2V5c1tpXS5rZXkuJGhhc2goKTtcblxuICAgICAgaWYgKGtleV9oYXNoID09PSBoYXNoLiQka2V5c1tpXS5rZXlfaGFzaCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF07XG4gICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgICBpZiAoYnVja2V0ID09PSBoYXNoLiQka2V5c1tpXSkge1xuICAgICAgICAgIGlmIChsYXN0X2J1Y2tldCAmJiBidWNrZXQubmV4dCkge1xuICAgICAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgICAgICAgZGVsZXRlIGxhc3RfYnVja2V0Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgICBoYXNoLiQkbWFwW2hhc2guJCRrZXlzW2ldLmtleV9oYXNoXSA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBoYXNoLiQkbWFwW2hhc2guJCRrZXlzW2ldLmtleV9oYXNoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBoYXNoLiQka2V5c1tpXS5rZXlfaGFzaCA9IGtleV9oYXNoO1xuXG4gICAgICBpZiAoISRoYXNfb3duKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGhhc2guJCRrZXlzW2ldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG4gICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgICBpZiAoYnVja2V0ID09PSBoYXNoLiQka2V5c1tpXSkge1xuICAgICAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBoYXNoLiQka2V5c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3VtZW50c19sZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzLCBoYXNoLCBpLCBsZW5ndGgsIGtleSwgdmFsdWU7XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0uJCRpc19oYXNoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgIH1cblxuICAgIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG4gICAgT3BhbC5oYXNoX2luaXQoaGFzaCk7XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKGFyZ3VtZW50c1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhcmdzW2ldLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgXCJ2YWx1ZSBub3Qgb2YgbGVuZ3RoIDI6IFwiICsgYXJnc1tpXS4kaW5zcGVjdCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrZXkgPSBhcmdzW2ldWzBdO1xuICAgICAgICAgIHZhbHVlID0gYXJnc1tpXVsxXTtcblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBmb3IgKGtleSBpbiBhcmdzKSB7XG4gICAgICAgICAgaWYgKCRoYXNfb3duKGFyZ3MsIGtleSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1trZXldO1xuXG4gICAgICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgXCJvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaFwiKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzX2xlbmd0aDsgaSArPSAyKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgLy8gQSBmYXN0ZXIgSGFzaCBjcmVhdG9yIGZvciBoYXNoZXMgdGhhdCBqdXN0IHVzZSBzeW1ib2xzIGFuZFxuICAvLyBzdHJpbmdzIGFzIGtleXMuIFRoZSBtYXAgYW5kIGtleXMgYXJyYXkgY2FuIGJlIGNvbnN0cnVjdGVkIGF0XG4gIC8vIGNvbXBpbGUgdGltZSwgc28gdGhleSBhcmUganVzdCBhZGRlZCBoZXJlIGJ5IHRoZSBjb25zdHJ1Y3RvclxuICAvLyBmdW5jdGlvbi5cbiAgLy9cbiAgT3BhbC5oYXNoMiA9IGZ1bmN0aW9uKGtleXMsIHNtYXApIHtcbiAgICB2YXIgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcblxuICAgIGhhc2guJCRzbWFwID0gc21hcDtcbiAgICBoYXNoLiQkbWFwICA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaGFzaC4kJGtleXMgPSBrZXlzO1xuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHJhbmdlIGluc3RhbmNlIHdpdGggZmlyc3QgYW5kIGxhc3QgdmFsdWVzLCBhbmQgd2hldGhlciB0aGVcbiAgLy8gcmFuZ2UgZXhjbHVkZXMgdGhlIGxhc3QgdmFsdWUuXG4gIC8vXG4gIE9wYWwucmFuZ2UgPSBmdW5jdGlvbihmaXJzdCwgbGFzdCwgZXhjKSB7XG4gICAgdmFyIHJhbmdlICAgICAgICAgPSBuZXcgT3BhbC5SYW5nZSgpO1xuICAgICAgICByYW5nZS5iZWdpbiAgID0gZmlyc3Q7XG4gICAgICAgIHJhbmdlLmVuZCAgICAgPSBsYXN0O1xuICAgICAgICByYW5nZS5leGNsICAgID0gZXhjO1xuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIHZhciByZXNlcnZlZF9pdmFyX25hbWVzID0gW1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICBcImNvbnN0cnVjdG9yXCIsIFwiZGlzcGxheU5hbWVcIiwgXCJfX2NvdW50X19cIiwgXCJfX25vU3VjaE1ldGhvZF9fXCIsXG4gICAgXCJfX3BhcmVudF9fXCIsIFwiX19wcm90b19fXCIsXG4gICAgLy8gbWV0aG9kc1xuICAgIFwiaGFzT3duUHJvcGVydHlcIiwgXCJ2YWx1ZU9mXCJcbiAgXTtcblxuICAvLyBHZXQgdGhlIGl2YXIgbmFtZSBmb3IgYSBnaXZlbiBuYW1lLlxuICAvLyBNb3N0bHkgYWRkcyBhIHRyYWlsaW5nICQgdG8gcmVzZXJ2ZWQgbmFtZXMuXG4gIC8vXG4gIE9wYWwuaXZhciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAocmVzZXJ2ZWRfaXZhcl9uYW1lcy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgbmFtZSArPSBcIiRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuICAvLyBTdXBwb3J0IGZvciAjZnJlZXplXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBoZWxwZXIgdGhhdCBjYW4gYmUgdXNlZCBmcm9tIG1ldGhvZHNcbiAgZnVuY3Rpb24gJGRlbnlfZnJvemVuX2FjY2VzcyhvYmopIHtcbiAgICBpZiAob2JqLiQkZnJvemVuKSB7XG4gICAgICAkcmFpc2UoT3BhbC5Gcm96ZW5FcnJvciwgXCJjYW4ndCBtb2RpZnkgZnJvemVuIFwiICsgKG9iai4kY2xhc3MoKSkgKyBcIjogXCIgKyAob2JqKSwgT3BhbC5oYXNoMihbXCJyZWNlaXZlclwiXSwge1wicmVjZWl2ZXJcIjogb2JqfSkpO1xuICAgIH1cbiAgfTtcbiAgT3BhbC5kZW55X2Zyb3plbl9hY2Nlc3MgPSAkZGVueV9mcm96ZW5fYWNjZXNzO1xuXG4gIC8vIGNvbW1vbiAjZnJlZXplIHJ1bnRpbWUgc3VwcG9ydFxuICBPcGFsLmZyZWV6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICRwcm9wKG9iaiwgXCIkJGZyb3plblwiLCB0cnVlKTtcblxuICAgIC8vIHNldCAkJGlkXG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoJyQkaWQnKSkgeyAkcHJvcChvYmosICckJGlkJywgJHVpZCgpKTsgfVxuXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSgnJCRtZXRhJykpIHtcbiAgICAgIC8vIGZyZWV6ZSAkJG1ldGEgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBzZXRcbiAgICAgIG9iai4kJG1ldGEuJGZyZWV6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgJCRtZXRhIGNhbiBiZSBzZXQgbGF6aWx5LCAkJG1ldGEgaXMgZnJvemVuIHdoZW4gc2V0IGluIHJ1bnRpbWUuanNcbiAgICAgICRwcm9wKG9iaiwgJyQkbWV0YScsIG51bGwpO1xuICAgIH1cblxuICAgIC8vICQkY29tcGFyYWJsZSBpcyB1c2VkIGludGVybmFsbHkgYW5kIHNldCBtdWx0aXBsZSB0aW1lc1xuICAgIC8vIGRlZmluaW5nIGl0IGJlZm9yZSBzZWFsaW5nIGVuc3VyZXMgaXQgY2FuIGJlIG1vZGlmaWVkIGxhdGVyIG9uXG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoJyQkY29tcGFyYWJsZScpKSB7ICRwcm9wKG9iaiwgJyQkY29tcGFyYWJsZScsIG51bGwpOyB9XG5cbiAgICAvLyBzZWFsIHRoZSBPYmplY3RcbiAgICBPYmplY3Quc2VhbChvYmopO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBmcmV6ZSBwcm9wcywgbWFrZSBzZXR0ZXJzIG9mIGluc3RhbmNlIHZhcmlhYmxlcyB0aHJvdyBGcm96ZW5FcnJvclxuICBPcGFsLmZyZWV6ZV9wcm9wcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBwcm9wLCBwcm9wX3R5cGUsIGRlc2M7XG5cbiAgICBmb3IocHJvcCBpbiBvYmopIHtcbiAgICAgIHByb3BfdHlwZSA9IHR5cGVvZihwcm9wKTtcblxuICAgICAgLy8gcHJvcF90eXBlIFwib2JqZWN0XCIgaGVyZSBpcyBhIFN0cmluZygpLCBza2lwICQgcHJvcHNcbiAgICAgIGlmICgocHJvcF90eXBlID09PSBcInN0cmluZ1wiIHx8IHByb3BfdHlwZSA9PT0gXCJvYmplY3RcIikgJiYgcHJvcFswXSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgICAgaWYgKGRlc2MgJiYgZGVzYy5lbnVtZXJhYmxlICYmIGRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgLy8gY3JlYXRlIGNsb3N1cmUgdG8gcmV0YWluIGN1cnJlbnQgdmFsdWUgYXMgY3ZcbiAgICAgICAgLy8gZm9yIE9wYWwgMi4wIGxldCBmb3IgY3Ygc2hvdWxkIGRvIHRoZSB0cmljaywgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBzZXQgdiB0byB1bmRlZmluZWQsIGFzIGlmIHRoZSBwcm9wZXJ0eSBpcyBub3Qgc2V0XG4gICAgICAgICAgdmFyIGN2ID0gb2JqW3Byb3BdO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBjdjsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oX3ZhbCkgeyAkZGVueV9mcm96ZW5fYWNjZXNzKG9iaik7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2V4cHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEVzY2FwZSBSZWdleHAgc3BlY2lhbCBjaGFycyBsZXR0aW5nIHRoZSByZXN1bHRpbmcgc3RyaW5nIGJlIHVzZWQgdG8gYnVpbGRcbiAgLy8gYSBuZXcgUmVnZXhwLlxuICAvL1xuICBPcGFsLmVzY2FwZV9yZWdleHAgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLVtcXF1cXC97fSgpKis/Ll4kXFxcXHwgXSkvZywgJ1xcXFwkMScpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxuXS9nLCAnXFxcXG4nKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xccl0vZywgJ1xcXFxyJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXGZdL2csICdcXFxcZicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx0XS9nLCAnXFxcXHQnKTtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XG4gIC8vIG9uIHRoZSBvYmplY3QgaXRzZWxmICgkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIGlmIChwYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgcmV0dXJuIHBhdHRlcm47IC8vIFJlZ0V4cCBhbHJlYWR5IGhhcyB0aGUgZ2xvYmFsIGZsYWdcbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uJCRnID09IG51bGwpIHtcbiAgICAgIHBhdHRlcm4uJCRnID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4ubXVsdGlsaW5lID8gJ2dtJyA6ICdnJykgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybi4kJGcubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuLiQkZztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgbXVsdGlsaW5lIFJlZ2V4cCBmcm9tIGEgUmVnRXhwIG9iamVjdCBhbmQgY2FjaGUgdGhlIHJlc3VsdFxuICAvLyBvbiB0aGUgb2JqZWN0IGl0c2VsZiAoJCRnbSBvciAkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICB2YXIgcmVzdWx0LCBmbGFncztcblxuICAgIC8vIFJlZ0V4cCBhbHJlYWR5IGhhcyB0aGUgZ2xvYmFsIGFuZCBtdWx0aWxpbmUgZmxhZ1xuICAgIGlmIChwYXR0ZXJuLmdsb2JhbCAmJiBwYXR0ZXJuLm11bHRpbGluZSkgcmV0dXJuIHBhdHRlcm47XG5cbiAgICBmbGFncyA9ICdnbScgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpO1xuICAgIGlmIChwYXR0ZXJuLm11bHRpbGluZSkge1xuICAgICAgLy8gd2UgYXJlIHVzaW5nIHRoZSAkJGcgYXR0cmlidXRlIGJlY2F1c2UgdGhlIFJlZ2V4cCBpcyBhbHJlYWR5IG11bHRpbGluZVxuICAgICAgaWYgKHBhdHRlcm4uJCRnID09IG51bGwpIHtcbiAgICAgICAgcGF0dGVybi4kJGcgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCBmbGFncyk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdHRlcm4uJCRnbSA9PSBudWxsKSB7XG4gICAgICAgIHBhdHRlcm4uJCRnbSA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnbTtcbiAgICB9XG4gICAgcmVzdWx0Lmxhc3RJbmRleCA9IG51bGw7IC8vIHJlc2V0IGxhc3RJbmRleCBwcm9wZXJ0eVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29tYmluZSBtdWx0aXBsZSByZWdleHAgcGFydHMgdG9nZXRoZXJcbiAgT3BhbC5yZWdleHAgPSBmdW5jdGlvbihwYXJ0cywgZmxhZ3MpIHtcbiAgICB2YXIgcGFydDtcbiAgICB2YXIgaWdub3JlQ2FzZSA9IHR5cGVvZiBmbGFncyAhPT0gJ3VuZGVmaW5lZCcgJiYgZmxhZ3MgJiYgZmxhZ3MuaW5kZXhPZignaScpID49IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBpZiAocGFydC5pZ25vcmVDYXNlICE9PSBpZ25vcmVDYXNlKVxuICAgICAgICAgIE9wYWwuS2VybmVsLiR3YXJuKFxuICAgICAgICAgICAgXCJpZ25vcmUgY2FzZSBkb2Vzbid0IG1hdGNoIGZvciBcIiArIHBhcnQuc291cmNlLiRpbnNwZWN0KCksXG4gICAgICAgICAgICBPcGFsLmhhc2goe3VwbGV2ZWw6IDF9KVxuICAgICAgICAgIClcblxuICAgICAgICBwYXJ0ID0gcGFydC5zb3VyY2U7XG4gICAgICB9XG4gICAgICBpZiAocGFydCA9PT0gJycpIHBhcnQgPSAnKD86JyArIHBhcnQgKyAnKSc7XG4gICAgICBwYXJ0c1tpXSA9IHBhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXJ0cy5qb2luKCcnKSwgZmxhZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXJ0cy5qb2luKCcnKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlcXVpcmUgc3lzdGVtXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgT3BhbC5tb2R1bGVzICAgICAgICAgPSB7fTtcbiAgT3BhbC5sb2FkZWRfZmVhdHVyZXMgPSBbJ2NvcmVsaWIvcnVudGltZSddO1xuICBPcGFsLmN1cnJlbnRfZGlyICAgICA9ICcuJztcbiAgT3BhbC5yZXF1aXJlX3RhYmxlICAgPSB7J2NvcmVsaWIvcnVudGltZSc6IHRydWV9O1xuXG4gIE9wYWwubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHZhciBwYXJ0cywgcGFydCwgbmV3X3BhcnRzID0gW10sIFNFUEFSQVRPUiA9ICcvJztcblxuICAgIGlmIChPcGFsLmN1cnJlbnRfZGlyICE9PSAnLicpIHtcbiAgICAgIHBhdGggPSBPcGFsLmN1cnJlbnRfZGlyLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhdGg7XG4gICAgfVxuXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLlxcLy8sICcnKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC4ocmJ8b3BhbHxqcykkLywgJycpO1xuICAgIHBhcnRzID0gcGF0aC5zcGxpdChTRVBBUkFUT1IpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSBjb250aW51ZTtcbiAgICAgIChwYXJ0ID09PSAnLi4nKSA/IG5ld19wYXJ0cy5wb3AoKSA6IG5ld19wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld19wYXJ0cy5qb2luKFNFUEFSQVRPUik7XG4gIH07XG5cbiAgT3BhbC5sb2FkZWQgPSBmdW5jdGlvbihwYXRocykge1xuICAgIHZhciBpLCBsLCBwYXRoO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGhzW2ldKTtcblxuICAgICAgaWYgKE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5sb2FkZWRfZmVhdHVyZXMucHVzaChwYXRoKTtcbiAgICAgIE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwubG9hZF9ub3JtYWxpemVkID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIE9wYWwubG9hZGVkKFtwYXRoXSk7XG5cbiAgICB2YXIgbW9kdWxlID0gT3BhbC5tb2R1bGVzW3BhdGhdO1xuXG4gICAgaWYgKG1vZHVsZSkge1xuICAgICAgdmFyIHJldHZhbCA9IG1vZHVsZShPcGFsKTtcbiAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV0dmFsIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAvLyBBIHNwZWNpYWwgY2FzZSBvZiByZXF1aXJlIGhhdmluZyBhbiBhc3luYyB0b3A6XG4gICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBhd2FpdCBpdC5cbiAgICAgICAgcmV0dXJuIHJldHZhbC50aGVuKCRyZXR1cm5fdmFsKHRydWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2V2ZXJpdHkgPSBPcGFsLmNvbmZpZy5taXNzaW5nX3JlcXVpcmVfc2V2ZXJpdHk7XG4gICAgICB2YXIgbWVzc2FnZSAgPSAnY2Fubm90IGxvYWQgc3VjaCBmaWxlIC0tICcgKyBwYXRoO1xuXG4gICAgICBpZiAoc2V2ZXJpdHkgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAkcmFpc2UoT3BhbC5Mb2FkRXJyb3IsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2V2ZXJpdHkgPT09IFwid2FybmluZ1wiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogTG9hZEVycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgT3BhbC5sb2FkID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIHJldHVybiBPcGFsLmxvYWRfbm9ybWFsaXplZChwYXRoKTtcbiAgfTtcblxuICBPcGFsLnJlcXVpcmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgaWYgKE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmxvYWRfbm9ybWFsaXplZChwYXRoKTtcbiAgfTtcblxuXG4gIC8vIFN0cmluZ3NcbiAgLy8gLS0tLS0tLVxuXG4gIE9wYWwuZW5jb2RpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBTZXRzIHRoZSBlbmNvZGluZyBvbiBhIHN0cmluZywgd2lsbCB0cmVhdCBzdHJpbmcgbGl0ZXJhbHMgYXMgZnJvemVuIHN0cmluZ3NcbiAgLy8gcmFpc2luZyBhIEZyb3plbkVycm9yLlxuICAvL1xuICAvLyBAcGFyYW0gc3RyIFtTdHJpbmddIHRoZSBzdHJpbmcgb24gd2hpY2ggdGhlIGVuY29kaW5nIHNob3VsZCBiZSBzZXRcbiAgLy8gQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGNhbm9uaWNhbCBuYW1lIG9mIHRoZSBlbmNvZGluZ1xuICAvLyBAcGFyYW0gdHlwZSBbU3RyaW5nXSBwb3NzaWJsZSB2YWx1ZXMgYXJlIGVpdGhlciBgXCJlbmNvZGluZ1wiYCwgYFwiaW50ZXJuYWxfZW5jb2RpbmdcImAsIG9yIGB1bmRlZmluZWRcbiAgT3BhbC5zZXRfZW5jb2RpbmcgPSBmdW5jdGlvbihzdHIsIG5hbWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHR5cGUgPSBcImVuY29kaW5nXCI7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ci4kJGZyb3plbiA9PT0gdHJ1ZSlcbiAgICAgICRyYWlzZShPcGFsLkZyb3plbkVycm9yLCBcImNhbid0IG1vZGlmeSBmcm96ZW4gU3RyaW5nXCIpO1xuXG4gICAgdmFyIGVuY29kaW5nID0gT3BhbC5maW5kX2VuY29kaW5nKG5hbWUpO1xuXG4gICAgaWYgKGVuY29kaW5nID09PSBzdHJbdHlwZV0pIHsgcmV0dXJuIHN0cjsgfVxuXG4gICAgc3RyW3R5cGVdID0gZW5jb2Rpbmc7XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8vIEZldGNoZXMgdGhlIGVuY29kaW5nIGZvciB0aGUgZ2l2ZW4gbmFtZSBvciByYWlzZXMgQXJndW1lbnRFcnJvci5cbiAgT3BhbC5maW5kX2VuY29kaW5nID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciByZWdpc3RlciA9IE9wYWwuZW5jb2RpbmdzO1xuICAgIHZhciBlbmNvZGluZyA9IHJlZ2lzdGVyW25hbWVdIHx8IHJlZ2lzdGVyW25hbWUudG9VcHBlckNhc2UoKV07XG4gICAgaWYgKCFlbmNvZGluZykgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgXCJ1bmtub3duIGVuY29kaW5nIG5hbWUgLSBcIiArIG5hbWUpO1xuICAgIHJldHVybiBlbmNvZGluZztcbiAgfVxuXG4gIC8vIEByZXR1cm5zIGEgU3RyaW5nIG9iamVjdCB3aXRoIHRoZSBlbmNvZGluZyBzZXQgZnJvbSBhIHN0cmluZyBsaXRlcmFsXG4gIE9wYWwuZW5jID0gZnVuY3Rpb24oc3RyLCBuYW1lKSB7XG4gICAgdmFyIGR1cCA9IG5ldyBTdHJpbmcoc3RyKTtcbiAgICBkdXAgPSBPcGFsLnNldF9lbmNvZGluZyhkdXAsIG5hbWUpO1xuICAgIGR1cC5pbnRlcm5hbF9lbmNvZGluZyA9IGR1cC5lbmNvZGluZztcbiAgICByZXR1cm4gZHVwXG4gIH1cblxuICAvLyBAcmV0dXJucyBhIFN0cmluZyBvYmplY3Qgd2l0aCB0aGUgaW50ZXJuYWwgZW5jb2Rpbmcgc2V0IHRvIEJpbmFyeVxuICBPcGFsLmJpbmFyeSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBkdXAgPSBuZXcgU3RyaW5nKHN0cik7XG4gICAgcmV0dXJuIE9wYWwuc2V0X2VuY29kaW5nKGR1cCwgXCJiaW5hcnlcIiwgXCJpbnRlcm5hbF9lbmNvZGluZ1wiKTtcbiAgfVxuXG4gIE9wYWwubGFzdF9wcm9taXNlID0gbnVsbDtcbiAgT3BhbC5wcm9taXNlX3VuaGFuZGxlZF9leGNlcHRpb24gPSBmYWxzZTtcblxuICAvLyBSdW4gYSBibG9jayBvZiBjb2RlLCBidXQgaWYgaXQgcmV0dXJucyBhIFByb21pc2UsIGRvbid0IHJ1biB0aGUgbmV4dFxuICAvLyBvbmUsIGJ1dCBxdWV1ZSBpdC5cbiAgT3BhbC5xdWV1ZSA9IGZ1bmN0aW9uKHByb2MpIHtcbiAgICBpZiAoT3BhbC5sYXN0X3Byb21pc2UpIHtcbiAgICAgIC8vIFRoZSBhc3luYyBwYXRoIGlzIHRha2VuIG9ubHkgaWYgYW55dGhpbmcgYmVmb3JlIHJldHVybmVkIGFcbiAgICAgIC8vIFByb21pc2UoVjIpLlxuICAgICAgT3BhbC5sYXN0X3Byb21pc2UgPSBPcGFsLmxhc3RfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIU9wYWwucHJvbWlzZV91bmhhbmRsZWRfZXhjZXB0aW9uKSByZXR1cm4gcHJvYyhPcGFsKTtcbiAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChPcGFsLnJlc3BvbmRfdG8oZXJyb3IsICckZnVsbF9tZXNzYWdlJykpIHtcbiAgICAgICAgICBlcnJvciA9IGVycm9yLiRmdWxsX21lc3NhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgLy8gQWJvcnQgZnVydGhlciBleGVjdXRpb25cbiAgICAgICAgT3BhbC5wcm9taXNlX3VuaGFuZGxlZF9leGNlcHRpb24gPSB0cnVlO1xuICAgICAgICBPcGFsLmV4aXQoMSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBPcGFsLmxhc3RfcHJvbWlzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcmV0ID0gcHJvYyhPcGFsKTtcbiAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmV0ID09PSAnb2JqZWN0JyAmJiByZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIE9wYWwubGFzdF9wcm9taXNlID0gcmV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH1cblxuICAvLyBPcGVyYXRvciBoZWxwZXJzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICBmdW5jdGlvbiBhcmVfYm90aF9udW1iZXJzKGwscikgeyByZXR1cm4gdHlwZW9mKGwpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YocikgPT09ICdudW1iZXInIH1cblxuICBPcGFsLnJiX3BsdXMgICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCArIHIgOiBsWyckKyddKHIpOyB9XG4gIE9wYWwucmJfbWludXMgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsIC0gciA6IGxbJyQtJ10ocik7IH1cbiAgT3BhbC5yYl90aW1lcyAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgKiByIDogbFsnJConXShyKTsgfVxuICBPcGFsLnJiX2RpdmlkZSA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCAvIHIgOiBsWyckLyddKHIpOyB9XG4gIE9wYWwucmJfbHQgICAgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsIDwgciA6IGxbJyQ8J10ocik7IH1cbiAgT3BhbC5yYl9ndCAgICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgPiByIDogbFsnJD4nXShyKTsgfVxuICBPcGFsLnJiX2xlICAgICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCA8PSByIDogbFsnJDw9J10ocik7IH1cbiAgT3BhbC5yYl9nZSAgICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgPj0gciA6IGxbJyQ+PSddKHIpOyB9XG5cbiAgLy8gT3B0aW1pemVkIGhlbHBlcnMgZm9yIGNhbGxzIGxpa2UgJHRydXRoeSgoYSlbJyQ9PT0nXShiKSkgLT4gJGVxZXFlcShhLCBiKVxuICBmdW5jdGlvbiBhcmVfYm90aF9udW1iZXJzX29yX3N0cmluZ3MobGhzLCByaHMpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBsaHMgPT09ICdudW1iZXInICYmIHR5cGVvZiByaHMgPT09ICdudW1iZXInKSB8fFxuICAgICAgICAgICAodHlwZW9mIGxocyA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHJocyA9PT0gJ3N0cmluZycpO1xuICB9XG5cbiAgZnVuY3Rpb24gJGVxZXEobGhzLCByaHMpIHtcbiAgICByZXR1cm4gYXJlX2JvdGhfbnVtYmVyc19vcl9zdHJpbmdzKGxocyxyaHMpID8gbGhzID09PSByaHMgOiAkdHJ1dGh5KChsaHMpWyckPT0nXShyaHMpKTtcbiAgfTtcbiAgT3BhbC5lcWVxID0gJGVxZXE7XG4gIE9wYWwuZXFlcWVxID0gZnVuY3Rpb24obGhzLCByaHMpIHtcbiAgICByZXR1cm4gYXJlX2JvdGhfbnVtYmVyc19vcl9zdHJpbmdzKGxocyxyaHMpID8gbGhzID09PSByaHMgOiAkdHJ1dGh5KChsaHMpWyckPT09J10ocmhzKSk7XG4gIH07XG4gIE9wYWwubmVxZXEgPSBmdW5jdGlvbihsaHMsIHJocykge1xuICAgIHJldHVybiBhcmVfYm90aF9udW1iZXJzX29yX3N0cmluZ3MobGhzLHJocykgPyBsaHMgIT09IHJocyA6ICR0cnV0aHkoKGxocylbJyQhPSddKHJocykpO1xuICB9O1xuICBPcGFsLm5vdCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh1bmRlZmluZWQgPT09IGFyZyB8fCBudWxsID09PSBhcmcgfHwgZmFsc2UgPT09IGFyZyB8fCBuaWwgPT09IGFyZykgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRydWUgPT09IGFyZyB8fCBhcmdbJyQhJ10uJCRwcmlzdGluZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAkdHJ1dGh5KGFyZ1snJCEnXSgpKTtcbiAgfVxuXG4gIC8vIFNob3J0Y3V0cyAtIG9wdGltaXplZCBmdW5jdGlvbiBnZW5lcmF0b3JzIGZvciBzaW1wbGUga2luZHMgb2YgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uICRyZXR1cm5fdmFsKGFyZykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICB9XG4gIE9wYWwucmV0dXJuX3ZhbCA9ICRyZXR1cm5fdmFsO1xuXG4gIE9wYWwucmV0dXJuX3NlbGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBPcGFsLnJldHVybl9pdmFyID0gZnVuY3Rpb24oaXZhcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzW2l2YXJdID09IG51bGwpIHsgcmV0dXJuIG5pbDsgfVxuICAgICAgcmV0dXJuIHRoaXNbaXZhcl07XG4gICAgfVxuICB9XG4gIE9wYWwuYXNzaWduX2l2YXIgPSBmdW5jdGlvbihpdmFyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2Vzcyh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzW2l2YXJdID0gdmFsO1xuICAgIH1cbiAgfVxuICBPcGFsLmFzc2lnbl9pdmFyX3ZhbCA9IGZ1bmN0aW9uKGl2YXIsIHN0YXRpY192YWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXNbaXZhcl0gPSBzdGF0aWNfdmFsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByaW1pdGl2ZXMgZm9yIGhhbmRsaW5nIHBhcmFtZXRlcnNcbiAgT3BhbC5lbnN1cmVfa3dhcmdzID0gZnVuY3Rpb24oa3dhcmdzKSB7XG4gICAgaWYgKGt3YXJncyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gT3BhbC5oYXNoMihbXSwge30pO1xuICAgIH0gZWxzZSBpZiAoa3dhcmdzLiQkaXNfaGFzaCkge1xuICAgICAgcmV0dXJuIGt3YXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgJ2V4cGVjdGVkIGt3YXJncycpO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwuZ2V0X2t3YXJnID0gZnVuY3Rpb24oa3dhcmdzLCBrZXkpIHtcbiAgICBpZiAoISRoYXNfb3duKGt3YXJncy4kJHNtYXAsIGtleSkpIHtcbiAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsICdtaXNzaW5nIGtleXdvcmQ6ICcra2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGt3YXJncy4kJHNtYXBba2V5XTtcbiAgfVxuXG4gIC8vIEFycmF5cyBvZiBzaXplID4gMzIgZWxlbWVudHMgdGhhdCBjb250YWluIG9ubHkgc3RyaW5ncyxcbiAgLy8gc3ltYm9scywgaW50ZWdlcnMgYW5kIG5pbHMgYXJlIGNvbXBpbGVkIGFzIGEgc2VsZi1leHRyYWN0aW5nXG4gIC8vIHN0cmluZy5cbiAgT3BhbC5sYXJnZV9hcnJheV91bnBhY2sgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgYXJyYXkgPSBzdHIuc3BsaXQoXCIsXCIpLCBsZW5ndGggPSBhcnJheS5sZW5ndGgsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzd2l0Y2goYXJyYXlbaV1bMF0pIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgYXJyYXlbaV0gPSBuaWxcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgY2FzZSAnMic6XG4gICAgICAgIGNhc2UgJzMnOlxuICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgIGNhc2UgJzYnOlxuICAgICAgICBjYXNlICc3JzpcbiAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgIGNhc2UgJzknOlxuICAgICAgICAgIGFycmF5W2ldID0gK2FycmF5W2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvLyBJbml0aWFsaXphdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLVxuICBPcGFsLkJhc2ljT2JqZWN0ID0gQmFzaWNPYmplY3QgPSAkYWxsb2NhdGVfY2xhc3MoJ0Jhc2ljT2JqZWN0JywgbnVsbCk7XG4gIE9wYWwuT2JqZWN0ICAgICAgPSBfT2JqZWN0ICAgICA9ICRhbGxvY2F0ZV9jbGFzcygnT2JqZWN0JywgT3BhbC5CYXNpY09iamVjdCk7XG4gIE9wYWwuTW9kdWxlICAgICAgPSBNb2R1bGUgICAgICA9ICRhbGxvY2F0ZV9jbGFzcygnTW9kdWxlJywgT3BhbC5PYmplY3QpO1xuICBPcGFsLkNsYXNzICAgICAgID0gQ2xhc3MgICAgICAgPSAkYWxsb2NhdGVfY2xhc3MoJ0NsYXNzJywgT3BhbC5Nb2R1bGUpO1xuICBPcGFsLk9wYWwgICAgICAgID0gX09wYWwgICAgICAgPSAkYWxsb2NhdGVfbW9kdWxlKCdPcGFsJyk7XG4gIE9wYWwuS2VybmVsICAgICAgPSBLZXJuZWwgICAgICA9ICRhbGxvY2F0ZV9tb2R1bGUoJ0tlcm5lbCcpO1xuXG4gICRzZXRfcHJvdG8oT3BhbC5CYXNpY09iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5PYmplY3QsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuTW9kdWxlLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLkNsYXNzLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAvLyBCYXNpY09iamVjdCBjYW4gcmVhY2ggaXRzZWxmLCBhdm9pZCBjb25zdF9zZXQgdG8gc2tpcCB0aGUgJCRiYXNlX21vZHVsZSBsb2dpY1xuICBCYXNpY09iamVjdC4kJGNvbnN0LkJhc2ljT2JqZWN0ID0gQmFzaWNPYmplY3Q7XG5cbiAgLy8gQXNzaWduIGJhc2ljIGNvbnN0YW50c1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiQmFzaWNPYmplY3RcIiwgIEJhc2ljT2JqZWN0KTtcbiAgJGNvbnN0X3NldChfT2JqZWN0LCBcIk9iamVjdFwiLCAgICAgICBfT2JqZWN0KTtcbiAgJGNvbnN0X3NldChfT2JqZWN0LCBcIk1vZHVsZVwiLCAgICAgICBNb2R1bGUpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiQ2xhc3NcIiwgICAgICAgIENsYXNzKTtcbiAgJGNvbnN0X3NldChfT2JqZWN0LCBcIk9wYWxcIiwgICAgICAgICBfT3BhbCk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJLZXJuZWxcIiwgICAgICAgS2VybmVsKTtcblxuICAvLyBGaXggYm9vdGVkIGNsYXNzZXMgdG8gaGF2ZSBjb3JyZWN0IC5jbGFzcyB2YWx1ZVxuICBCYXNpY09iamVjdC4kJGNsYXNzID0gQ2xhc3M7XG4gIF9PYmplY3QuJCRjbGFzcyAgICAgPSBDbGFzcztcbiAgTW9kdWxlLiQkY2xhc3MgICAgICA9IENsYXNzO1xuICBDbGFzcy4kJGNsYXNzICAgICAgID0gQ2xhc3M7XG4gIF9PcGFsLiQkY2xhc3MgICAgICAgPSBNb2R1bGU7XG4gIEtlcm5lbC4kJGNsYXNzICAgICAgPSBNb2R1bGU7XG5cbiAgLy8gRm9yd2FyZCAudG9TdHJpbmcoKSB0byAjdG9fc1xuICAkcHJvcChfT2JqZWN0LiQkcHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG9fcyA9IHRoaXMuJHRvX3MoKTtcbiAgICBpZiAodG9fcy4kJGlzX3N0cmluZyAmJiB0eXBlb2YodG9fcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBhIHN0cmluZyBjcmVhdGVkIHVzaW5nIG5ldyBTdHJpbmcoJ3N0cmluZycpXG4gICAgICByZXR1cm4gdG9fcy52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b19zO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWFrZSBLZXJuZWwjcmVxdWlyZSBpbW1lZGlhdGVseSBhdmFpbGFibGUgYXMgaXQncyBuZWVkZWQgdG8gcmVxdWlyZSBhbGwgdGhlXG4gIC8vIG90aGVyIGNvcmVsaWIgZmlsZXMuXG4gICRwcm9wKF9PYmplY3QuJCRwcm90b3R5cGUsICckcmVxdWlyZScsIE9wYWwucmVxdWlyZSk7XG5cbiAgLy8gSW5zdGFudGlhdGUgdGhlIG1haW4gb2JqZWN0XG4gIE9wYWwudG9wID0gbmV3IF9PYmplY3QoKTtcbiAgT3BhbC50b3AuJHRvX3MgPSBPcGFsLnRvcC4kaW5zcGVjdCA9ICRyZXR1cm5fdmFsKCdtYWluJyk7XG4gIE9wYWwudG9wLiRkZWZpbmVfbWV0aG9kID0gdG9wX2RlZmluZV9tZXRob2Q7XG5cbiAgLy8gRm93YXJkIGNhbGxzIHRvIGRlZmluZV9tZXRob2Qgb24gdGhlIHRvcCBvYmplY3QgdG8gT2JqZWN0XG4gIGZ1bmN0aW9uIHRvcF9kZWZpbmVfbWV0aG9kKCkge1xuICAgIHZhciBhcmdzID0gJHNsaWNlKGFyZ3VtZW50cyk7XG4gICAgdmFyIGJsb2NrID0gdG9wX2RlZmluZV9tZXRob2QuJCRwO1xuICAgIHRvcF9kZWZpbmVfbWV0aG9kLiQkcCA9IG51bGw7XG4gICAgcmV0dXJuIE9wYWwuc2VuZChfT2JqZWN0LCAnZGVmaW5lX21ldGhvZCcsIGFyZ3MsIGJsb2NrKVxuICB9O1xuXG4gIC8vIE5pbFxuICBPcGFsLk5pbENsYXNzID0gJGFsbG9jYXRlX2NsYXNzKCdOaWxDbGFzcycsIE9wYWwuT2JqZWN0KTtcbiAgJGNvbnN0X3NldChfT2JqZWN0LCAnTmlsQ2xhc3MnLCBPcGFsLk5pbENsYXNzKTtcbiAgbmlsID0gT3BhbC5uaWwgPSBuZXcgT3BhbC5OaWxDbGFzcygpO1xuICBuaWwuJCRpZCA9IG5pbF9pZDtcbiAgbmlsLmNhbGwgPSBuaWwuYXBwbHkgPSBmdW5jdGlvbigpIHsgJHJhaXNlKE9wYWwuTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicpOyB9O1xuICBuaWwuJCRmcm96ZW4gPSB0cnVlO1xuICBuaWwuJCRjb21wYXJhYmxlID0gZmFsc2U7XG4gIE9iamVjdC5zZWFsKG5pbCk7XG5cbiAgT3BhbC50aHJvd2VyID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciB0aHJvd2VyID0gbmV3IEVycm9yKCd1bmV4cGVjdGVkICcrdHlwZSk7XG4gICAgdGhyb3dlci4kdGhyb3dlcl90eXBlID0gdHlwZTtcbiAgICB0aHJvd2VyLiR0aHJvdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSBuaWw7XG4gICAgICB0aHJvd2VyLiR2ID0gdmFsdWU7XG4gICAgICB0aHJvdyB0aHJvd2VyO1xuICAgIH07XG4gICAgcmV0dXJuIHRocm93ZXI7XG4gIH07XG5cbiAgT3BhbC50X2V2YWxfcmV0dXJuID0gT3BhbC50aHJvd2VyKFwicmV0dXJuXCIpO1xuXG4gIFR5cGVFcnJvci4kJHN1cGVyID0gRXJyb3I7XG5cbiAgLy8gSWYgZW5hYmxlLWZpbGUtc291cmNlLWVtYmVkIGNvbXBpbGVyIG9wdGlvbiBpcyBlbmFibGVkLCBlYWNoIG1vZHVsZSBsb2FkZWQgd2lsbCBhZGQgaXRzXG4gIC8vIHNvdXJjZXMgdG8gdGhpcyBvYmplY3RcbiAgT3BhbC5maWxlX3NvdXJjZXMgPSB7fTtcbn0pLmNhbGwodGhpcyk7XG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3J1bnRpbWUuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUY7QUFDRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7O0FBRUY7QUFDRTs7QUFFRjtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUY7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUU7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDVTtBQUNBO0FBQ0E7QUFDQTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7O0FBRUY7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDTztBQUNUOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDUzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oZWxwZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvciwgY29lcmNlX3RvXG5cbm1vZHVsZSA6Ok9wYWxcbiAgZGVmIHNlbGYuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylcbiAgICBgT3BhbC5icmlkZ2UoY29uc3RydWN0b3IsIGtsYXNzKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvIShvYmplY3QsIHR5cGUsIG1ldGhvZCwgKmFyZ3MpXG4gICAgY29lcmNlZCA9IGAkY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKWBcblxuICAgIHVubGVzcyB0eXBlID09PSBjb2VyY2VkXG4gICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpYFxuICAgIGVuZFxuXG4gICAgY29lcmNlZFxuICBlbmRcblxuICBkZWYgc2VsZi5jb2VyY2VfdG8/KG9iamVjdCwgdHlwZSwgbWV0aG9kLCAqYXJncylcbiAgICByZXR1cm4gdW5sZXNzIG9iamVjdC5yZXNwb25kX3RvPyBtZXRob2RcblxuICAgIGNvZXJjZWQgPSBgJGNvZXJjZV90byhvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncylgXG5cbiAgICByZXR1cm4gaWYgY29lcmNlZC5uaWw/XG5cbiAgICB1bmxlc3MgdHlwZSA9PT0gY29lcmNlZFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKWBcbiAgICBlbmRcblxuICAgIGNvZXJjZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqZWN0LCB0eXBlLCBtZXRob2QpXG4gICAgcmV0dXJuIG9iamVjdCBpZiB0eXBlID09PSBvYmplY3RcblxuICAgIGlmIG9iamVjdC5yZXNwb25kX3RvPyBtZXRob2RcbiAgICAgIG9iamVjdC5fX3NlbmRfXyBtZXRob2RcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29tcGFyZShhLCBiKVxuICAgIGNvbXBhcmUgPSBhIDw9PiBiXG5cbiAgICBpZiBgY29tcGFyZSA9PT0gbmlsYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3thLmNsYXNzfSB3aXRoICN7Yi5jbGFzc30gZmFpbGVkXCJcbiAgICBlbmRcblxuICAgIGNvbXBhcmVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJncy4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3NfYXJ5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucmVzcG9uZF90bz8ob2JqLCBtZXRob2QsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgJXh7XG4gICAgICBpZiAob2JqID09IG51bGwgfHwgIW9iai4kJGNsYXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvYmoucmVzcG9uZF90bz8obWV0aG9kLCBpbmNsdWRlX2FsbClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmNvZXJjZV90byEobmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpXG5cbiAgICB1bmxlc3MgYC9eQFthLXpBLVpfXVthLXpBLVowLTlfXSo/JC8udGVzdChuYW1lKWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIicje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBuYW1lXCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBuYW1lXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgaWYgYG5hbWUubGVuZ3RoIDwgMyB8fCBuYW1lLnNsaWNlKDAsMikgIT09ICdAQCdgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJgI3tuYW1lfScgaXMgbm90IGFsbG93ZWQgYXMgYSBjbGFzcyB2YXJpYWJsZSBuYW1lXCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBuYW1lXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0X25hbWU/KGNvbnN0X25hbWUpXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIGNvbnN0X25hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICN7Y29uc3RfbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKX1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7Y29uc3RfbmFtZX1bMF0gPT09ICN7Y29uc3RfbmFtZX1bMF0udG9VcHBlckNhc2UoKVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICBjb25zdF9uYW1lID0gOjpPcGFsLmNvZXJjZV90byEoY29uc3RfbmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpIGlmIGRlZmluZWQ/IDo6U3RyaW5nXG5cbiAgICAleHtcbiAgICAgIGlmICghY29uc3RfbmFtZSB8fCBjb25zdF9uYW1lWzBdICE9IGNvbnN0X25hbWVbMF0udG9VcHBlckNhc2UoKSkge1xuICAgICAgICAje3JhaXNlIDo6TmFtZUVycm9yLCBcIndyb25nIGNvbnN0YW50IG5hbWUgI3tjb25zdF9uYW1lfVwifVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0X25hbWVcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICAjIE1hcmsgc29tZSBtZXRob2RzIGFzIHByaXN0aW5lIGluIG9yZGVyIHRvIGFwcGx5IG9wdGltaXphdGlvbnMgd2hlbiB0aGV5XG4gICMgYXJlIHN0aWxsIGluIHRoZWlyIG9yaWdpbmFsIGZvcm0uIFRoaXMgY291bGQgcHJvYmFibHkgYmUgbW92ZWQgdG9cbiAgIyB0aGUgYE9wYWwuZGVmKClgIEpTIEFQSSwgYnV0IGZvciBub3cgaXQgd2lsbCBzdGF5IG1hbnVhbC5cbiAgI1xuICAjIEBleGFtcGxlXG4gICNcbiAgIyAgIE9wYWwucHJpc3RpbmUgQXJyYXksIDphbGxvY2F0ZSwgOmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLCA6aW5pdGlhbGl6ZV9kdXBcbiAgI1xuICAjICAgY2xhc3MgQXJyYXlcbiAgIyAgICAgZGVmIGR1cFxuICAjICAgICAgICV4e1xuICAjICAgICAgICAgaWYgKFxuICAjICAgICAgICAgICBzZWxmLiRhbGxvY2F0ZS4kJHByaXN0aW5lICYmXG4gICMgICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZVxuICAjICAgICAgICAgKSByZXR1cm4gc2VsZi5zbGljZSgwKTtcbiAgIyAgICAgICB9XG4gICNcbiAgIyAgICAgICBzdXBlclxuICAjICAgICBlbmRcbiAgIyAgIGVuZFxuICAjXG4gICMgQHBhcmFtIG93bmVyX2NsYXNzIFtDbGFzc10gdGhlIGNsYXNzIG93bmluZyB0aGUgbWV0aG9kc1xuICAjIEBwYXJhbSBtZXRob2RfbmFtZXMgW0FycmF5PFN5bWJvbD5dIHRoZSBsaXN0IG9mIG1ldGhvZHMgbmFtZXMgdG8gbWFya1xuICAjIEByZXR1cm4gW25pbF1cbiAgZGVmIHNlbGYucHJpc3RpbmUob3duZXJfY2xhc3MsICptZXRob2RfbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aG9kX25hbWUsIG1ldGhvZDtcbiAgICAgIGZvciAodmFyIGkgPSBtZXRob2RfbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbWV0aG9kX25hbWUgPSBtZXRob2RfbmFtZXNbaV07XG4gICAgICAgIG1ldGhvZCA9IG93bmVyX2NsYXNzLiQkcHJvdG90eXBlW09wYWwuanNpZChtZXRob2RfbmFtZSldO1xuXG4gICAgICAgIGlmIChtZXRob2QgJiYgIW1ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgICBtZXRob2QuJCRwcmlzdGluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gIGB2YXIgaW5zcGVjdF9zdGFjayA9IFtdYFxuXG4gICMgUGVyZm9ybXMgYSBzYWZlIGNhbGwgdG8gaW5zcGVjdCBmb3IgYW55IHZhbHVlLCB3aGV0aGVyXG4gICMgbmF0aXZlIG9yIE9wYWwtd3JhcHBlZC5cbiAgI1xuICAjIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICAjIEByZXR1cm4gW1N0cmluZ11cbiAgZGVmIHNlbGYuaW5zcGVjdCh2YWx1ZSA9IHVuZGVmaW5lZClcbiAgICBgdmFyIHB1c2hlZCA9IGZhbHNlYFxuICAgIGJlZ2luXG4gICAgICAleHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSlMgbnVsbCB2YWx1ZVxuICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEpTIHVuZGVmaW5lZCB2YWx1ZVxuICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuJCRjbGFzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBKUyBvYmplY3QgLyBvdGhlciB2YWx1ZSB0aGF0IGlzIG5vdCBicmlkZ2VkXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS4kaW5zcGVjdCAhPT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZS4kaW5zcGVjdC4kJHN0dWIpIHtcbiAgICAgICAgICAvLyBCYXNpY09iamVjdCBhbmQgZnJpZW5kc1xuICAgICAgICAgIHJldHVybiAje1wiIzwje2B2YWx1ZS4kJGNsYXNzYH06MHgje3ZhbHVlLl9faWRfXy50b19zKDE2KX0+XCJ9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zcGVjdF9zdGFjay5pbmRleE9mKCN7dmFsdWUuX19pZF9ffSkgIT09IC0xKSB7XG4gICAgICAgICAgLy8gaW5zcGVjdCByZWN1cnNpbmcgaW5zaWRlIGluc3BlY3QgdG8gZmluZCBvdXQgYWJvdXQgdGhlXG4gICAgICAgICAgLy8gc2FtZSBvYmplY3RcbiAgICAgICAgICByZXR1cm4gI3tcIiM8I3tgdmFsdWUuJCRjbGFzc2B9OjB4I3t2YWx1ZS5fX2lkX18udG9fcygxNil9PlwifVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGFueXRoaW5nIHN1cHBvcnRpbmcgT3BhbFxuICAgICAgICAgIGluc3BlY3Rfc3RhY2sucHVzaCgje3ZhbHVlLl9faWRfX30pO1xuICAgICAgICAgIHB1c2hlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLiRpbnNwZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5pbFxuICAgIHJlc2N1ZSA6OkV4Y2VwdGlvbiA9PiBlICMgcnVib2NvcDpkaXNhYmxlIExpbnQvUmVzY3VlRXhjZXB0aW9uXG4gICAgICBcIiM8I3tgdmFsdWUuJCRjbGFzc2B9OjB4I3t2YWx1ZS5fX2lkX18udG9fcygxNil9PlwiXG4gICAgZW5zdXJlXG4gICAgICBgaWYgKHB1c2hlZCkgaW5zcGVjdF9zdGFjay5wb3AoKWBcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpPcGFsPiIsImJyaWRnZSIsInNlbGYiLCJjb25zdHJ1Y3RvciIsImtsYXNzIiwiY29lcmNlX3RvISIsIm9iamVjdCIsInR5cGUiLCJtZXRob2QiLCJjb2VyY2VkIiwiS2VybmVsIiwicmFpc2UiLCJjb2VyY2VfdG8/IiwicmVzcG9uZF90bz8iLCJuaWw/IiwidHJ5X2NvbnZlcnQiLCJfX3NlbmRfXyIsImNvbXBhcmUiLCJhIiwiYiIsIjw9PiIsIkFyZ3VtZW50RXJyb3IiLCJjbGFzcyIsImRlc3RydWN0dXJlIiwiYXJncyIsIm9iaiIsImluY2x1ZGVfYWxsIiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJuYW1lIiwiT3BhbCIsIlN0cmluZyIsIk5hbWVFcnJvciIsIm5ldyIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY29uc3RfbmFtZT8iLCJjb25zdF9uYW1lIiwiY29uc3RfbmFtZSEiLCJwcmlzdGluZSIsIm93bmVyX2NsYXNzIiwiaW5zcGVjdCIsInZhbHVlIiwiX19pZF9fIiwidG9fcyIsIjE2IiwiRXhjZXB0aW9uIiwiZSJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOzs7O0lBQ0VDLE1BQUlDLElBQUpELGFBQUFBLGtCQUFnQkUsV0FBRCxFQUFjQyxLQUE3Qkg7QUFBQUE7TUFDRUEsT0FBQ0EsK0JBQURBO0lBREZBLENBQUFBO0lBSUFJLE1BQUlILElBQUpHLGlCQUFBQSxnQ0FBb0JDLE1BQUQsRUFBU0MsSUFBVCxFQUFlQyxNQUFmLEVBUHJCLEVBT0VIO0FBQUFBLE1BQUFBOzs7TUFQRjtNQU80QztNQUN4Q0ksVUFBV0o7TUFFWCxLQUFBLFFBQU9FLElBQVAsRUFBZ0JFLE9BQWhCLENBQUE7UUFDRUMsT0FBUUMsT0FBQUEsQ0FBUU4sMENBQVJNO01BRFY7TUFJQU4sT0FBQUk7SUFQRkosQ0FBQUEsSUFBQUE7SUFVQU8sTUFBSVYsSUFBSlUsaUJBQUFBLGdDQUFvQk4sTUFBRCxFQUFTQyxJQUFULEVBQWVDLE1BQWYsRUFqQnJCLEVBaUJFSTtBQUFBQSxNQUFBQTs7O01BakJGO01BaUI0QztNQUN4QyxLQUFBLFFBQWNOLE1BQU1PLGdCQUFBQSxDQUFhTCxNQUFiSyxDQUFwQixDQUFBO1FBQUEsT0FBQTtNQUFBO01BRUFKLFVBQVdHO01BRVgsSUFBQSxRQUFVSCxPQUFPSyxTQUFBQSxDQUFBQSxD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Q25FQTtBQUNBQTtBQUNBQTtBQUNBQSw2QkFBK0JDLEtBQUtDLFFBQUFBLENBQUFBLENBQVFGO0FBQzVDQTtBQUNBQTtBQUNBQTtBQUNBQTtRQUNNQSxPQUFBO01BN0JBO1FBOEJGLHNCQUFPLENBQUFLLGdCQUFBLENBQVAsSUFBc0JDLENBQUFBLElBQXRCLElBQXNCQTtVQUF0QjtZQUNFTixPQUFDQSxJQUFELEdBQUEsQ0FBTUEsYUFBTixDQUFBLEdBQXFCQSxLQUFyQixHQUFBLENBQTBCQyxLQUFLQyxRQUFBQSxDQUFBQSxDQUFPQyxNQUFBQSxDQUFNQyxFQUFORCxDQUF0QyxDQUFBLEdBQWdESDtVQURsRDtRQUFBLENBOUJFO01BQUE7TUFBQTtRQWlDQ0E7TUFqQ0QsQ0FBQTtJQUhKQSxDQUFBQSxJQUFBQTtFQXBLRnZDLEdBQU8sSUFBUEE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyNjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21vZHVsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCBjb25zdF9zZXQsIE9iamVjdCwgcmV0dXJuX2l2YXIsIGFzc2lnbl9pdmFyLCBpdmFyLCBkZW55X2Zyb3plbl9hY2Nlc3MsIGZyZWV6ZSwgcHJvcCwganNpZFxuXG5jbGFzcyA6Ok1vZHVsZVxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIG1vZHVsZSA9IE9wYWwuYWxsb2NhdGVfbW9kdWxlKG5pbCwgZnVuY3Rpb24oKXt9KTtcbiAgICAgIC8vIExpbmsgdGhlIHByb3RvdHlwZSBvZiBNb2R1bGUgc3ViY2xhc3Nlc1xuICAgICAgaWYgKHNlbGYgIT09IE9wYWwuTW9kdWxlKSBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kdWxlLCBzZWxmLiQkcHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgbW9kdWxlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cbiAgZW5kXG5cbiAgZGVmID09PShvYmplY3QpXG4gICAgcmV0dXJuIGZhbHNlIGlmIGBvYmplY3QgPT0gbnVsbGBcblxuICAgIGBPcGFsLmlzX2Eob2JqZWN0LCBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgdW5sZXNzIDo6TW9kdWxlID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdjb21wYXJlZCB3aXRoIG5vbiBjbGFzcy9tb2R1bGUnXG4gICAgZW5kXG5cbiAgICAjIGNsYXNzIGNhbm5vdCBiZSBhIGRlc2NlbmRhbnQgb2YgaXRzZWxmXG4gICAgJXh7XG4gICAgICB2YXIgd29ya2luZyA9IHNlbGYsXG4gICAgICAgICAgYW5jZXN0b3JzLFxuICAgICAgICAgIGksIGxlbmd0aDtcblxuICAgICAgaWYgKHdvcmtpbmcgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoc2VsZiksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBvdGhlcikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG90aGVyKSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBlcXVhbD8ob3RoZXIpIHx8IHNlbGYgPCBvdGhlclxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICB1bmxlc3MgOjpNb2R1bGUgPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcbiAgICBlbmRcblxuICAgIG90aGVyIDwgc2VsZlxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmID4gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgOjpNb2R1bGUgPT09IG90aGVyXG4gICAgICByZXR1cm4gbmlsXG4gICAgZW5kXG5cbiAgICBsdCA9IHNlbGYgPCBvdGhlclxuICAgIHJldHVybiBuaWwgaWYgbHQubmlsP1xuICAgIGx0ID8gLTEgOiAxXG4gIGVuZFxuXG4gIGRlZiBhbGlhc19tZXRob2QobmV3bmFtZSwgb2xkbmFtZSlcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG5ld25hbWUgPSBgJGNvZXJjZV90byhuZXduYW1lLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYFxuICAgIG9sZG5hbWUgPSBgJGNvZXJjZV90byhvbGRuYW1lLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYFxuICAgIGBPcGFsLmFsaWFzKHNlbGYsIG5ld25hbWUsIG9sZG5hbWUpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYWxpYXNfbmF0aXZlKG1pZCwganNpZCA9IG1pZClcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGBPcGFsLmFsaWFzX25hdGl2ZShzZWxmLCBtaWQsIGpzaWQpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYW5jZXN0b3JzXG4gICAgYE9wYWwuYW5jZXN0b3JzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYXBwZW5kX2ZlYXR1cmVzKGluY2x1ZGVyKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKGluY2x1ZGVyKWBcblxuICAgIGBPcGFsLmFwcGVuZF9mZWF0dXJlcyhzZWxmLCBpbmNsdWRlcilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYXR0cl9hY2Nlc3NvcigqbmFtZXMpXG4gICAgYXR0cl9yZWFkZXIoKm5hbWVzKVxuICAgIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgZW5kXG5cbiAgZGVmIGF0dHIoKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMiAmJiAoYXJnc1sxXSA9PT0gdHJ1ZSB8fCBhcmdzWzFdID09PSBmYWxzZSkpIHtcbiAgICAgICAgI3t3YXJuICdvcHRpb25hbCBib29sZWFuIGFyZ3VtZW50IGlzIG9ic29sZXRlZCcsIHVwbGV2ZWw6IDF9XG5cbiAgICAgICAgYXJnc1sxXSA/ICN7YXR0cl9hY2Nlc3NvcihgYXJnc1swXWApfSA6ICN7YXR0cl9yZWFkZXIoYGFyZ3NbMF1gKX07XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cl9yZWFkZXIoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBhdHRyX3JlYWRlcigqbmFtZXMpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgcHJvdG8gPSBzZWxmLiQkcHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXSxcbiAgICAgICAgICAgIGlkICAgPSAkanNpZChuYW1lKSxcbiAgICAgICAgICAgIGl2YXIgPSAkaXZhcihuYW1lKTtcblxuICAgICAgICB2YXIgYm9keSA9ICRyZXR1cm5faXZhcihpdmFyKTtcblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBpbnN0YW5jZSB2YXJpYWJsZSBhcyBuaWxcbiAgICAgICAgT3BhbC5wcm9wKHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIGJvZHkuJCRwYXJhbWV0ZXJzID0gW107XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDA7XG5cbiAgICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICRqc2lkKG5hbWUgKyAnPScpLFxuICAgICAgICAgICAgaXZhciA9ICRpdmFyKG5hbWUpO1xuXG4gICAgICAgIHZhciBib2R5ID0gJGFzc2lnbl9pdmFyKGl2YXIpXG5cbiAgICAgICAgYm9keS4kJHBhcmFtZXRlcnMgPSBbWydyZXEnXV07XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDE7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwucHJvcChwcm90bywgaXZhciwgbmlsKTtcblxuICAgICAgICBPcGFsLmRlZm4oc2VsZiwgaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgYXV0b2xvYWQoY29uc3QsIHBhdGgpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAoISN7T3BhbC5jb25zdF9uYW1lPyhjb25zdCl9KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwiYXV0b2xvYWQgbXVzdCBiZSBjb25zdGFudCBuYW1lOiAje2NvbnN0fVwifVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0aCA9PSBcIlwiKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnZW1wdHkgZmlsZSBuYW1lJ31cbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLiQkY29uc3QuaGFzT3duUHJvcGVydHkoI3tjb25zdH0pKSB7XG4gICAgICAgIGlmICghc2VsZi4kJGF1dG9sb2FkKSB7XG4gICAgICAgICAgc2VsZi4kJGF1dG9sb2FkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG4gICAgICAgIHNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0gPSB7IHBhdGg6ICN7cGF0aH0sIGxvYWRlZDogZmFsc2UsIHJlcXVpcmVkOiBmYWxzZSwgc3VjY2VzczogZmFsc2UsIGV4Y2VwdGlvbjogZmFsc2UgfTtcblxuICAgICAgICBpZiAoc2VsZi4kY29uc3RfYWRkZWQgJiYgIXNlbGYuJGNvbnN0X2FkZGVkLiQkcHJpc3RpbmUpIHtcbiAgICAgICAgICBzZWxmLiRjb25zdF9hZGRlZCgje2NvbnN0fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXV0b2xvYWQ/KGNvbnN0KVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRhdXRvbG9hZCAmJiBzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dICYmICFzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dLnJlcXVpcmVkICYmICFzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dLnN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0ucGF0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuY2VzdG9ycyA9IHNlbGYuJGFuY2VzdG9ycygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZCAmJiBhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFsje2NvbnN0fV0gJiYgIWFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkWyN7Y29uc3R9XS5yZXF1aXJlZCAmJiAhYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dLnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dLnBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVzXG4gICAgYE9iamVjdC5rZXlzKE9wYWwuY2xhc3NfdmFyaWFibGVzKHNlbGYpKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX2dldChuYW1lKVxuICAgIG5hbWUgPSA6Ok9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX2dldChzZWxmLCBuYW1lLCBmYWxzZSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9zZXQobmFtZSwgdmFsdWUpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZV9zZXQoc2VsZiwgbmFtZSwgdmFsdWUpYFxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVfZGVmaW5lZD8obmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikuaGFzT3duUHJvcGVydHkobmFtZSlgXG4gIGVuZFxuXG4gIGRlZiBjb25zdF9hZGRlZChuYW1lKVxuICBlbmRcbiAgOjpPcGFsLnByaXN0aW5lIHNlbGYsIDpjb25zdF9hZGRlZFxuXG4gIGRlZiByZW1vdmVfY2xhc3NfdmFyaWFibGUobmFtZSlcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG5hbWUgPSA6Ok9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgaWYgKE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLiQkY3ZhcnMsIG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNlbGYuJCRjdmFyc1tuYW1lXTtcbiAgICAgICAgZGVsZXRlIHNlbGYuJCRjdmFyc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvciwgXCJjYW5ub3QgcmVtb3ZlICN7bmFtZX0gZm9yICN7c2VsZn1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdGFudHMoaW5oZXJpdCA9IHRydWUpXG4gICAgYE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdGFudHMoaW5oZXJpdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIG5lc3RpbmcgPSAoc2VsZi4kJG5lc3RpbmcgfHwgW10pLmNvbmNhdCgkT2JqZWN0KSxcbiAgICAgICAgICAgIGNvbnN0YW50LCBjb25zdGFudHMgPSB7fSxcbiAgICAgICAgICAgIGksIGlpO1xuXG4gICAgICAgIGZvcihpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBmb3IgKGNvbnN0YW50IGluIG5lc3RpbmdbaV0uJCRjb25zdCkge1xuICAgICAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5uZXN0aW5nXG4gICAgYHNlbGYuJCRuZXN0aW5nIHx8IFtdYFxuICBlbmRcblxuICAjIGNoZWNrIGZvciBjb25zdGFudCB3aXRoaW4gY3VycmVudCBzY29wZVxuICAjIGlmIGluaGVyaXQgaXMgdHJ1ZSBvciBzZWxmIGlzIE9iamVjdCwgd2lsbCBhbHNvIGNoZWNrIGFuY2VzdG9yc1xuICBkZWYgY29uc3RfZGVmaW5lZD8obmFtZSwgaW5oZXJpdCA9IHRydWUpXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKSB1bmxlc3MgbmFtZSA9fiA6Ok9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIHZhciBtb2R1bGUsIG1vZHVsZXMgPSBbc2VsZl0sIG1vZHVsZV9jb25zdGFudHMsIGksIGlpO1xuXG4gICAgICAvLyBBZGQgdXAgYW5jZXN0b3JzIGlmIGluaGVyaXQgaXMgdHJ1ZVxuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KE9wYWwuYW5jZXN0b3JzKHNlbGYpKTtcblxuICAgICAgICAvLyBBZGQgT2JqZWN0J3MgYW5jZXN0b3JzIGlmIGl0J3MgYSBtb2R1bGUg4oCTIG1vZHVsZXMgaGF2ZSBubyBhbmNlc3RvcnMgb3RoZXJ3aXNlXG4gICAgICAgIGlmIChzZWxmLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KFskT2JqZWN0XSkuY29uY2F0KE9wYWwuYW5jZXN0b3JzKCRPYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IG1vZHVsZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuICAgICAgICBpZiAobW9kdWxlLiQkY29uc3RbI3tuYW1lfV0gIT0gbnVsbCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgbW9kdWxlLiQkYXV0b2xvYWQgJiZcbiAgICAgICAgICBtb2R1bGUuJCRhdXRvbG9hZFsje25hbWV9XSAmJlxuICAgICAgICAgICFtb2R1bGUuJCRhdXRvbG9hZFsje25hbWV9XS5yZXF1aXJlZCAmJlxuICAgICAgICAgICFtb2R1bGUuJCRhdXRvbG9hZFsje25hbWV9XS5zdWNjZXNzXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdF9nZXQobmFtZSwgaW5oZXJpdCA9IHRydWUpXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgaWYgKG5hbWUuaW5kZXhPZignOjonKSA9PT0gMCAmJiBuYW1lICE9PSAnOjonKXtcbiAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgYG5hbWUuaW5kZXhPZignOjonKSAhPSAtMSAmJiBuYW1lICE9ICc6OidgXG4gICAgICByZXR1cm4gbmFtZS5zcGxpdCgnOjonKS5pbmplY3Qoc2VsZikgeyB8bywgY3wgby5jb25zdF9nZXQoYykgfVxuICAgIGVuZFxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IDo6T3BhbDo6Q09OU1RfTkFNRV9SRUdFWFBcblxuICAgICV4e1xuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuJCQoW3NlbGZdLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLmNvbnN0X2dldF9sb2NhbChzZWxmLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdF9taXNzaW5nKG5hbWUpXG4gICAgZnVsbF9jb25zdF9uYW1lID0gc2VsZiA9PSA6Ok9iamVjdCA/IG5hbWUgOiBcIiN7c2VsZn06OiN7bmFtZX1cIlxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwidW5pbml0aWFsaXplZCBjb25zdGFudCAje2Z1bGxfY29uc3RfbmFtZX1cIiwgbmFtZSlcbiAgZW5kXG5cbiAgZGVmIGNvbnN0X3NldChuYW1lLCB2YWx1ZSlcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG5hbWUgPSA6Ok9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgIGlmIG5hbWUgIX4gOjpPcGFsOjpDT05TVF9OQU1FX1JFR0VYUCB8fCBuYW1lLnN0YXJ0X3dpdGg/KCc6OicpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIGAkY29uc3Rfc2V0KHNlbGYsIG5hbWUsIHZhbHVlKWBcblxuICAgIHZhbHVlXG4gIGVuZFxuXG4gIGRlZiBwdWJsaWNfY29uc3RhbnQoY29uc3RfbmFtZSlcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9tZXRob2QobmFtZSwgbWV0aG9kID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbClcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgYSBQcm9jIG9iamVjdCB3aXRob3V0IGEgYmxvY2snfVxuICAgIH1cblxuICAgIGJsb2NrIHx8PSBjYXNlIG1ldGhvZFxuICAgICAgICAgICAgICB3aGVuIDo6UHJvY1xuICAgICAgICAgICAgICAgIG1ldGhvZFxuXG4gICAgICAgICAgICAgIHdoZW4gOjpNZXRob2RcbiAgICAgICAgICAgICAgICBgI3ttZXRob2QudG9fcHJvY30uJCR1bmJvdW5kYFxuXG4gICAgICAgICAgICAgIHdoZW4gOjpVbmJvdW5kTWV0aG9kXG4gICAgICAgICAgICAgICAgLT4oKmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kID0gbWV0aG9kLmJpbmQoc2VsZilcbiAgICAgICAgICAgICAgICAgIGJvdW5kLmNhbGwoKmFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YmxvY2suY2xhc3N9IChleHBlY3RlZCBQcm9jL01ldGhvZClcIlxuICAgICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZihQcm94eSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBtZXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgICAgIGJsb2NrLiQkcHJveHlfdGFyZ2V0ID0gYmxvY2tcbiAgICAgICAgYmxvY2sgPSBuZXcgUHJveHkoYmxvY2ssIHtcbiAgICAgICAgICBhcHBseTogZnVuY3Rpb24odGFyZ2V0LCBzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgb2xkX25hbWUgPSB0YXJnZXQuJCRqc2lkXG4gICAgICAgICAgICB0YXJnZXQuJCRqc2lkID0gbmFtZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgPT09IHRhcmdldC4kJGJyayB8fCBlID09PSB0YXJnZXQuJCRyZXQpIHJldHVybiBlLiR2O1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGFyZ2V0LiQkanNpZCA9IG9sZF9uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBibG9jay4kJGpzaWQgICAgICAgID0gbmFtZTtcbiAgICAgIGJsb2NrLiQkcyAgICAgICAgICAgPSBudWxsO1xuICAgICAgYmxvY2suJCRkZWYgICAgICAgICA9IGJsb2NrO1xuICAgICAgYmxvY2suJCRkZWZpbmVfbWV0aCA9IHRydWU7XG5cbiAgICAgIHJldHVybiBPcGFsLmRlZm4oc2VsZiwgJGpzaWQobmFtZSksIGJsb2NrKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICAjIFNwZWNpYWxpemVkIHZlcnNpb24gb2YgZnJlZXplLCBiZWNhdXNlIHRoZSAkJGJhc2VfbW9kdWxlIHByb3BlcnR5IG5lZWRzIHRvIGJlXG4gICAgIyBhY2Nlc3NpYmxlIGRlc3BpdGUgdGhlIGZyb3plbiBzdGF0dXNcblxuICAgIHJldHVybiBzZWxmIGlmIGZyb3plbj9cblxuICAgICV4e1xuICAgICAgaWYgKCFzZWxmLmhhc093blByb3BlcnR5KCckJGJhc2VfbW9kdWxlJykpIHsgJHByb3Aoc2VsZiwgJyQkYmFzZV9tb2R1bGUnLCBudWxsKTsgfVxuXG4gICAgICByZXR1cm4gJGZyZWV6ZShzZWxmKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfbWV0aG9kKCpuYW1lcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgaWYgKCEodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgfHwgbmFtZS4kJGlzX3N0cmluZykpIHtcbiAgICAgICAgICAje3JhaXNlIDo6VHlwZUVycm9yLCBcIiN7bmFtZX0gaXMgbm90IGEgc3ltYm9sIG5vciBhIHN0cmluZ1wifVxuICAgICAgICB9XG4gICAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgICAgT3BhbC5yZGVmKHNlbGYsIFwiJFwiICsgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzP1xuICAgIGAhIXNlbGYuJCRpc19zaW5nbGV0b25gXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlKCptb2RzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5pbmNsdWRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZF9tb2R1bGVzXG4gICAgYE9wYWwuaW5jbHVkZWRfbW9kdWxlcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1vZClcbiAgICAleHtcbiAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGlpLCBtb2QyLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhzZWxmKTtcblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBtb2QyID0gYW5jZXN0b3JzW2ldO1xuICAgICAgICBpZiAobW9kMiA9PT0gbW9kICYmIG1vZDIgIT09IHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aCA9IHNlbGYuJCRwcm90b3R5cGVbJGpzaWQobmFtZSldO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgY2xhc3MgYCN7c2VsZi5uYW1lfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3s6OlVuYm91bmRNZXRob2QubmV3KHNlbGYsIGBtZXRoLiQkb3duZXIgfHwgI3tzZWxmfWAsIGBtZXRoYCwgbmFtZSl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX21ldGhvZHMoaW5jbHVkZV9zdXBlciA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2luY2x1ZGVfc3VwZXJ9KSkge1xuICAgICAgICByZXR1cm4gT3BhbC5pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5jbHVkZWQobW9kKVxuICBlbmRcblxuICBkZWYgZXh0ZW5kZWQobW9kKVxuICBlbmRcblxuICBkZWYgZXh0ZW5kX29iamVjdChvYmplY3QpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Mob2JqZWN0KWBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3JlbW92ZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF91bmRlZmluZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7bmV3IEZ1bmN0aW9uKFwiT3BhbCxzZWxmXCIsIFwicmV0dXJuIFwiICsgY29tcGlsZWQpKE9wYWwsIHNlbGYpfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLnNpemV9IGZvciAwKVwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXFxuICBOT1RFOklmIHlvdSB3YW50IHRvIGVuYWJsZSBwYXNzaW5nIGEgU3RyaW5nIGFyZ3VtZW50IHBsZWFzZSBhZGQgXFxcInJlcXVpcmUgJ29wYWwtcGFyc2VyJ1xcXCIgdG8geW91ciBzY3JpcHRcXG5cIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIFtzZWxmXSk7XG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2V4ZWMoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJ31cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfZGVmaW5lZD8obWV0aG9kKVxuICAgICV4e1xuICAgICAgdmFyIGJvZHkgPSBzZWxmLiQkcHJvdG90eXBlWyRqc2lkKG1ldGhvZCldO1xuICAgICAgcmV0dXJuICghIWJvZHkpICYmICFib2R5LiQkc3R1YjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtb2R1bGVfZnVuY3Rpb24oKm1ldGhvZHMpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJG1vZHVsZV9mdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWV0aCA9IG1ldGhvZHNbaV0sXG4gICAgICAgICAgICAgIGlkICAgPSAkanNpZChtZXRoKSxcbiAgICAgICAgICAgICAgZnVuYyA9IHNlbGYuJCRwcm90b3R5cGVbaWRdO1xuXG4gICAgICAgICAgT3BhbC5kZWZzKHNlbGYsIGlkLCBmdW5jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kcy5sZW5ndGggPT09IDEgPyBtZXRob2RzWzBdIDogbWV0aG9kcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmFtZVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRmdWxsX25hbWUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRmdWxsX25hbWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSwgYmFzZSA9IHNlbGY7XG5cbiAgICAgIHdoaWxlIChiYXNlKSB7XG4gICAgICAgIC8vIEdpdmUgdXAgaWYgYW55IG9mIHRoZSBhbmNlc3RvcnMgaXMgdW5uYW1lZFxuICAgICAgICBpZiAoYmFzZS4kJG5hbWUgPT09IG5pbCB8fCBiYXNlLiQkbmFtZSA9PSBudWxsKSByZXR1cm4gbmlsO1xuXG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KGJhc2UuJCRuYW1lKTtcblxuICAgICAgICBiYXNlID0gYmFzZS4kJGJhc2VfbW9kdWxlO1xuXG4gICAgICAgIGlmIChiYXNlID09PSAkT2JqZWN0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRmdWxsX25hbWUgPSByZXN1bHQuam9pbignOjonKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kKCptb2RzKVxuICAgICV4e1xuICAgICAgaWYgKG1vZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gMCwgZXhwZWN0ZWQgMSspJ31cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLnByZXBlbmRfZmVhdHVyZXMgc2VsZn07XG4gICAgICAgICN7YG1vZGAucHJlcGVuZGVkIHNlbGZ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByZXBlbmRfZmVhdHVyZXMocHJlcGVuZGVyKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhwcmVwZW5kZXIpO1xuXG4gICAgICBpZiAoIXNlbGYuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7c2VsZi5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIE9wYWwucHJlcGVuZF9mZWF0dXJlcyhzZWxmLCBwcmVwZW5kZXIpXG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByZXBlbmRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY29uc3QobmFtZSlcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGBPcGFsLmNvbnN0X3JlbW92ZShzZWxmLCBuYW1lKWBcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgT3BhbC5Nb2R1bGUuJG5hbWUuY2FsbChzZWxmKWAgfHwgXCIjPCN7YHNlbGYuJCRpc19tb2R1bGUgPyAnTW9kdWxlJyA6ICdDbGFzcydgfToweCN7X19pZF9fLnRvX3MoMTYpfT5cIlxuICBlbmRcblxuICBkZWYgdW5kZWZfbWV0aG9kKCpuYW1lcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgaWYgKCEodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgfHwgbmFtZS4kJGlzX3N0cmluZykpIHtcbiAgICAgICAgICAje3JhaXNlIDo6VHlwZUVycm9yLCBcIiN7bmFtZX0gaXMgbm90IGEgc3ltYm9sIG5vciBhIHN0cmluZ1wifVxuICAgICAgICB9XG4gICAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgICAgT3BhbC51ZGVmKHNlbGYsIFwiJFwiICsgbmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIGNvbnN0cyA9IGNvbnN0YW50c1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgbmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBuYW1lICE9PSAnY29uc3RydWN0b3InICYmICEje2NvbnN0cy5pbmNsdWRlPyhgbmFtZWApfSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdAJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHN1cGVyXG4gICAgY29weS5jb3B5X2NsYXNzX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9jb25zdGFudHMoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3B5X2NsYXNzX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXIuJCRjdmFycykge1xuICAgICAgICBzZWxmLiQkY3ZhcnNbbmFtZV0gPSBvdGhlci4kJGN2YXJzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfY29uc3RhbnRzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIG5hbWUsIG90aGVyX2NvbnN0YW50cyA9IG90aGVyLiQkY29uc3Q7XG5cbiAgICAgIGZvciAobmFtZSBpbiBvdGhlcl9jb25zdGFudHMpIHtcbiAgICAgICAgJGNvbnN0X3NldChzZWxmLCBuYW1lLCBvdGhlcl9jb25zdGFudHNbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlZmluZShrbGFzcywgJmJsb2NrKVxuICAgIHJlZmluZW1lbnRfbW9kdWxlLCBtLCBrbGFzc19pZCA9IHNlbGYsIG5pbCwgbmlsXG4gICAgJXh7XG4gICAgICBrbGFzc19pZCA9IE9wYWwuaWQoa2xhc3MpO1xuICAgICAgaWYgKHR5cGVvZiBzZWxmLiQkcmVmaW5lX21vZHVsZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2VsZi4kJHJlZmluZV9tb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VsZi4kJHJlZmluZV9tb2R1bGVzW2tsYXNzX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBtID0gc2VsZi4kJHJlZmluZV9tb2R1bGVzW2tsYXNzX2lkXSA9ICN7OjpSZWZpbmVtZW50Lm5ld307XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbSA9IHNlbGYuJCRyZWZpbmVfbW9kdWxlc1trbGFzc19pZF07XG4gICAgICB9XG4gICAgICBtLnJlZmluZW1lbnRfbW9kdWxlID0gcmVmaW5lbWVudF9tb2R1bGVcbiAgICAgIG0ucmVmaW5lZF9jbGFzcyA9IGtsYXNzXG4gICAgfVxuICAgIG0uY2xhc3NfZXhlYygmYmxvY2spXG4gICAgbVxuICBlbmRcblxuICBkZWYgcmVmaW5lbWVudHNcbiAgICAleHtcbiAgICAgIHZhciByZWZpbmVfbW9kdWxlcyA9IHNlbGYuJCRyZWZpbmVfbW9kdWxlcywgaGFzaCA9ICN7e319OztcbiAgICAgIGlmICh0eXBlb2YgcmVmaW5lX21vZHVsZXMgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBoYXNoO1xuICAgICAgZm9yICh2YXIgaWQgaW4gcmVmaW5lX21vZHVsZXMpIHtcbiAgICAgICAgaGFzaFsnJFtdPSddKHJlZmluZV9tb2R1bGVzW2lkXS5yZWZpbmVkX2NsYXNzLCByZWZpbmVfbW9kdWxlc1tpZF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICAjIENvbXBpbGVyIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxuICBkZWYgdXNpbmcobW9kKVxuICAgIDo6S2VybmVsLnJhaXNlICdNb2R1bGUjdXNpbmcgaXMgbm90IHBlcm1pdHRlZCBpbiBtZXRob2RzJ1xuICBlbmRcblxuICBhbGlhcyBjbGFzc19ldmFsIG1vZHVsZV9ldmFsXG4gIGFsaWFzIGNsYXNzX2V4ZWMgbW9kdWxlX2V4ZWNcbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5lbmRcblxuY2xhc3MgOjpSZWZpbmVtZW50IDwgOjpNb2R1bGVcbiAgYXR0cl9yZWFkZXIgOnJlZmluZWRfY2xhc3NcblxuICBkZWYgaW5zcGVjdFxuICAgIGlmIEByZWZpbmVtZW50X21vZHVsZVxuICAgICAgXCIjPHJlZmluZW1lbnQ6I3tAcmVmaW5lZF9jbGFzcy5pbnNwZWN0fUAje0ByZWZpbmVtZW50X21vZHVsZS5pbnNwZWN0fT5cIlxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpNb2R1bGU+IiwiYWxsb2NhdGUiLCJzZWxmIiwiaW5pdGlhbGl6ZSIsImJsb2NrX2dpdmVuPyIsIm1vZHVsZV9ldmFsIiwiYmxvY2siLCJ0b19wcm9jIiwiPT09Iiwib2JqZWN0IiwiPCIsIm90aGVyIiwiTW9kdWxlIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCI8PSIsIiRyZXRfb3JfMSIsImVxdWFsPyIsIj4iLCI+PSIsIjw9PiIsImx0IiwibmlsPyIsIi0xIiwiMSIsImFsaWFzX21ldGhvZCIsIm5ld25hbWUiLCJvbGRuYW1lIiwiU3RyaW5nIiwiYWxpYXNfbmF0aXZlIiwibWlkIiwianNpZCIsImFuY2VzdG9ycyIsImFwcGVuZF9mZWF0dXJlcyIsImluY2x1ZGVyIiwiYXR0cl9hY2Nlc3NvciIsImF0dHJfcmVhZGVyIiwibmFtZXMiLCJhdHRyX3dyaXRlciIsImF0dHIiLCJ3YXJuIiwiYXJncyIsImF1dG9sb2FkIiwiY29uc3QkIiwicGF0aCIsIk9wYWwiLCJjb25zdF9uYW1lPyIsIk5hbWVFcnJvciIsIkFyZ3VtZW50RXJyb3IiLCJhdXRvbG9hZD8iLCJjbGFzc192YXJpYWJsZXMiLCJjbGFzc192YXJpYWJsZV9nZXQiLCJuYW1lIiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjbGFzc192YXJpYWJsZV9zZXQiLCJ2YWx1ZSIsImNsYXNzX3ZhcmlhYmxlX2RlZmluZWQ/IiwiY29uc3RfYWRkZWQiLCJwcmlzdGluZSIsInJlbW92ZV9jbGFzc192YXJpYWJsZSIsImNvbnN0YW50cyIsImluaGVyaXQiLCJuZXN0aW5nIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9uYW1lISIsIj1+IiwiT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFAiLCJuZXciLCJjb25zdF9nZXQiLCJpbmplY3QiLCJzcGxpdCIsImJsb2NrIGluIGNvbnN0X2dldCIsIm8iLCJjIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb25zdF9nZXQiLCJjb25zdF9taXNzaW5nIiwiZnVsbF9jb25zdF9uYW1lIiwiT2JqZWN0IiwiY29uc3Rfc2V0IiwiIX4iLCJzdGFydF93aXRoPyIsInB1YmxpY19jb25zdGFudCIsImRlZmluZV9tZXRob2QiLCJtZXRob2QiLCJQcm9jIiwiJHJldF9vcl8yIiwiTWV0aG9kIiwiVW5ib3VuZE1ldGhvZCIsImJsb2NrIGluIGRlZmluZV9tZXRob2QiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmluZV9tZXRob2QiLCJib3VuZCIsImJpbmQiLCJjYWxsIiwiY2xhc3MiLCJmcmVlemUiLCJmcm96ZW4/IiwicmVtb3ZlX21ldGhvZCIsInNpbmdsZXRvbl9jbGFzcz8iLCJpbmNsdWRlIiwiaW5jbHVkZWQiLCJpbmNsdWRlZF9tb2R1bGVzIiwiaW5jbHVkZT8iLCJtb2QiLCJpbnN0YW5jZV9tZXRob2QiLCJpbnN0YW5jZV9tZXRob2RzIiwiaW5jbHVkZV9zdXBlciIsImV4dGVuZGVkIiwiZXh0ZW5kX29iamVjdCIsIm1ldGhvZF9hZGRlZCIsIm1ldGhvZF9yZW1vdmVkIiwibWV0aG9kX3VuZGVmaW5lZCIsIjMiLCJjb3Zlcj8iLCJzaXplIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYmxvY2sgaW4gbW9kdWxlX2V2YWwiLCJibG9jayAoMiBsZXZlbHMpIGluIG1vZHVsZV9ldmFsIiwiYW55PyIsIm1vZHVsZV9leGVjIiwiTG9jYWxKdW1wRXJyb3IiLCJtZXRob2RfZGVmaW5lZD8iLCJtb2R1bGVfZnVuY3Rpb24iLCJwcmVwZW5kIiwicHJlcGVuZF9mZWF0dXJlcyIsInByZXBlbmRlZCIsInByZXBlbmRlciIsInJlbW92ZV9jb25zdCIsInRvX3MiLCJfX2lkX18iLCIxNiIsInVuZGVmX21ldGhvZCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsImNvbnN0cyIsImR1cCIsImNvcHkiLCJjb3B5X2NsYXNzX3ZhcmlhYmxlcyIsImNvcHlfY29uc3RhbnRzIiwicmVmaW5lIiwia2xhc3MiLCJyZWZpbmVtZW50X21vZHVsZSIsIm0iLCJrbGFzc19pZCIsIlJlZmluZW1lbnQiLCJjbGFzc19leGVjIiwicmVmaW5lbWVudHMiLCJ1c2luZyIsIjxjbGFzczpSZWZpbmVtZW50PiIsImluc3BlY3QiLCJAcmVmaW5lbWVudF9tb2R1bGUiLCJAcmVmaW5lZF9jbGFzcyJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxNQUFJQyxJQUFKRCxlQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQU5FQSxDQUFBQTs7QUFTQUUsSUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUNFLElBQXVCQyxlQUF2QjtRQUFBRCxPQUFBRSxNQUFBSCxJQUFBRyxlQUFBQSxFQUFBQSxFQUFBQSxFQUFhQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFaRjtNQUFBO1FBYkpGLE9BQUE7TUFhSTtJQURGQSxDQUFBQTs7QUFJQUssSUFBQUEsbUJBQUFBLDZCQUFRQyxNQUFSRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFpQkEsY0FBakIsQ0FBQTtRQUFBLE9BQU87TUFBUDtNQUVBQSxPQUFDQSx1QkFBREE7SUFIRkEsQ0FBQUE7O0FBTUFFLElBQUFBLGlCQUFBQSx1QkFBTUMs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R0FBdUNBLEdBQXZDLEdBQUEsQ0FBMENDLHNCQUFrQkQsU0FBQUEsQ0FBQUEsQ0FBNUQsQ0FBQSxHQUFxRUE7TUFEdkU7UUFHRUEsT0FBQSxPQUFBM0osSUFBQSxFQUFBLG9EQUFBLFdBQUEsRUFBQSxFQUFBLEVBQUEsTUFBQTtNQUhGO0lBREYySixDQUFBQTtFQUhGRCxHQUFNLElBQU5BLEVBQXFCaEosT0FBckJnSjtBQWh5QkE3SjsifX0seyJvZmZzZXQiOnsibGluZSI6NDI3MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY2xhc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG5cbmNsYXNzIDo6Q2xhc3NcbiAgZGVmIHNlbGYubmV3KHN1cGVyY2xhc3MgPSBPYmplY3QsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghc3VwZXJjbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzc1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHN1cGVyY2xhc3MpO1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICAgICN7YGtsYXNzYC5jbGFzc19ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/fVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuICAgICAgb2JqLiQkaWQgPSBPcGFsLnVpZCgpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZXNjZW5kYW50c1xuICAgIHN1YmNsYXNzZXMgKyBzdWJjbGFzc2VzLm1hcCgmOmRlc2NlbmRhbnRzKS5mbGF0dGVuXG4gIGVuZFxuXG4gIGRlZiBpbmhlcml0ZWQoY2xzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3JpZ2luYWwpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG9yaWdpbmFsKVxuICAgICV4e1xuICAgICAgc2VsZi4kJG5hbWUgPSBudWxsO1xuICAgICAgc2VsZi4kJGZ1bGxfbmFtZSA9IG51bGw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV3KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqZWN0ID0gI3thbGxvY2F0ZX07XG4gICAgICBPcGFsLnNlbmQob2JqZWN0LCBvYmplY3QuJGluaXRpYWxpemUsIGFyZ3MsIGJsb2NrKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3ViY2xhc3Nlc1xuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBXZWFrUmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaSwgc3ViY2xhc3MsIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi4kJHN1YmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJjbGFzcyA9IHNlbGYuJCRzdWJjbGFzc2VzW2ldLmRlcmVmKCk7XG4gICAgICAgICAgaWYgKHN1YmNsYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHN1YmNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHN1YmNsYXNzZXM7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VwZXJjbGFzc1xuICAgIGBzZWxmLiQkc3VwZXIgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICV4e1xuICAgICAgdmFyIHNpbmdsZXRvbl9vZiA9IHNlbGYuJCRzaW5nbGV0b25fb2Y7XG5cbiAgICAgIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiN7YHNpbmdsZXRvbl9vZmAubmFtZX0+XCJ9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2luZ2xldG9uX29mKSB7XG4gICAgICAgIC8vIGEgc2luZ2xldG9uIGNsYXNzIGNyZWF0ZWQgZnJvbSBhbiBvYmplY3RcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiM8I3tgc2luZ2xldG9uX29mLiQkY2xhc3NgLm5hbWV9OjB4I3tgT3BhbC5pZChzaW5nbGV0b25fb2YpYC50b19zKDE2KX0+PlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7c3VwZXIoKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXR0YWNoZWRfb2JqZWN0XG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJHNpbmdsZXRvbl9vZiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkc2luZ2xldG9uX29mO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYCN7c2VsZn0nIGlzIG5vdCBhIHNpbmdsZXRvbiBjbGFzc1wifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6Q2xhc3M+IiwibmV3Iiwic3VwZXJjbGFzcyIsIk9iamVjdCIsImJsb2NrX2dpdmVuPyIsImNsYXNzX2V2YWwiLCJibG9jayIsInRvX3Byb2MiLCJhbGxvY2F0ZSIsImRlc2NlbmRhbnRzIiwiKyIsInN1YmNsYXNzZXMiLCJtYXAiLCJmbGF0dGVuIiwiaW5oZXJpdGVkIiwiaW5pdGlhbGl6ZV9kdXAiLCJvcmlnaW5hbCIsImluaXRpYWxpemVfY29weSIsInRvX3MiLCJuYW1lIiwiMTYiLCJhdHRhY2hlZF9vYmplY3QiLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBLGdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUMsTUFBSUgsSUFBSkcsVUFBQUEsc0JBQWFDLFVBQWJEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWEscUNBQWFFOztBQUU1QkY7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLE1BQVEsQ0FBOEJHLGVBQTlCLEdBQUEsQ0FBT0MsTUFBUEosQ0FBQ0EsS0FBREEsQ0FBT0ksY0FBQUEsRUFBQUEsRUFBQUEsRUFBYUMsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBWkYsQ0FBUCxJQUFBLEdBQUE7QUFDUko7QUFDQUE7SUFWRUEsQ0FBQUEsSUFBQUE7O0FBYUFPLElBQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQTs7QUFRQUMsSUFBQUEsMkJBQUFBLHVCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBV0MsU0FBWFosSUFBQWEsWUFBQUEsQ0FBQUEsQ0FBV0QsRUFBWUUsTUFBVmQsSUFBQWEsWUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTSxhQUFETCxTQUFBQSxDQUFBQSxDQUFMSyxDQUFtQkMsU0FBQUEsQ0FBQUEsQ0FBL0JIO0lBRGJELENBQUFBOztBQUlBSyxJQUFBQSx5QkFBQUEsWUE1QkYsR0E0QkVBLENBQUFBOztBQUdBQyxJQUFBQSw4QkFBQUEsMEJBQW1CQyxRQUFuQkQ7QUFBQUEsTUFBQUE7OztNQUNFakIsSUFBQW1CLGlCQUFBQSxDQUFnQkQsUUFBaEJDOztBQUVKRjtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQTs7QUFRQWQsSUFBQUEsbUJBQUFBLHNCQXZDRixFQXVDRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUF2Q0Y7TUF1Q1U7O0FBRVZBLG1CQUFxQkgsSUFBQVUsVUFBQUEsQ0FBQUEsQ0FBU1A7QUFDOUJBO0FBQ0FBO0FBQ0FBO0lBTEVBLENBQUFBLElBQUFBOztBQVFBVSxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFmRUEsQ0FBQUE7O0FBa0JBVCxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxtQkFBREE7SUFERkEsQ0FBQUE7O0FBSUFnQixJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7QUFFRkE7O0FBRUFBO0FBQ0FBLGVBQWtCQSxVQUFELEdBQUEsQ0FBV0EsQ0FBQ0EsWUFBREEsQ0FBY0MsTUFBQUEsQ0FBQUEsQ0FBekIsQ0FBQSxHQUErQkQsR0FBR0E7QUFDbkRBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGVBQWtCQSxZQUFELEdBQUEsQ0FBYUEsQ0FBQ0Esb0JBQURBLENBQXNCQyxNQUFBQSxDQUFBQSxDQUFuQyxDQUFBLEdBQXlDRCxLQUF6QyxHQUFBLENBQThDQSxDQUFDQSxxQkFBREEsQ0FBdUJBLE1BQUFBLENBQU1FLEVBQU5GLENBQXJFLENBQUEsR0FBK0VBLElBQUlBO0FBQ3BHQTs7QUFFQUEsYUFBZSxPQUFBcEIsSUFBQSxFQUFBLDhDQUFBLFFBQUEsRUFBQSxFQUFBLEVBQUEsSUFBQSxDQUFRb0I7QUFDdkJBO0lBYkVBLENBQUFBOztBQWdCQUcsSUFBQUEsK0JBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFFBQVVDLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTZCSCxHQUFELEdBQUEsQ0FBSXZCLElBQUosQ0FBQSxHQUFTdUIsNEJBQTdCRTtBQUNsQkY7QUFDQUE7SUFSRUEsQ0FBQUE7SUFXQXJCLE9BQUEsYUFBTSxTQUFOLEVBQWMsTUFBZDtFQTlGRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBSDsifX0seyJvZmZzZXQiOnsibGluZSI6NDQwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYmFzaWNfb2JqZWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgdXNlX3N0cmljdDogdHJ1ZVxuXG5jbGFzcyA6OkJhc2ljT2JqZWN0XG4gIGRlZiBpbml0aWFsaXplKCopXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgYWxpYXMgZXF1YWw/ID09XG5cbiAgZGVmIF9faWRfX1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgICB9XG4gICAgICBPcGFsLnByb3Aoc2VsZiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19zZW5kX18oc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFzeW1ib2wuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tyYWlzZSA6OlR5cGVFcnJvciwgXCIje2luc3BlY3R9IGlzIG5vdCBhIHN5bWJvbCBub3IgYSBzdHJpbmdcIn1cbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bmMgPSBzZWxmW09wYWwuanNpZChzeW1ib2wpXTtcblxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgICBmdW5jLiQkcCA9IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJG1ldGhvZF9taXNzaW5nLiQkcCA9IGJsb2NrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kbWV0aG9kX21pc3NpbmcuYXBwbHkoc2VsZiwgW3N5bWJvbF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAhXG4gICAgZmFsc2VcbiAgZW5kXG4gIDo6T3BhbC5wcmlzdGluZSA6IVxuXG4gIGRlZiAhPShvdGhlcilcbiAgICAhKHNlbGYgPT0gb3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7bmV3IEZ1bmN0aW9uKFwiT3BhbCxzZWxmXCIsIFwicmV0dXJuIFwiICsgY29tcGlsZWQpKE9wYWwsIHNlbGYpfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2submlsPyAmJiBhcmdzLmxlbmd0aCA+PSAxICYmIGFyZ3MuZmlyc3RbMF0gPT0gJ0AnXG4gICAgICAjIGdldCBpbnN0YW5jZSB2YXJpYWJsZVxuICAgICAgcmV0dXJuIGluc3RhbmNlX3ZhcmlhYmxlX2dldChhcmdzLmZpcnN0KVxuICAgIGVsc2lmIGFyZ3MuYW55P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5zaXplfSBmb3IgMClcIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgLy8gTmVlZCB0byBwYXNzICQkZXZhbCBzbyB0aGF0IG1ldGhvZCBkZWZpbml0aW9ucyBrbm93IGlmIHRoaXMgaXNcbiAgICAgIC8vIGJlaW5nIGRvbmUgb24gYSBjbGFzcy9tb2R1bGUuIENhbm5vdCBiZSBjb21waWxlciBkcml2ZW4gc2luY2VcbiAgICAgIC8vIHNlbmQoOmluc3RhbmNlX2V2YWwpIG5lZWRzIHRvIHdvcmsuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgfVxuXG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXhlYygqYXJncywgJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IGJsb2NrX3NlbGY7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3Npbmcoc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgIGluc3BlY3RfcmVzdWx0ID0gOjpPcGFsLmluc3BlY3Qoc2VsZilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vTWV0aG9kRXJyb3IubmV3KFxuICAgICAgXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3RfcmVzdWx0fVwiLCBzeW1ib2wsIGFyZ3NcbiAgICApLCBuaWwsIDo6S2VybmVsLmNhbGxlcigxKVxuICBlbmRcblxuICA6Ok9wYWwucHJpc3RpbmUoc2VsZiwgOm1ldGhvZF9taXNzaW5nKVxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZF9uYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpCYXNpY09iamVjdD4iLCJpbml0aWFsaXplIiwiPT0iLCJvdGhlciIsImVxbD8iLCJzZWxmIiwiX19pZF9fIiwiX19zZW5kX18iLCJzeW1ib2wiLCJyYWlzZSIsIlR5cGVFcnJvciIsImluc3BlY3QiLCIhIiwiT3BhbCIsInByaXN0aW5lIiwiIT0iLCJpbnN0YW5jZV9ldmFsIiwiYmxvY2siLCJuaWw/IiwiMSIsIjMiLCJjb3Zlcj8iLCJhcmdzIiwic2l6ZSIsIktlcm5lbCIsIkFyZ3VtZW50RXJyb3IiLCJzdHJpbmciLCJmaWxlIiwiX2xpbmVubyIsImRlZmF1bHRfZXZhbF9vcHRpb25zIiwiJHJldF9vcl8xIiwiY29tcGlsaW5nX29wdGlvbnMiLCJfX09QQUxfQ09NUElMRVJfQ09ORklHX18iLCJtZXJnZSIsImNvbXBpbGVkIiwiY29tcGlsZSIsInByb2MiLCJibG9jayBpbiBpbnN0YW5jZV9ldmFsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnN0YW5jZV9ldmFsIiwiPj0iLCJsZW5ndGgiLCJmaXJzdCIsIltdIiwiMCIsImluc3RhbmNlX3ZhcmlhYmxlX2dldCIsImFueT8iLCJpbnN0YW5jZV9leGVjIiwic2luZ2xldG9uX21ldGhvZF9hZGRlZCIsInNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZCIsInNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkIiwibWV0aG9kX21pc3NpbmciLCJpbnNwZWN0X3Jlc3VsdCIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJjYWxsZXIiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwibWV0aG9kX25hbWUiLCJpbmNsdWRlX2FsbCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOzs7OztBQUNFQyxJQUFBQSwwQkFB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OztNQTNJRjtNQTJJaUM7TUEzSWpDQSxPQUFBO0lBMklFQSxDQUFBQSxJQUFBQTs7QUFHQUMsSUFBQUEsOEJBQUFBLDBCQUFtQjFDLE1BQUQsRUE5SXBCLEVBOElFMEM7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUE5SUY7TUE4STZCO01BQ3pCQyxpQkFBaUJ0QyxLQUFNRixTQUFBQSxDQUFTTixJQUFUTTtNQUN2QnVDLE9BQUExQixPQUFRZixPQUFBQSxDQUFPMkMsb0JBQWVDLEtBQUFBLENBQzNCSCxvQkFBRCxHQUFBLENBQXFCMUMsTUFBckIsQ0FBQSxHQUE0QjBDLFFBQTVCLEdBQUEsQ0FBb0NDLGNBQXBDLENBRGEsRUFDeUMzQyxNQUR6QyxFQUNpRGMsSUFEbEMrQixDQUE5QixFQUVHLEdBRkgsRUFFUTdCLE9BQVE4QixRQUFBQSxDQUFRbkMsQ0FBUm1DLENBRlI3QztJQUZWeUMsQ0FBQUEsSUFBQUE7SUFPQXJDLEtBQU1DLFVBQUFBLENBQVVULElBQWhCLEVBQXNCLGdCQUFoQlM7SUFFTmQsT0FBQXVELG1DQUFBQSxnREFBd0JDLFdBQUQsRUFBY0MsV0FBckNGO0FBQUFBOztNQUFxQyx1Q0FBYztNQUNqREEsT0FBQTtJQURGQSxDQUFBQSxJQUFBQTtFQXJKRnZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ2MjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCByZXNwb25kX3RvLCBPcGFsLCBkZW55X2Zyb3plbl9hY2Nlc3MsIGZyZWV6ZSwgZnJlZXplX3Byb3BzLCBqc2lkXG4jIHVzZV9zdHJpY3Q6IHRydWVcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiA9fihvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmICF+KG9iailcbiAgICAhKHNlbGYgPX4gb2JqKVxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgIG9iamVjdF9pZCA9PSBvdGhlci5vYmplY3RfaWQgfHwgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgICV4e1xuICAgICAgLy8gc2V0IGd1YXJkIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgIHNlbGYuJCRjb21wYXJhYmxlID0gdHJ1ZTtcblxuICAgICAgdmFyIHggPSAje3NlbGYgPT0gb3RoZXJ9O1xuXG4gICAgICBpZiAoeCAmJiB4ICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aCA9IHNlbGZbJGpzaWQobmFtZSldO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgY2xhc3MgYCN7c2VsZi5jbGFzc30nXCIsIG5hbWUpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7OjpNZXRob2QubmV3KHNlbGYsIGBtZXRoLiQkb3duZXIgfHwgI3tzZWxmLmNsYXNzfWAsIGBtZXRoYCwgbmFtZSl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZHMoYWxsID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7YWxsfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwubWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHB1YmxpY19tZXRob2RzKGFsbCA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2FsbH0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5yZWNlaXZlcl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEFycmF5KG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBjb2VyY2VkO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgY29lcmNlZCA9ICN7OjpPcGFsLmNvZXJjZV90bz8ob2JqZWN0LCA6OkFycmF5LCA6dG9fYXJ5KX07XG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XG5cbiAgICAgIGNvZXJjZWQgPSAjezo6T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgOjpBcnJheSwgOnRvX2EpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgcmV0dXJuIFtvYmplY3RdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0X2V4aXQoJmJsb2NrKVxuICAgICRfX2F0X2V4aXRfXyB8fD0gW11cbiAgICAkX19hdF9leGl0X18gPDwgYmxvY2tcbiAgICBibG9ja1xuICBlbmRcblxuICBkZWYgY2FsbGVyKHN0YXJ0ID0gMSwgbGVuZ3RoID0gbmlsKVxuICAgICV4e1xuICAgICAgdmFyIHN0YWNrLCByZXN1bHQ7XG5cbiAgICAgIHN0YWNrID0gbmV3IEVycm9yKCkuJGJhY2t0cmFjZSgpO1xuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAje3N0YXJ0fSArIDEsIGlpID0gc3RhY2subGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBpZiAoIXN0YWNrW2ldLm1hdGNoKC9ydW50aW1lXFwuanMvKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YWNrW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCAhPSBuaWwpIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjYWxsZXJfbG9jYXRpb25zKCphcmdzKVxuICAgIGNhbGxlcigqYXJncykubWFwIGRvIHxsb2N8XG4gICAgICA6OlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbi5uZXcobG9jKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xhc3NcbiAgICBgc2VsZi4kJGNsYXNzYFxuICBlbmRcblxuICBkZWYgY29weV9pbnN0YW5jZV92YXJpYWJsZXMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG90aGVyKSwgaSwgaWksIG5hbWU7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGtleXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBuYW1lID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApICE9PSAnJCcgJiYgb3RoZXIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBzZWxmW25hbWVdID0gb3RoZXJbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb3B5X3NpbmdsZXRvbl9tZXRob2RzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGksIG5hbWUsIG5hbWVzLCBsZW5ndGg7XG5cbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eSgnJCRtZXRhJykgJiYgb3RoZXIuJCRtZXRhICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBvdGhlcl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob3RoZXIpO1xuICAgICAgICB2YXIgc2VsZl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZik7XG4gICAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICBpZiAoT3BhbC5pc19tZXRob2QobmFtZSkpIHtcbiAgICAgICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdID0gb3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QgPSBPYmplY3QuYXNzaWduKHt9LCBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihcbiAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG90aGVyKSwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICckJyAmJiBuYW1lLmNoYXJBdCgxKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiBuaWwpXG4gICAgdW5sZXNzIGZyZWV6ZS5uaWw/IHx8IGZyZWV6ZSA9PSB0cnVlIHx8IGZyZWV6ZSA9PSBmYWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHZhbHVlIGZvciBmcmVlemU6ICN7ZnJlZXplLmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICBjb3B5ID0gc2VsZi5jbGFzcy5hbGxvY2F0ZVxuXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmLCBmcmVlemU6IGZyZWV6ZSlcblxuICAgIGlmIGZyZWV6ZSA9PSB0cnVlIHx8IChmcmVlemUubmlsPyAmJiBmcm96ZW4/KVxuICAgICAgY29weS5mcmVlemVcbiAgICBlbmRcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY2xvbmUob3RoZXIsIGZyZWV6ZTogbmlsKVxuICAgIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfc2luZ2xldG9uX21ldGhvZChuYW1lLCBtZXRob2QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBzaW5nbGV0b25fY2xhc3MuZGVmaW5lX21ldGhvZChuYW1lLCBtZXRob2QsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3RoZXIpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICBlbmRcblxuICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgOjpFbnVtZXJhdG9yLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBlcXVhbD8ob3RoZXIpXG4gICAgYHNlbGYgPT09IG90aGVyYFxuICBlbmRcblxuICBkZWYgZXhpdChzdGF0dXMgPSB0cnVlKVxuICAgICRfX2F0X2V4aXRfXyB8fD0gW11cblxuICAgIHVudGlsICRfX2F0X2V4aXRfXy5lbXB0eT9cbiAgICAgIGJsb2NrID0gJF9fYXRfZXhpdF9fLnBvcFxuICAgICAgYmxvY2suY2FsbFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc3RhdHVzLiQkaXNfYm9vbGVhbikge1xuICAgICAgICBzdGF0dXMgPSBzdGF0dXMgPyAwIDogMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXR1cyA9ICRjb2VyY2VfdG8oc3RhdHVzLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKVxuICAgICAgfVxuXG4gICAgICBPcGFsLmV4aXQoc3RhdHVzKTtcbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBleHRlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICBpZiAobW9kcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAje3JhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuIDAsIGV4cGVjdGVkIDErKSd9XG4gICAgICB9XG5cbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBzaW5nbGV0b24gPSAje3NpbmdsZXRvbl9jbGFzc307XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5hcHBlbmRfZmVhdHVyZXMgYHNpbmdsZXRvbmB9O1xuICAgICAgICAje2Btb2RgLmV4dGVuZF9vYmplY3Qgc2VsZn07XG4gICAgICAgICN7YG1vZGAuZXh0ZW5kZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mKHNlbGYpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICRmcmVlemVfcHJvcHMoc2VsZik7XG4gICAgICAgIHJldHVybiAkZnJlZXplKHNlbGYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZnJvemVuP1xuICAgICV4e1xuICAgICAgc3dpdGNoICh0eXBlb2Yoc2VsZikpIHtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICByZXR1cm4gKHNlbGYuJCRmcm96ZW4gfHwgZmFsc2UpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdldHMoKmFyZ3MpXG4gICAgJHN0ZGluLmdldHMoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgX19pZF9fXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGB2YXIgaW5zcGVjdF9zdGFjayA9IFtdYFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgaXZzID0gJydcbiAgICBpZCA9IF9faWRfX1xuICAgIGlmIGBpbnNwZWN0X3N0YWNrYC5pbmNsdWRlPyBpZFxuICAgICAgaXZzID0gJyAuLi4nXG4gICAgZWxzZVxuICAgICAgYGluc3BlY3Rfc3RhY2tgIDw8IGlkXG4gICAgICBwdXNoZWQgPSB0cnVlXG4gICAgICBpbnN0YW5jZV92YXJpYWJsZXMuZWFjaCBkbyB8aXxcbiAgICAgICAgaXZhciA9IGluc3RhbmNlX3ZhcmlhYmxlX2dldChpKVxuICAgICAgICBpbnNwZWN0ID0gT3BhbC5pbnNwZWN0KGl2YXIpXG4gICAgICAgIGl2cyArPSBcIiAje2l9PSN7aW5zcGVjdH1cIlxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje2lkLnRvX3MoMTYpfSN7aXZzfT5cIlxuICByZXNjdWUgPT4gZVxuICAgIFwiIzwje3NlbGYuY2xhc3N9OjB4I3tpZC50b19zKDE2KX0+XCJcbiAgZW5zdXJlXG4gICAgYGluc3BlY3Rfc3RhY2tgLnBvcCBpZiBwdXNoZWRcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICAleHtcbiAgICAgIGlmICgha2xhc3MuJCRpc19jbGFzcyAmJiAha2xhc3MuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2NsYXNzIG9yIG1vZHVsZSByZXF1aXJlZCd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNsYXNzID09PSBrbGFzcztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSA6Ok9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZiwgbmFtZS5zdWJzdHIoMSkpYFxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfZ2V0KG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICB2YXIgaXZhciA9IHNlbGZbT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKV07XG5cbiAgICAgIHJldHVybiBpdmFyID09IG51bGwgPyBuaWwgOiBpdmFyO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX3NldChuYW1lLCB2YWx1ZSlcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG5hbWUgPSA6Ok9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBzZWxmW09wYWwuaXZhcihuYW1lLnN1YnN0cigxKSldID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBrZXkgPSBPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpLFxuICAgICAgICAgIHZhbDtcbiAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFsID0gc2VsZltrZXldO1xuICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcImluc3RhbmNlIHZhcmlhYmxlICN7bmFtZX0gbm90IGRlZmluZWRcIlxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGl2YXI7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gJyQnKSB7XG4gICAgICAgICAgaWYgKG5hbWUuc3Vic3RyKC0xKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgaXZhcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBJbnRlZ2VyKHZhbHVlLCBiYXNlID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGksIHN0ciwgYmFzZV9kaWdpdHM7XG5cbiAgICAgIGlmICghdmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYmFzZSBzcGVjaWZpZWQgZm9yIG5vbiBzdHJpbmcgdmFsdWUnfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEludGVnZXJcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8IHZhbHVlID09PSAtSW5maW5pdHkgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgdmFsdWV9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyg6dG9faW50KX0pIHtcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pbnR9O1xuICAgICAgICAgIGlmIChpICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3s6Ok9wYWwuY29lcmNlX3RvISh2YWx1ZSwgOjpJbnRlZ2VyLCA6dG9faSl9O1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IFwiMFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJhc2UgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9ICRjb2VyY2VfdG8oYmFzZSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChiYXNlID09PSAxIHx8IGJhc2UgPCAwIHx8IGJhc2UgPiAzNikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwifVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0ciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KS8sIGZ1bmN0aW9uIChfLCBoZWFkLCBmbGFnKSB7XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMikge1xuICAgICAgICAgICAgYmFzZSA9IDI7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8tYnJlYWtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSA4KSB7XG4gICAgICAgICAgICBiYXNlID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTApIHtcbiAgICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgICAgIGJhc2UgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICB9XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfSk7XG5cbiAgICAgIGJhc2UgPSAoYmFzZSA9PT0gMCA/IDEwIDogYmFzZSk7XG5cbiAgICAgIGJhc2VfZGlnaXRzID0gJzAtJyArIChiYXNlIDw9IDEwID8gYmFzZSAtIDEgOiAnOWEtJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAoYmFzZSAtIDExKSkpO1xuXG4gICAgICBpZiAoIShuZXcgUmVnRXhwKCdeXFxcXHMqWystXT9bJyArIGJhc2VfZGlnaXRzICsgJ10rXFxcXHMqJCcpKS50ZXN0KHN0cikpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9XG5cbiAgICAgIGkgPSBwYXJzZUludChzdHIsIGJhc2UpO1xuXG4gICAgICBpZiAoaXNOYU4oaSkpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEZsb2F0KHZhbHVlKVxuICAgICV4e1xuICAgICAgdmFyIHN0cjtcblxuICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEZsb2F0XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBoZXggc3RyaW5ncyBvbmx5OlxuICAgICAgICBpZiAoL15cXHMqWy0rXT8wW3hYXVswLTlhLWZBLUZdK1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5JbnRlZ2VyKGBzdHJgKX07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIS9eXFxzKlstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspP1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBGbG9hdCgpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3s6Ok9wYWwuY29lcmNlX3RvISh2YWx1ZSwgOjpGbG9hdCwgOnRvX2YpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBIYXNoKGFyZylcbiAgICByZXR1cm4ge30gaWYgYXJnLm5pbD8gfHwgYXJnID09IFtdXG4gICAgcmV0dXJuIGFyZyBpZiA6Okhhc2ggPT09IGFyZ1xuICAgIDo6T3BhbC5jb2VyY2VfdG8hKGFyZywgOjpIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPcGFsLmlzX2Eoc2VsZiwga2xhc3MpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGl0c2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxhbWJkYSgmYmxvY2spXG4gICAgYE9wYWwubGFtYmRhKGJsb2NrKWBcbiAgZW5kXG5cbiAgZGVmIGxvYWQoZmlsZSlcbiAgICBmaWxlID0gOjpPcGFsLmNvZXJjZV90byEoZmlsZSwgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgYE9wYWwubG9hZCgje2ZpbGV9KWBcbiAgZW5kXG5cbiAgZGVmIGxvb3BcbiAgICByZXR1cm4gZW51bV9mb3IoOmxvb3ApIHsgOjpGbG9hdDo6SU5GSU5JVFkgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSB0cnVlXG4gICAgICBiZWdpblxuICAgICAgICB5aWVsZFxuICAgICAgcmVzY3VlIDo6U3RvcEl0ZXJhdGlvbiA9PiBlXG4gICAgICAgIHJldHVybiBlLnJlc3VsdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaW50ZigqYXJncylcbiAgICBpZiBhcmdzLmFueT9cbiAgICAgIHByaW50IGZvcm1hdCgqYXJncylcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcHJvYygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYGJsb2NrLiQkaXNfbGFtYmRhID0gZmFsc2VgXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKnN0cnMpXG4gICAgJHN0ZG91dC5wdXRzKCpzdHJzKVxuICBlbmRcblxuICBkZWYgcCgqYXJncylcbiAgICBhcmdzLmVhY2ggeyB8b2JqfCAkc3Rkb3V0LnB1dHMgb2JqLmluc3BlY3QgfVxuXG4gICAgYXJncy5sZW5ndGggPD0gMSA/IGFyZ3NbMF0gOiBhcmdzXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqc3RycylcbiAgICAkc3Rkb3V0LnByaW50KCpzdHJzKVxuICBlbmRcblxuICBkZWYgcmVhZGxpbmUoKmFyZ3MpXG4gICAgJHN0ZGluLnJlYWRsaW5lKCphcmdzKVxuICBlbmRcblxuICBkZWYgd2Fybigqc3RycywgdXBsZXZlbDogbmlsKVxuICAgIGlmIHVwbGV2ZWxcbiAgICAgIHVwbGV2ZWwgPSA6Ok9wYWwuY29lcmNlX3RvISh1cGxldmVsLCA6OkludGVnZXIsIDp0b19zdHIpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibmVnYXRpdmUgbGV2ZWwgKCN7dXBsZXZlbH0pXCIgaWYgdXBsZXZlbCA8IDBcbiAgICAgIGxvY2F0aW9uID0gY2FsbGVyKHVwbGV2ZWwgKyAxLCAxKS5maXJzdCYuc3BsaXQoJzppbiBgJykmLmZpcnN0XG4gICAgICBsb2NhdGlvbiA9IFwiI3tsb2NhdGlvbn06IFwiIGlmIGxvY2F0aW9uXG4gICAgICBzdHJzID0gc3Rycy5tYXAgeyB8c3wgXCIje2xvY2F0aW9ufXdhcm5pbmc6ICN7c31cIiB9XG4gICAgZW5kXG5cbiAgICAkc3RkZXJyLnB1dHMoKnN0cnMpIHVubGVzcyAkVkVSQk9TRS5uaWw/IHx8IHN0cnMuZW1wdHk/XG4gIGVuZFxuXG4gIGRlZiByYWlzZShleGNlcHRpb24gPSB1bmRlZmluZWQsIHN0cmluZyA9IG5pbCwgYmFja3RyYWNlID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKGV4Y2VwdGlvbiA9PSBudWxsICYmICN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgdGhyb3cgI3skIX07XG4gICAgICB9XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3s6OlJ1bnRpbWVFcnJvci5uZXcgJyd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoJHJlc3BvbmRfdG8oZXhjZXB0aW9uLCAnJHRvX3N0cicpKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7OjpSdW50aW1lRXJyb3IubmV3IGV4Y2VwdGlvbi50b19zdHJ9O1xuICAgICAgfVxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfY2xhc3MgJiYgJHJlc3BvbmRfdG8oZXhjZXB0aW9uLCAnJGV4Y2VwdGlvbicpKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7ZXhjZXB0aW9uLmV4Y2VwdGlvbiBzdHJpbmd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfZXhjZXB0aW9uKSB7XG4gICAgICAgIC8vIGV4Y2VwdGlvbiBpcyBmaW5lXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3s6OlR5cGVFcnJvci5uZXcgJ2V4Y2VwdGlvbiBjbGFzcy9vYmplY3QgZXhwZWN0ZWQnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhY2t0cmFjZSAhPT0gbmlsKSB7XG4gICAgICAgIGV4Y2VwdGlvbi4kc2V0X2JhY2t0cmFjZShiYWNrdHJhY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3skIX0gIT09IG5pbCkge1xuICAgICAgICBPcGFsLmV4Y2VwdGlvbnMucHVzaCgjeyQhfSk7XG4gICAgICB9XG5cbiAgICAgICN7JCF9ID0gZXhjZXB0aW9uO1xuICAgICAgI3skQH0gPSAje2BleGNlcHRpb25gLmJhY2t0cmFjZX07XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByYW5kKG1heCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3s6OlJhbmRvbTo6REVGQVVMVC5yYW5kfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAobWF4IDwgMCkge1xuICAgICAgICAgIG1heCA9IE1hdGguYWJzKG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ICUgMSAhPT0gMCkge1xuICAgICAgICAgIG1heCA9IG1heC4kdG9faSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCA9PT0gMCkge1xuICAgICAgICAgIG1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICA6OlJhbmRvbTo6REVGQVVMVC5yYW5kKG1heClcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG8/KG5hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgJXh7XG4gICAgICB2YXIgYm9keSA9IHNlbGZbJGpzaWQobmFtZSldO1xuXG4gICAgICBpZiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZlsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXS4kJHByaXN0aW5lID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAje3Jlc3BvbmRfdG9fbWlzc2luZz8obmFtZSwgaW5jbHVkZV9hbGwpfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZF9uYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIDo6T3BhbC5wcmlzdGluZShzZWxmLCA6cmVzcG9uZF90bz8sIDpyZXNwb25kX3RvX21pc3Npbmc/KVxuXG4gIGRlZiByZXF1aXJlKGZpbGUpXG4gICAgJXh7XG4gICAgICAvLyBBcyBPYmplY3QucmVxdWlyZSByZWZlcnMgdG8gS2VybmVsLnJlcXVpcmUgb25jZSBLZXJuZWwgaGFzIGJlZW4gbG9hZGVkIHRoZSBTdHJpbmdcbiAgICAgIC8vIGNsYXNzIG1heSBub3QgYmUgYXZhaWxhYmxlIHlldCwgdGhlIGNvZXJjaW9uIHJlcXVpcmVzIGJvdGggIFN0cmluZyBhbmQgQXJyYXkgdG8gYmUgbG9hZGVkLlxuICAgICAgaWYgKHR5cGVvZiAje2ZpbGV9ICE9PSAnc3RyaW5nJyAmJiBPcGFsLlN0cmluZyAmJiBPcGFsLkFycmF5KSB7XG4gICAgICAgICN7ZmlsZSA9IDo6T3BhbC5jb2VyY2VfdG8hKGZpbGUsIDo6U3RyaW5nLCA6dG9fc3RyKSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3BhbC5yZXF1aXJlKCN7ZmlsZX0pXG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVxdWlyZV9yZWxhdGl2ZShmaWxlKVxuICAgIDo6T3BhbC50cnlfY29udmVydCEoZmlsZSwgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgZmlsZSA9IDo6RmlsZS5leHBhbmRfcGF0aCA6OkZpbGUuam9pbihgT3BhbC5jdXJyZW50X2ZpbGVgLCAnLi4nLCBmaWxlKVxuXG4gICAgYE9wYWwucmVxdWlyZSgje2ZpbGV9KWBcbiAgZW5kXG5cbiAgIyBgcGF0aGAgc2hvdWxkIGJlIHRoZSBmdWxsIHBhdGggdG8gYmUgZm91bmQgaW4gcmVnaXN0ZXJlZCBtb2R1bGVzIChgT3BhbC5tb2R1bGVzYClcbiAgZGVmIHJlcXVpcmVfdHJlZShwYXRoLCBhdXRvbG9hZDogZmFsc2UpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHBhdGggPSAjezo6RmlsZS5leHBhbmRfcGF0aChwYXRoKX1cbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIGlmIChwYXRoID09PSAnLicpIHBhdGggPSAnJztcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgIGlmICgje2BuYW1lYC5zdGFydF93aXRoPyhwYXRoKX0pIHtcbiAgICAgICAgICBpZighI3thdXRvbG9hZH0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtuYW1lLCBPcGFsLnJlcXVpcmUobmFtZSldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW25hbWUsIHRydWVdKTsgLy8gZG8gbm90aGluZywgZGVsZWdhdGVkIHRvIGEgYXV0b2xvYWRpbmdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3NcbiAgICBgT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgc2xlZXAoc2Vjb25kcyA9IG5pbClcbiAgICAleHtcbiAgICAgIGlmIChzZWNvbmRzID09PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IE5pbENsYXNzIGludG8gdGltZSBpbnRlcnZhbFwifVxuICAgICAgfVxuICAgICAgaWYgKCFzZWNvbmRzLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlY29uZHMuY2xhc3N9IGludG8gdGltZSBpbnRlcnZhbFwifVxuICAgICAgfVxuICAgICAgaWYgKHNlY29uZHMgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndGltZSBpbnRlcnZhbCBtdXN0IGJlIHBvc2l0aXZlJ31cbiAgICAgIH1cbiAgICAgIHZhciBnZXRfdGltZSA9IE9wYWwuZ2xvYmFsLnBlcmZvcm1hbmNlID9cbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfSA6XG4gICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBuZXcgRGF0ZSgpfVxuXG4gICAgICB2YXIgdCA9IGdldF90aW1lKCk7XG4gICAgICB3aGlsZSAoZ2V0X3RpbWUoKSAtIHQgPD0gc2Vjb25kcyAqIDEwMDApO1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoc2Vjb25kcyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3JhbmQoc2VlZCA9IFJhbmRvbS5uZXdfc2VlZClcbiAgICA6OlJhbmRvbS5zcmFuZChzZWVkKVxuICBlbmRcblxuICBkZWYgU3RyaW5nKHN0cilcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyhzdHIsIDo6U3RyaW5nLCA6dG9fc3RyKSB8fFxuICAgICAgOjpPcGFsLmNvZXJjZV90byEoc3RyLCA6OlN0cmluZywgOnRvX3MpXG4gIGVuZFxuXG4gIGRlZiB0YXAoJmJsb2NrKVxuICAgIHlpZWxkIHNlbGZcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIFwiIzwje3NlbGYuY2xhc3N9OjB4I3tfX2lkX18udG9fcygxNil9PlwiXG4gIGVuZFxuXG4gIGRlZiBjYXRjaCh0YWcgPSBuaWwpXG4gICAgdGFnIHx8PSA6Ok9iamVjdC5uZXdcbiAgICB5aWVsZCh0YWcpXG4gIHJlc2N1ZSA6OlVuY2F1Z2h0VGhyb3dFcnJvciA9PiBlXG4gICAgcmV0dXJuIGUudmFsdWUgaWYgZS50YWcgPT0gdGFnXG4gICAgOjpLZXJuZWwucmFpc2VcbiAgZW5kXG5cbiAgZGVmIHRocm93KHRhZywgb2JqID0gbmlsKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6VW5jYXVnaHRUaHJvd0Vycm9yLm5ldyh0YWcsIG9iailcbiAgZW5kXG5cbiAgIyBiYXNpYyBpbXBsZW1lbnRhdGlvbiBvZiBvcGVuLCBkZWxlZ2F0ZSB0byBGaWxlLm9wZW5cbiAgZGVmIG9wZW4oKmFyZ3MsICZibG9jaylcbiAgICA6OkZpbGUub3BlbigqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgeWllbGRfc2VsZlxuICAgIHJldHVybiBlbnVtX2Zvcig6eWllbGRfc2VsZikgeyAxIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgIHlpZWxkIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgZmFpbCByYWlzZVxuICBhbGlhcyBraW5kX29mPyBpc19hP1xuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG4gIGFsaWFzIHB1YmxpY19zZW5kIF9fc2VuZF9fXG4gIGFsaWFzIHNlbmQgX19zZW5kX19cbiAgYWxpYXMgdGhlbiB5aWVsZF9zZWxmXG4gIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcbmVuZFxuXG5jbGFzcyA6Ok9iamVjdFxuICAjIE9iamVjdC5yZXF1aXJlIGhhcyBiZWVuIHNldCB0byBydW50aW1lLmpzIE9wYWwucmVxdWlyZVxuICAjIE5vdyB3ZSBoYXZlIEtlcm5lbCBsb2FkZWQsIG1ha2Ugc3VyZSBPYmplY3QucmVxdWlyZSByZWZlcnMgdG8gS2VybmVsLnJlcXVpcmVcbiAgIyB3aGljaCBpcyB3aGF0IHJ1YnkgZG9lcyBhbmQgYWxsb3dzIGZvciBvdmVyd3JpdGluZyBieSBhdXRvbG9hZGVyc1xuICBgZGVsZXRlICRPYmplY3QuJCRwcm90b3R5cGUuJHJlcXVpcmVgXG4gIGluY2x1ZGUgOjpLZXJuZWxcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOktlcm5lbD4iLCI9fiIsIiF+Iiwib2JqIiwic2VsZiIsIiEiLCI9PT0iLCJvdGhlciIsIiRyZXRfb3JfMSIsIm9iamVjdF9pZCIsIj09IiwiPD0+IiwibWV0aG9kIiwibmFtZSIsIktlcm5lbCIsInJhaXNlIiwiTmFtZUVycm9yIiwibmV3IiwiY2xhc3MiLCJNZXRob2QiLCJtZXRob2RzIiwiYWxsIiwicHVibGljX21ldGhvZHMiLCJBcnJheSIsIm9iamVjdCIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiYXRfZXhpdCIsIiRfX2F0X2V4aXRfXyIsIjw8IiwiYmxvY2siLCJjYWxsZXIiLCJzdGFydCIsImxlbmd0aCIsIjEiLCJjYWxsZXJfbG9jYXRpb25zIiwibWFwIiwiYXJncyIsImJsb2NrIGluIGNhbGxlcl9sb2NhdGlvbnMiLCJsb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIGNhbGxlcl9sb2NhdGlvbnMiLCJUaHJlYWQ6OkJhY2t0cmFjZTo6TG9jYXRpb24iLCJUaHJlYWQ6OkJhY2t0cmFjZSIsIlRocmVhZCIsImNvcHlfaW5zdGFuY2VfdmFyaWFibGVzIiwiY29weV9zaW5nbGV0b25fbWV0aG9kcyIsImNsb25lIiwiJGt3YXJncyIsImZyZWV6ZSIsIm5pbD8iLCJBcmd1bWVudEVycm9yIiwiY29weSIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZV9jbG9uZSIsImZyb3plbj8iLCJpbml0aWFsaXplX2NvcHkiLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImRlZmluZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19wcm9jIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJlbnVtX2ZvciIsImZvciIsIkVudW1lcmF0b3IiLCJlcXVhbD8iLCJleGl0Iiwic3RhdHVzIiwiZW1wdHk/IiwicG9wIiwiY2FsbCIsIkludGVnZXIiLCJleHRlbmQiLCJUeXBlRXJyb3IiLCJhcHBlbmRfZmVhdHVyZXMiLCJleHRlbmRfb2JqZWN0IiwiZXh0ZW5kZWQiLCJnZXRzIiwiJHN0ZGluIiwiaGFzaCIsIl9faWRfXyIsImluc3BlY3QiLCJpdnMiLCJpZCIsImluY2x1ZGU/IiwicHVzaGVkIiwiZWFjaCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsImJsb2NrIGluIGluc3BlY3QiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnNwZWN0IiwiaXZhciIsImluc3RhbmNlX3ZhcmlhYmxlX2dldCIsIisiLCJ0b19zIiwiMTYiLCJTdGFuZGFyZEVycm9yIiwiZSIsImluc3RhbmNlX29mPyIsImtsYXNzIiwiaW5zdGFuY2VfdmFyaWFibGVfZGVmaW5lZD8iLCJpbnN0YW5jZV92YXJpYWJsZV9uYW1lISIsImluc3RhbmNlX3ZhcmlhYmxlX3NldCIsInZhbHVlIiwicmVtb3ZlX2luc3RhbmNlX3ZhcmlhYmxlIiwiYmFzZSIsIkZsb2F0RG9tYWluRXJyb3IiLCJyZXNwb25kX3RvPyIsInRvX2ludCIsImNvZXJjZV90byEiLCJGbG9hdCIsIkhhc2giLCJhcmciLCJpc19hPyIsIml0c2VsZiIsImxhbWJkYSIsImxvYWQiLCJmaWxlIiwiU3RyaW5nIiwibG9vcCIsImJsb2NrX2dpdmVuPyIsImJsb2NrIGluIGxvb3AiLCJibG9jayAoMiBsZXZlbHMpIGluIGxvb3AiLCJGbG9hdDo6SU5GSU5JVFkiLCJTdG9wSXRlcmF0aW9uIiwicmVzdWx0IiwicHJpbnRmIiwiYW55PyIsInByaW50IiwiZm9ybWF0IiwicHJvYyIsInB1dHMiLCIkc3Rkb3V0Iiwic3RycyIsInAiLCJibG9jayBpbiBwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwIiwiPD0iLCJbXSIsIjAiLCJyZWFkbGluZSIsIndhcm4iLCJ1cGxldmVsIiwiPCIsImxvY2F0aW9uIiwiZmlyc3QiLCJibG9jayBpbiB3YXJuIiwicyIsImJsb2NrICgyIGxldmVscykgaW4gd2FybiIsIiRWRVJCT1NFIiwiJHN0ZGVyciIsImV4Y2VwdGlvbiIsInN0cmluZyIsImJhY2t0cmFjZSIsIiQhIiwiUnVudGltZUVycm9yIiwidG9fc3RyIiwiJEAiLCJyYW5kIiwibWF4IiwiUmFuZG9tOjpERUZBVUxUIiwiUmFuZG9tIiwiaW5jbHVkZV9hbGwiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwibWV0aG9kX25hbWUiLCJwcmlzdGluZSIsInJlcXVpcmUiLCJyZXF1aXJlX3JlbGF0aXZlIiwidHJ5X2NvbnZlcnQhIiwiRmlsZSIsImV4cGFuZF9wYXRoIiwiam9pbiIsInJlcXVpcmVfdHJlZSIsInBhdGgiLCJzdGFydF93aXRoPyIsImF1dG9sb2FkIiwic2xlZXAiLCJzZWNvbmRzIiwic3JhbmQiLCJzZWVkIiwibmV3X3NlZWQiLCJzdHIiLCJ0YXAiLCJjYXRjaCIsInRhZyIsIk9iamVjdCIsIlVuY2F1Z2h0VGhyb3dFcnJvciIsInRocm93Iiwib3BlbiIsInlpZWxkX3NlbGYiLCJibG9jayBpbiB5aWVsZF9zZWxmIiwiPGNsYXNzOk9iamVjdD4iLCJpbmNsdWRlIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBR0FDO0VBQUFBOztJQUFBQTs7OztBQUNFQyxJQUFBQSxrQkFBQUEsWUFDRSxLQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsa0JBQUFBLCtCQUFPQyxHQUFQRDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBRUUsSUFBS0gsT0FBQUEsQ0FBR0UsR0FBSEYsQ0FBUEksTUFBQUEsQ0FBQUE7SUFERkgsQ0FBQUE7O0FBSUFJLElBQUFBLG1CQUFBQSw2QkFBUUMsS0FBUkQ7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFBRSxDQUFBQSxZQUFBSixJQUFBSyxXQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHSCxLQUFLRSxXQUFBQSxDQUFBQSxDQUFSQyxDQUFWRixDQUFBLENBQUE7UUFBQUYsT0FBQTtNQUFBO1FBQWdDQSxPQUFBRixJQUFLTSxPQUFBQSxDQUFHSCxLQUFIRztNQUFyQztJQURGSixDQUFBQTs7QUFJQUssSUFBQUEsbUJBQUFBLDZCQUFRSixLQUFSSTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBOztBQUVBQSxjQUFnQlAsSUFBS00sT0FBQUEsQ0FBR0gsS0FB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QVg7SUFDQSxhQUFNLFVBQU4sRUFBZSxPQUFmO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLFFBQWhCO0lBQ0EsYUFBTSxhQUFOLEVBQWtCLFVBQWxCO0lBQ0EsYUFBTSxNQUFOLEVBQVcsVUFBWDtJQUNBLGFBQU0sTUFBTixFQUFXLFlBQVg7SUFDQTdMLE9BQUEsYUFBTSxTQUFOLEVBQWMsVUFBZDtFQTV4QkZBLEdBQU8sSUFBUEE7RUEreEJBRCxPQUFBZ007RUFBQUE7Ozs7SUFJR0E7SUFDREEsT0FBQTNMLElBQUE0TCxTQUFBQSxDQUFRbEwsT0FBUmtMO0VBTEZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFseUJBaE07In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU3MTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21haW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgPDwgc2VsZlxuICBkZWYgdG9fc1xuICAgICdtYWluJ1xuICBlbmRcblxuICBkZWYgaW5jbHVkZShtb2QpXG4gICAgOjpPYmplY3QuaW5jbHVkZSBtb2RcbiAgZW5kXG5cbiAgZGVmIGF1dG9sb2FkKCphcmdzKVxuICAgIGBPcGFsLk9iamVjdC4kYXV0b2xvYWQuYXBwbHkoT3BhbC5PYmplY3QsIGFyZ3MpYFxuICBlbmRcblxuICAjIENvbXBpbGVyIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxuICBkZWYgdXNpbmcobW9kKVxuICAgIDo6S2VybmVsLnJhaXNlICdtYWluLnVzaW5nIGlzIHBlcm1pdHRlZCBvbmx5IGF0IHRvcGxldmVsJ1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJ0b19zIiwiaW5jbHVkZSIsIm1vZCIsIk9iamVjdCIsImF1dG9sb2FkIiwidXNpbmciLCJLZXJuZWwiLCJyYWlzZSIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBOzs7O0FBQ0VDLElBQUFBLG9CQUFBQSxZQUNFLE1BREZBLENBQUFBOztBQUlBQyxJQUFBQSx1QkFBQUEsbUJBQVlDLEdBQVpEO0FBQUFBO01BQ0VBLE9BQUFFLE9BQVFGLFNBQUFBLENBQVNDLEdBQVREO0lBRFZBLENBQUFBOztBQUlBRyxJQUFBQSx3QkFBQUEsb0JBVEYsRUFTRUE7QUFBQUEsTUFBQUE7OztNQVRGO01BU2U7TUFDWEEsT0FBQ0EsOENBQURBO0lBREZBLENBQUFBLElBQUFBO0lBS0EsT0FBQUMscUJBQUFBLGlCQUFVSCxHQUFWRztBQUFBQTtNQUNFQSxPQUFBQyxPQUFRQyxPQUFBQSxDQUFPRiwwQ0FBUEU7SUFEVkYsQ0FBQUE7RUFkRiw0QkFBU0csSUFBVDtBQUFBVDsifX0seyJvZmZzZXQiOnsibGluZSI6NTc0NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZXJyb3IvZXJybm8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIDo6RXJybm9cbiAgZXJyb3JzID0gW1xuICAgIFs6RUlOVkFMLCAnSW52YWxpZCBhcmd1bWVudCcsIDIyXSxcbiAgICBbOkVFWElTVCwgJ0ZpbGUgZXhpc3RzJywgMTddLFxuICAgIFs6RUlTRElSLCAnSXMgYSBkaXJlY3RvcnknLCAyMV0sXG4gICAgWzpFTUZJTEUsICdUb28gbWFueSBvcGVuIGZpbGVzJywgMjRdLFxuICAgIFs6RVNQSVBFLCAnSWxsZWdhbCBzZWVrJywgMjldLFxuICAgIFs6RUFDQ0VTLCAnUGVybWlzc2lvbiBkZW5pZWQnLCAxM10sXG4gICAgWzpFUEVSTSwgJ09wZXJhdGlvbiBub3QgcGVybWl0dGVkJywgMV0sXG4gICAgWzpFTk9FTlQsICdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JywgMl0sXG4gICAgWzpFTkFNRVRPT0xPTkcsICdGaWxlIG5hbWUgdG9vIGxvbmcnLCAzNl1cbiAgXVxuXG4gIGtsYXNzID0gbmlsXG5cbiAgJXh7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKCkgeyAvLyBDcmVhdGUgYSBjbG9zdXJlXG4gICAgICAgIHZhciBjbGFzc19uYW1lID0gZXJyb3JzW2ldWzBdO1xuICAgICAgICB2YXIgZGVmYXVsdF9tZXNzYWdlID0gZXJyb3JzW2ldWzFdO1xuICAgICAgICB2YXIgZXJybm8gPSBlcnJvcnNbaV1bMl07XG5cbiAgICAgICAga2xhc3MgPSBPcGFsLmtsYXNzKHNlbGYsIE9wYWwuU3lzdGVtQ2FsbEVycm9yLCBjbGFzc19uYW1lKTtcbiAgICAgICAga2xhc3MuZXJybm8gPSBlcnJubztcblxuICAgICAgICAje1xuICAgICAgICAgIGNsYXNzIDw8IGtsYXNzXG4gICAgICAgICAgICBkZWYgbmV3KG5hbWUgPSBuaWwpXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBgZGVmYXVsdF9tZXNzYWdlYFxuICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIC0gI3tuYW1lfVwiIGlmIG5hbWVcbiAgICAgICAgICAgICAgc3VwZXIobWVzc2FnZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfVxuZW5kXG5cbmNsYXNzIDo6U3lzdGVtQ2FsbEVycm9yIDwgOjpTdGFuZGFyZEVycm9yXG4gIGRlZiBlcnJub1xuICAgIHNlbGYuY2xhc3MuZXJybm9cbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGF0dHJfcmVhZGVyIDplcnJub1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkVycm5vPiIsImVycm9ycyIsIjIyIiwiMTciLCIyMSIsIjI0IiwiMjkiLCIxMyIsIjEiLCIyIiwiMzYiLCJrbGFzcyIsIm5ldyIsIm5hbWUiLCJtZXNzYWdlIiwiKyIsInNlbGYiLCI8Y2xhc3M6U3lzdGVtQ2FsbEVycm9yPiIsImVycm5vIiwiY2xhc3MiLCJhdHRyX3JlYWRlciIsIlN0YW5kYXJkRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsU0FBUyxDQUNQLENBQUMsUUFBRCxFQUFVRCxrQkFBVixFQUE4QkUsRUFBOUIsQ0FETyxFQUVQLENBQUMsUUFBRCxFQUFVRixhQUFWLEVBQXlCRyxFQUF6QixDQUZPLEVBR1AsQ0FBQyxRQUFELEVBQVVILGdCQUFWLEVBQTRCSSxFQUE1QixDQUhPLEVBSVAsQ0FBQyxRQUFELEVBQVVKLHFCQUFWLEVBQWlDSyxFQUFqQyxDQUpPLEVBS1AsQ0FBQyxRQUFELEVBQVVMLGNBQVYsRUFBMEJNLEVBQTFCLENBTE8sRUFNUCxDQUFDLFFBQUQsRUFBVU4sbUJBQVYsRUFBK0JPLEVBQS9CLENBTk8sRUFPUCxDQUFDLE9BQUQsRUFBU1AseUJBQVQsRUFBb0NRLENBQXBDLENBUE8sRUFRUCxDQUFDLFFBQUQsRUFBVVIsMkJBQVYsRUFBdUNTLENBQXZDLENBUk8sRUFTUCxDQUFDLGNBQUQsRUFBZ0JULG9CQUFoQixFQUFzQ1UsRUFBdEMsQ0FUTztJQVlUQyxRQUFROztBQUdWWDtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBLFFBQ1U7O01BQ0UsT0FBQVksbUJBQUFBLGdCQUFRQyxJQUFSRDtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBQVEseUJBQU87UUFDYkUsVUFBV0Y7UUFDWCxJQUFBLFFBQTJCQyxJQUEzQixDQUFBO1VBQUFDLFVBQVFDLFNBQVJELE9BQVFDLEVBQUlILEtBQUQsR0FBQSxDQUFNQyxJQUFOLENBQUhFO1FBQVI7UUFDQUgsT0FBQSxPQUFBSSxJQUFBLEVBQUEsNkNBQUEsT0FBQSxFQUFBLENBQU1GLE9BQU4sQ0FBQSxFQUFBLElBQUE7TUFIRkYsQ0FBQUEsSUFBQUE7SUFERiw0QkFBU0QsS0FBVDtBQVFWWDtBQUNBQTtBQUNBQTtFQXJDQUEsR0FBTyxJQUFQQTtFQXdDQUQsT0FBQWtCO0VBQUFBOztJQUFBQTs7OztBQUNFQyxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBRixJQUFJRyxPQUFBQSxDQUFBQSxDQUFNRCxPQUFBQSxDQUFBQTtJQURaQSxDQUFBQTtJQUlBRCxPQUFBOztNQUNFLE9BQUFELElBQUFJLGFBQUFBLENBQVksT0FBWkE7SUFERiw0QkFBU0osSUFBVDtFQUxGQyxHQUFNLElBQU5BLEVBQTBCSSxvQkFBMUJKO0FBeENBbEI7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU4MDgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6RXhjZXB0aW9uIDwgYEVycm9yYFxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2V4Y2VwdGlvbicsIHRydWUpYFxuICBgdmFyIHN0YWNrX3RyYWNlX2xpbWl0YFxuXG4gIGBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAxMDBgXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIG1lc3NhZ2UgICA9IChhcmdzLmxlbmd0aCA+IDApID8gYXJnc1swXSA6IG5pbDtcbiAgICAgIHZhciBlcnJvciAgICAgPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKG1lc3NhZ2UpO1xuICAgICAgZXJyb3IubmFtZSAgICA9IHNlbGYuJCRuYW1lO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICBlcnJvci5jYXVzZSAgID0gI3skIX07XG4gICAgICBPcGFsLnNlbmQoZXJyb3IsIGVycm9yLiRpbml0aWFsaXplLCBhcmdzKTtcblxuICAgICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoKSB3aWxsIHVzZSAubmFtZSBhbmQgLnRvU3RyaW5nIHRvIGJ1aWxkIHRoZVxuICAgICAgLy8gZmlyc3QgbGluZSBvZiB0aGUgc3RhY2sgdHJhY2Ugc28gaXQgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGVycm9yXG4gICAgICAvLyBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12Ni54L2RvY3MvYXBpL2Vycm9ycy5odG1sXG4gICAgICBpZiAoT3BhbC5jb25maWcuZW5hYmxlX3N0YWNrX3RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIC8vIFBhc3NpbmcgS2VybmVsLnJhaXNlIHdpbGwgY3V0IHRoZSBzdGFjayB0cmFjZSBmcm9tIHRoYXQgcG9pbnQgYWJvdmVcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrX3RyYWNlX2xpbWl0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgZW5kXG4gIGBzdGFja190cmFjZV9saW1pdCA9IHNlbGYuJG5ld2BcblxuICBkZWYgc2VsZi5leGNlcHRpb24oKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICAjIHVzaW5nIHNlbGYubWVzc2FnZSBha2EgQG1lc3NhZ2UgdG8gcmV0YWluIGNvbXBhdGliaWxpdHkgd2l0aCBuYXRpdmUgZXhjZXB0aW9uJ3MgbWVzc2FnZSBwcm9wZXJ0eVxuICAgIGBzZWxmLm1lc3NhZ2UgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWxgXG4gIGVuZFxuXG4gICV4e1xuICAgIC8vIENvbnZlcnQgYmFja3RyYWNlIGZyb20gYW55IGZvcm1hdCB0byBSdWJ5IGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvcnJlY3RfYmFja3RyYWNlKGJhY2t0cmFjZSkge1xuICAgICAgdmFyIG5ld19idCA9IFtdLCBtO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhY2t0cmFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbG9jID0gYmFja3RyYWNlW2ldO1xuICAgICAgICBpZiAoIWxvYyB8fCAhbG9jLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgLyogRG8gbm90aGluZyAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIENocm9taXVtIGZvcm1hdCAqL1xuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiAgICBhdCAoLio/KSBcXCgoLio/KVxcKSQvKSkpIHtcbiAgICAgICAgICBuZXdfYnQucHVzaChtWzJdICsgXCI6aW4gYFwiICsgbVsxXSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiAgICBhdCAoLio/KSQvKSkpIHtcbiAgICAgICAgICBuZXdfYnQucHVzaChtWzFdICsgXCI6aW4gYHVuZGVmaW5lZCdcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyogTm9kZSBmb3JtYXQgKi9cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBsb2MubWF0Y2goL14gIGZyb20gKC4qPykkLykpKSB7XG4gICAgICAgICAgbmV3X2J0LnB1c2gobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogTW96aWxsYS9BcHBsZSBmb3JtYXQgKi9cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBsb2MubWF0Y2goL14oLio/KUAoLio/KSQvKSkpIHtcbiAgICAgICAgICBuZXdfYnQucHVzaChtWzJdICsgJzppbiBgJyArIG1bMV0gKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld19idDtcbiAgICB9XG4gIH1cblxuICBkZWYgYmFja3RyYWNlXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5iYWNrdHJhY2UpIHtcbiAgICAgICAgLy8gbmlsIGlzIGEgdmFsaWQgYmFja3RyYWNlXG4gICAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhY2t0cmFjZSA9IHNlbGYuc3RhY2s7XG5cbiAgICAgIGlmICh0eXBlb2YoYmFja3RyYWNlKSAhPT0gJ3VuZGVmaW5lZCcgJiYgYmFja3RyYWNlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZSA9IGNvcnJlY3RfYmFja3RyYWNlKGJhY2t0cmFjZS5zcGxpdChcIlxcblwiKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiYWNrdHJhY2UpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlID0gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJhY2t0cmFjZV9sb2NhdGlvbnNcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZV9sb2NhdGlvbnMpIHJldHVybiBzZWxmLmJhY2t0cmFjZV9sb2NhdGlvbnM7XG4gICAgICBzZWxmLmJhY2t0cmFjZV9sb2NhdGlvbnMgPSAje2JhY2t0cmFjZSYubWFwIGRvIHxsb2N8XG4gICAgICAgIDo6VGhyZWFkOjpCYWNrdHJhY2U6OkxvY2F0aW9uLm5ldyhsb2MpXG4gICAgICBlbmR9XG4gICAgICByZXR1cm4gc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhdXNlXG4gICAgYHNlbGYuY2F1c2UgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgZXhjZXB0aW9uKHN0ciA9IG5pbClcbiAgICAleHtcbiAgICAgIGlmIChzdHIgPT09IG5pbCB8fCBzZWxmID09PSBzdHIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbG9uZWQgPSAje2Nsb25lfTtcbiAgICAgIGNsb25lZC5tZXNzYWdlID0gc3RyO1xuICAgICAgaWYgKHNlbGYuYmFja3RyYWNlKSBjbG9uZWQuYmFja3RyYWNlID0gc2VsZi5iYWNrdHJhY2UuJGR1cCgpO1xuICAgICAgY2xvbmVkLnN0YWNrID0gc2VsZi5zdGFjaztcbiAgICAgIGNsb25lZC5jYXVzZSA9IHNlbGYuY2F1c2U7XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBub3QgdXNpbmcgYWxpYXMgbWVzc2FnZSB0b19zIGJlY2F1c2UgeW91IG5lZWQgdG8gYmUgYWJsZSB0byBvdmVycmlkZSB0b19zIGFuZCBoYXZlIG1lc3NhZ2UgdXNlIG92ZXJyaWRkZW4gbWV0aG9kLCB3b24ndCB3b3JrIHdpdGggYWxpYXNcbiAgZGVmIG1lc3NhZ2VcbiAgICB0b19zXG4gIGVuZFxuXG4gIGRlZiBmdWxsX21lc3NhZ2Uoa3dhcmdzID0gbmlsKVxuICAgIHVubGVzcyBkZWZpbmVkPyBIYXNoXG4gICAgICAjIFdlIGFyZSBkZWFsaW5nIHdpdGggYW4gdW5mdWxseSBsb2FkZWQgT3BhbCBsaWJyYXJ5LCBzbyB3ZSBzaG91bGRcbiAgICAgICMgZG8gd2l0aCBhcyBsaXR0bGUgYXMgd2UgY2FuLlxuXG4gICAgICByZXR1cm4gXCIje0BtZXNzYWdlfVxcbiN7YHNlbGYuc3RhY2tgfVwiXG4gICAgZW5kXG5cbiAgICBrd2FyZ3MgPSB7IGhpZ2hsaWdodDogJHN0ZGVyci50dHk/LCBvcmRlcjogOnRvcCB9Lm1lcmdlKGt3YXJncyB8fCB7fSlcbiAgICBoaWdobGlnaHQsIG9yZGVyID0ga3dhcmdzWzpoaWdobGlnaHRdLCBrd2FyZ3NbOm9yZGVyXVxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImV4cGVjdGVkIHRydWUgb3IgZmFsc2UgYXMgaGlnaGxpZ2h0OiAje2hpZ2hsaWdodH1cIiB1bmxlc3MgW3RydWUsIGZhbHNlXS5pbmNsdWRlPyBoaWdobGlnaHRcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiZXhwZWN0ZWQgOnRvcCBvciA6Ym90dG9tIGFzIG9yZGVyOiAje29yZGVyfVwiIHVubGVzcyAlaVt0b3AgYm90dG9tXS5pbmNsdWRlPyBvcmRlclxuXG4gICAgaWYgaGlnaGxpZ2h0XG4gICAgICBib2xkX3VuZGVybGluZSA9IFwiXFxlWzE7NG1cIlxuICAgICAgYm9sZCA9IFwiXFxlWzFtXCJcbiAgICAgIHJlc2V0ID0gXCJcXGVbbVwiXG4gICAgZWxzZVxuICAgICAgYm9sZF91bmRlcmxpbmUgPSBib2xkID0gcmVzZXQgPSAnJ1xuICAgIGVuZFxuXG4gICAgYnQgPSBiYWNrdHJhY2UuZHVwXG4gICAgYnQgPSBjYWxsZXIgaWYgIWJ0IHx8IGJ0LmVtcHR5P1xuICAgIGZpcnN0ID0gYnQuc2hpZnRcblxuICAgIG1zZyA9IFwiI3tmaXJzdH06IFwiXG4gICAgbXNnICs9IFwiI3tib2xkfSN7dG9fc30gKCN7Ym9sZF91bmRlcmxpbmV9I3tzZWxmLmNsYXNzfSN7cmVzZXR9I3tib2xkfSkje3Jlc2V0fVxcblwiXG5cbiAgICBtc2cgKz0gYnQubWFwIHsgfGxvY3wgXCJcXHRmcm9tICN7bG9jfVxcblwiIH0uam9pblxuXG4gICAgbXNnICs9IGNhdXNlLmZ1bGxfbWVzc2FnZShoaWdobGlnaHQ6IGhpZ2hsaWdodCkgaWYgY2F1c2VcblxuICAgIGlmIG9yZGVyID09IDpib3R0b21cbiAgICAgIG1zZyA9IG1zZy5zcGxpdChcIlxcblwiKS5yZXZlcnNlLmpvaW4oXCJcXG5cIilcbiAgICAgIG1zZyA9IFwiI3tib2xkfVRyYWNlYmFjayN7cmVzZXR9IChtb3N0IHJlY2VudCBjYWxsIGxhc3QpOlxcblwiICsgbXNnXG4gICAgZW5kXG5cbiAgICBtc2dcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBhc19zdHIgPSB0b19zXG4gICAgYXNfc3RyLmVtcHR5PyA/IHNlbGYuY2xhc3MudG9fcyA6IFwiIzwje3NlbGYuY2xhc3MudG9fc306ICN7dG9fc30+XCJcbiAgZW5kXG5cbiAgZGVmIHNldF9iYWNrdHJhY2UoYmFja3RyYWNlKVxuICAgICV4e1xuICAgICAgdmFyIHZhbGlkID0gdHJ1ZSwgaSwgaWk7XG5cbiAgICAgIGlmIChiYWNrdHJhY2UgPT09IG5pbCkge1xuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IG5pbDtcbiAgICAgICAgc2VsZi5zdGFjayA9ICcnO1xuICAgICAgfSBlbHNlIGlmIChiYWNrdHJhY2UuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBbYmFja3RyYWNlXTtcbiAgICAgICAgc2VsZi5zdGFjayA9ICcgIGZyb20gJyArIGJhY2t0cmFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChiYWNrdHJhY2UuJCRpc19hcnJheSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gYmFja3RyYWNlLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghYmFja3RyYWNlW2ldLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdiYWNrdHJhY2UgbXVzdCBiZSBBcnJheSBvZiBTdHJpbmcnfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBiYWNrdHJhY2U7XG4gICAgICAgIHNlbGYuc3RhY2sgPSAje2BiYWNrdHJhY2VgLm1hcCB7IHxpfCAnICBmcm9tICcgKyBpIH19LmpvaW4oXCJcXG5cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYWNrdHJhY2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICMgdXNpbmcgc2VsZi5tZXNzYWdlIGFrYSBAbWVzc2FnZSB0byByZXRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG5hdGl2ZSBleGNlcHRpb24ncyBtZXNzYWdlIHByb3BlcnR5XG4gICAgKEBtZXNzYWdlICYmIEBtZXNzYWdlLnRvX3MpIHx8IHNlbGYuY2xhc3MudG9fc1xuICBlbmRcbmVuZFxuXG4jIGtlZXAgdGhlIGluZGVudGF0aW9uLCBpdCBtYWtlcyB0aGUgZXhjZXB0aW9uIGhpZXJhcmNoeSBjbGVhclxuY2xhc3MgOjpTY3JpcHRFcnJvciAgICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6U3ludGF4RXJyb3IgICAgICAgICA8IDo6U2NyaXB0RXJyb3I7IGVuZFxuY2xhc3MgOjpMb2FkRXJyb3IgICAgICAgICAgIDwgOjpTY3JpcHRFcnJvcjsgZW5kXG5jbGFzcyA6Ok5vdEltcGxlbWVudGVkRXJyb3IgPCA6OlNjcmlwdEVycm9yOyBlbmRcblxuY2xhc3MgOjpTeXN0ZW1FeGl0ICAgICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6Tm9NZW1vcnlFcnJvciAgICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OlNpZ25hbEV4Y2VwdGlvbiAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpJbnRlcnJ1cHQgICAgICAgICAgIDwgOjpTaWduYWxFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpTZWN1cml0eUVycm9yICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6U3lzdGVtU3RhY2tFcnJvciAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5cbmNsYXNzIDo6U3RhbmRhcmRFcnJvciAgICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OkVuY29kaW5nRXJyb3IgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpaZXJvRGl2aXNpb25FcnJvciAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6TmFtZUVycm9yICAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6Ok5vTWV0aG9kRXJyb3IgICAgICAgICA8IDo6TmFtZUVycm9yOyBlbmRcbmNsYXNzIDo6UnVudGltZUVycm9yICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OkZyb3plbkVycm9yICAgICAgICAgICA8IDo6UnVudGltZUVycm9yOyBlbmRcbmNsYXNzIDo6TG9jYWxKdW1wRXJyb3IgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OlR5cGVFcnJvciAgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpBcmd1bWVudEVycm9yICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6VW5jYXVnaHRUaHJvd0Vycm9yICAgIDwgOjpBcmd1bWVudEVycm9yOyBlbmRcbmNsYXNzIDo6SW5kZXhFcnJvciAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OlN0b3BJdGVyYXRpb24gICAgICAgICA8IDo6SW5kZXhFcnJvcjsgZW5kXG5jbGFzcyA6OkNsb3NlZFF1ZXVlRXJyb3IgICAgICAgIDwgOjpTdG9wSXRlcmF0aW9uOyBlbmRcbmNsYXNzIDo6S2V5RXJyb3IgICAgICAgICAgICAgIDwgOjpJbmRleEVycm9yOyBlbmRcbmNsYXNzIDo6UmFuZ2VFcnJvciAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OkZsb2F0RG9tYWluRXJyb3IgICAgICA8IDo6UmFuZ2VFcnJvcjsgZW5kXG5jbGFzcyA6OklPRXJyb3IgICAgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpFT0ZFcnJvciAgICAgICAgICAgICAgPCA6OklPRXJyb3I7IGVuZFxuY2xhc3MgOjpTeXN0ZW1DYWxsRXJyb3IgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6UmVnZXhwRXJyb3IgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OlRocmVhZEVycm9yICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpGaWJlckVycm9yICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcblxuOjpPYmplY3QuYXV0b2xvYWQgOkVycm5vLCAnY29yZWxpYi9lcnJvci9lcnJubydcblxuY2xhc3MgOjpGcm96ZW5FcnJvciA8IDo6UnVudGltZUVycm9yXG4gIGF0dHJfcmVhZGVyIDpyZWNlaXZlclxuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIHJlY2VpdmVyOiBuaWwpXG4gICAgc3VwZXIgbWVzc2FnZVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6VW5jYXVnaHRUaHJvd0Vycm9yIDwgOjpBcmd1bWVudEVycm9yXG4gIGF0dHJfcmVhZGVyIDp0YWcsIDp2YWx1ZVxuXG4gIGRlZiBpbml0aWFsaXplKHRhZywgdmFsdWUgPSBuaWwpXG4gICAgQHRhZyA9IHRhZ1xuICAgIEB2YWx1ZSA9IHZhbHVlXG5cbiAgICBzdXBlcihcInVuY2F1Z2h0IHRocm93ICN7QHRhZy5pbnNwZWN0fVwiKVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6Ok5hbWVFcnJvclxuICBhdHRyX3JlYWRlciA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwpXG4gICAgc3VwZXIgbWVzc2FnZVxuICAgIEBuYW1lID0gbmFtZVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6Ok5vTWV0aG9kRXJyb3JcbiAgYXR0cl9yZWFkZXIgOmFyZ3NcblxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCBuYW1lID0gbmlsLCBhcmdzID0gW10pXG4gICAgc3VwZXIgbWVzc2FnZSwgbmFtZVxuICAgIEBhcmdzID0gYXJnc1xuICBlbmRcbmVuZFxuXG5jbGFzcyA6OlN0b3BJdGVyYXRpb25cbiAgYXR0cl9yZWFkZXIgOnJlc3VsdFxuZW5kXG5cbmNsYXNzIDo6S2V5RXJyb3JcbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgcmVjZWl2ZXI6IG5pbCwga2V5OiBuaWwpXG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICAgIEBrZXkgPSBrZXlcbiAgZW5kXG5cbiAgZGVmIHJlY2VpdmVyXG4gICAgQHJlY2VpdmVyIHx8IDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgJ25vIHJlY2VpdmVyIGlzIGF2YWlsYWJsZScpXG4gIGVuZFxuXG4gIGRlZiBrZXlcbiAgICBAa2V5IHx8IDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgJ25vIGtleSBpcyBhdmFpbGFibGUnKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgOjpKU1xuICBjbGFzcyBFcnJvclxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RXhjZXB0aW9uPiIsIm5ldyIsInNlbGYiLCIkISIsImV4Y2VwdGlvbiIsImFyZ3MiLCJpbml0aWFsaXplIiwiYmFja3RyYWNlIiwiYmFja3RyYWNlX2xvY2F0aW9ucyIsImJsb2NrIGluIGJhY2t0cmFjZV9sb2NhdGlvbnMiLCJsb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIGJhY2t0cmFjZV9sb2NhdGlvbnMiLCJUaHJlYWQ6OkJhY2t0cmFjZTo6TG9jYXRpb24iLCJUaHJlYWQ6OkJhY2t0cmFjZSIsIlRocmVhZCIsImNhdXNlIiwic3RyIiwiY2xvbmUiLCJtZXNzYWdlIiwidG9fcyIsImZ1bGxfbWVzc2FnZSIsImt3YXJncyIsIkBtZXNzYWdlIiwiJHN0ZGVyciIsInR0eT8iLCJtZXJnZSIsIiRyZXRfb3JfMSIsIltdIiwiaGlnaGxpZ2h0Iiwib3JkZXIiLCJpbmNsdWRlPyIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImJvbGRfdW5kZXJsaW5lIiwiYm9sZCIsInJlc2V0IiwiYnQiLCJkdXAiLCJlbXB0eT8iLCJjYWxsZXIiLCJmaXJzdCIsInNoaWZ0IiwibXNnIiwiKyIsImNsYXNzIiwibWFwIiwiYmxvY2sgaW4gZnVsbF9tZXNzYWdlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmdWxsX21lc3NhZ2UiLCJqb2luIiwic3BsaXQiLCJyZXZlcnNlIiwiaW5zcGVjdCIsImFzX3N0ciIsInNldF9iYWNrdHJhY2UiLCJUeXBlRXJyb3IiLCJibG9jayBpbiBzZXRfYmFja3RyYWNlIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gc2V0X2JhY2t0cmFjZSIsIiRyZXRfb3JfMiIsIjxjbGFzczpTY3JpcHRFcnJvcj4iLCJFeGNlcHRpb24iLCI8Y2xhc3M6U3ludGF4RXJyb3I+IiwiU2NyaXB0RXJyb3IiLCI8Y2xhc3M6TG9hZEVycm9yPiIsIjxjbGFzczpOb3RJbXBsZW1lbnRlZEVycm9yPiIsIjxjbGFzczpTeXN0ZW1FeGl0PiIsIjxjbGFzczpOb01lbW9yeUVycm9yPiIsIjxjbGFzczpTaWduYWxFeGNlcHRpb24+IiwiPGNsYXNzOkludGVycnVwdD4iLCJTaWduYWxFeGNlcHRpb24iLCI8Y2xhc3M6U2VjdXJpdHlFcnJvcj4iLCI8Y2xhc3M6U3lzdGVtU3RhY2tFcnJvcj4iLCI8Y2xhc3M6U3RhbmRhcmRFcnJvcj4iLCI8Y2xhc3M6RW5jb2RpbmdFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOlplcm9EaXZpc2lvbkVycm9yPiIsIjxjbGFzczpOYW1lRXJyb3I+IiwiPGNsYXNzOk5vTWV0aG9kRXJyb3I+IiwiTmFtZUVycm9yIiwiPGNsYXNzOlJ1bnRpbWVFcnJvcj4iLCI8Y2xhc3M6RnJvemVuRXJyb3I+IiwiUnVudGltZUVycm9yIiwiPGNsYXNzOkxvY2FsSnVtcEVycm9yPiIsIjxjbGFzczpUeXBlRXJyb3I+IiwiPGNsYXNzOkFyZ3VtZW50RXJyb3I+IiwiPGNsYXNzOlVuY2F1Z2h0VGhyb3dFcnJvcj4iLCI8Y2xhc3M6SW5kZXhFcnJvcj4iLCI8Y2xhc3M6U3RvcEl0ZXJhdGlvbj4iLCJJbmRleEVycm9yIiwiPGNsYXNzOkNsb3NlZFF1ZXVlRXJyb3I+IiwiU3RvcEl0ZXJhdGlvbiIsIjxjbGFzczpLZXlFcnJvcj4iLCI8Y2xhc3M6UmFuZ2VFcnJvcj4iLCI8Y2xhc3M6RmxvYXREb21haW5FcnJvcj4iLCJSYW5nZUVycm9yIiwiPGNsYXNzOklPRXJyb3I+IiwiPGNsYXNzOkVPRkVycm9yPiIsIklPRXJyb3IiLCI8Y2xhc3M6U3lzdGVtQ2FsbEVycm9yPiIsIjxjbGFzczpSZWdleHBFcnJvcj4iLCI8Y2xhc3M6VGhyZWFkRXJyb3I+IiwiPGNsYXNzOkZpYmVyRXJyb3I+IiwiT2JqZWN0IiwiYXV0b2xvYWQiLCJhdHRyX3JlYWRlciIsIiRrd2FyZ3MiLCJAcmVjZWl2ZXIiLCJyZWNlaXZlciIsInRhZyIsInZhbHVlIiwiQHRhZyIsIkB2YWx1ZSIsIm5hbWUiLCJAbmFtZSIsIkBhcmdzIiwiQGtleSIsImtleSIsIjxtb2R1bGU6SlM+IiwiPGNsYXNzOkVycm9yPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNHQTtJQUNBQTtJQUVBQTtJQUVEQyxNQUFJQyxJQUFKRCxVQUFBQSwwQkFORixFQU1FQTtBQUFBQSxNQUFBQTtBQUFBQTs7O01BTkY7TUFNZTs7QUFFZkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsc0JBQXdCRSxXQUFHRjtBQUMzQkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQW5CRUEsQ0FBQUEsSUFBQUE7SUFxQkNEO0lBRURJLE1BQUlGLElBQUpFLGdCQUFBQSxxQkE3QkYsRUE2QkVBO0FBQUFBLE1BQUFBOzs7TUE3QkY7TUE2QnFCO01BQ2pCQSxPQUFBSCxNQUFBQyxJQUFBRCxPQUFBQSxFQUFJLE1BQUNJLElBQUQsQ0FBSko7SUFERkcsQ0FBQUEsSUFBQUE7O0FBSUFFLElBQUFBLDBCQUFBQSxzQkFqQ0YsRUFpQ0VBO0FBQUFBLE1BQUFBOzs7TUFqQ0Y7TUFpQ2lCO01BRWJBLE9BQUNBLGdEQUFEQTtJQUZGQSxDQUFBQSxJQUFBQTs7QUFNRk47QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNB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O01BblNGOztNQW1TMEIsc0NBQUEsaUNBQVU7O01BQUssNEJBQUEsdUJBQUs7TUFDMUMsT0FBQUosSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFNZ0IsT0FBTixDQUFBLEVBQUEsSUFBQTtNQUNBeUYsZ0JBQVlDO01BQ1p0RyxPQUFBOEcsQ0FBQUEsV0FBT0MsR0FBUEQ7SUFIRjlHLENBQUFBLElBQUFBOztBQU1Bc0csSUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFsRixDQUFBQSxZQUFBaUYsYUFBQWpGLENBQUEsQ0FBQTtRQUFBa0YsT0FBQTtNQUFBO1FBQWFBLE9BQUE3RSxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQzJFLDBCQUF4QjVFO01BQXJCO0lBREY0RSxDQUFBQTtJQUlBaEIsT0FBQXlCLG1CQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUEzRixDQUFBQSxZQUFBMEYsUUFBQTFGLENBQUEsQ0FBQTtRQUFBMkYsT0FBQTtNQUFBO1FBQVFBLE9BQUF0RixPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ29GLHFCQUF4QnJGO01BQWhCO0lBREZxRixDQUFBQTtFQVhGekIsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQWdCQTdGLE9BQUF1SDtFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDLFFBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQU8sSUFBUEE7QUFsVEF2SDsifX0seyJvZmZzZXQiOnsibGluZSI6NjIzMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29uc3RhbnRzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6UlVCWV9QTEFURk9STSAgICAgICA9ICdvcGFsJ1xuOjpSVUJZX0VOR0lORSAgICAgICAgID0gJ29wYWwnXG46OlJVQllfVkVSU0lPTiAgICAgICAgPSAnMy4yLjAnXG46OlJVQllfRU5HSU5FX1ZFUlNJT04gPSAnMS43LjMnXG46OlJVQllfUkVMRUFTRV9EQVRFICAgPSAnMjAyMy0wMy0yMydcbjo6UlVCWV9QQVRDSExFVkVMICAgICA9IDBcbjo6UlVCWV9SRVZJU0lPTiAgICAgICA9ICcwJ1xuOjpSVUJZX0NPUFlSSUdIVCAgICAgID0gJ29wYWwgLSBDb3B5cmlnaHQgKEMpIDIwMTEtMjAyMyBBZGFtIEJleW5vbiBhbmQgdGhlIE9wYWwgY29udHJpYnV0b3JzJ1xuOjpSVUJZX0RFU0NSSVBUSU9OICAgID0gXCJvcGFsICN7OjpSVUJZX0VOR0lORV9WRVJTSU9OfSAoI3s6OlJVQllfUkVMRUFTRV9EQVRFfSByZXZpc2lvbiAjezo6UlVCWV9SRVZJU0lPTn0pXCJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiMCIsIlJVQllfRU5HSU5FX1ZFUlNJT04iLCJSVUJZX1JFTEVBU0VfREFURSIsIlJVQllfUkVWSVNJT04iXSwibWFwcGluZ3MiOiJBQUFBQSxvQ0FBQUEsZ0JBQUFBO0VBQUFBOzs7RUFBQSxXQUFBLElBQUEsbUJBQXdCQSxNQUF4QjtFQUNBLFdBQUEsSUFBQSxpQkFBd0JBLE1BQXhCO0VBQ0EsV0FBQSxJQUFBLGtCQUF3QkEsT0FBeEI7RUFDQSxXQUFBLElBQUEseUJBQXdCQSxPQUF4QjtFQUNBLFdBQUEsSUFBQSx1QkFBd0JBLFlBQXhCO0VBQ0EsV0FBQSxJQUFBLHFCQUF3QkMsQ0FBeEI7RUFDQSxXQUFBLElBQUEsbUJBQXdCRCxHQUF4QjtFQUNBLFdBQUEsSUFBQSxvQkFBd0JBLHNFQUF4QjtFQUNBQSxPQUFBLFdBQUEsSUFBQSxzQkFBeUJBLE9BQUQsR0FBQSxDQUFRRSwwQkFBUixDQUFBLEdBQThCRixJQUE5QixHQUFBLENBQWtDRyx3QkFBbEMsQ0FBQSxHQUFzREgsWUFBdEQsR0FBQSxDQUFrRUksb0JBQWxFLENBQUEsR0FBa0ZKLEdBQTFHO0FBUkFBOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo2MjQ4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcnVudGltZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaGVscGVycydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvbW9kdWxlJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jbGFzcydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYmFzaWNfb2JqZWN0J1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL21haW4nXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2Vycm9yJ1xuXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2NvbnN0YW50cydcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiT2JqZWN0IiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDRCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixpQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsaUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixlQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixzQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGNBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGVBQVRFO0VBRVJGLE9BQUFDLE9BQVFDLFNBQUFBLENBQVNGLG1CQUFURTtBQVRSRjsifX0seyJvZmZzZXQiOnsibGluZSI6NjI2NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbmlsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6TmlsQ2xhc3NcbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRtZXRhID0gI3tzZWxmfWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcbiAgZW5kXG5cbiAgZGVmICFcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIGBvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYG90aGVyID09PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogdHJ1ZSlcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAnbmlsJ1xuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIDo6TmlsQ2xhc3NcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbXVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIGBPcGFsLmhhc2goKWBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgJydcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICA6OkNvbXBsZXgubmV3KDAsIDApXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZSgqYXJncylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IgaWYgYXJncy5sZW5ndGggPiAxXG4gICAgOjpLZXJuZWwuUmF0aW9uYWwoMCwgMSlcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICA6Oktlcm5lbC5SYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgdG9fZiB0b19pXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk5pbENsYXNzPiIsInNlbGYiLCJhbGxvY2F0ZSIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwibmFtZSIsIiEiLCImIiwifCIsIm90aGVyIiwiXiIsIj09IiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwiaW5zcGVjdCIsIm5pbD8iLCJzaW5nbGV0b25fY2xhc3MiLCJOaWxDbGFzcyIsInRvX2EiLCJ0b19oIiwidG9faSIsIjAiLCJ0b19zIiwidG9fYyIsIkNvbXBsZXgiLCJuZXciLCJyYXRpb25hbGl6ZSIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMSIsIkFyZ3VtZW50RXJyb3IiLCJSYXRpb25hbCIsInRvX3IiLCJpbnN0YW5jZV92YXJpYWJsZXMiXSwibWFwcGluZ3MiOiJBQUFBQSw4QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNHQSwwQkFBNEJDO0lBRTdCOzs7O0FBQ0VDLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTZCSCwwQkFBRCxHQUFBLENBQTJCRCxJQUFBSyxNQUFBQSxDQUFBQSxDQUEzQixDQUFwQkY7TUFEVkYsQ0FBQUE7OztNQUlBLHNCQUFNLEtBQU47TUFSSixPQUFBO0lBR0UsNEJBQVNELElBQVQ7O0FBUUFNLElBQUFBLGlCQUFBQSxZQUNFLElBREZBLENBQUFBOztBQUlBQyxJQUFBQSxpQkFBQUEsWUFDRSxLQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsaUJBQUFBLHVCQUFNQyxLQUFORDtBQUFBQTtNQUNFQSxPQUFDQSxnQ0FBREE7SUFERkEsQ0FBQUE7O0FBSUFFLElBQUFBLGlCQUFBQSx1QkFBTUQsS0FBTkM7QUFBQUE7TUFDRUEsT0FBQ0EsZ0NBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxrQkFBQUEsNEJBQU9GLEtBQVBFO0FBQUFBO01BQ0VBLE9BQUNBLGFBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxtQkFBQUEsWUFDRSxHQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQW5DRkMsT0FtQ0VEO0FBQUFBLE1BQUFBOzs7TUFuQ0Y7O01BbUNZLGtDQUFBLDZCQUFRO01BQ2hCQSxPQUFBO0lBREZBLENBQUFBLElBQUFBOztBQUlBRSxJQUFBQSx1QkFBQUEsWUFDRWhCLEtBREZnQixDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLFlBQ0UsSUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLCtCQUFBQSwyQkFBQUE7QUFBQUE7TUFDRUEsT0FBQUM7SUFERkQsQ0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQTtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQTtNQUNFQSxPQUFDQSxXQUFEQTtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLFlBQ0VDLENBREZELENBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsWUFDRXhCLEVBREZ3QixDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQTtNQUNFQSxPQUFBQyxjQUFTQyxLQUFBQSxDQUFLSixDQUFkLEVBQWlCQSxDQUFSSTtJQURYRixDQUFBQTs7QUFJQUcsSUFBQUEsMkJBQUFBLHVCQXZFRixFQXVFRUE7QUFBQUEsTUFBQUE7OztNQXZFRjtNQXVFa0I7TUFDZCxJQUFBLFFBQThDQyxPQUFaQyxJQUFJQyxRQUFBQSxDQUFBQSxDQUFRRixFQUFFRyxDQUFGSCxDQUE5QyxDQUFBO1FBQUExQixPQUFRQyxPQUFBQSxDQUFPNkIsb0JBQVA3QjtNQUFSO01BQ0F3QixPQUFBekIsT0FBUStCLFVBQUFBLENBQVVYLENBQWxCLEVBQXFCUyxDQUFiRTtJQUZWTixDQUFBQSxJQUFBQTs7QUFLQU8sSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQTtNQUNFQSxPQUFBaEMsT0FBUStCLFVBQUFBLENBQVVYLENBQWxCLEVBQXFCUyxDQUFiRTtJQURWQyxDQUFBQTs7QUFJQUMsSUFBQUEsa0NBQUFBLDhCQUFBQTtBQUFBQTtNQUNFQSxPQUFBO0lBREZBLENBQUFBO0lBSUFwQyxPQUFBLGFBQU0sTUFBTixFQUFXLE1BQVg7RUFwRkZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYzNzQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jvb2xlYW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyB1c2Vfc3RyaWN0OiB0cnVlXG5cbmNsYXNzIDo6Qm9vbGVhbiA8IGBCb29sZWFuYFxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2Jvb2xlYW4nLCB0cnVlKWBcblxuICAleHtcbiAgICB2YXIgcHJvcGVydGllcyA9IFsnJCRjbGFzcycsICckJG1ldGEnXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsIHByb3BlcnRpZXNbaV0sIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcyA9PSB0cnVlICA/IE9wYWwuVHJ1ZUNsYXNzIDpcbiAgICAgICAgICAgICAgICAgdGhpcyA9PSBmYWxzZSA/IE9wYWwuRmFsc2VDbGFzcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcGFsLkJvb2xlYW47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCBcIiQkaWRcIiwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSB0cnVlICA/IDIgOlxuICAgICAgICAgICAgICAgdGhpcyA9PSBmYWxzZSA/IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudmFsdWVPZigpID8gMiA6IDBgXG4gIGVuZFxuXG4gIGRlZiAhXG4gICAgYHNlbGYgIT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKSA6IGZhbHNlYFxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyB0cnVlIDogKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKWBcbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyID09PSBmYWxzZSB8fCBvdGhlciA9PT0gbmlsKSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPT09IG90aGVyLnZhbHVlT2YoKWBcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBzZWxmLiQkbWV0YWBcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAndHJ1ZScgOiAnZmFsc2UnYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwvaXNzdWVzLzIyMzBcbiAgI1xuICAjIFRoaXMgaXMgYSBoYWNrIHRoYXQgYWxsb3dzIHlvdSB0byBhZGQgbWV0aG9kcyB0byBUcnVlQ2xhc3MgYW5kIEZhbHNlQ2xhc3MuXG4gICMgRG8gbm90ZSwgdGhhdCB3aGlsZSB0cnVlIGFuZCBmYWxzZSBoYXZlIGEgY29ycmVjdCAkJGNsYXNzIChpdCdzIGVpdGhlclxuICAjIFRydWVDbGFzcyBvciBGYWxzZUNsYXNzKSwgdGhlaXIgcHJvdG90eXBlIGlzIGBCb29sZWFuLiQkcHJvdG90eXBlYCwgd2hpY2hcbiAgIyBiYXNpY2FsbHkgbWVhbnMgdGhhdCB3aGVuIGNhbGxpbmcgYHRydWUuc29tZXRoaW5nYCB3ZSBhY3R1YWxseSBjYWxsXG4gICMgYEJvb2xlYW4jc29tZXRoaW5nYCBpbnN0ZWFkIG9mIGBUcnVlQ2xhc3Mjc29tZXRoaW5nYC4gU28gdXNpbmdcbiAgIyBtZXRob2RfbWlzc2luZyB3ZSBkaXNwYXRjaCBpdCB0byBgVHJ1ZUNsYXNzL0ZhbHNlQ2xhc3Mjc29tZXRoaW5nYCBjb3JyZWN0bHkuXG4gICNcbiAgIyBUaGUgZG93bnNpZGUgaXMgdGhhdCBhIGNvcnJlY3QgaW1wbGVtZW50YXRpb24gd291bGQgYWxzbyBhbGxvdyB1cyB0byBvdmVycmlkZVxuICAjIHRoZSBtZXRob2RzIGRlZmluZWQgb24gQm9vbGVhbiwgYnV0IG91ciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IGFsbG93IHRoYXQsXG4gICMgdW5sZXNzIHlvdSBkZWZpbmUgdGhlbSBvbiBCb29sZWFuIGFuZCBub3Qgb24gVHJ1ZUNsYXNzL0ZhbHNlQ2xhc3MuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgYHZhciBib2R5ID0gc2VsZi4kJGNsYXNzLiQkcHJvdG90eXBlW09wYWwuanNpZCgje21ldGhvZH0pXWBcbiAgICBzdXBlciB1bmxlc3MgYHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyAmJiAhYm9keS4kJHN0dWJgXG4gICAgYE9wYWwuc2VuZChzZWxmLCBib2R5LCAje2FyZ3N9LCAje2Jsb2NrfSlgXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZCwgX2luY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgYHZhciBib2R5ID0gc2VsZi4kJGNsYXNzLiQkcHJvdG90eXBlW09wYWwuanNpZCgje21ldGhvZH0pXWBcbiAgICBgdHlwZW9mIGJvZHkgIT09ICd1bmRlZmluZWQnICYmICFib2R5LiQkc3R1YmBcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBlcXVhbD8gPT1cbiAgYWxpYXMgaW5zcGVjdCB0b19zXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cbmVuZFxuXG5jbGFzcyA6OlRydWVDbGFzcyA8IDo6Qm9vbGVhbjsgZW5kXG5jbGFzcyA6OkZhbHNlQ2xhc3MgPCA6OkJvb2xlYW47IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6Qm9vbGVhbj4iLCJhbGxvY2F0ZSIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwic2VsZiIsIm5hbWUiLCJfX2lkX18iLCIhIiwiJiIsIm90aGVyIiwifCIsIl4iLCI9PSIsInNpbmdsZXRvbl9jbGFzcyIsInRvX3MiLCJkdXAiLCJjbG9uZSIsIiRrd2FyZ3MiLCJtZXRob2RfbWlzc2luZyIsIm1ldGhvZCIsImFyZ3MiLCJibG9jayIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJfaW5jbHVkZV9hbGwiLCI8Y2xhc3M6VHJ1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O0FBN0dBNUI7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjY1MTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBhcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHlcblxubW9kdWxlIDo6Q29tcGFyYWJsZVxuICAleHtcbiAgICBmdW5jdGlvbiBub3JtYWxpemUod2hhdCkge1xuICAgICAgaWYgKE9wYWwuaXNfYSh3aGF0LCBPcGFsLkludGVnZXIpKSB7IHJldHVybiB3aGF0OyB9XG5cbiAgICAgIGlmICgje2B3aGF0YCA+IDB9KSB7IHJldHVybiAxOyB9XG4gICAgICBpZiAoI3tgd2hhdGAgPCAwfSkgeyByZXR1cm4gLTE7IH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWxfY29tcGFyaXNvbihsaHMsIHJocykge1xuICAgICAgdmFyIGNsYXNzX25hbWU7XG4gICAgICAje1xuICAgICAgICBjYXNlIGByaHNgXG4gICAgICAgIHdoZW4gbmlsLCB0cnVlLCBmYWxzZSwgOjpJbnRlZ2VyLCA6OkZsb2F0XG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJGluc3BlY3QoKWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGBjbGFzc19uYW1lID0gcmhzLiQkY2xhc3NgXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2BsaHNgLmNsYXNzfSB3aXRoICN7YGNsYXNzX25hbWVgfSBmYWlsZWRcIn1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbXBfb3JfZmFpbChsaHMsIHJocykge1xuICAgICAgdmFyIGNtcCA9ICN7YGxoc2AgPD0+IGByaHNgfTtcbiAgICAgIGlmICghJHRydXRoeShjbXApKSBmYWlsX2NvbXBhcmlzb24obGhzLCByaHMpO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShjbXApO1xuICAgIH1cbiAgfVxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gdHJ1ZSBpZiBlcXVhbD8ob3RoZXIpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmW1wiJDw9PlwiXSA9PSBPcGFsLktlcm5lbFtcIiQ8PT5cIl0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBmb3IgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICBpZiAoc2VsZi4kJGNvbXBhcmFibGUpIHtcbiAgICAgICAgc2VsZi4kJGNvbXBhcmFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxuXG4gICAgYG5vcm1hbGl6ZShjbXApID09IDBgXG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPiAwYFxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA+PSAwYFxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDwgMGBcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPD0gMGBcbiAgZW5kXG5cbiAgZGVmIGJldHdlZW4/KG1pbiwgbWF4KVxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmIDwgbWluXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNlbGYgPiBtYXhcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBjbGFtcChtaW4sIG1heCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBjLCBleGNsO1xuXG4gICAgICBpZiAobWF4ID09PSBuaWwpIHtcbiAgICAgICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCBhIG5ldyBSdWJ5IDIuNyBiZWhhdmlvdXIgdGhhdCB3ZSBhcmUgYWJsZSB0b1xuICAgICAgICAvLyBwcm92aWRlIGEgc2luZ2xlIFJhbmdlIGFyZ3VtZW50IGluc3RlYWQgb2YgMiBDb21wYXJhYmxlcy5cblxuICAgICAgICBpZiAoIU9wYWwuaXNfYShtaW4sIE9wYWwuUmFuZ2UpKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7bWluLmNsYXNzfSAoZXhwZWN0ZWQgUmFuZ2UpXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBleGNsID0gbWluLmV4Y2w7XG4gICAgICAgIG1heCA9IG1pbi5lbmQ7XG4gICAgICAgIG1pbiA9IG1pbi5iZWdpbjtcblxuICAgICAgICBpZiAobWF4ICE9PSBuaWwgJiYgZXhjbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY2Fubm90IGNsYW1wIHdpdGggYW4gZXhjbHVzaXZlIHJhbmdlJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluICE9PSBuaWwgJiYgbWF4ICE9PSBuaWwgJiYgY21wX29yX2ZhaWwobWluLCBtYXgpID4gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21pbiBhcmd1bWVudCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXggYXJndW1lbnQnfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluICE9PSBuaWwpIHtcbiAgICAgICAgYyA9IGNtcF9vcl9mYWlsKHNlbGYsIG1pbik7XG5cbiAgICAgICAgaWYgKGMgPT0gMCkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChjIDwgMCkgcmV0dXJuIG1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heCAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtYXgpO1xuXG4gICAgICAgIGlmIChjID4gMCkgcmV0dXJuIG1heDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkNvbXBhcmFibGU+IiwiPiIsIjAiLCI8IiwiJHJldF9vcl8xIiwiSW50ZWdlciIsIkZsb2F0IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiY2xhc3MiLCI8PT4iLCI9PSIsIm90aGVyIiwic2VsZiIsImVxdWFsPyIsImNtcCIsIj49IiwiPD0iLCJiZXR3ZWVuPyIsIm1pbiIsIm1heCIsImNsYW1wIiwiVHlwZUVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7O0FBRUFBO0FBQ0FBOztBQUVBQSxVQUFtQkMsT0FBTkQsSUFBTUMsRUFBRUMsQ0FBRkQsQ0FBSUQ7QUFDdkJBLFVBQW1CRyxPQUFOSCxJQUFNRyxFQUFFRCxDQUFGQyxDQUFJSDtBQUN2QkE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLE1BRVEsQ0FoQlIsQ0FBQSxRQWdCYSxHQWhCYixFQWVRSSxDQUFBQSxZQUFNSixHQUFOSSxDQWZSLENBQUEsSUFBQSxDQUFBLENBQUEsUUFnQmtCLElBaEJsQixFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxRQWdCd0IsS0FoQnhCLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLFFBZ0IrQkMsY0FoQi9CLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxRQWdCMENDLFlBaEIxQyxFQUFBLFNBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBZ0JRLEdBQUEsQ0FDR04sMkJBREgsSUFBQSxDQUdHQSx3QkFISCxDQUFBO0FBTVJBLE1BQVFPLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDVCxnQkFBRCxHQUFBLENBQWlCQSxDQUFDQSxHQUFEQSxDQUFLVSxPQUFBQSxDQUFBQSxDQUF0QixDQUFBLEdBQTZCVixRQUE3QixHQUFBLENBQXNDQSxVQUF0QyxDQUFBLEdBQWtEQSxTQUExRVE7QUFDaEJSOztBQUVBQTtBQUNBQSxnQkFBa0JBLENBQUNBLEdBQURBLENBQU1XLFFBQUFBLENBQUtYLEdBQUxXLENBQVVYO0FBQ2xDQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFRVksSUFBQUEsa0JBQUFBLDhCQUFPQyxLQUFQRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFlRSxJQUFBQyxXQUFBQSxDQUFPRixLQUFQRSxDQUFmLENBQUE7UUFBQSxPQUFPO01BQVA7O0FBR0pIO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJLEtBQUEsUUFBb0JJLENBQUFBLE1BQU9GLElBQUtILFFBQUFBLENBQUlFLEtBQUpGLENBQVpLLENBQXBCLENBQUE7UUFBQSxPQUFPO01BQVA7TUFFQUosT0FBQ0EsbUJBQURBO0lBakJGQSxDQUFBQTs7QUFvQkFYLElBQUFBLGlCQUFBQSwyQkFBTVksS0FBTlo7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDRCQUFEQTtJQURGQSxDQUFBQTs7QUFJQWdCLElBQUFBLGtCQUFBQSw4QkFBT0osS0FBUEk7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDZCQUFEQTtJQURGQSxDQUFBQTs7QUFJQWQsSUFBQUEsaUJBQUFBLDJCQUFNVSxLQUFOVjtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsNEJBQURBO0lBREZBLENBQUFBOztBQUlBZSxJQUFBQSxrQkFBQUEsOEJBQU9MLEtBQVBLO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSw2QkFBREE7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSxvQ0FBYUMsR0FBRCxFQUFNQyxHQUFsQkY7QUFBQUEsTUFBQUE7OztNQUNFLElBQXFCaEIsT0FBTFcsSUFBS1gsRUFBRWlCLEdBQUZqQixDQUFyQjtRQUFBLE9BQU87TUFBUDtNQUNBLElBQXFCRixPQUFMYSxJQUFLYixFQUFFb0IsR0FBRnBCLENBQXJCO1FBQUEsT0FBTztNQUFQO01BQ0FrQixPQUFBO0lBSEZBLENBQUFBO0lBTUFuQixPQUFBc0IscUJBQUFBLGlCQUFVRixHQUFELEVBQU1DLEdBQWZDO0FBQUFBLE1BQUFBOzs7TUFBZSx1QkFBTTs7QUFFdkJBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsVUFBWWYsT0FBUUMsT0FBQUEsQ0FBT2UsZ0JBQWYsRUFBNkJELHNCQUFELEdBQUEsQ0FBdUJGLEdBQUdWLE9BQUFBLENBQUFBLENBQTFCLENBQUEsR0FBaUNZLG1CQUFyRGQ7QUFDcEJjOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsVUFBWWYsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NhLHNDQUF4QmQ7QUFDcEJjO0FBQ0FBOztBQUVBQTtBQUNBQSxRQUFVZixPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2EsZ0RBQXhCZDtBQUNsQmM7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQXZDRUEsQ0FBQUEsSUFBQUE7RUF4RUZ0QixHQUFPLElBQVBBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo2NjU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yZWdleHAucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG8sIHByb3AsIGZyZWV6ZVxuXG5jbGFzcyA6OlJlZ2V4cEVycm9yIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcblxuY2xhc3MgOjpSZWdleHAgPCBgUmVnRXhwYFxuICBzZWxmOjpJR05PUkVDQVNFID0gMVxuICBzZWxmOjpFWFRFTkRFRCA9IDJcbiAgc2VsZjo6TVVMVElMSU5FID0gNFxuXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfcmVnZXhwJywgdHJ1ZSlgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgYWxsb2NhdGVkID0gc3VwZXJcbiAgICAgIGAje2FsbG9jYXRlZH0udW5pbml0aWFsaXplZCA9IHRydWVgXG4gICAgICBhbGxvY2F0ZWRcbiAgICBlbmRcblxuICAgIGRlZiBlc2NhcGUoc3RyaW5nKVxuICAgICAgYE9wYWwuZXNjYXBlX3JlZ2V4cChzdHJpbmcpYFxuICAgIGVuZFxuXG4gICAgZGVmIGxhc3RfbWF0Y2gobiA9IG5pbClcbiAgICAgIGlmIG4ubmlsP1xuICAgICAgICAkflxuICAgICAgZWxzaWYgJH5cbiAgICAgICAgJH5bbl1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHVuaW9uKCpwYXJ0cylcbiAgICAgICV4e1xuICAgICAgICB2YXIgaXNfZmlyc3RfcGFydF9hcnJheSwgcXVvdGVkX3ZhbGlkYXRlZCwgcGFydCwgb3B0aW9ucywgZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAvKD8hKS87XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGZhc3QgaWYgdGhlcmUncyBvbmx5IG9uZSBlbGVtZW50XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMSAmJiBwYXJ0c1swXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3ZlciB0aGUgMiBhcnJheXMgcGFzc2VkIGFzIGFyZ3VtZW50cyBjYXNlXG4gICAgICAgIGlzX2ZpcnN0X3BhcnRfYXJyYXkgPSBwYXJ0c1swXS4kJGlzX2FycmF5O1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBpc19maXJzdF9wYXJ0X2FycmF5KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgQXJyYXkgaW50byBTdHJpbmcnfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBzcGxhdCBpc3N1ZXMgKHJlbGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvODU4KVxuICAgICAgICBpZiAoaXNfZmlyc3RfcGFydF9hcnJheSkge1xuICAgICAgICAgIHBhcnRzID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YCl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocGFydC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgICAgZWFjaF9wYXJ0X29wdGlvbnMgPSAje2BwYXJ0YC5vcHRpb25zfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zICE9IGVhY2hfcGFydF9vcHRpb25zKSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdBbGwgZXhwcmVzc2lvbnMgbXVzdCB1c2UgdGhlIHNhbWUgb3B0aW9ucyd9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goJygnK3BhcnQuc291cmNlKycpJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YC50b19zdHIpfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAjIFRha2UgYWR2YW50YWdlIG9mIGxvZ2ljIHRoYXQgY2FuIHBhcnNlIG9wdGlvbnMgZnJvbSBKUyBSZWdleFxuICAgICAgbmV3KGBxdW90ZWRfdmFsaWRhdGVkYC5qb2luKCd8JyksIGBvcHRpb25zYClcbiAgICBlbmRcblxuICAgIGRlZiBuZXcocmVnZXhwLCBvcHRpb25zID0gdW5kZWZpbmVkKVxuICAgICAgJXh7XG4gICAgICAgIGlmIChyZWdleHAuJCRpc19yZWdleHApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnZXhwID0gI3s6Ok9wYWwuY29lcmNlX3RvIShyZWdleHAsIDo6U3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgaWYgKHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDEpID09PSAnXFxcXCcgJiYgcmVnZXhwLmNoYXJBdChyZWdleHAubGVuZ3RoIC0gMikgIT09ICdcXFxcJykge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSZWdleHBFcnJvciwgXCJ0b28gc2hvcnQgZXNjYXBlIHNlcXVlbmNlOiAvI3tyZWdleHB9L1wifVxuICAgICAgICB9XG5cbiAgICAgICAgcmVnZXhwID0gcmVnZXhwLnJlcGxhY2UoJ1xcXFxBJywgJ14nKS5yZXBsYWNlKCdcXFxceicsICckJylcblxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICN7IW9wdGlvbnN9KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSAnJztcbiAgICAgICAgICBpZiAoI3tJR05PUkVDQVNFfSAmIG9wdGlvbnMpIHsgdGVtcCArPSAnaSc7IH1cbiAgICAgICAgICBpZiAoI3tNVUxUSUxJTkV9ICAmIG9wdGlvbnMpIHsgdGVtcCArPSAnbSc7IH1cbiAgICAgICAgICBvcHRpb25zID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gJ2knO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGFsaWFzIGNvbXBpbGUgbmV3XG4gICAgYWxpYXMgcXVvdGUgZXNjYXBlXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgaW5zdGFuY2VvZiBSZWdFeHAgJiYgc2VsZi50b1N0cmluZygpID09PSBvdGhlci50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgPT09KHN0cmluZylcbiAgICBgI3ttYXRjaCg6Ok9wYWwuY29lcmNlX3RvPyhzdHJpbmcsIDo6U3RyaW5nLCA6dG9fc3RyKSl9ICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9fihzdHJpbmcpXG4gICAgbWF0Y2goc3RyaW5nKSAmJiAkfi5iZWdpbigwKVxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgIyBTcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGZyZWV6ZSwgYmVjYXVzZSB0aGUgJCRnbSBhbmQgJCRnIHByb3BlcnRpZXMgbmVlZCB0byBiZSBzZXRcbiAgICAjIGVzcGVjaWFsbHkgZm9yIFJlZ0V4cC5cblxuICAgIHJldHVybiBzZWxmIGlmIGZyb3plbj9cblxuICAgICV4e1xuICAgICAgaWYgKCFzZWxmLmhhc093blByb3BlcnR5KCckJGcnKSkgeyAkcHJvcChzZWxmLCAnJCRnJywgbnVsbCk7IH1cbiAgICAgIGlmICghc2VsZi5oYXNPd25Qcm9wZXJ0eSgnJCRnbScpKSB7ICRwcm9wKHNlbGYsICckJGdtJywgbnVsbCk7IH1cblxuICAgICAgcmV0dXJuICRmcmVlemUoc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICMgVXNlIGEgcmVnZXhwIHRvIGV4dHJhY3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgdGhlIG9wdGlvbmFsIG1vZGUgbW9kaWZpZXJzIGZyb20gdGhlIHN0cmluZy5cbiAgICAjIEluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24sIGVzY2FwZSBhbnkgZnJvbnQgc2xhc2ggKG5vdCBhbHJlYWR5IGVzY2FwZWQpIHdpdGggYSBiYWNrc2xhc2guXG4gICAgJXh7XG4gICAgICB2YXIgcmVnZXhwX2Zvcm1hdCA9IC9eXFwvKC4qKVxcLyhbXlxcL10qKSQvO1xuICAgICAgdmFyIHZhbHVlID0gc2VsZi50b1N0cmluZygpO1xuICAgICAgdmFyIG1hdGNoZXMgPSByZWdleHBfZm9ybWF0LmV4ZWModmFsdWUpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgdmFyIHJlZ2V4cF9wYXR0ZXJuID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgdmFyIHJlZ2V4cF9mbGFncyA9IG1hdGNoZXNbMl07XG4gICAgICAgIHZhciBjaGFycyA9IHJlZ2V4cF9wYXR0ZXJuLnNwbGl0KCcnKTtcbiAgICAgICAgdmFyIGNoYXJzX2xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRfY2hhciA9IGNoYXJzW2ldO1xuICAgICAgICAgIGlmICghY2hhcl9lc2NhcGVkICYmIGN1cnJlbnRfY2hhciA9PSAnLycpIHtcbiAgICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdCgnXFxcXCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gcmVnZXhwX3BhdHRlcm5fZXNjYXBlZC5jb25jYXQoY3VycmVudF9jaGFyKTtcbiAgICAgICAgICBpZiAoY3VycmVudF9jaGFyID09ICdcXFxcJykge1xuICAgICAgICAgICAgaWYgKGNoYXJfZXNjYXBlZCkge1xuICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBvdmVyIGVzY2FwZVxuICAgICAgICAgICAgICBjaGFyX2VzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy8nICsgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCArICcvJyArIHJlZ2V4cF9mbGFncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaChzdHJpbmcsIHBvcyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIHZhciBtID0gc2VsZi5leGVjKCRjb2VyY2VfdG8oc3RyaW5nLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGBzZWxmYCwgYG1gKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb3MgPSAkY29lcmNlX3RvKHBvcywgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgICBpZiAobWQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1kLmluZGV4ID49IHBvcykge1xuICAgICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcoYHJlYCwgYG1kYCl9O1xuICAgICAgICAgIHJldHVybiBibG9jayA9PT0gbmlsID8gI3skfn0gOiAje3lpZWxkICR+fTtcbiAgICAgICAgfVxuICAgICAgICByZS5sYXN0SW5kZXggPSBtZC5pbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2g/KHN0cmluZywgcG9zID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA9PT0gbmlsID8gZmFsc2UgOiBzZWxmLnRlc3QoJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJykpO1xuICAgICAgfVxuXG4gICAgICBwb3MgPSAkY29lcmNlX3RvKHBvcywgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG1kID09PSBudWxsIHx8IG1kLmluZGV4IDwgcG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hbWVzXG4gICAgc291cmNlLnNjYW4oL1xcKD88KFxcdyspPi8sIG5vX21hdGNoZGF0YTogdHJ1ZSkubWFwKCY6Zmlyc3QpLnVuaXFcbiAgZW5kXG5cbiAgZGVmIG5hbWVkX2NhcHR1cmVzXG4gICAgc291cmNlLnNjYW4oL1xcKD88KFxcdyspPi8sIG5vX21hdGNoZGF0YTogdHJ1ZSkgIyBTY2FuIGZvciBjYXB0dXJlIGdyb3Vwc1xuICAgICAgICAgIC5tYXAoJjpmaXJzdCkgICAgICAgICAgICAgICAgICAgICAgICAgICAjIEdldCB0aGUgZmlyc3QgcmVnZXhwIG1hdGNoIChcXHcrKVxuICAgICAgICAgIC5lYWNoX3dpdGhfaW5kZXggICAgICAgICAgICAgICAgICAgICAgICAjIEFkZCBpbmRleCB0byBhbiBpdGVyYXRvclxuICAgICAgICAgIC5ncm91cF9ieSgmOmZpcnN0KSAgICAgICAgICAgICAgICAgICAgICAjIEdyb3VwIGJ5IHRoZSBjYXB0dXJlIGdyb3VwIG5hbWVzXG4gICAgICAgICAgLnRyYW5zZm9ybV92YWx1ZXMgZG8gfGl8ICAgICAgICAgICAgICAgICMgQ29udmVydCBoYXNoIHZhbHVlc1xuICAgICAgICAgICAgaS5tYXAgeyB8anwgai5sYXN0ICsgMSB9ICAgICAgICAgICAgICAjIERyb3AgdGhlIGNhcHR1cmUgZ3JvdXAgbmFtZXM7IGluY3JlYXNlIGluZGV4ZXMgYnkgMVxuICAgICAgICAgIGVuZFxuICBlbmRcblxuICBkZWYgflxuICAgIHNlbGYgPX4gJF9cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZVxuICAgIGBzZWxmLnNvdXJjZWBcbiAgZW5kXG5cbiAgZGVmIG9wdGlvbnNcbiAgICAjIEZsYWdzIHdvdWxkIGJlIG5pY2UgdG8gdXNlIHdpdGggdGhpcywgYnV0IHN0aWxsIGV4cGVyaW1lbnRhbCAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cC9mbGFnc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAvLyBzaG91bGQgYmUgc3VwcG9ydGVkIGluIElFNiBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS83ZjV6MjZ3NCh2PXZzLjk0KS5hc3B4XG4gICAgICBpZiAoc2VsZi5tdWx0aWxpbmUpIHtcbiAgICAgICAgcmVzdWx0IHw9ICN7TVVMVElMSU5FfTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmVzdWx0IHw9ICN7SUdOT1JFQ0FTRX07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhc2Vmb2xkP1xuICAgIGBzZWxmLmlnbm9yZUNhc2VgXG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgdG9fcyBzb3VyY2VcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgYXR0cl9yZWFkZXIgOnBvc3RfbWF0Y2gsIDpwcmVfbWF0Y2gsIDpyZWdleHAsIDpzdHJpbmdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWdleHAsIG1hdGNoX2dyb3Vwcywgbm9fbWF0Y2hkYXRhOiBmYWxzZSlcbiAgICAkfiAgICAgICAgICA9IHNlbGYgdW5sZXNzIG5vX21hdGNoZGF0YVxuICAgIEByZWdleHAgICAgID0gcmVnZXhwXG4gICAgQGJlZ2luICAgICAgPSBgbWF0Y2hfZ3JvdXBzLmluZGV4YFxuICAgIEBzdHJpbmcgICAgID0gYG1hdGNoX2dyb3Vwcy5pbnB1dGBcbiAgICBAcHJlX21hdGNoICA9IGBtYXRjaF9ncm91cHMuaW5wdXQuc2xpY2UoMCwgbWF0Y2hfZ3JvdXBzLmluZGV4KWBcbiAgICBAcG9zdF9tYXRjaCA9IGBtYXRjaF9ncm91cHMuaW5wdXQuc2xpY2UobWF0Y2hfZ3JvdXBzLmluZGV4ICsgbWF0Y2hfZ3JvdXBzWzBdLmxlbmd0aClgXG4gICAgQG1hdGNoZXMgICAgPSBbXVxuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWF0Y2hfZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IG1hdGNoX2dyb3Vwc1tpXTtcblxuICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgICAgICAgICN7QG1hdGNoZXN9LnB1c2gobmlsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAje0BtYXRjaGVzfS5wdXNoKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKGlkeClcbiAgICBpZiAobWF0Y2ggPSBzZWxmW2lkeF0pXG4gICAgICBtYXRjaFxuICAgIGVsc2lmIGlkeC5pc19hPyhJbnRlZ2VyKSAmJiBpZHggPj0gbGVuZ3RoXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tpZHh9IG91dCBvZiBtYXRjaGVzXCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG1hdGNoX2xlbmd0aChpZHgpXG4gICAgbWF0Y2goaWR4KSYubGVuZ3RoXG4gIGVuZFxuXG4gIGRlZiBbXSgqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzWzBdLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGlmICgjeyFyZWdleHAubmFtZXMuaW5jbHVkZT8oYXJnc1swXSl9KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwidW5kZWZpbmVkIGdyb3VwIG5hbWUgcmVmZXJlbmNlOiAje2FyZ3NbMF19XCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7bmFtZWRfY2FwdHVyZXNbYXJnc1swXV19XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7QG1hdGNoZXNbKmFyZ3NdfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9mZnNldChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjb2Zmc2V0IG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtzZWxmLmJlZ2luLCBzZWxmLmJlZ2luICsgc2VsZi5tYXRjaGVzW25dLmxlbmd0aF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyA6Ok1hdGNoRGF0YSA9PT0gb3RoZXJcblxuICAgIGBzZWxmLnN0cmluZyA9PSBvdGhlci5zdHJpbmdgICYmXG4gICAgICBgc2VsZi5yZWdleHAudG9TdHJpbmcoKSA9PSBvdGhlci5yZWdleHAudG9TdHJpbmcoKWAgJiZcbiAgICAgIGBzZWxmLnByZV9tYXRjaCA9PSBvdGhlci5wcmVfbWF0Y2hgICYmXG4gICAgICBgc2VsZi5wb3N0X21hdGNoID09IG90aGVyLnBvc3RfbWF0Y2hgICYmXG4gICAgICBgc2VsZi5iZWdpbiA9PSBvdGhlci5iZWdpbmBcbiAgZW5kXG5cbiAgZGVmIGJlZ2luKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNiZWdpbiBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmJlZ2luO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVuZChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjZW5kIG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuYmVnaW4gKyBzZWxmLm1hdGNoZXNbbl0ubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhcHR1cmVzXG4gICAgYCN7QG1hdGNoZXN9LnNsaWNlKDEpYFxuICBlbmRcblxuICBkZWYgbmFtZWRfY2FwdHVyZXNcbiAgICBtYXRjaGVzID0gY2FwdHVyZXNcbiAgICByZWdleHAubmFtZWRfY2FwdHVyZXMudHJhbnNmb3JtX3ZhbHVlcyBkbyB8aXxcbiAgICAgIG1hdGNoZXNbaS5sYXN0IC0gMV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG5hbWVzXG4gICAgcmVnZXhwLm5hbWVzXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gXCIjPE1hdGNoRGF0YSBcIiArICN7YCN7QG1hdGNoZXN9WzBdYC5pbnNwZWN0fTtcblxuICAgICAgaWYgKCN7cmVnZXhwLm5hbWVzLmVtcHR5P30pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICN7QG1hdGNoZXN9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3RyICs9IFwiIFwiICsgaSArIFwiOlwiICsgI3tgI3tAbWF0Y2hlc31baV1gLmluc3BlY3R9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3sgbmFtZWRfY2FwdHVyZXMuZWFjaCBkbyB8aywgdnxcbiAgICAgICAgICAgICAleHtcbiAgICAgICAgICAgICAgIHN0ciArPSBcIiBcIiArICN7a30gKyBcIjpcIiArICN7di5pbnNwZWN0fVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgZW5kIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiPlwiO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BtYXRjaGVzfS5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgQG1hdGNoZXNcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgI3tAbWF0Y2hlc31bMF1gXG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgYSwgaW5kZXgsIHZhbHVlcyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIGlmIChhcmdzW2ldLiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgICBhID0gI3tgYXJnc1tpXWAudG9fYX07XG4gICAgICAgICAgYS51bnNoaWZ0KGksIDEpO1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoYXJncywgYSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9ICN7OjpPcGFsLmNvZXJjZV90byEoYGFyZ3NbaV1gLCA6OkludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggKz0gI3tAbWF0Y2hlc30ubGVuZ3RoO1xuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG5pbCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZXMucHVzaCgje0BtYXRjaGVzfVtpbmRleF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBzaXplIGxlbmd0aFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSZWdleHBFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOlJlZ2V4cD4iLCJzZWxmIiwiMSIsIjIiLCI0IiwiYWxsb2NhdGUiLCJhbGxvY2F0ZWQiLCJlc2NhcGUiLCJzdHJpbmciLCJsYXN0X21hdGNoIiwibiIsIm5pbD8iLCIkfiIsIltdIiwidW5pb24iLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm9wdGlvbnMiLCJ0b19zdHIiLCJuZXciLCJqb2luIiwicmVnZXhwIiwiT3BhbCIsImNvZXJjZV90byEiLCJTdHJpbmciLCJSZWdleHBFcnJvciIsIiEiLCJJR05PUkVDQVNFIiwiTVVMVElMSU5FIiwiPT0iLCJvdGhlciIsIj09PSIsIm1hdGNoIiwiY29lcmNlX3RvPyIsIj1+IiwiJHJldF9vcl8xIiwiYmVnaW4iLCIwIiwiZnJlZXplIiwiZnJvemVuPyIsImluc3BlY3QiLCJwb3MiLCJNYXRjaERhdGEiLCJJbnRlZ2VyIiwibWF0Y2g/IiwibmFtZXMiLCJtYXAiLCJzb3VyY2UiLCJzY2FuIiwidG9fcHJvYyIsInVuaXEiLCJuYW1lZF9jYXB0dXJlcyIsInRyYW5zZm9ybV92YWx1ZXMiLCJncm91cF9ieSIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIG5hbWVkX2NhcHR1cmVzIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gbmFtZWRfY2FwdHVyZXMiLCJqIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBuYW1lZF9jYXB0dXJlcyIsIisiLCJsYXN0IiwifiIsIiRfIiwiY2FzZWZvbGQ/IiwiPGNsYXNzOk1hdGNoRGF0YT4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJtYXRjaF9ncm91cHMiLCIka3dhcmdzIiwibm9fbWF0Y2hkYXRhIiwiQHJlZ2V4cCIsIkBiZWdpbiIsIkBzdHJpbmciLCJAcHJlX21hdGNoIiwiQHBvc3RfbWF0Y2giLCJAbWF0Y2hlcyIsImlkeCIsImlzX2E/IiwiPj0iLCJsZW5ndGgiLCJJbmRleEVycm9yIiwibWF0Y2hfbGVuZ3RoIiwiaW5jbHVkZT8iLCJhcmdzIiwib2Zmc2V0IiwiQXJndW1lbnRFcnJvciIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsImVuZCIsImNhcHR1cmVzIiwibWF0Y2hlcyIsIi0iLCJlbXB0eT8iLCJlYWNoIiwiYmxvY2sgaW4gaW5zcGVjdCIsImsiLCJ2IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnNwZWN0IiwidG9fYSIsInRvX3MiLCJ2YWx1ZXNfYXQiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsT0FBTSxJQUFOQSxFQUFzQkMsb0JBQXRCRDtFQUVBRTtFQUFB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QUlDLENBQTNCRjs7UUFBd0I7UUFBRztRQUN6QkcsT0FDYkEsNEJBQThCRixDQUFFRSxTQUFXRCxDQUFDMUQsU0FBQUEsQ0FBQUEsRUFGakN3RCxDQUFjRDtBQUt6QnZEOztBQUVBQTtBQUNBQTtJQWxCRUEsQ0FBQUE7O0FBcUJBd0MsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBR0osWUFBU0k7SUFEZEEsQ0FBQUE7O0FBSUFvQixJQUFBQSxvQkFBQUEsYUFDRSxTQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBR3pCLFlBQVN5QjtJQURkQSxDQUFBQTs7QUFJQUMsSUFBQUEseUJBQUFBLHFCQTViRixFQTRiRUE7QUFBQUEsTUFBQUE7OztNQTViRjtNQTRiZ0I7O0FBRWhCQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLGNBQWdCQSxDQUFDQSxPQUFEQSxDQUFTRixNQUFBQSxDQUFBQSxDQUFNRTtBQUMvQkE7QUFDQUE7QUFDQUE7O0FBRUFBLGdCQUFrQmhGLEtBQU1DLGVBQUFBLENBQWErRSxPQUFuQixFQUE2QjNELGNBQTdCLEVBQXdDLFFBQWxDcEIsQ0FBMkMrRTs7QUFFbkVBO0FBQ0FBLG1CQUFxQjFCLFlBQVMwQjtBQUM5QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBLG9CQUFzQjFCLFlBQVMwQjtBQUMvQkE7O0FBRUFBO0FBQ0FBO0lBMUJFQSxDQUFBQSxJQUFBQTtJQTZCQSxhQUFNLE1BQU4sRUFBVyxJQUFYO0lBQ0FyQyxPQUFBLGFBQU0sTUFBTixFQUFXLFFBQVg7RUF2S0ZBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBblRBckU7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjcyNDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cmluZy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90bywgcmVzcG9uZF90bywgZ2xvYmFsX211bHRpbGluZV9yZWdleHAsIHByb3BcblxucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG5cbmNsYXNzIDo6U3RyaW5nIDwgYFN0cmluZ2BcbiAgaW5jbHVkZSA6OkNvbXBhcmFibGVcblxuICAleHtcbiAgICBPcGFsLnByb3AoI3tzZWxmfS4kJHByb3RvdHlwZSwgJyQkaXNfc3RyaW5nJywgdHJ1ZSk7XG4gIH1cblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQod2hhdClcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyh3aGF0LCA6OlN0cmluZywgOnRvX3N0cilcbiAgZW5kXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IGFyZ3NbMF0gfHwgXCJcIjtcbiAgICAgIHZhciBvcHRzID0gYXJnc1thcmdzLmxlbmd0aC0xXTtcbiAgICAgIHN0ciA9ICRjb2VyY2VfdG8oc3RyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy4kJGlzX2hhc2gpIHtcbiAgICAgICAgaWYgKG9wdHMuJCRzbWFwLmVuY29kaW5nKSBzdHIgPSBzdHIuJGZvcmNlX2VuY29kaW5nKG9wdHMuJCRzbWFwLmVuY29kaW5nKTtcbiAgICAgIH1cbiAgICAgIHN0ciA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3Ioc3RyKTtcbiAgICAgIGlmICghc3RyLiRpbml0aWFsaXplLiQkcHJpc3RpbmUpICN7YHN0cmAuaW5pdGlhbGl6ZSgqYXJncyl9O1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGVuZFxuXG4gICMgT3VyIGluaXRpYWxpemUgbWV0aG9kIGRvZXMgbm90aGluZywgdGhlIHN0cmluZyB2YWx1ZSBzZXR1cCBpcyBiZWluZ1xuICAjIGRvbmUgYnkgU3RyaW5nLm5ldy4gVGhlcmVmb3JlIG5vdCBhbGwga2luZHMgb2Ygc3ViY2xhc3Npbmcgd2lsbCB3b3JrLlxuICAjIEFzIGEgcnVsZSBvZiB0aHVtYiwgd2hlbiBzdWJjbGFzc2luZyBTdHJpbmcsIGVpdGhlciBtYWtlIHN1cmUgdG8gb3ZlcnJpZGVcbiAgIyAubmV3IG9yIG1ha2Ugc3VyZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCBnaXZlbiB0byBhIGNvbnN0cnVjdG9yIGlzXG4gICMgYSBzdHJpbmcgd2Ugd2FudCBvdXIgc3ViY2xhc3Mtc3RyaW5nIHRvIGhvbGQuXG4gIGRlZiBpbml0aWFsaXplKHN0ciA9IHVuZGVmaW5lZCwgZW5jb2Rpbmc6IG5pbCwgY2FwYWNpdHk6IG5pbClcbiAgZW5kXG5cbiAgZGVmICUoZGF0YSlcbiAgICBpZiA6OkFycmF5ID09PSBkYXRhXG4gICAgICBmb3JtYXQoc2VsZiwgKmRhdGEpXG4gICAgZWxzZVxuICAgICAgZm9ybWF0KHNlbGYsIGRhdGEpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKGNvdW50KVxuICAgICV4e1xuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKTtcblxuICAgICAgLy8gQWxsIGNyZWRpdCBmb3IgdGhlIGJpdC10d2lkZGxpbmcgbWFnaWMgY29kZSBiZWxvdyBnb2VzIHRvIE1vemlsbGFcbiAgICAgIC8vIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIG9mIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KCkgcG9zdGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XG5cbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoICogY291bnQgPj0gMSA8PCAyOCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ211bHRpcGx5IGNvdW50IG11c3Qgbm90IG92ZXJmbG93IG1heGltdW0gc3RyaW5nIHNpemUnfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoY291bnQgJiAxKSA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgPj4+PSAxO1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBgJGNvZXJjZV90bygje290aGVyfSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcblxuICAgICV4e1xuICAgICAgaWYgKG90aGVyID09IFwiXCIgJiYgc2VsZi4kJGNsYXNzID09PSBPcGFsLlN0cmluZykgcmV0dXJuICN7c2VsZn07XG4gICAgICBpZiAoc2VsZiA9PSBcIlwiICYmIG90aGVyLiQkY2xhc3MgPT09IE9wYWwuU3RyaW5nKSByZXR1cm4gI3tvdGhlcn07XG4gICAgICB2YXIgb3V0ID0gc2VsZiArIG90aGVyO1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcgPT09IG91dC5lbmNvZGluZyAmJiBvdGhlci5lbmNvZGluZyA9PT0gb3V0LmVuY29kaW5nKSByZXR1cm4gb3V0O1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcubmFtZSA9PT0gXCJVVEYtOFwiIHx8IG90aGVyLmVuY29kaW5nLm5hbWUgPT09IFwiVVRGLThcIikgcmV0dXJuIG91dDtcbiAgICAgIHJldHVybiBPcGFsLmVuYyhvdXQsIHNlbGYuZW5jb2RpbmcpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fc3RyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX3N0ci50b19zXG5cbiAgICAgIGBzZWxmID4gb3RoZXIgPyAxIDogKHNlbGYgPCBvdGhlciA/IC0xIDogMClgXG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIHZhciBjbXAgPSAje290aGVyIDw9PiBzZWxmfTtcblxuICAgICAgICBpZiAoY21wID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbXAgPiAwID8gLTEgOiAoY21wIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudG9TdHJpbmcoKSA9PT0gb3RoZXIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgkcmVzcG9uZF90byhvdGhlciwgJyR0b19zdHInKSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9fihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndHlwZSBtaXNtYXRjaDogU3RyaW5nIGdpdmVuJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje290aGVyID1+IHNlbGZ9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLCBleGNsdWRlLCByYW5nZTtcblxuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgZXhjbHVkZSA9IGluZGV4LmV4Y2w7XG4gICAgICAgIHJhbmdlICAgPSBpbmRleDtcbiAgICAgICAgbGVuZ3RoICA9IGluZGV4LmVuZCA9PT0gbmlsID8gLTEgOiAkY29lcmNlX3RvKGluZGV4LmVuZCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGluZGV4ICAgPSBpbmRleC5iZWdpbiA9PT0gbmlsID8gMCA6ICRjb2VyY2VfdG8oaW5kZXguYmVnaW4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhpbmRleCkgPiBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXhjbHVkZSB8fCByYW5nZS5lbmQgPT09IG5pbCkge1xuICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gaW5kZXg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuc3Vic3RyKGluZGV4LCBsZW5ndGgpO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YoaW5kZXgpICE9PSAtMSA/IGluZGV4IDogbmlsO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzZWxmLm1hdGNoKGluZGV4KTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGBpbmRleGAsIGBtYXRjaGApfVxuXG4gICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCAmJiAtbGVuZ3RoIDwgbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoW2xlbmd0aCArPSBtYXRjaC5sZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaFtsZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuXG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLnN1YnN0cihpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID4gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc3Vic3RyKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJcbiAgICBgbmV3IFN0cmluZygje3NlbGZ9KWAuZm9yY2VfZW5jb2RpbmcoJ2JpbmFyeScpXG4gIGVuZFxuXG4gIGRlZiBjYXBpdGFsaXplXG4gICAgYHNlbGYuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzZWxmLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpYFxuICBlbmRcblxuICBkZWYgY2FzZWNtcChvdGhlcilcbiAgICByZXR1cm4gbmlsIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcbiAgICAleHtcbiAgICAgIHZhciBhc2NpaV9vbmx5ID0gL15bXFx4MDAtXFx4N0ZdKiQvO1xuICAgICAgaWYgKGFzY2lpX29ubHkudGVzdChzZWxmKSAmJiBhc2NpaV9vbmx5LnRlc3Qob3RoZXIpKSB7XG4gICAgICAgIHNlbGYgPSBzZWxmLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIG90aGVyID0gb3RoZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZiA8PT4gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGNhc2VjbXA/KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGNtcCA9ICN7Y2FzZWNtcChvdGhlcil9O1xuICAgICAgaWYgKGNtcCA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY21wID09PSAwO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNlbnRlcih3aWR0aCwgcGFkc3RyID0gJyAnKVxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGxqdXN0aWZpZWQgPSAje2xqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmNlaWwsIHBhZHN0cn0sXG4gICAgICAgICAgcmp1c3RpZmllZCA9ICN7cmp1c3QgKCh3aWR0aCArIGBzZWxmLmxlbmd0aGApIC8gMikuZmxvb3IsIHBhZHN0cn07XG5cbiAgICAgIHJldHVybiByanVzdGlmaWVkICsgbGp1c3RpZmllZC5zbGljZShzZWxmLmxlbmd0aCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hvbXAoc2VwYXJhdG9yID0gJC8pXG4gICAgcmV0dXJuIHNlbGYgaWYgYHNlcGFyYXRvciA9PT0gbmlsIHx8IHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgc2VwYXJhdG9yID0gOjpPcGFsLmNvZXJjZV90byEoc2VwYXJhdG9yLCA6OlN0cmluZywgOnRvX3N0cikudG9fc1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvXFxyP1xcbj8kLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VwYXJhdG9yID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvKFxccj9cXG4pKyQvLCAnJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmLmxlbmd0aCA+PSBzZXBhcmF0b3IubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0YWlsID0gc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoLCBzZXBhcmF0b3IubGVuZ3RoKTtcblxuICAgICAgICBpZiAodGFpbCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjaG9wXG4gICAgJXh7XG4gICAgICB2YXIgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHJlc3VsdDtcblxuICAgICAgaWYgKGxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuY2hhckF0KGxlbmd0aCAtIDEpID09PSBcIlxcblwiICYmIHNlbGYuY2hhckF0KGxlbmd0aCAtIDIpID09PSBcIlxcclwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIGxlbmd0aCAtIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hyXG4gICAgYHNlbGYuY2hhckF0KDApYFxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiBuaWwpXG4gICAgdW5sZXNzIGZyZWV6ZS5uaWw/IHx8IGZyZWV6ZSA9PSB0cnVlIHx8IGZyZWV6ZSA9PSBmYWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHZhbHVlIGZvciBmcmVlemU6ICN7ZnJlZXplLmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICBjb3B5ID0gYG5ldyBTdHJpbmcoc2VsZilgXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYsIGZyZWV6ZTogZnJlZXplKVxuXG4gICAgaWYgZnJlZXplID09IHRydWVcbiAgICAgIGBpZiAoIWNvcHkuJCRmcm96ZW4pIHsgY29weS4kJGZyb3plbiA9IHRydWU7IH1gXG4gICAgZWxzaWYgZnJlZXplLm5pbD9cbiAgICAgIGBpZiAoc2VsZi4kJGZyb3plbikgeyBjb3B5LiQkZnJvemVuID0gdHJ1ZTsgfWBcbiAgICBlbmRcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgbmV3IFN0cmluZyhzZWxmKWBcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgY291bnQoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggLSBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ0FyZ3VtZW50RXJyb3I6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDErKSd9XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX3ByZWZpeChwcmVmaXgpXG4gICAgJXh7XG4gICAgICBpZiAoIXByZWZpeC4kJGlzX3N0cmluZykge1xuICAgICAgICBwcmVmaXggPSAkY29lcmNlX3RvKHByZWZpeCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc2xpY2UoMCwgcHJlZml4Lmxlbmd0aCkgPT09IHByZWZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9zdWZmaXgoc3VmZml4KVxuICAgICV4e1xuICAgICAgaWYgKCFzdWZmaXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgc3VmZml4ID0gJGNvZXJjZV90byhzdWZmaXgsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNsaWNlKHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZG93bmNhc2VcbiAgICBgc2VsZi50b0xvd2VyQ2FzZSgpYFxuICBlbmRcblxuICBkZWYgZWFjaF9saW5lKHNlcGFyYXRvciA9ICQvLCBjaG9tcDogZmFsc2UsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfbGluZSwgc2VwYXJhdG9yLCBjaG9tcDogY2hvbXAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBuaWwpIHtcbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHNlbGYpO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBzZXBhcmF0b3IgPSAkY29lcmNlX3RvKHNlcGFyYXRvciwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgdmFyIGEsIGksIG4sIGxlbmd0aCwgY2hvbXBlZCwgdHJhaWxpbmcsIHNwbGl0dGVkLCB2YWx1ZTtcblxuICAgICAgaWYgKHNlcGFyYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yIChhID0gc2VsZi5zcGxpdCgvKCg/Olxccj9cXG4pezJ9KSg/Oig/Olxccj9cXG4pKikvKSwgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgICAgIGlmIChhW2ldIHx8IGFbaSArIDFdKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IChhW2ldIHx8IFwiXCIpICsgKGFbaSArIDFdIHx8IFwiXCIpO1xuICAgICAgICAgICAgaWYgKGNob21wKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gI3tgdmFsdWVgLmNob21wKFwiXFxuXCIpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGNob21wZWQgID0gI3tjaG9tcChzZXBhcmF0b3IpfTtcbiAgICAgIHRyYWlsaW5nID0gc2VsZi5sZW5ndGggIT0gY2hvbXBlZC5sZW5ndGg7XG4gICAgICBzcGxpdHRlZCA9IGNob21wZWQuc3BsaXQoc2VwYXJhdG9yKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc3BsaXR0ZWQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBzcGxpdHRlZFtpXTtcbiAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAxIHx8IHRyYWlsaW5nKSB7XG4gICAgICAgICAgdmFsdWUgKz0gc2VwYXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaG9tcCkge1xuICAgICAgICAgIHZhbHVlID0gI3tgdmFsdWVgLmNob21wKHNlcGFyYXRvcil9O1xuICAgICAgICB9XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZW5kX3dpdGg/KCpzdWZmaXhlcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdWZmaXhlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VmZml4ID0gJGNvZXJjZV90byhzdWZmaXhlc1tpXSwgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICAgIGlmIChzZWxmLmxlbmd0aCA+PSBzdWZmaXgubGVuZ3RoICYmXG4gICAgICAgICAgICBzZWxmLnN1YnN0cihzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgsIHN1ZmZpeC5sZW5ndGgpID09IHN1ZmZpeCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIGdzdWIocGF0dGVybiwgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOmdzdWIsIHBhdHRlcm59O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gJycsIG1hdGNoX2RhdGEgPSBuaWwsIGluZGV4ID0gMCwgbWF0Y2gsIF9yZXBsYWNlbWVudDtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0SW5kZXg7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJlc3VsdCArPSBzZWxmLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoX2RhdGEgPSAjezo6TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGB9O1xuXG4gICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGFzdEluZGV4ID0gcGF0dGVybi5sYXN0SW5kZXg7XG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gYmxvY2sobWF0Y2hbMF0pO1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gbGFzdEluZGV4OyAvLyBzYXZlIGFuZCByZXN0b3JlIGxhc3RJbmRleFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50LiQkaXNfaGFzaCkge1xuICAgICAgICAgIF9yZXBsYWNlbWVudCA9ICN7YHJlcGxhY2VtZW50YFtgbWF0Y2hbMF1gXS50b19zfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoIXJlcGxhY2VtZW50LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9ICRjb2VyY2VfdG8ocmVwbGFjZW1lbnQsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJlcGxhY2UoLyhbXFxcXF0rKShbMC05KyZgJ10pL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwgc2xhc2hlcywgY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKHNsYXNoZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGNhc2UgXCImXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbMF07XG4gICAgICAgICAgICBjYXNlIFwiYFwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6ICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIChtYXRjaFtjb21tYW5kXSB8fCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudCArIChzZWxmW21hdGNoLmluZGV4XSB8fCBcIlwiKSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudClcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgfVxuXG4gICAgICAjeyR+ID0gYG1hdGNoX2RhdGFgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgZGVmIGhleFxuICAgIHRvX2kgMTZcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKCFvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICBvdGhlciA9ICRjb2VyY2VfdG8ob3RoZXIsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5pbmRleE9mKG90aGVyKSAhPT0gLTE7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgcmVnZXg7XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gJGNvZXJjZV90byhvZmZzZXQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICByZWdleCA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZWFyY2gpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICN7JH4gPSBuaWx9O1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF0Y2guaW5kZXggPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGByZWdleGAsIGBtYXRjaGApfVxuICAgICAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWdleC5sYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaCA9ICRjb2VyY2VfdG8oc2VhcmNoLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCAmJiBvZmZzZXQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXggPSBzZWxmLmluZGV4T2Yoc2VhcmNoLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBuaWwgOiBpbmRleDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzcyAqL1xuICAgICAgdmFyIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxcdTAwN0YtXFx1MDA5RlxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgICAgbWV0YSA9IHtcbiAgICAgICAgICAgICdcXHUwMDA3JzogJ1xcXFxhJyxcbiAgICAgICAgICAgICdcXHUwMDFiJzogJ1xcXFxlJyxcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAnXFx2JzogJ1xcXFx2JyxcbiAgICAgICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXNjYXBlZCA9IHNlbGYucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChjaHIpIHtcbiAgICAgICAgICAgIGlmIChtZXRhW2Nocl0pIHJldHVybiBtZXRhW2Nocl07XG4gICAgICAgICAgICBjaHIgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmIChjaHIgPD0gMHhmZiAmJiAoc2VsZi5lbmNvZGluZ1tcIiRiaW5hcnk/XCJdKCkgfHwgc2VsZi5pbnRlcm5hbF9lbmNvZGluZ1tcIiRiaW5hcnk/XCJdKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBjaHIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHUnICsgKCcwMDAwJyArIGNoci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVkLnJlcGxhY2UoL1xcI1tcXCRcXEBcXHtdL2csICdcXFxcJCYnKSArICdcIic7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzICovXG4gICAgfVxuICBlbmRcblxuICBkZWYgaW50ZXJuXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGBzZWxmLmxlbmd0aGBcbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgbGluZXMoc2VwYXJhdG9yID0gJC8sIGNob21wOiBmYWxzZSwgJmJsb2NrKVxuICAgIGUgPSBlYWNoX2xpbmUoc2VwYXJhdG9yLCBjaG9tcDogY2hvbXAsICZibG9jaylcbiAgICBibG9jayA/IHNlbGYgOiBlLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGxqdXN0KHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gYCRjb2VyY2VfdG8oI3t3aWR0aH0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3s6OlN0cmluZ30sICd0b19zdHInKWAudG9fc1xuXG4gICAgaWYgcGFkc3RyLmVtcHR5P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnemVybyB3aWR0aCBwYWRkaW5nJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIHNlbGYgaWYgYHdpZHRoIDw9IHNlbGYubGVuZ3RoYFxuXG4gICAgJXh7XG4gICAgICB2YXIgaW5kZXggID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gXCJcIjtcblxuICAgICAgd2lkdGggLT0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgd2lkdGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IHBhZHN0cjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYgKyByZXN1bHQuc2xpY2UoMCwgd2lkdGgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15bXFx1MDAwMFxcc10qLywgJycpYFxuICBlbmRcblxuICBkZWYgYXNjaWlfb25seT9cbiAgICAjIG5vbi1BU0NJSS1jb21wYXRpYmxlIGVuY29kaW5nIG11c3QgcmV0dXJuIGZhbHNlXG4gICAgJXh7XG4gICAgICBpZiAoIXNlbGYuZW5jb2RpbmcuYXNjaWkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiAvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChzZWxmKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaChwYXR0ZXJuLCBwb3MgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IDo6UmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyA6OlJlZ2V4cCA9PT0gcGF0dGVyblxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2goc2VsZiwgcG9zLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8ocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkKVxuICAgIGlmIFN0cmluZyA9PT0gcGF0dGVybiB8fCBwYXR0ZXJuLnJlc3BvbmRfdG8/KDp0b19zdHIpXG4gICAgICBwYXR0ZXJuID0gOjpSZWdleHAubmV3KHBhdHRlcm4udG9fc3RyKVxuICAgIGVuZFxuXG4gICAgdW5sZXNzIDo6UmVnZXhwID09PSBwYXR0ZXJuXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7cGF0dGVybi5jbGFzc30gKGV4cGVjdGVkIFJlZ2V4cClcIlxuICAgIGVuZFxuXG4gICAgcGF0dGVybi5tYXRjaD8oc2VsZiwgcG9zKVxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgICV4e1xuICAgICAgdmFyIGkgPSBzZWxmLmxlbmd0aDtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzZWxmO1xuICAgICAgdmFyIGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXggPSBzZWxmLnNlYXJjaCgvW2EtekEtWjAtOV0vKTtcbiAgICAgIHZhciBjYXJyeSA9IGZhbHNlO1xuICAgICAgdmFyIGNvZGU7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvZGUgPSBzZWxmLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICgoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fFxuICAgICAgICAgIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHx8XG4gICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpKSB7XG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgY2FzZSA1NzpcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSA0ODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gNjU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEyMjpcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSA5NztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZmlyc3RfYWxwaGFudW1fY2hhcl9pbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgICBjb2RlID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgcmVzdWx0LnNsaWNlKGkgKyAxKTtcbiAgICAgICAgaWYgKGNhcnJ5ICYmIChpID09PSAwIHx8IGkgPT09IGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXgpKSB7XG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdC5zbGljZShpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhcnJ5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgb2N0XG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYsXG4gICAgICAgICAgcmFkaXggPSA4O1xuXG4gICAgICBpZiAoL15cXHMqXy8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KSguKykkL2ksIGZ1bmN0aW9uIChvcmlnaW5hbCwgaGVhZCwgZmxhZywgdGFpbCkge1xuICAgICAgICBzd2l0Y2ggKHRhaWwuY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgIGlmICh0YWlsLmNoYXJBdCgxKSA9PT0gJ3gnICYmIGZsYWcgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICByYWRpeCA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcwbyc6XG4gICAgICAgICAgcmFkaXggPSA4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIHJhZGl4ID0gMTY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdCA9IHBhcnNlSW50KHN0cmluZy5yZXBsYWNlKC9fKD8hXykvZywgJycpLCByYWRpeCk7XG4gICAgICByZXR1cm4gaXNOYU4ocmVzdWx0KSA/IDAgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgb3JkXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuY29kZVBvaW50QXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc2VsZi5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5jaGFyQ29kZUF0KDApO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHBhcnRpdGlvbihzZXApXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbTtcblxuICAgICAgaWYgKHNlcC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gc2VwLmV4ZWMoc2VsZik7XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7OjpNYXRjaERhdGEubmV3IGBzZXBgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcCA9ICRjb2VyY2VfdG8oc2VwLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5pbmRleE9mKHNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gW3NlbGYsICcnLCAnJ107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNlbGYuc2xpY2UoMCwgaSksXG4gICAgICAgIHNlbGYuc2xpY2UoaSwgaSArIHNlcC5sZW5ndGgpLFxuICAgICAgICBzZWxmLnNsaWNlKGkgKyBzZXAubGVuZ3RoKVxuICAgICAgXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKWBcbiAgZW5kXG5cbiAgZGVmIHJpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtLCByLCBfbTtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gJGNvZXJjZV90byhvZmZzZXQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgciA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZWFyY2gpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIF9tID0gci5leGVjKHNlbGYpO1xuICAgICAgICAgIGlmIChfbSA9PT0gbnVsbCB8fCBfbS5pbmRleCA+IG9mZnNldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSBfbTtcbiAgICAgICAgICByLmxhc3RJbmRleCA9IG0uaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3s6Ok1hdGNoRGF0YS5uZXcgYHJgLCBgbWB9O1xuICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2ggPSAkY29lcmNlX3RvKHNlYXJjaCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VhcmNoLCBvZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaSA9PT0gLTEgPyBuaWwgOiBpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJqdXN0KHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gYCRjb2VyY2VfdG8oI3t3aWR0aH0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3s6OlN0cmluZ30sICd0b19zdHInKWAudG9fc1xuXG4gICAgaWYgcGFkc3RyLmVtcHR5P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnemVybyB3aWR0aCBwYWRkaW5nJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIHNlbGYgaWYgYHdpZHRoIDw9IHNlbGYubGVuZ3RoYFxuXG4gICAgJXh7XG4gICAgICB2YXIgY2hhcnMgICAgID0gTWF0aC5mbG9vcih3aWR0aCAtIHNlbGYubGVuZ3RoKSxcbiAgICAgICAgICBwYXR0ZXJucyAgPSBNYXRoLmZsb29yKGNoYXJzIC8gcGFkc3RyLmxlbmd0aCksXG4gICAgICAgICAgcmVzdWx0ICAgID0gQXJyYXkocGF0dGVybnMgKyAxKS5qb2luKHBhZHN0ciksXG4gICAgICAgICAgcmVtYWluaW5nID0gY2hhcnMgLSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ICsgcGFkc3RyLnNsaWNlKDAsIHJlbWFpbmluZykgKyBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJwYXJ0aXRpb24oc2VwKVxuICAgICV4e1xuICAgICAgdmFyIGksIG0sIHIsIF9tO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBudWxsO1xuICAgICAgICByID0gJGdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHNlcCk7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gX207XG4gICAgICAgICAgci5sYXN0SW5kZXggPSBtLmluZGV4ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7OjpNYXRjaERhdGEubmV3IGByYCwgYG1gfTtcbiAgICAgICAgICBzZXAgPSBtWzBdO1xuICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcCA9ICRjb2VyY2VfdG8oc2VwLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFsnJywgJycsIHNlbGZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLFxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKSxcbiAgICAgICAgc2VsZi5zbGljZShpICsgc2VwLmxlbmd0aClcbiAgICAgIF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcnN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvW1xcc1xcdTAwMDBdKiQvLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBzY2FuKHBhdHRlcm4sIG5vX21hdGNoZGF0YTogZmFsc2UsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBtYXRjaF9kYXRhID0gbmlsLFxuICAgICAgICAgIG1hdGNoO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gJGdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHBhdHRlcm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnZ20nKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKSkgIT0gbnVsbCkge1xuICAgICAgICBtYXRjaF9kYXRhID0gI3s6Ok1hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgLCBub19tYXRjaGRhdGE6IG5vX21hdGNoZGF0YX07XG4gICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgbWF0Y2gubGVuZ3RoID09IDEgPyByZXN1bHQucHVzaChtYXRjaFswXSkgOiByZXN1bHQucHVzaCgje2BtYXRjaF9kYXRhYC5jYXB0dXJlc30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoLmxlbmd0aCA9PSAxID8gT3BhbC55aWVsZDEoYmxvY2ssIG1hdGNoWzBdKSA6IE9wYWwueWllbGQxKGJsb2NrLCAje2BtYXRjaF9kYXRhYC5jYXB0dXJlc30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbm9fbWF0Y2hkYXRhKSAjeyR+ID0gYG1hdGNoX2RhdGFgfTtcblxuICAgICAgcmV0dXJuIChibG9jayAhPT0gbmlsID8gc2VsZiA6IHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICAjIFdlIHJlZGVmaW5lIHRoaXMgbWV0aG9kIG9uIFN0cmluZywgYXMga2VybmVsLnJiIGlzIGluIHN0cmljdCBtb2RlXG4gICMgc28gdGhhdCB0aGluZ3MgbGlrZSBCb29sZWFuIGRvbid0IGdldCBib3hlZC4gRm9yIFN0cmluZyB0aG91Z2ggLVxuICAjIHdlIGVpdGhlciBuZWVkIHRvIGJveCBpdCB0byBkZWZpbmUgcHJvcGVydGllcyBvbiBpdCwgb3IgcnVuIGl0IGluXG4gICMgbm9uLXN0cmljdCBtb2RlLiBUaGlzIGlzIGEgbWVzcyBhbmQgd2UgbmVlZCB0byBjb21lIGJhY2sgdG8gaXRcbiAgIyBhdCBhIGxhdGVyIHRpbWUuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3NcbiAgICBgT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgc3BsaXQocGF0dGVybiA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW1pdCA9ICN7OjpPcGFsLmNvZXJjZV90byEobGltaXQsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAobGltaXQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gW3NlbGZdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQgfHwgcGF0dGVybiA9PT0gbmlsKSB7XG4gICAgICAgIHBhdHRlcm4gPSAjeyQ7IHx8ICcgJ307XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGksIGlpO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gJGdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHBhdHRlcm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gJyAnKSB7XG4gICAgICAgICAgcGF0dGVybiA9IC9cXHMrL2dtO1xuICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHN0cmluZy5zcGxpdChwYXR0ZXJuKTtcblxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEgJiYgcmVzdWx0WzBdID09PSBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFtyZXN1bHRbMF1dO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKGkgPSByZXN1bHQuaW5kZXhPZih1bmRlZmluZWQpKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0LnNwbGljZShpLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSAwKSB7XG4gICAgICAgIHdoaWxlIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICAgIHJlc3VsdC5sZW5ndGggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHJpbmcpO1xuXG4gICAgICBpZiAobGltaXQgPCAwKSB7XG4gICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaFswXSA9PT0gJycgJiYgcGF0dGVybi5zb3VyY2UuaW5kZXhPZignKD89JykgPT09IC0xKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBtYXRjaC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaFswXSA9PT0gJycpIHtcbiAgICAgICAgcmVzdWx0LnNwbGljZShsaW1pdCAtIDEsIHJlc3VsdC5sZW5ndGggLSAxLCByZXN1bHQuc2xpY2UobGltaXQgLSAxKS5qb2luKCcnKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgICAgaWYgKGkgKyAxID09PSBsaW1pdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXN1bHQuc3BsaWNlKGxpbWl0IC0gMSwgcmVzdWx0Lmxlbmd0aCAtIDEsIHN0cmluZy5zbGljZShpbmRleCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcXVlZXplKCpzZXRzKVxuICAgICV4e1xuICAgICAgaWYgKHNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJlcGxhY2UoLyguKVxcMSsvZywgJyQxJyk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyBjaGFyX2NsYXNzICsgJylcXFxcMSsnLCAnZycpLCAnJDEnKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdGFydF93aXRoPygqcHJlZml4ZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcHJlZml4ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByZWZpeGVzW2ldLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgdmFyIHJlZ2V4cCA9IHByZWZpeGVzW2ldO1xuICAgICAgICAgIHZhciBtYXRjaCA9IHJlZ2V4cC5leGVjKHNlbGYpO1xuXG4gICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwgJiYgbWF0Y2guaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcoYHJlZ2V4cGAsIGBtYXRjaGApfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gJGNvZXJjZV90byhwcmVmaXhlc1tpXSwgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICAgICAgaWYgKHNlbGYuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvXltcXHNcXHUwMDAwXSp8W1xcc1xcdTAwMDBdKiQvZywgJycpYFxuICBlbmRcblxuICBkZWYgc3ViKHBhdHRlcm4sIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoIXBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCwgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICByZXN1bHQgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAjezo6TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGB9XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDEgZm9yIDIpJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBibG9jayhtYXRjaFswXSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50LiQkaXNfaGFzaCkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc30gKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSAkY29lcmNlX3RvKHJlcGxhY2VtZW50LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yZXBsYWNlKC8oW1xcXFxdKykoWzAtOSsmYCddKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIHNsYXNoZXMsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2gubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoWzBdO1xuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyAobWF0Y2hbY29tbWFuZF0gfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIHJlcGxhY2VtZW50ICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdW0obiA9IDE2KVxuICAgICV4e1xuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBzZWxmLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCAmIChNYXRoLnBvdygyLCBuKSAtIDEpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN3YXBjYXNlXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZi5yZXBsYWNlKC8oW2Etel0rKXwoW0EtWl0rKS9nLCBmdW5jdGlvbigkMCwkMSwkMikge1xuICAgICAgICByZXR1cm4gJDEgPyAkMC50b1VwcGVyQ2FzZSgpIDogJDAudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGbG9hdChzZWxmLnJlcGxhY2UoL18vZywgJycpKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdCkgfHwgcmVzdWx0ID09IEluZmluaXR5IHx8IHJlc3VsdCA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19pKGJhc2UgPSAxMClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHJhZGl4ID0gJGNvZXJjZV90byhiYXNlLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHJhZGl4ID09PSAxIHx8IHJhZGl4IDwgMCB8fCByYWRpeCA+IDM2KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tgcmFkaXhgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoL15cXHMqXy8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KSguKykkLywgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4JyAmJiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMikge1xuICAgICAgICAgICAgcmFkaXggPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDgpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDEwKSB7XG4gICAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTYpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFxuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdCA9IHBhcnNlSW50KHN0cmluZy5yZXBsYWNlKC9fKD8hXykvZywgJycpLCByYWRpeCk7XG4gICAgICByZXR1cm4gaXNOYU4ocmVzdWx0KSA/IDAgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIG1ldGhvZF9uYW1lID0gYHNlbGYudmFsdWVPZigpYFxuICAgIGpzaWQgPSBgT3BhbC5qc2lkKG1ldGhvZF9uYW1lKWBcblxuICAgIHByb2MgPSA6Oktlcm5lbC5wcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgZ2l2ZW4nfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3YgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChyZWN2ID09IG51bGwpIHJlY3YgPSBuaWw7XG5cbiAgICAgICAgdmFyIGJvZHkgPSByZWN2W2pzaWRdO1xuXG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgIGJvZHkgPSByZWN2LiRtZXRob2RfbWlzc2luZztcbiAgICAgICAgICBhcmdzWzBdID0gI3ttZXRob2RfbmFtZX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJncyA9IGFyZ3Muc2xpY2UoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYm9keS4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBib2R5LmNhbGwocmVjdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGBwcm9jLiQkc291cmNlX2xvY2F0aW9uID0gbmlsYFxuXG4gICAgcHJvY1xuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiB0cihmcm9tLCB0bylcbiAgICAleHtcbiAgICAgIGZyb20gPSAkY29lcmNlX3RvKGZyb20sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcbiAgICAgIHRvID0gJGNvZXJjZV90byh0bywgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMCB8fCBmcm9tID09PSB0bykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xuICAgICAgdmFyIHN1YnMgPSB7fTtcbiAgICAgIHZhciBmcm9tX2NoYXJzID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICB2YXIgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcbiAgICAgIHZhciB0b19jaGFycyA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG5cbiAgICAgIHZhciBpbnZlcnNlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XG4gICAgICBpZiAoZnJvbV9jaGFyc1swXSA9PT0gJ14nICYmIGZyb21fY2hhcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgZnJvbV9jaGFycy5zaGlmdCgpO1xuICAgICAgICBnbG9iYWxfc3ViID0gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV1cbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgIHZhciBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZnJvbV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpID09IGZyb21fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyb21fY2hhcnMgPSBmcm9tX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcblxuICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0b19sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRvX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICAgICAgdmFyIGxhc3RfdG8gPSBudWxsO1xuICAgICAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHRvX2NoYXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X3RvID0gY2g7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICBpZiAobGFzdF90byA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpID09IHRvX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgICAgICBzdGFydCA9IGxhc3RfdG8uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b19jaGFycyA9IHRvX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgICAgIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IGZyb21fbGVuZ3RoIC0gdG9fbGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoX2RpZmYgPiAwKSB7XG4gICAgICAgICAgdmFyIHBhZF9jaGFyID0gKHRvX2xlbmd0aCA+IDAgPyB0b19jaGFyc1t0b19sZW5ndGggLSAxXSA6ICcnKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoX2RpZmY7IGkrKykge1xuICAgICAgICAgICAgdG9fY2hhcnMucHVzaChwYWRfY2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdG9fY2hhcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5ld19zdHIgPSAnJ1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF07XG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgbmV3X3N0ciArPSAoc3ViID09IG51bGwgPyBnbG9iYWxfc3ViIDogY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiAhPSBudWxsID8gc3ViIDogY2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3X3N0cjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cl9zKGZyb20sIHRvKVxuICAgICV4e1xuICAgICAgZnJvbSA9ICRjb2VyY2VfdG8oZnJvbSwgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuICAgICAgdG8gPSAkY29lcmNlX3RvKHRvLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG5cbiAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaW5fcmFuZ2UsIGMsIGNoLCBzdGFydCwgZW5kLCBsZW5ndGg7XG4gICAgICB2YXIgc3VicyA9IHt9O1xuICAgICAgdmFyIGZyb21fY2hhcnMgPSBmcm9tLnNwbGl0KCcnKTtcbiAgICAgIHZhciBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIHRvX2NoYXJzID0gdG8uc3BsaXQoJycpO1xuICAgICAgdmFyIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcblxuICAgICAgdmFyIGludmVyc2UgPSBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxfc3ViID0gbnVsbDtcbiAgICAgIGlmIChmcm9tX2NoYXJzWzBdID09PSAnXicgJiYgZnJvbV9jaGFycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGludmVyc2UgPSB0cnVlO1xuICAgICAgICBmcm9tX2NoYXJzLnNoaWZ0KCk7XG4gICAgICAgIGdsb2JhbF9zdWIgPSB0b19jaGFyc1t0b19sZW5ndGggLSAxXVxuICAgICAgICBmcm9tX2xlbmd0aCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbV9jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgdmFyIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBmcm9tX2NoYXJzW2ldO1xuICAgICAgICBpZiAobGFzdF9mcm9tID09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICBpZiAobGFzdF9mcm9tID09PSAnLScpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGkgPT0gZnJvbV9sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgc3RhcnQgPSBsYXN0X2Zyb20uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnJvbV9jaGFycyA9IGZyb21fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuXG4gICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRvX2xlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdG9fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgICAgICB2YXIgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoID0gdG9fY2hhcnNbaV07XG4gICAgICAgICAgICBpZiAobGFzdF9mcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICBpZiAobGFzdF90byA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpID09IHRvX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3X3N0ciA9ICcnXG4gICAgICB2YXIgbGFzdF9zdWJzdGl0dXRlID0gbnVsbFxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF1cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICBpZiAoc3ViID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdfc3RyICs9IGdsb2JhbF9zdWI7XG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChzdWIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsIHx8IGxhc3Rfc3Vic3RpdHV0ZSAhPT0gc3ViKSB7XG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gc3ViO1xuICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBzdWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3X3N0cjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1cGNhc2VcbiAgICBgc2VsZi50b1VwcGVyQ2FzZSgpYFxuICBlbmRcblxuICBkZWYgdXB0byhzdG9wLCBleGNsID0gZmFsc2UsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOnVwdG8sIHN0b3AsIGV4Y2wgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgdmFyIGEsIGIsIHMgPSBzZWxmLnRvU3RyaW5nKCk7XG5cbiAgICAgIHN0b3AgPSAkY29lcmNlX3RvKHN0b3AsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChzLmxlbmd0aCA9PT0gMSAmJiBzdG9wLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgIGEgPSBzLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGIgPSBzdG9wLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgd2hpbGUgKGEgPD0gYikge1xuICAgICAgICAgIGlmIChleGNsICYmIGEgPT09IGIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKFN0cmluZy5mcm9tQ2hhckNvZGUoYSkpO1xuXG4gICAgICAgICAgYSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VJbnQocywgMTApLnRvU3RyaW5nKCkgPT09IHMgJiYgcGFyc2VJbnQoc3RvcCwgMTApLnRvU3RyaW5nKCkgPT09IHN0b3ApIHtcblxuICAgICAgICBhID0gcGFyc2VJbnQocywgMTApO1xuICAgICAgICBiID0gcGFyc2VJbnQoc3RvcCwgMTApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhhLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgYSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgd2hpbGUgKHMubGVuZ3RoIDw9IHN0b3AubGVuZ3RoICYmIHMgPD0gc3RvcCkge1xuICAgICAgICAgIGlmIChleGNsICYmIHMgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKHMpO1xuXG4gICAgICAgICAgcyA9ICN7YHNgLnN1Y2N9O1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKSB7XG4gICAgICBmdW5jdGlvbiBleHBsb2RlX3NlcXVlbmNlc19pbl9jaGFyYWN0ZXJfc2V0KHNldCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBpLCBsZW4gPSBzZXQubGVuZ3RoLFxuICAgICAgICAgICAgY3Vycl9jaGFyLFxuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2gsXG4gICAgICAgICAgICBjaGFyX2NvZGVfZnJvbSxcbiAgICAgICAgICAgIGNoYXJfY29kZV91cHRvLFxuICAgICAgICAgICAgY2hhcl9jb2RlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjdXJyX2NoYXIgPSBzZXQuY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChjdXJyX2NoYXIgPT09ICctJyAmJiBpID4gMCAmJiBpIDwgKGxlbiAtIDEpICYmICFza2lwX25leHRfZGFzaCkge1xuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20gPSBzZXQuY2hhckNvZGVBdChpIC0gMSk7XG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byA9IHNldC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChjaGFyX2NvZGVfZnJvbSA+IGNoYXJfY29kZV91cHRvKSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YGNoYXJfY29kZV9mcm9tYH0tI3tgY2hhcl9jb2RlX3VwdG9gfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjaGFyX2NvZGUgPSBjaGFyX2NvZGVfZnJvbSArIDE7IGNoYXJfY29kZSA8IGNoYXJfY29kZV91cHRvICsgMTsgY2hhcl9jb2RlKyspIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcl9jb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2ggPSAoY3Vycl9jaGFyID09PSAnXFxcXCcpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGN1cnJfY2hhcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHNldEEsIHNldEIpIHtcbiAgICAgICAgaWYgKHNldEEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHNldEI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgaSwgbGVuID0gc2V0QS5sZW5ndGgsXG4gICAgICAgICAgICBjaHI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNociA9IHNldEEuY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChzZXRCLmluZGV4T2YoY2hyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBsZW4sIHNldCwgbmVnLCBjaHIsIHRtcCxcbiAgICAgICAgICBwb3NfaW50ZXJzZWN0aW9uID0gJycsXG4gICAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9ICcnO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHNldCA9ICRjb2VyY2VfdG8oc2V0c1tpXSwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgbmVnID0gKHNldC5jaGFyQXQoMCkgPT09ICdeJyAmJiBzZXQubGVuZ3RoID4gMSk7XG4gICAgICAgIHNldCA9IGV4cGxvZGVfc2VxdWVuY2VzX2luX2NoYXJhY3Rlcl9zZXQobmVnID8gc2V0LnNsaWNlKDEpIDogc2V0KTtcbiAgICAgICAgaWYgKG5lZykge1xuICAgICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24obmVnX2ludGVyc2VjdGlvbiwgc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3NfaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uKHBvc19pbnRlcnNlY3Rpb24sIHNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCAmJiBuZWdfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdG1wID0gJyc7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaHIgPSBwb3NfaW50ZXJzZWN0aW9uLmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAobmVnX2ludGVyc2VjdGlvbi5pbmRleE9mKGNocikgPT09IC0xKSB7XG4gICAgICAgICAgICB0bXAgKz0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3NfaW50ZXJzZWN0aW9uID0gdG1wO1xuICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuICdbJyArICN7OjpSZWdleHAuZXNjYXBlKGBwb3NfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnW14nICsgI3s6OlJlZ2V4cC5lc2NhcGUoYG5lZ19pbnRlcnNlY3Rpb25gKX0gKyAnXSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBbXVxuICBlbmRcblxuICBkZWYgc2VsZi5fbG9hZCgqYXJncylcbiAgICBuZXcoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiB1bmljb2RlX25vcm1hbGl6ZShmb3JtID0gOm5mYylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiSW52YWxpZCBub3JtYWxpemF0aW9uIGZvcm0gI3tmb3JtfVwiIHVubGVzcyAlaVtuZmMgbmZkIG5ma2MgbmZrZF0uaW5jbHVkZT8oZm9ybSlcbiAgICBgc2VsZi5ub3JtYWxpemUoI3tmb3JtLnVwY2FzZX0pYFxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemVkPyhmb3JtID0gOm5mYylcbiAgICB1bmljb2RlX25vcm1hbGl6ZShmb3JtKSA9PSBzZWxmXG4gIGVuZFxuXG4gIGRlZiB1bnBhY2soZm9ybWF0KVxuICAgIDo6S2VybmVsLnJhaXNlIFwiVG8gdXNlIFN0cmluZyN1bnBhY2ssIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL3VucGFjaycuXCJcbiAgZW5kXG5cbiAgZGVmIHVucGFjazEoZm9ybWF0KVxuICAgIDo6S2VybmVsLnJhaXNlIFwiVG8gdXNlIFN0cmluZyN1bnBhY2sxLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL3N0cmluZy91bnBhY2snLlwiXG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHNlbGY7IH1cbiAgICAgICRwcm9wKHNlbGYsIFwiJCRmcm96ZW5cIiwgdHJ1ZSk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJykgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi4kJGZyb3plbikgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi5lbmNvZGluZy5uYW1lID09ICdVVEYtOCcgJiYgc2VsZi5pbnRlcm5hbF9lbmNvZGluZy5uYW1lID09ICdVVEYtOCcpIHJldHVybiBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gc2VsZi4kZHVwKCkuJGZyZWV6ZSgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZyb3plbj9cbiAgICBgdHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnIHx8IHNlbGYuJCRmcm96ZW4gPT09IHRydWVgXG4gIGVuZFxuXG4gIGFsaWFzICtAIGR1cFxuICBhbGlhcyA9PT0gPT1cbiAgYWxpYXMgYnl0ZXNsaWNlIFtdXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgZXF1YWw/ID09PVxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG4gIGFsaWFzIHNsaWNlIFtdXG4gIGFsaWFzIHN1Y2MgbmV4dFxuICBhbGlhcyB0b19zdHIgdG9fc1xuICBhbGlhcyB0b19zeW0gaW50ZXJuXG5cbiAgOjpPcGFsLnByaXN0aW5lIHNlbGYsIDppbml0aWFsaXplXG5lbmRcblxuU3ltYm9sID0gU3RyaW5nXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlN0cmluZz4iLCJpbmNsdWRlIiwiQ29tcGFyYWJsZSIsIl9faWRfXyIsInRyeV9jb252ZXJ0Iiwid2hhdCIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiU3RyaW5nIiwibmV3IiwiaW5pdGlhbGl6ZSIsImFyZ3MiLCIlIiwiZGF0YSIsIkFycmF5IiwiZm9ybWF0IiwiKiIsImNvdW50IiwiSW50ZWdlciIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIlJhbmdlRXJyb3IiLCIrIiwib3RoZXIiLCI8PT4iLCJyZXNwb25kX3RvPyIsInRvX3N0ciIsInRvX3MiLCI9PSIsIj1+IiwiVHlwZUVycm9yIiwiW10iLCJpbmRleCIsImxlbmd0aCIsIiR+IiwiTWF0Y2hEYXRhIiwiYiIsImZvcmNlX2VuY29kaW5nIiwiY2FwaXRhbGl6ZSIsImNhc2VjbXAiLCJjYXNlY21wPyIsImNlbnRlciIsIndpZHRoIiwicGFkc3RyIiwiZW1wdHk/IiwibGp1c3QiLCIvIiwiMiIsImNlaWwiLCJyanVzdCIsImZsb29yIiwiY2hvbXAiLCJzZXBhcmF0b3IiLCIkLyIsImNvZXJjZV90byEiLCJjaG9wIiwiY2hyIiwiY2xvbmUiLCIka3dhcmdzIiwiZnJlZXplIiwibmlsPyIsImNsYXNzIiwiY29weSIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJpbml0aWFsaXplX2Nsb25lIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJkZWxldGUiLCJkZWxldGVfcHJlZml4IiwicHJlZml4IiwiZGVsZXRlX3N1ZmZpeCIsInN1ZmZpeCIsImRvd25jYXNlIiwiZWFjaF9saW5lIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJlbmRfd2l0aD8iLCJnc3ViIiwicGF0dGVybiIsInJlcGxhY2VtZW50IiwiaGFzaCIsImhleCIsInRvX2kiLCIxNiIsImluY2x1ZGU/Iiwic2VhcmNoIiwib2Zmc2V0IiwiaW5zcGVjdCIsImludGVybiIsImxpbmVzIiwiZSIsImJsb2NrIiwidG9fcHJvYyIsInRvX2EiLCJsc3RyaXAiLCJhc2NpaV9vbmx5PyIsIm1hdGNoIiwicG9zIiwiUmVnZXhwIiwibWF0Y2g/IiwibmV4dCIsIm9jdCIsIm9yZCIsInBhcnRpdGlvbiIsInNlcCIsInJldmVyc2UiLCJyaW5kZXgiLCJycGFydGl0aW9uIiwicnN0cmlwIiwic2NhbiIsIm5vX21hdGNoZGF0YSIsImNhcHR1cmVzIiwic2luZ2xldG9uX2NsYXNzIiwic3BsaXQiLCJsaW1pdCIsIiRyZXRfb3JfMSIsIiQ7Iiwic3F1ZWV6ZSIsInN0YXJ0X3dpdGg/Iiwic3RyaXAiLCJzdWIiLCJzdW0iLCJuIiwic3dhcGNhc2UiLCJ0b19mIiwiYmFzZSIsIjEwIiwibWV0aG9kX25hbWUiLCJqc2lkIiwicHJvYyIsImJsb2NrIGluIHRvX3Byb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX3Byb2MiLCJ0ciIsImZyb20iLCJ0byIsInRyX3MiLCJ1cGNhc2UiLCJ1cHRvIiwic3RvcCIsImV4Y2wiLCJzdWNjIiwiZXNjYXBlIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiX2xvYWQiLCJ1bmljb2RlX25vcm1hbGl6ZSIsImZvcm0iLCJ1bmljb2RlX25vcm1hbGl6ZWQ/IiwidW5wYWNrIiwidW5wYWNrMSIsIi1AIiwiZnJvemVuPyIsInByaXN0aW5lIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEOztBQUdGRCxjQUFnQkYsSUFBS0U7QUFDckJBOztBQUVFRyxJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxlQUFEQTtJQURGQSxDQUFBQTtJQUlBQyxNQUFJTixJQUFK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QUFBLElBQUFBOztBQUlBQyxJQUFBQSxzQkFBQUEsa0JBQVdySSxNQUFYcUk7QUFBQUE7TUFDRUEsT0FBQWpJLE9BQVFDLE9BQUFBLENBQU9nSSx1RUFBUGhJO0lBRFZnSSxDQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLG1CQUFZdEksTUFBWnNJO0FBQUFBO01BQ0VBLE9BQUFsSSxPQUFRQyxPQUFBQSxDQUFPaUksd0VBQVBqSTtJQURWaUksQ0FBQUE7O0FBSUF6RixJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUE7O0FBUUEwRixJQUFBQSxrQkFBQUEsNEJBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFORUEsQ0FBQUE7O0FBU0FDLElBQUFBLHVCQUFBQSxnQ0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLGtEQUFEQTtJQURGQSxDQUFBQTtJQUlBLGFBQU0sSUFBTixFQUFTLEtBQVQ7SUFDQSxhQUFNLEtBQU4sRUFBVSxJQUFWO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLElBQWhCO0lBQ0EsYUFBTSxNQUFOLEVBQVcsSUFBWDtJQUNBLGFBQU0sUUFBTixFQUFhLEtBQWI7SUFDQSxhQUFNLFdBQU4sRUFBZ0IsUUFBaEI7SUFDQSxhQUFNLE9BQU4sRUFBWSxJQUFaO0lBQ0EsYUFBTSxNQUFOLEVBQVcsTUFBWDtJQUNBLGFBQU0sUUFBTixFQUFhLE1BQWI7SUFDQSxhQUFNLFFBQU4sRUFBYSxRQUFiO0lBRUF2SixPQUFBTSxLQUFNa0osVUFBQUEsQ0FBVTFKLElBQWhCLEVBQXNCLFlBQWhCMEo7RUF6MURSeEosR0FBTSxJQUFOQSxFQUFrQkgsTUFBbEJHO0VBNDFEQUgsT0FBQSxrQ0FBU1csWUFBVDtBQWoyREFYOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo5MzkwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG8sIHlpZWxkMSwgeWllbGRYLCBkZW55X2Zyb3plbl9hY2Nlc3NcblxubW9kdWxlIDo6RW51bWVyYWJsZVxuICAleHtcbiAgICBmdW5jdGlvbiBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YWx1ZSA9IFtuaWxdO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBkZWYgYWxsPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIHVubGVzcyB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICB1bmxlc3MgOjpPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIHRydWUgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIDo6T3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIGNodW5rKCZibG9jaylcbiAgICByZXR1cm4gdG9fZW51bSg6Y2h1bmspIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBuaWwsIGFjY3VtdWxhdGUgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiByZWxlYXNlQWNjdW11bGF0ZSgpIHtcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHByZXZpb3VzYCwgYGFjY3VtdWxhdGVgKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGtleSA9ICR5aWVsZDEoYmxvY2ssIHZhbHVlKTtcblxuICAgICAgICAgIGlmIChrZXkgPT09IG5pbCkge1xuICAgICAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbXTtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbmlsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMgPT09IG5pbCB8fCBwcmV2aW91cyA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldmlvdXMgPSBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjaHVua193aGlsZSgmYmxvY2spXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNsaWNlX3doZW4geyB8YmVmb3JlLCBhZnRlcnwgISh5aWVsZCBiZWZvcmUsIGFmdGVyKSB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3RfY29uY2F0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICBtYXAoJmJsb2NrKS5mbGF0dGVuKDEpXG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgdG9fYS5jb21wYWN0XG4gIGVuZFxuXG4gIGRlZiBjb3VudChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXN1bHQgPSAwXG5cbiAgICAleHtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG8gfCphcmdzfFxuICAgICAgICA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqZWN0XG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9jay5uaWw/XG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgeyB0cnVlIH1cbiAgICBlbmRcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgYHJlc3VsdCsrYCBpZiBgJHlpZWxkWChibG9jaywgYXJncylgXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGN5Y2xlKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmN5Y2xlLCBuKSBkb1xuICAgICAgICBpZiBuLm5pbD9cbiAgICAgICAgICByZXNwb25kX3RvPyg6c2l6ZSkgPyA6OkZsb2F0OjpJTkZJTklUWSA6IG5pbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgICBuID4gMCA/IGVudW1lcmF0b3Jfc2l6ZSAqIG4gOiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICBuID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAgIHJldHVybiBpZiBgbiA8PSAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgYWxsID0gW10sIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBhbGwucHVzaChwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKGFsbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRldGVjdChpZm5vbmUgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmRldGVjdCwgaWZub25lIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAgIGlmIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaWZub25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihpZm5vbmUpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGlmbm9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpZm5vbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGRyb3AobnVtYmVyKVxuICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgbnVtYmVyIDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ICA9IFtdLFxuICAgICAgICAgIGN1cnJlbnQgPSAwO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobnVtYmVyIDw9IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQrKztcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZHJvcF93aGlsZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgICA9IFtdLFxuICAgICAgICAgIGRyb3BwaW5nID0gdHJ1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBpZiAoZHJvcHBpbmcpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgICBpZiAoISR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICBkcm9wcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NvbnMobiwgJmJsb2NrKVxuICAgIGlmIGBhcmd1bWVudHMubGVuZ3RoICE9IDFgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAxKVwiXG4gICAgZW5kXG5cbiAgICBuID0gOjpPcGFsLnRyeV9jb252ZXJ0IG4sIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2l6ZSdcbiAgICBlbmRcblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jb25zLCBuKSBkb1xuICAgICAgICBlbnVtX3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgICAgaWYgZW51bV9zaXplLm5pbD9cbiAgICAgICAgICBuaWxcbiAgICAgICAgZWxzaWYgZW51bV9zaXplID09IDAgfHwgZW51bV9zaXplIDwgblxuICAgICAgICAgIDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW1fc2l6ZSAtIG4gKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBidWZmZXIgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICBidWZmZXIucHVzaChlbGVtZW50KTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiBuKSB7XG4gICAgICAgICAgYnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbikge1xuICAgICAgICAgICR5aWVsZDEoYmxvY2ssIGJ1ZmZlci5zbGljZSgwLCBuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2VudHJ5KCpkYXRhLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIHRvX2VudW0oOmVhY2hfZW50cnksICpkYXRhKSB7IGVudW1lcmF0b3Jfc2l6ZSB9XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAkeWllbGQxKGJsb2NrLCBpdGVtKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBkYXRhKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9zbGljZShuLCAmYmxvY2spXG4gICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2xpY2Ugc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9zbGljZSwgbikgeyByZXNwb25kX3RvPyg6c2l6ZSkgPyAoc2l6ZSAvIG4pLmNlaWwgOiBuaWwgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBzbGljZSA9IFtdXG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA9PT0gbikge1xuICAgICAgICAgICR5aWVsZDEoYmxvY2ssIHNsaWNlKTtcbiAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIC8vIG91ciBcImxhc3RcIiBncm91cCwgaWYgc21hbGxlciB0aGFuIG4gdGhlbiB3b24ndCBoYXZlIGJlZW4geWllbGRlZFxuICAgICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9pbmRleCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX2luZGV4LCAqYXJncykgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfb2JqZWN0KG9iamVjdCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX29iamVjdCwgb2JqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgb2JqZWN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcbiAgICB9XG5cbiAgICBvYmplY3RcbiAgZW5kXG5cbiAgZGVmIGVudHJpZXMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0pO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaWx0ZXJfbWFwKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmZpbHRlcl9tYXApIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgbWFwKCZibG9jaykuc2VsZWN0KCY6aXRzZWxmKVxuICBlbmRcblxuICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmluZF9hbGwpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaW5kX2luZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZmluZF9pbmRleCBpZiBgb2JqZWN0ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gMFxuXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpID09IG9iamVjdFxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChudW1iZXIgPSB1bmRlZmluZWQpXG4gICAgaWYgYG51bWJlciA9PT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8dmFsdWV8XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgcmVzdWx0ID0gW11cbiAgICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgIGlmIGBudW1iZXIgPCAwYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbnVtYmVyID09IDBgXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnQgPSAwXG5cbiAgICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgICBgcmVzdWx0LnB1c2goI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9KWBcblxuICAgICAgICBpZiBgbnVtYmVyIDw9ICsrY3VycmVudGBcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IHVubGVzcyBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXG4gICAgICBlbHNpZiB2YWx1ZS5sZW5ndGggPD0gMVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGdyZXBfdihwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IGlmIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JvdXBfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Z3JvdXBfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaGFzaCA9IHt9XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAjeyhoYXNoW2B2YWx1ZWBdIHx8PSBbXSkgPDwgYHBhcmFtYH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaFxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8ob2JqKVxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaWYgOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9ialxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5qZWN0KG9iamVjdCA9IHVuZGVmaW5lZCwgc3ltID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gJHlpZWxkWChibG9jaywgW3Jlc3VsdCwgdmFsdWVdKTtcblxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICghI3s6OlN5bWJvbCA9PT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje29iamVjdC5pbnNwZWN0fSBpcyBub3QgYSBTeW1ib2xcIn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3ltICAgID0gb2JqZWN0O1xuICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gI3tgcmVzdWx0YC5fX3NlbmRfXyBzeW0sIGB2YWx1ZWB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxhenlcbiAgICA6OkVudW1lcmF0b3I6OkxhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVudW1lcmF0b3Jfc2l6ZVxuICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IHNpemUgOiBuaWxcbiAgZW5kXG5cbiAgZGVmIG1heChuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAobiA9PT0gdW5kZWZpbmVkIHx8IG4gPT09IG5pbCkge1xuICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBbaXRlbSwgcmVzdWx0XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gI3tgaXRlbWAgPD0+IGByZXN1bHRgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuID0gJGNvZXJjZV90byhuLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG5cbiAgICBzb3J0KCZibG9jaykucmV2ZXJzZS5maXJzdChuKVxuICBlbmRcblxuICBkZWYgbWF4X2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1heF9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykucmV2ZXJzZS50YWtlIG5cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPD0+IGBieWB9ID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtXG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbihuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHJldHVybiBzb3J0IHsgfGEsIGJ8IHlpZWxkIGEsIGIgfS50YWtlIG5cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHNvcnQudGFrZSBuXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBibG9jayhwYXJhbSwgcmVzdWx0KTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCN7OjpPcGFsLmNvbXBhcmUoYHBhcmFtYCwgYHJlc3VsdGApfSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWluX2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbl9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykudGFrZSBuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgYnk7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgIDw9PiBgYnlgfSA8IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5tYXgoJmJsb2NrKVxuICAgIGJsb2NrIHx8PSA6Oktlcm5lbC5wcm9jIHsgfGEsIGJ8IGEgPD0+IGIgfVxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gbmlsLCBtYXggPSBuaWwsIGZpcnN0X3RpbWUgPSB0cnVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIGlmIChmaXJzdF90aW1lKSB7XG4gICAgICAgICAgbWluID0gbWF4ID0gZWxlbWVudDtcbiAgICAgICAgICBmaXJzdF90aW1lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pbl9jbXAgPSAje2Jsb2NrLmNhbGwoYG1pbmAsIGBlbGVtZW50YCl9O1xuXG4gICAgICAgICAgaWYgKG1pbl9jbXAgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5fY21wID4gMCkge1xuICAgICAgICAgICAgbWluID0gZWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbWF4X2NtcCA9ICN7YmxvY2suY2FsbChgbWF4YCwgYGVsZW1lbnRgKX07XG5cbiAgICAgICAgICBpZiAobWF4X2NtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1heF9jbXAgPCAwKSB7XG4gICAgICAgICAgICBtYXggPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbm1heF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5tYXhfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW5fcmVzdWx0ID0gbmlsLFxuICAgICAgICAgIG1heF9yZXN1bHQgPSBuaWwsXG4gICAgICAgICAgbWluX2J5LFxuICAgICAgICAgIG1heF9ieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgobWluX2J5ID09PSB1bmRlZmluZWQpIHx8ICN7YHZhbHVlYCA8PT4gYG1pbl9ieWB9IDwgMCkge1xuICAgICAgICAgIG1pbl9yZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBtaW5fYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG1heF9ieSA9PT0gdW5kZWZpbmVkKSB8fCAje2B2YWx1ZWAgPD0+IGBtYXhfYnlgfSA+IDApIHtcbiAgICAgICAgICBtYXhfcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgbWF4X2J5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbbWluX3Jlc3VsdCwgbWF4X3Jlc3VsdF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbm9uZT8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGl0ZW0gPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgb25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgY291bnQgPSAwXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICByZXR1cm4gZmFsc2UgaWYgY291bnQgPiAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIG5leHQgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgOjpPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjb3VudCA9PSAxXG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cGFydGl0aW9uKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHRydXRoeSA9IFtdLCBmYWxzeSA9IFtdLCByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICB0cnV0aHkucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmFsc3kucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCEkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXZlcnNlX2VhY2gpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgJHlpZWxkWChibG9jaywgcmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzbGljZV9iZWZvcmUocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICA6OkVudW1lcmF0b3IubmV3IGRvIHxlfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmxvY2socGFyYW0sICN7cGF0dGVybi5kdXB9KTtcblxuICAgICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkgJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2VfYWZ0ZXIocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIHsgfGV8IHBhdHRlcm4gPT09IGUgfVxuICAgIGVuZFxuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgYWNjdW11bGF0ZTtcblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgZW5kX2NodW5rID0gJHlpZWxkMShibG9jaywgZWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCR0cnV0aHkoZW5kX2NodW5rKSkge1xuICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBhY2N1bXVsYXRlYCl9O1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAoYWNjdW11bGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBhY2N1bXVsYXRlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzbGljZV93aGVuKCZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKScgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBuaWwsIGxhc3RfYWZ0ZXIgPSBuaWw7XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbXMgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICBiZWZvcmUgPSBwYXJhbXNbMF0sXG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyYW1zWzFdLFxuICAgICAgICAgICAgICBtYXRjaCA9ICR5aWVsZFgoYmxvY2ssIFtiZWZvcmUsIGFmdGVyXSk7XG5cbiAgICAgICAgICBsYXN0X2FmdGVyID0gYWZ0ZXI7XG5cbiAgICAgICAgICBpZiAoc2xpY2UgPT09IG5pbCkge1xuICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShtYXRjaCkpIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zKDIpO1xuXG4gICAgICAgIGlmIChzbGljZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2xpY2UucHVzaChsYXN0X2FmdGVyKTtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICBhcnkgPSB0b19hXG4gICAgYmxvY2sgPSAtPihhLCBiKSB7IGEgPD0+IGIgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgYXJ5LnNvcnQoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc29ydF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGR1cCA9IG1hcCBkb1xuICAgICAgYXJnID0gOjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKVxuICAgICAgW3lpZWxkKGFyZyksIGFyZ11cbiAgICBlbmRcbiAgICBkdXAuc29ydCEgeyB8YSwgYnwgYGFbMF1gIDw9PiBgYlswXWAgfVxuICAgIGR1cC5tYXAhIHsgfGl8IGBpWzFdYCB9XG4gIGVuZFxuXG4gICMgVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgS2FoYW4gc3VtbWF0aW9uIGFsZ29yaXRobSBpZiBpdCBpcyBwb3NzaWJsZSB0byBhcHBseSBvbmUuXG4gIGRlZiBzdW0oaW5pdGlhbCA9IDApXG4gICAgcmVzdWx0ID0gaW5pdGlhbFxuICAgIGNvbXBlbnNhdGlvbiA9IDBcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaXRlbSA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgeWllbGQoKmFyZ3MpXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG4gICAgICAgICAgICAgZW5kXG5cbiAgICAgIGlmICFbOjpGbG9hdDo6SU5GSU5JVFksIC06OkZsb2F0OjpJTkZJTklUWV0uaW5jbHVkZT8oaXRlbSkgJiYgaXRlbS5yZXNwb25kX3RvPyg6LSlcbiAgICAgICAgeSA9IGl0ZW0gLSBjb21wZW5zYXRpb25cbiAgICAgICAgdCA9IHJlc3VsdCArIHlcbiAgICAgICAgY29tcGVuc2F0aW9uID0gKHQgLSByZXN1bHQpIC0geVxuICAgICAgICByZXN1bHQgPSB0XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdCArPSBpdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdGFrZShudW0pXG4gICAgZmlyc3QobnVtKVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp0YWtlX3doaWxlIHVubGVzcyBibG9ja1xuXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcblxuICAgICAgdW5sZXNzIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICBlbmRcblxuICAgICAgYHJlc3VsdC5wdXNoKHZhbHVlKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHVuaXEoJmJsb2NrKVxuICAgIGhhc2ggPSB7fVxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuXG4gICAgICBwcm9kdWNlZCA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgICAgIHlpZWxkKHZhbHVlKVxuICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIHVubGVzcyBoYXNoLmtleT8ocHJvZHVjZWQpXG4gICAgICAgIGhhc2hbcHJvZHVjZWRdID0gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaGFzaC52YWx1ZXNcbiAgZW5kXG5cbiAgZGVmIHRhbGx5KGhhc2ggPSB1bmRlZmluZWQpXG4gICAgYGlmIChoYXNoICYmIGhhc2ggIT09IG5pbCkgeyAkZGVueV9mcm96ZW5fYWNjZXNzKGhhc2gpOyB9YFxuXG4gICAgb3V0ID0gZ3JvdXBfYnkoJjppdHNlbGYpLnRyYW5zZm9ybV92YWx1ZXMoJjpjb3VudClcbiAgICBpZiBoYXNoXG4gICAgICBvdXQuZWFjaCB7IHxrLCB2fCBoYXNoW2tdID0gaGFzaC5mZXRjaChrLCAwKSArIHYgfVxuICAgICAgaGFzaFxuICAgIGVsc2VcbiAgICAgIG91dFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9faCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oKCphcmdzKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgdmFyIGFyeSA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYHBhcmFtYCwgOjpBcnJheSwgOnRvX2FyeSl9LCBrZXksIHZhbDtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgZWxlbWVudCB0eXBlICN7YGFyeWAuY2xhc3N9IChleHBlY3RlZCBhcnJheSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJ5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIGFycmF5IGxlbmd0aCAoZXhwZWN0ZWQgMiwgd2FzICN7YGFyeWAubGVuZ3RofSlcIn1cbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBhcnlbMF07XG4gICAgICAgIHZhbCA9IGFyeVsxXTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX3NldChrbGFzcyA9IFNldCwgKmFyZ3MsICZibG9jaylcbiAgICBrbGFzcy5uZXcoc2VsZiwgKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXG4gICAgdG9fYS56aXAoKm90aGVycylcbiAgZW5kXG5cbiAgYWxpYXMgZmluZCBkZXRlY3RcbiAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXG4gIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG4gIGFsaWFzIG1hcCBjb2xsZWN0XG4gIGFsaWFzIG1lbWJlcj8gaW5jbHVkZT9cbiAgYWxpYXMgcmVkdWNlIGluamVjdFxuICBhbGlhcyBzZWxlY3QgZmluZF9hbGxcbiAgYWxpYXMgdG9fYSBlbnRyaWVzXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpFbnVtZXJhYmxlPiIsImFsbD8iLCJwYXR0ZXJuIiwiZWFjaCIsInNlbGYiLCJibG9jayBpbiBhbGw/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbGw/IiwiY29tcGFyYWJsZSIsInB1YmxpY19zZW5kIiwiYmxvY2tfZ2l2ZW4/IiwidmFsdWUiLCJPcGFsIiwiZGVzdHJ1Y3R1cmUiLCJhbnk/IiwiYmxvY2sgaW4gYW55PyIsImJsb2NrICgyIGxldmVscykgaW4gYW55PyIsImNodW5rIiwidG9fZW51bSIsImJsb2NrIGluIGNodW5rIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjaHVuayIsImVudW1lcmF0b3Jfc2l6ZSIsIm5ldyIsIkVudW1lcmF0b3IiLCJ5aWVsZGVyIiwieWllbGQiLCJjaHVua193aGlsZSIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInNsaWNlX3doZW4iLCJibG9jayBpbiBjaHVua193aGlsZSIsImJlZm9yZSIsImFmdGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjaHVua193aGlsZSIsIiEiLCJjb2xsZWN0IiwiZW51bV9mb3IiLCJibG9jayBpbiBjb2xsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0IiwiY29sbGVjdF9jb25jYXQiLCJibG9jayBpbiBjb2xsZWN0X2NvbmNhdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdF9jb25jYXQiLCJtYXAiLCJibG9jayIsInRvX3Byb2MiLCJmbGF0dGVuIiwiMSIsImNvbXBhY3QiLCJ0b19hIiwiY291bnQiLCJvYmplY3QiLCJyZXN1bHQiLCIwIiwid2FybiIsInByb2MiLCJibG9jayBpbiBjb3VudCIsImJsb2NrICgyIGxldmVscykgaW4gY291bnQiLCJhcmdzIiwiPT0iLCJuaWw/IiwiY3ljbGUiLCJuIiwiYmxvY2sgaW4gY3ljbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGN5Y2xlIiwicmVzcG9uZF90bz8iLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiPiIsIioiLCJkZXRlY3QiLCJpZm5vbmUiLCJibG9jayBpbiBkZXRlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGRldGVjdCIsImRyb3AiLCJudW1iZXIiLCJkcm9wX3doaWxlIiwiZWFjaF9jb25zIiwidHJ5X2NvbnZlcnQiLCJibG9jayBpbiBlYWNoX2NvbnMiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfY29ucyIsImVudW1fc2l6ZSIsIjwiLCIrIiwiLSIsImVhY2hfZW50cnkiLCJkYXRhIiwiYmxvY2sgaW4gZWFjaF9lbnRyeSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9lbnRyeSIsImVhY2hfc2xpY2UiLCJibG9jayBpbiBlYWNoX3NsaWNlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3NsaWNlIiwiLyIsInNpemUiLCJjZWlsIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3dpdGhfaW5kZXgiLCJlYWNoX3dpdGhfb2JqZWN0IiwiYmxvY2sgaW4gZWFjaF93aXRoX29iamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF93aXRoX29iamVjdCIsImVudHJpZXMiLCJmaWx0ZXJfbWFwIiwiYmxvY2sgaW4gZmlsdGVyX21hcCIsImJsb2NrICgyIGxldmVscykgaW4gZmlsdGVyX21hcCIsInNlbGVjdCIsImZpbmRfYWxsIiwiYmxvY2sgaW4gZmluZF9hbGwiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbmRfYWxsIiwiZmluZF9pbmRleCIsImluZGV4IiwiYmxvY2sgaW4gZmluZF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gZmluZF9pbmRleCIsImZpcnN0IiwiYmxvY2sgaW4gZmlyc3QiLCJjdXJyZW50IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaXJzdCIsImdyZXAiLCJibG9jayBpbiBncmVwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBncmVwIiwiY21wIiwiX19zZW5kX18iLCJsZW5ndGgiLCI8PSIsIltdIiwicHVzaCIsImdyZXBfdiIsImJsb2NrIGluIGdyZXBfdiIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcF92IiwiZ3JvdXBfYnkiLCJibG9jayBpbiBncm91cF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gZ3JvdXBfYnkiLCJoYXNoIiwiJHJldF9vcl8xIiwiW109IiwiPDwiLCJpbmNsdWRlPyIsIm9iaiIsImJsb2NrIGluIGluY2x1ZGU/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbmNsdWRlPyIsImluamVjdCIsInN5bSIsIlN5bWJvbCIsIj09PSIsIlR5cGVFcnJvciIsImluc3BlY3QiLCJsYXp5IiwiRW51bWVyYXRvcjo6TGF6eSIsImJsb2NrIGluIGxhenkiLCJlbnVtJCIsImJsb2NrICgyIGxldmVscykgaW4gbGF6eSIsIm1heCIsIjw9PiIsInNvcnQiLCJyZXZlcnNlIiwibWF4X2J5IiwiYmxvY2sgaW4gbWF4X2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtYXhfYnkiLCJzb3J0X2J5IiwidGFrZSIsIm1pbiIsImJsb2NrIGluIG1pbiIsImEiLCJiIiwiY29tcGFyZSIsIm1pbl9ieSIsImJsb2NrIGluIG1pbl9ieSIsImJsb2NrICgyIGxldmVscykgaW4gbWluX2J5IiwibWlubWF4IiwiYmxvY2sgaW4gbWlubWF4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW5tYXgiLCJjYWxsIiwibWlubWF4X2J5IiwiYmxvY2sgaW4gbWlubWF4X2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW5tYXhfYnkiLCJub25lPyIsImJsb2NrIGluIG5vbmU/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBub25lPyIsIml0ZW0iLCJvbmU/IiwiYmxvY2sgaW4gb25lPyIsImJsb2NrICgyIGxldmVscykgaW4gb25lPyIsInBhcnRpdGlvbiIsImJsb2NrIGluIHBhcnRpdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcGFydGl0aW9uIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXZlcnNlX2VhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHJldmVyc2VfZWFjaCIsInNsaWNlX2JlZm9yZSIsImJsb2NrIGluIHNsaWNlX2JlZm9yZSIsImUiLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWNlX2JlZm9yZSIsImR1cCIsInNsaWNlX2FmdGVyIiwiYmxvY2sgaW4gc2xpY2VfYWZ0ZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWNlX2FmdGVyIiwiYmxvY2sgaW4gc2xpY2Vfd2hlbiIsImJsb2NrICgyIGxldmVscykgaW4gc2xpY2Vfd2hlbiIsImFyeSIsImJsb2NrIGluIHNvcnQiLCJibG9jayAoMiBsZXZlbHMpIGluIHNvcnQiLCJibG9jayBpbiBzb3J0X2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0X2J5IiwiYXJnIiwic29ydCEiLCJtYXAhIiwiaSIsInN1bSIsImluaXRpYWwiLCJjb21wZW5zYXRpb24iLCJibG9jayBpbiBzdW0iLCJibG9jayAoMiBsZXZlbHMpIGluIHN1bSIsIi1AIiwieSIsInQiLCJudW0iLCJ0YWtlX3doaWxlIiwiYmxvY2sgaW4gdGFrZV93aGlsZSIsImJsb2NrICgyIGxldmVscykgaW4gdGFrZV93aGlsZSIsInVuaXEiLCJibG9jayBpbiB1bmlxIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB1bmlxIiwicHJvZHVjZWQiLCJrZXk/IiwidmFsdWVzIiwidGFsbHkiLCJvdXQiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwiYmxvY2sgaW4gdGFsbHkiLCJrIiwidiIsImJsb2NrICgyIGxldmVscykgaW4gdGFsbHkiLCJmZXRjaCIsInRvX2giLCJjb2VyY2VfdG8/IiwiQXJyYXkiLCJjbGFzcyIsInRvX3NldCIsIlNldCIsImtsYXNzIiwiemlwIiwib3RoZXJzIl0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7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QUFBQTs7O01BMXZDRjtNQTB2Q1U7TUFDTkEsT0FBSUEsTUFBSmhQLElBQUE0QyxNQUFBQSxDQUFBQSxDQUFJb00sT0FBQUEsRUFBSyxNQUFDQyxNQUFELENBQUxEO0lBRE5BLENBQUFBLElBQUFBO0lBSUEsYUFBTSxNQUFOLEVBQVcsUUFBWDtJQUNBLGFBQU0sUUFBTixFQUFhLFVBQWI7SUFDQSxhQUFNLFVBQU4sRUFBZSxnQkFBZjtJQUNBLGFBQU0sS0FBTixFQUFVLFNBQVY7SUFDQSxhQUFNLFNBQU4sRUFBYyxVQUFkO0lBQ0EsYUFBTSxRQUFOLEVBQWEsUUFBYjtJQUNBLGFBQU0sUUFBTixFQUFhLFVBQWI7SUFDQXBQLE9BQUEsYUFBTSxNQUFOLEVBQVcsU0FBWDtFQW53Q0ZBLEdBQU8sSUFBUEE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMTcyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL2FyaXRobWV0aWNfc2VxdWVuY2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpFbnVtZXJhdG9yXG4gIGNsYXNzIHNlbGY6OkFyaXRobWV0aWNTZXF1ZW5jZSA8IHNlbGZcbiAgICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2FyaXRobWV0aWNfc2VxJywgdHJ1ZSlgXG5cbiAgICBgdmFyIGluZiA9IEluZmluaXR5YFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBpbml0aWFsaXplKHJhbmdlLCBzdGVwID0gdW5kZWZpbmVkLCBjcmVhdGlvbl9tZXRob2QgPSA6c3RlcClcbiAgICAgIEBjcmVhdGlvbl9tZXRob2QgPSBjcmVhdGlvbl9tZXRob2RcbiAgICAgIGlmIHJhbmdlLmlzX2E/IDo6QXJyYXlcbiAgICAgICAgQHN0ZXBfYXJnMSwgQHN0ZXBfYXJnMiwgQHRvcGZ4LCBAYnlwZnggPSAqcmFuZ2VcbiAgICAgICAgQHJlY2VpdmVyX251bSA9IHN0ZXBcbiAgICAgICAgQHN0ZXAgPSAxXG5cbiAgICAgICAgQHJhbmdlID0gaWYgQHN0ZXBfYXJnMlxuICAgICAgICAgICAgICAgICAgIEBzdGVwID0gQHN0ZXBfYXJnMlxuICAgICAgICAgICAgICAgICAgIChAcmVjZWl2ZXJfbnVtLi5Ac3RlcF9hcmcxKVxuICAgICAgICAgICAgICAgICBlbHNpZiBAc3RlcF9hcmcxXG4gICAgICAgICAgICAgICAgICAgKEByZWNlaXZlcl9udW0uLkBzdGVwX2FyZzEpXG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAoQHJlY2VpdmVyX251bS4ubmlsKVxuICAgICAgICAgICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgQHNraXBwZWRfYXJnID0gdHJ1ZSB1bmxlc3Mgc3RlcFxuICAgICAgICBAcmFuZ2UsIEBzdGVwID0gcmFuZ2UsIHN0ZXAgfHwgMVxuICAgICAgZW5kXG5cbiAgICAgIEBvYmplY3QgPSBzZWxmXG5cbiAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCIgaWYgQHN0ZXAgPT0gMFxuICAgICAgdW5sZXNzIEBzdGVwLnJlc3BvbmRfdG8/IDp0b19pbnRcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgQXJndW1lbnRFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7QHN0ZXAuY2xhc3N9IFwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbnRvIEludGVnZXInXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGF0dHJfcmVhZGVyIDpzdGVwXG5cbiAgICBkZWYgYmVnaW5cbiAgICAgIEByYW5nZS5iZWdpblxuICAgIGVuZFxuXG4gICAgZGVmIGVuZFxuICAgICAgQHJhbmdlLmVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGV4Y2x1ZGVfZW5kP1xuICAgICAgQHJhbmdlLmV4Y2x1ZGVfZW5kP1xuICAgIGVuZFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBfbGVzc2VyX3RoYW5fZW5kPyh2YWwpXG4gICAgICBlbmRfID0gc2VsZi5lbmQgfHwgYGluZmBcbiAgICAgIGlmIHN0ZXAgPiAwXG4gICAgICAgIGV4Y2x1ZGVfZW5kPyA/IHZhbCA8IGVuZF8gOiB2YWwgPD0gZW5kX1xuICAgICAgZWxzZVxuICAgICAgICBleGNsdWRlX2VuZD8gPyB2YWwgPiBlbmRfIDogdmFsID49IGVuZF9cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBfZ3JlYXRlcl90aGFuX2JlZ2luPyh2YWwpXG4gICAgICBiZWdpbl8gPSBzZWxmLmJlZ2luIHx8IC1gaW5mYFxuICAgICAgaWYgc3RlcCA+IDBcbiAgICAgICAgdmFsID4gYmVnaW5fXG4gICAgICBlbHNlXG4gICAgICAgIHZhbCA8IGJlZ2luX1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZmlyc3QoY291bnQgPSB1bmRlZmluZWQpXG4gICAgICBpdGVyID0gc2VsZi5iZWdpbiB8fCAtYGluZmBcblxuICAgICAgcmV0dXJuIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpID8gaXRlciA6IG5pbCB1bmxlc3MgY291bnRcblxuICAgICAgb3V0ID0gW11cblxuICAgICAgd2hpbGUgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcikgJiYgY291bnQgPiAwXG4gICAgICAgIG91dCA8PCBpdGVyXG4gICAgICAgIGl0ZXIgKz0gc3RlcFxuICAgICAgICBjb3VudCAtPSAxXG4gICAgICBlbmRcblxuICAgICAgb3V0XG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgmYmxvY2spXG4gICAgICByZXR1cm4gc2VsZiB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAgIGNhc2Ugc2VsZi5iZWdpblxuICAgICAgd2hlbiBuaWxcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgVHlwZUVycm9yLCBcIm5pbCBjYW4ndCBiZSBjb2VyY2VkIGludG8gSW50ZWdlclwiXG4gICAgICBlbmRcblxuICAgICAgaXRlciA9IHNlbGYuYmVnaW4gfHwgLWBpbmZgXG5cbiAgICAgIHdoaWxlIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpXG4gICAgICAgIHlpZWxkIGl0ZXJcbiAgICAgICAgaXRlciArPSBzdGVwXG4gICAgICBlbmRcbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBsYXN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICAgY2FzZSBzZWxmLmVuZFxuICAgICAgd2hlbiBgaW5mYCwgLWBpbmZgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgc2VsZi5lbmRcbiAgICAgIHdoZW4gbmlsXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBlbmRsZXNzIGFyaXRobWV0aWMgc2VxdWVuY2UnXG4gICAgICBlbmRcblxuICAgICAgaXRlciA9IHNlbGYuZW5kIC0gKChzZWxmLmVuZCAtIHNlbGYuYmVnaW4pICUgc3RlcClcbiAgICAgIGl0ZXIgLT0gc3RlcCB1bmxlc3MgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcilcblxuICAgICAgcmV0dXJuIF9ncmVhdGVyX3RoYW5fYmVnaW4/KGl0ZXIpID8gaXRlciA6IG5pbCB1bmxlc3MgY291bnRcblxuICAgICAgb3V0ID0gW11cblxuICAgICAgd2hpbGUgX2dyZWF0ZXJfdGhhbl9iZWdpbj8oaXRlcikgJiYgY291bnQgPiAwXG4gICAgICAgIG91dCA8PCBpdGVyXG4gICAgICAgIGl0ZXIgLT0gc3RlcFxuICAgICAgICBjb3VudCAtPSAxXG4gICAgICBlbmRcblxuICAgICAgb3V0LnJldmVyc2VcbiAgICBlbmRcblxuICAgIGRlZiBzaXplXG4gICAgICBzdGVwX3NpZ24gPSBzdGVwID4gMCA/IDEgOiAtMVxuXG4gICAgICBpZiAhX2xlc3Nlcl90aGFuX2VuZD8oc2VsZi5iZWdpbilcbiAgICAgICAgMFxuICAgICAgZWxzaWYgWy1gaW5mYCwgYGluZmBdLmluY2x1ZGU/KHN0ZXApXG4gICAgICAgIDFcbiAgICAgIGVsc2lmIFstYGluZmAgKiBzdGVwX3NpZ24sIG5pbF0uaW5jbHVkZT8oc2VsZi5iZWdpbikgfHxcbiAgICAgICAgICAgIFtgaW5mYCAqIHN0ZXBfc2lnbiwgbmlsXS5pbmNsdWRlPyhzZWxmLmVuZClcbiAgICAgICAgYGluZmBcbiAgICAgIGVsc2VcbiAgICAgICAgaXRlciA9IHNlbGYuZW5kIC0gKChzZWxmLmVuZCAtIHNlbGYuYmVnaW4pICUgc3RlcClcbiAgICAgICAgaXRlciAtPSBzdGVwIHVubGVzcyBfbGVzc2VyX3RoYW5fZW5kPyhpdGVyKVxuICAgICAgICAoKGl0ZXIgLSBzZWxmLmJlZ2luKSAvIHN0ZXApLmFicy50b19pICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgPT0ob3RoZXIpXG4gICAgICBzZWxmLmNsYXNzID09IG90aGVyLmNsYXNzICYmXG4gICAgICAgIHNlbGYuYmVnaW4gPT0gb3RoZXIuYmVnaW4gJiZcbiAgICAgICAgc2VsZi5lbmQgPT0gb3RoZXIuZW5kICYmXG4gICAgICAgIHN0ZXAgPT0gb3RoZXIuc3RlcCAmJlxuICAgICAgICBleGNsdWRlX2VuZD8gPT0gb3RoZXIuZXhjbHVkZV9lbmQ/XG4gICAgZW5kXG5cbiAgICBkZWYgaGFzaFxuICAgICAgW3NlbGYuYmVnaW4sIHNlbGYuZW5kLCBzdGVwLCBleGNsdWRlX2VuZD9dLmhhc2hcbiAgICBlbmRcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBpZiBAcmVjZWl2ZXJfbnVtXG4gICAgICAgIGFyZ3MgPSBpZiBAc3RlcF9hcmcyXG4gICAgICAgICAgICAgICAgIFwiKCN7QHRvcGZ4fSN7QHN0ZXBfYXJnMS5pbnNwZWN0fSwgI3tAYnlwZnh9I3tAc3RlcF9hcmcyLmluc3BlY3R9KVwiXG4gICAgICAgICAgICAgICBlbHNpZiBAc3RlcF9hcmcxXG4gICAgICAgICAgICAgICAgIFwiKCN7QHRvcGZ4fSN7QHN0ZXBfYXJnMS5pbnNwZWN0fSlcIlxuICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgXCIoI3tAcmVjZWl2ZXJfbnVtLmluc3BlY3R9LiN7QGNyZWF0aW9uX21ldGhvZH0je2FyZ3N9KVwiXG4gICAgICBlbHNlXG4gICAgICAgIGFyZ3MgPSB1bmxlc3MgQHNraXBwZWRfYXJnXG4gICAgICAgICAgICAgICAgIFwiKCN7QHN0ZXB9KVwiXG4gICAgICAgICAgICAgICBlbmRcbiAgICAgICAgXCIoKCN7QHJhbmdlLmluc3BlY3R9KS4je0BjcmVhdGlvbl9tZXRob2R9I3thcmdzfSlcIlxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyA9PT0gPT1cbiAgICBhbGlhcyBlcWw/ID09XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpzZWxmOjpBcml0aG1ldGljU2VxdWVuY2U+IiwiaW5pdGlhbGl6ZSIsInJhbmdlIiwic3RlcCIsImNyZWF0aW9uX21ldGhvZCIsIkBjcmVhdGlvbl9tZXRob2QiLCJpc19hPyIsIkFycmF5IiwiQHN0ZXBfYXJnMSIsIkBzdGVwX2FyZzIiLCJAdG9wZngiLCJAYnlwZngiLCJAcmVjZWl2ZXJfbnVtIiwiQHN0ZXAiLCIxIiwiQHJhbmdlIiwiQHNraXBwZWRfYXJnIiwiJHJldF9vcl8xIiwiQG9iamVjdCIsInNlbGYiLCIwIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwicmVzcG9uZF90bz8iLCJjbGFzcyIsImF0dHJfcmVhZGVyIiwiYmVnaW4iLCJlbmQiLCJleGNsdWRlX2VuZD8iLCJfbGVzc2VyX3RoYW5fZW5kPyIsInZhbCIsImVuZF8iLCI+IiwiPCIsIjw9IiwiPj0iLCJfZ3JlYXRlcl90aGFuX2JlZ2luPyIsImJlZ2luXyIsIi1AIiwiZmlyc3QiLCJjb3VudCIsIml0ZXIiLCJvdXQiLCI8PCIsIisiLCItIiwiZWFjaCIsImJsb2NrX2dpdmVuPyIsIlR5cGVFcnJvciIsImxhc3QiLCJGbG9hdERvbWFpbkVycm9yIiwiUmFuZ2VFcnJvciIsIiUiLCJyZXZlcnNlIiwic2l6ZSIsInN0ZXBfc2lnbiIsIi0xIiwiaW5jbHVkZT8iLCIqIiwiLyIsImFicyIsInRvX2kiLCI9PSIsIm90aGVyIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwiJHJldF9vcl80IiwiaGFzaCIsImluc3BlY3QiLCJhcmdzIl0sIm1hcHBpbmdzIjoiQUFBQUEseURBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNHQTtNQUVBQTs7QUFHREMsTUFBQUEsMEJBQUFBLHNCQUFlQyxLQUFELEVBQVFDLElBQVIsRUFBMEJDLGVBQXhDSDtBQUFBQSxRQUFBQTs7OztRQUF3QywrQ0FBa0I7UUFDeERJLHVCQUFtQkQ7UUFDbkIsSUFBQSxRQUFHRixLQUFLSSxVQUFBQSxDQUFPQyxZQUFQRCxDQUFSLENBQUE7O1VBQ0UsS0FBeUMsVUFBQSxNQUFDSixLQUFELENBQUEsQ0FBekMsRUFBQU0sQ0FBQUEsaUJBQUEsNkJBQUFBLENBQUEsRUFBWUMsQ0FBQUEsaUJBQVosNkJBQVlBLENBQVosRUFBd0JDLENBQUFBLGFBQXhCLDZCQUF3QkEsQ0FBeEIsRUFBZ0NDLENBQUFBLGFBQWhDLDZCQUFnQ0EsQ0FBaEM7VUFDQUMsb0JBQWdCVDtVQUNoQlUsWUFBUUM7VUFFUkMsYUFBUyxDQUFBLFFBQUdOLGNBQUgsQ0FBQSxHQUFBLENBQ0VSLENBQUFZLENBQUFBLFlBQVFKLGNBQVJJLEdBQ0MsZ0JBQUFELGlCQUFBLEVBQWVKLGNBQWYsUUFERFAsQ0FERixJQUdBLENBQUEsUUFBTU8sY0FBTixDQUFBLEdBQUEsQ0FDRyxnQkFBQUksaUJBQUEsRUFBZUosY0FBZixRQURILElBQUEsQ0FHRyxnQkFBQUksaUJBQUEsRUFBZSxHQUFmLFFBSEgsQ0FBQSxDQUhBO1FBTFg7O1VBY0UsS0FBQSxRQUEyQlQsSUFBM0IsQ0FBQTtZQUFBYSxtQkFBZTtVQUFmO1VBQ0EsS0FBZ0IsQ0FB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QUEsR0FBQSxDQUNHNkQsR0FBRCxHQUFBLENBQUkzRCxVQUFKLENBQUEsR0FBQSxDQUFhRixjQUFVNkQsU0FBQUEsQ0FBQUEsQ0FBdkIsQ0FBQSxHQUFnQ0EsR0FEbEMsSUFBQSxHQUFBLENBRkE7VUFNUEEsT0FBQ0EsR0FBRCxHQUFBLENBQUl6RCxpQkFBYXlELFNBQUFBLENBQUFBLENBQWpCLENBQUEsR0FBMEJBLEdBQTFCLEdBQUEsQ0FBNkJoRSxvQkFBN0IsQ0FBQSxHQUFBLENBQWdEaUUsSUFBaEQsQ0FBQSxHQUFxREQ7UUFQdkQ7O1VBU0VDLE9BQU8sQ0FBQSxRQUFPdEQsZ0JBQVAsQ0FBQSxHQUFBLENBQUEsR0FBQSxJQUFBLENBQ0dxRCxHQUFELEdBQUEsQ0FBSXhELFNBQUosQ0FBQSxHQUFVd0QsR0FEWixDQUFBO1VBR1BBLE9BQUNBLElBQUQsR0FBQSxDQUFLdEQsVUFBTXNELFNBQUFBLENBQUFBLENBQVgsQ0FBQSxHQUFvQkEsSUFBcEIsR0FBQSxDQUF3QmhFLG9CQUF4QixDQUFBLEdBQUEsQ0FBMkNpRSxJQUEzQyxDQUFBLEdBQWdERDtRQVpsRDtNQURGQSxDQUFBQTtNQWlCQSxhQUFNLEtBQU4sRUFBVSxJQUFWO01BQ0FyRSxPQUFBLGFBQU0sTUFBTixFQUFXLElBQVg7SUE3S0ZBLEdBQU1tQixJQUFObkIsRUFBaUNtQixJQUFqQ25CO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMzk4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL2NoYWluLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogZGVueV9mcm96ZW5fYWNjZXNzXG5cbmNsYXNzIDo6RW51bWVyYXRvclxuICBjbGFzcyBzZWxmOjpDaGFpbiA8IHNlbGZcbiAgICBkZWYgaW5pdGlhbGl6ZSgqZW51bXMpXG4gICAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgICAgQGVudW1zID0gZW51bXNcbiAgICAgIEBpdGVyYXRlZCA9IFtdXG4gICAgICBAb2JqZWN0ID0gc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIGVhY2goKmFyZ3MsICZibG9jaylcbiAgICAgIHJldHVybiB0b19lbnVtKDplYWNoLCAqYXJncykgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgICBAZW51bXMuZWFjaCBkbyB8ZW51bXxcbiAgICAgICAgQGl0ZXJhdGVkIDw8IGVudW1cbiAgICAgICAgZW51bS5lYWNoKCphcmdzLCAmYmxvY2spXG4gICAgICBlbmRcblxuICAgICAgc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIHNpemUoKmFyZ3MpXG4gICAgICBhY2N1bSA9IDBcbiAgICAgIEBlbnVtcy5lYWNoIGRvIHxlbnVtfFxuICAgICAgICBzaXplID0gZW51bS5zaXplKCphcmdzKVxuICAgICAgICByZXR1cm4gc2l6ZSBpZiBbbmlsLCA6OkZsb2F0OjpJTkZJTklUWV0uaW5jbHVkZT8gc2l6ZVxuICAgICAgICBhY2N1bSArPSBzaXplXG4gICAgICBlbmRcbiAgICAgIGFjY3VtXG4gICAgZW5kXG5cbiAgICBkZWYgcmV3aW5kXG4gICAgICBAaXRlcmF0ZWQucmV2ZXJzZV9lYWNoIGRvIHxlbnVtfFxuICAgICAgICBlbnVtLnJld2luZCBpZiBlbnVtLnJlc3BvbmRfdG8/IDpyZXdpbmRcbiAgICAgIGVuZFxuICAgICAgQGl0ZXJhdGVkID0gW11cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBcIiM8RW51bWVyYXRvcjo6Q2hhaW46ICN7QGVudW1zLmluc3BlY3R9PlwiXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpzZWxmOjpDaGFpbj4iLCJpbml0aWFsaXplIiwiQGVudW1zIiwiZW51bXMiLCJAaXRlcmF0ZWQiLCJAb2JqZWN0Iiwic2VsZiIsImVhY2giLCJibG9ja19naXZlbj8iLCJ0b19lbnVtIiwiYXJncyIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJzaXplIiwiZW51bSQiLCI8PCIsImJsb2NrIiwidG9fcHJvYyIsImFjY3VtIiwiMCIsImJsb2NrIGluIHNpemUiLCJibG9jayAoMiBsZXZlbHMpIGluIHNpemUiLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsImluY2x1ZGU/IiwiKyIsInJld2luZCIsInJldmVyc2VfZWFjaCIsImJsb2NrIGluIHJld2luZCIsInJlc3BvbmRfdG8/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXdpbmQiLCJpbnNwZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7OztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOzs7QUFDRUMsTUFBQUEsMEJBQUFBLHNCQUpKLEVBSUlBO0FBQUFBLFFBQUFBOzs7UUFKSjtRQUltQjtRQUNaQTtRQUVEQyxhQUFTQztRQUNUQyxnQkFBWTtRQUNaSCxPQUFBSSxDQUFBQSxjQUFVQyxJQUFWRDtNQUxGSixDQUFBQSxJQUFBQTs7QUFRQU0sTUFBQUEsb0JBQUFBLGdCQVpKLEVBWUlBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBWko7UUFZYTtRQUNQLEtBQTZDQyxlQUE3QztVQUFBLE9BQU9DLE1BQUFILElBQUFHLFdBQUFBLEVBQUEsQ0FBUSxNQUFSLENBQUEsUUFBZSxNQUFDQyxJQUFELENBQWYsQ0FBQUQsRUFBQUUsYUFBQUEsRUFBQUM7O1lBQXdCQSxPQUFBTixJQUFBTyxNQUFBQSxDQUFBQSxDQUF4QkYsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUY7UUFBUDtRQUVNRixNQUFOTCxVQUFNSyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFOSSxhQUFnQkcsS0FBaEJILEVBQUFDO0FBQUFBOzs7VUFBZ0I7VUFDZFIsYUFBVVcsT0FBQUEsQ0FBR0QsS0FBSEM7VUFDVkgsT0FBSUwsTUFBSk8sS0FBSVAsUUFBQUEsRUFBTSxNQUFDRyxJQUFELENBQU5ILEVBQWNTLEtBQURDLFNBQUFBLENBQUFBLENBQWJWLEVBRk5JLENBQUFBLEdBQUFBLFNBQUFBLENBQU1KO1FBS05BLE9BQUFEO01BUkZDLENBQUFBLElBQUFBOztBQVdBTSxNQUFBQSxvQkFBQUEsZ0JBdkJKLEVBdUJJQSxHQUFBQSxNQUFBQSxJQUFBQSw4QkFBQUE7QUFBQUEsUUFBQUE7OztRQXZCSjtRQXVCYTtRQUNQSyxRQUFRQztRQUNGWixNQUFOTCxVQUFNSyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFOYSxhQUFnQk4sS0FBaEJNLEVBQUFDOzs7VUFBZ0I7VUFDZFIsT0FBV0EsTUFBSkMsS0FBSUQsUUFBQUEsRUFBTSxNQUFDSCxJQUFELENBQU5HO1VBQ1gsSUFBQSxRQUFlLENBQUMsR0FBRCxFQUFNUyxJQUFBQyxZQUFBRCxhQUFOLENBQXdCRSxhQUFBQSxDQUFVWCxJQUFWVyxDQUF2QyxDQUFBO1lBQUEsU0FBQSxRQUFPWCxJQUFQO1VBQUE7VUFDQVEsT0FBQUgsQ0FBQUEsUUFBTU8sU0FBTlAsS0FBTU8sRUFBR1osSUFBSFksQ0FBTlAsRUFIRkUsQ0FBQUEsR0FBQUEsZ0JBQUFBLENBQU1iO1FBS05NLE9BQUFLLE1BUEZMO1VBQUFBO1VBQUFBO1FBQUFBO01BQUFBLENBQUFBLElBQUFBOztBQVVBYSxNQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOzs7UUFDV0MsTUFBVHZCLGFBQVN1QixnQkFBQUEsRUFBQUEsRUFBQUEsRUFBVEMsYUFBMkJkLEtBQTNCYzs7VUFBMkI7VUFDekIsSUFBQSxRQUFlZCxLQUFJZSxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFuQixDQUFBO1lBQUFDLE9BQUFoQixLQUFJWSxRQUFBQSxDQUFBQTtVQUFKO1lBbkNSSSxPQUFBO1VBbUNRLEVBREZGLENBQVNEO1FBR1R2QixnQkFBWTtRQUNac0IsT0FBQXBCO01BTEZvQixDQUFBQTtNQVFBMUIsT0FBQStCLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLHVCQUFELEdBQUEsQ0FBd0I3QixVQUFNNkIsU0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBQSxHQUF1Q0E7TUFEekNBLENBQUFBO0lBdENGL0IsR0FBTU0sSUFBTk4sRUFBb0JNLElBQXBCTjtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMTQ5NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9nZW5lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBkZW55X2Zyb3plbl9hY2Nlc3NcblxuY2xhc3MgRW51bWVyYXRvclxuICBjbGFzcyBHZW5lcmF0b3JcbiAgICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgeWllbGRlciA9IFlpZWxkZXIubmV3KCZibG9jaylcblxuICAgICAgJXh7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgT3BhbC55aWVsZFgoI3tAYmxvY2t9LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUuJHRocm93ZXJfdHlwZSA9PSBcImJyZWFrZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGUuJHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6R2VuZXJhdG9yPiIsInNlbGYiLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsImluaXRpYWxpemUiLCJibG9jayIsIktlcm5lbCIsInJhaXNlIiwiTG9jYWxKdW1wRXJyb3IiLCJAYmxvY2siLCJlYWNoIiwieWllbGRlciIsIm5ldyIsIllpZWxkZXIiLCJ0b19wcm9jIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxpQkFBUkQ7O0FBRUFFLE1BQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFDR0E7UUFFRCxLQUFBLFFBQXlEQyxLQUF6RCxDQUFBO1VBQUFDLE9BQVFDLE9BQUFBLENBQU9DLHFCQUFmLEVBQWlDSixnQkFBekJHO1FBQVI7UUFFQUgsT0FBQUssQ0FBQUEsYUFBU0osS0FBVEk7TUFMRkwsQ0FBQUE7TUFRQUosT0FBQVUsb0JBQUFBLGdCQWRKLEVBY0lBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBZEo7UUFjYTtRQUNQQyxVQUFpQkMsTUFBUEMsYUFBT0QsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTVAsS0FBRFMsU0FBQUEsQ0FBQUEsQ0FBTEY7O0FBR3ZCRjtBQUNBQSx1QkFBeUJDLE9BQVFEOztBQUVqQ0Esc0JBQXdCRCxVQUFPQztBQUMvQkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7UUFFTUEsT0FBQVQ7TUFuQkZTLENBQUFBLElBQUFBO0lBWEZWLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMTU1NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9sYXp5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG8sIHlpZWxkMSwgeWllbGRYLCBkZW55X2Zyb3plbl9hY2Nlc3NcblxuY2xhc3MgOjpFbnVtZXJhdG9yXG4gIGNsYXNzIHNlbGY6OkxhenkgPCBzZWxmXG4gICAgY2xhc3Mgc2VsZjo6U3RvcExhenlFcnJvciA8IDo6RXhjZXB0aW9uOyBlbmRcblxuICAgIGRlZiBzZWxmLmZvcihvYmplY3QsICopXG4gICAgICBsYXp5ID0gc3VwZXJcbiAgICAgIGBsYXp5LmVudW1lcmF0b3IgPSBvYmplY3RgXG4gICAgICBsYXp5XG4gICAgZW5kXG5cbiAgICBkZWYgaW5pdGlhbGl6ZShvYmplY3QsIHNpemUgPSBuaWwsICZibG9jaylcbiAgICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBuZXcgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIEBlbnVtZXJhdG9yID0gb2JqZWN0XG5cbiAgICAgIHN1cGVyIHNpemUgZG8gfHlpZWxkZXIsICplYWNoX2FyZ3N8XG4gICAgICAgIG9iamVjdC5lYWNoKCplYWNoX2FyZ3MpIGRvIHwqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCgje3lpZWxkZXJ9KTtcblxuICAgICAgICAgICAgJHlpZWxkWChibG9jaywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIHJlc2N1ZSBTdG9wTGF6eUVycm9yXG4gICAgICAgIG5pbFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbGF6eVxuICAgICAgc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgICN7ZW51bS55aWVsZCBgdmFsdWVgfTtcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgY29sbGVjdF9jb25jYXQoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje2B2YWx1ZWAucmVzcG9uZF90bz8gOmZvcmNlfSAmJiAje2B2YWx1ZWAucmVzcG9uZF90bz8gOmVhY2h9KSB7XG4gICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSAjezo6T3BhbC50cnlfY29udmVydCBgdmFsdWVgLCA6OkFycmF5LCA6dG9fYXJ5fTtcblxuICAgICAgICAgICAgaWYgKGFycmF5ID09PSBuaWwpIHtcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGB2YWx1ZWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICN7YHZhbHVlYC5lYWNoIHsgfHZ8IGVudW0ueWllbGQgdiB9fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGRyb3AobilcbiAgICAgIG4gPSBgJGNvZXJjZV90bygje259LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiA6OkludGVnZXIgPT09IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICBuIDwgY3VycmVudF9zaXplID8gbiA6IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICBkcm9wcGVkID0gMFxuICAgICAgTGF6eS5uZXcoc2VsZiwgc2V0X3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgZHJvcHBlZCA8IG5cbiAgICAgICAgICBkcm9wcGVkICs9IDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZHJvcF93aGlsZSgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IGRyb3Bfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIHN1Y2NlZWRpbmcgPSB0cnVlXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgc3VjY2VlZGluZ1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAgIGlmICghJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3VjY2VlZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgICBzZWxmLmNsYXNzLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgZW5kXG5cbiAgICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBzZWxlY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBncmVwKHBhdHRlcm4sICZibG9jaylcbiAgICAgIGlmIGJsb2NrXG4gICAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgJHlpZWxkMShibG9jaywgcGFyYW0pYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGBwYXJhbWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiByZWplY3QoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSByZWplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICghJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdGFrZShuKVxuICAgICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBuIDwgMFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBjdXJyZW50X3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgIHNldF9zaXplICAgICA9IGlmIDo6SW50ZWdlciA9PT0gY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgIG4gPCBjdXJyZW50X3NpemUgPyBuIDogY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIHRha2VuID0gMFxuICAgICAgTGF6eS5uZXcoc2VsZiwgc2V0X3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgdGFrZW4gPCBuXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgICB0YWtlbiArPSAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICA6Oktlcm5lbC5yYWlzZSBTdG9wTGF6eUVycm9yXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHRha2Vfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBTdG9wTGF6eUVycm9yfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGluc3BlY3RcbiAgICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0BlbnVtZXJhdG9yLmluc3BlY3R9PlwiXG4gICAgZW5kXG5cbiAgICBhbGlhcyBmb3JjZSB0b19hXG4gICAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXG4gICAgYWxpYXMgZmxhdF9tYXAgY29sbGVjdF9jb25jYXRcbiAgICBhbGlhcyBtYXAgY29sbGVjdFxuICAgIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxuICAgIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiPGNsYXNzOnNlbGY6Okxhenk+IiwiPGNsYXNzOnNlbGY6OlN0b3BMYXp5RXJyb3I+Iiwic2VsZiIsIkV4Y2VwdGlvbiIsImZvciIsIm9iamVjdCIsImxhenkiLCIkZndkX3Jlc3QiLCJpbml0aWFsaXplIiwic2l6ZSIsImJsb2NrX2dpdmVuPyIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIkBlbnVtZXJhdG9yIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsInlpZWxkZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJlYWNoIiwiZWFjaF9hcmdzIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiU3RvcExhenlFcnJvciIsImNvbGxlY3QiLCJibG9jayIsIm5ldyIsIkxhenkiLCJlbnVtZXJhdG9yX3NpemUiLCJibG9jayBpbiBjb2xsZWN0IiwiZW51bSQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QiLCJ5aWVsZCIsImNvbGxlY3RfY29uY2F0IiwiYmxvY2sgaW4gY29sbGVjdF9jb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3RfY29uY2F0IiwicmVzcG9uZF90bz8iLCJ2IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBjb2xsZWN0X2NvbmNhdCIsIk9wYWwiLCJ0cnlfY29udmVydCIsIkFycmF5IiwiZHJvcCIsIm4iLCJJbnRlZ2VyIiwiPCIsIjAiLCJjdXJyZW50X3NpemUiLCJzZXRfc2l6ZSIsImRyb3BwZWQiLCJibG9jayBpbiBkcm9wIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkcm9wIiwiKyIsIjEiLCJhcmdzIiwiZHJvcF93aGlsZSIsInN1Y2NlZWRpbmciLCJibG9jayBpbiBkcm9wX3doaWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkcm9wX3doaWxlIiwiZW51bV9mb3IiLCJjbGFzcyIsIm1ldGhvZCIsInRvX3Byb2MiLCJmaW5kX2FsbCIsImJsb2NrIGluIGZpbmRfYWxsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX2FsbCIsImdyZXAiLCJwYXR0ZXJuIiwiYmxvY2sgaW4gZ3JlcCIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcCIsImRlc3RydWN0dXJlIiwiPT09IiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJ0YWtlIiwidGFrZW4iLCJibG9jayBpbiB0YWtlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWtlIiwidGFrZV93aGlsZSIsImJsb2NrIGluIHRha2Vfd2hpbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIHRha2Vfd2hpbGUiLCJpbnNwZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxPQUFNQyxJQUFORCxFQUE0QkUsZ0JBQTVCRjtNQUVBRyxNQUFJRixJQUFKRSxVQUFBQSxxQkFBYUMsTUFBRCxFQU5oQixFQU1JRDtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBTko7UUFNeUI7UUFDbkJFLE9BQU8sT0FBQUosSUFBQSxFQUFBLGtEQUFBLE9BQUEsRUFBQSxDQUFBRyxNQUFBLENBQUEsUUFBQSxNQUFBRSxTQUFBLENBQUEsQ0FBQSxFQUFBLE1BQUE7UUFDTkg7UUFDREEsT0FBQUU7TUFIRkYsQ0FBQUEsSUFBQUE7O0FBTUFJLE1BQUFBLDBCQUFBQSxzQkFBZUgsTUFBRCxFQUFTSSxJQUF2QkQ7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFBdUIseUJBQU87UUFDM0JBO1FBRUQsS0FBT0UsZUFBUDtVQUNFQyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ0wsd0NBQXhCSTtRQURWO1FBSUFFLGtCQUFjVDtRQUVkRyxPQUFBLE9BQUFOLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBTU8sSUFBTixDQUFBLEVBQUFNLGFBQWVDLE9BQUQsRUFyQnBCLEVBcUJNRCxFQUFBRTs7O1VBQWU7VUFyQnJCO1VBcUI4QjtVQUN0QjtZQUFBQSxPQUFNQyxNQUFOYixNQUFNYSxRQUFBQSxFQUFNLE1BQUNDLFNBQUQsQ0FBTkQsRUFBTkQsYUF0QlIsRUFzQlFBLEVBQUFHOzs7Y0F0QlI7Y0FzQm9DOztBQUVwQ0EseUJBQTJCSixPQUFRSTs7QUFFbkNBO0FBQ0FBLFdBTFFILENBQUFBLElBQU1DO1VBQU47WUFPRixzQkFBTyxDQUFBRyxtQkFBQSxDQUFQO2NBQUE7Z0JBQ0VKLE9B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UHRCLENBQWNpRDtBQUNoQ0E7QUFDQUE7QUFDQUEsWUFBY3BFLE9BQVFDLE9BQUFBLENBQU9TLG1CQUFQVCxDQUFxQm1FO0FBQzNDQTtBQUNBQSxTQVZNRCxDQUFBQSxJQUFJdEQ7TUFMTnFELENBQUFBOztBQW1CQUcsTUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQ0EsSUFBRCxHQUFBLENBQUs5RSxJQUFJd0QsT0FBQUEsQ0FBQUEsQ0FBVCxDQUFBLEdBQWdCc0IsSUFBaEIsR0FBQSxDQUFvQmxFLGVBQVdrRSxTQUFBQSxDQUFBQSxDQUEvQixDQUFBLEdBQXdDQTtNQUQxQ0EsQ0FBQUE7TUFJQSxhQUFNLE9BQU4sRUFBWSxNQUFaO01BQ0EsYUFBTSxRQUFOLEVBQWEsVUFBYjtNQUNBLGFBQU0sVUFBTixFQUFlLGdCQUFmO01BQ0EsYUFBTSxLQUFOLEVBQVUsU0FBVjtNQUNBLGFBQU0sUUFBTixFQUFhLFVBQWI7TUFDQWhGLE9BQUEsYUFBTSxTQUFOLEVBQWMsVUFBZDtJQS9PRkEsR0FBTUUsSUFBTkYsRUFBbUJFLElBQW5CRjtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMTkxMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci95aWVsZGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEVudW1lcmF0b3JcbiAgY2xhc3MgWWllbGRlclxuICAgIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgICAjIHJ1Ym9jb3A6ZGlzYWJsZSBMaW50L1ZvaWRcbiAgICAgIHNlbGZcbiAgICAgICMgcnVib2NvcDplbmFibGUgTGludC9Wb2lkXG4gICAgZW5kXG5cbiAgICBkZWYgeWllbGQoKnZhbHVlcylcbiAgICAgICV4e1xuICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWCgje0BibG9ja30sIHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLiR0aHJvd2VyX3R5cGUgPT0gXCJicmVha1wiKSB7XG4gICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgPDwodmFsdWUpXG4gICAgICBzZWxmLnlpZWxkKHZhbHVlKVxuXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgdG9fcHJvY1xuICAgICAgcHJvYyBkbyB8KnZhbHVlc3xcbiAgICAgICAgc2VsZi55aWVsZCgqdmFsdWVzKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpZaWVsZGVyPiIsImluaXRpYWxpemUiLCJAYmxvY2siLCJibG9jayIsInNlbGYiLCJ5aWVsZCIsIjw8IiwidmFsdWUiLCJ0b19wcm9jIiwicHJvYyIsImJsb2NrIGluIHRvX3Byb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX3Byb2MiLCJ2YWx1ZXMiXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7OztBQUNFQyxNQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0VDLGFBQVNDO1FBRVRGLE9BQUFHO01BSEZILENBQUFBOztBQU9BSSxNQUFBQSxxQkFBQUEsMEJBVEosRUFTSUE7QUFBQUEsUUFBQUE7OztRQVRKO1FBU2M7O0FBRWRBLGdDQUFrQ0gsVUFBT0c7O0FBRXpDQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7TUFUSUEsQ0FBQUEsSUFBQUE7O0FBWUFDLE1BQUFBLGtCQUFBQSwyQkFBT0MsS0FBUEQ7QUFBQUEsUUFBQUE7OztRQUNFRixJQUFJQyxPQUFBQSxDQUFPRSxLQUFQRjtRQUVKQyxPQUFBRjtNQUhGRSxDQUFBQTtNQU1BTixPQUFBUSx1QkFBQUEsbUJBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBQyxNQUFBTCxJQUFBSyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyxhQTVCTixFQTRCTUEsRUFBQUM7OztVQTVCTjtVQTRCZTtVQUNQQSxPQUFJTixNQUFKRCxJQUFJQyxTQUFBQSxFQUFPLE1BQUNPLE1BQUQsQ0FBUFAsRUFETkssQ0FBQUEsR0FBQUEsc0JBQUFBLENBQUFEO01BREZELENBQUFBO0lBMUJGUixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQURGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTE5NzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZSwgY29lcmNlX3RvLCBkZW55X2Zyb3plbl9hY2Nlc3NcblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyA6OkVudW1lcmF0b3JcbiAgaW5jbHVkZSA6OkVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2VudW1lcmF0b3IgPSB0cnVlYFxuXG4gIGRlZiBzZWxmLmZvcihvYmplY3QsIG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9iaiA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBvYmoub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgb2JqLnNpemUgICA9IGJsb2NrO1xuICAgICAgb2JqLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIG9iai5hcmdzICAgPSBhcmdzO1xuICAgICAgb2JqLmN1cnNvciA9IDA7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqLCAmYmxvY2spXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBAY3Vyc29yID0gMFxuICAgIGlmIGJsb2NrXG4gICAgICBAb2JqZWN0ID0gR2VuZXJhdG9yLm5ldygmYmxvY2spXG4gICAgICBAbWV0aG9kID0gOmVhY2hcbiAgICAgIEBhcmdzICAgPSBbXVxuICAgICAgQHNpemUgICA9IGBhcmd1bWVudHNbMF0gfHwgbmlsYFxuXG4gICAgICBpZiBAc2l6ZSAmJiAhQHNpemUucmVzcG9uZF90bz8oOmNhbGwpXG4gICAgICAgIEBzaXplID0gYCRjb2VyY2VfdG8oI3tAc2l6ZX0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgQG9iamVjdCA9IGBhcmd1bWVudHNbMF1gXG4gICAgICBAbWV0aG9kID0gYGFyZ3VtZW50c1sxXSB8fCBcImVhY2hcImBcbiAgICAgIEBhcmdzICAgPSBgJHNsaWNlKGFyZ3VtZW50cywgMilgXG4gICAgICBAc2l6ZSAgID0gbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgaWYgYmxvY2submlsPyAmJiBhcmdzLmVtcHR5P1xuXG4gICAgYXJncyA9IEBhcmdzICsgYXJnc1xuXG4gICAgcmV0dXJuIHNlbGYuY2xhc3MubmV3KEBvYmplY3QsIEBtZXRob2QsICphcmdzKSBpZiBibG9jay5uaWw/XG5cbiAgICBAb2JqZWN0Ll9fc2VuZF9fKEBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgQHNpemUucmVzcG9uZF90bz8oOmNhbGwpID8gQHNpemUuY2FsbCgqQGFyZ3MpIDogQHNpemVcbiAgZW5kXG5cbiAgZGVmIHdpdGhfaW5kZXgob2Zmc2V0ID0gMCwgJmJsb2NrKVxuICAgIG9mZnNldCA9IGlmIG9mZnNldFxuICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgZW5kXG5cbiAgICByZXR1cm4gZW51bV9mb3IoOndpdGhfaW5kZXgsIG9mZnNldCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsIGluZGV4ID0gb2Zmc2V0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBibG9jayhwYXJhbSwgaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZWFjaCgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHN1cGVyXG4gICAgQG9iamVjdFxuICBlbmRcblxuICBkZWYgcmV3aW5kXG4gICAgQGN1cnNvciA9IDBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHBlZWtfdmFsdWVzXG4gICAgQHZhbHVlcyB8fD0gbWFwIHsgfCppfCBpIH1cbiAgICA6Oktlcm5lbC5yYWlzZSA6OlN0b3BJdGVyYXRpb24sICdpdGVyYXRpb24gcmVhY2hlZCBhbiBlbmQnIGlmIEBjdXJzb3IgPj0gQHZhbHVlcy5sZW5ndGhcbiAgICBAdmFsdWVzW0BjdXJzb3JdXG4gIGVuZFxuXG4gIGRlZiBwZWVrXG4gICAgdmFsdWVzID0gcGVla192YWx1ZXNcbiAgICB2YWx1ZXMubGVuZ3RoIDw9IDEgPyB2YWx1ZXNbMF0gOiB2YWx1ZXNcbiAgZW5kXG5cbiAgZGVmIG5leHRfdmFsdWVzXG4gICAgb3V0ID0gcGVla192YWx1ZXNcbiAgICBAY3Vyc29yICs9IDFcbiAgICBvdXRcbiAgZW5kXG5cbiAgZGVmIG5leHRcbiAgICB2YWx1ZXMgPSBuZXh0X3ZhbHVlc1xuICAgIHZhbHVlcy5sZW5ndGggPD0gMSA/IHZhbHVlc1swXSA6IHZhbHVlc1xuICBlbmRcblxuICBkZWYgZmVlZChhcmcpXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgXCJPcGFsIGRvZXNuJ3Qgc3VwcG9ydCBFbnVtZXJhdG9yI2ZlZWRcIlxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICA6OkVudW1lcmF0b3I6OkNoYWluLm5ldyhzZWxmLCBvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICByZXN1bHQgPSBcIiM8I3tzZWxmLmNsYXNzfTogI3tAb2JqZWN0Lmluc3BlY3R9OiN7QG1ldGhvZH1cIlxuXG4gICAgaWYgQGFyZ3MuYW55P1xuICAgICAgcmVzdWx0ICs9IFwiKCN7QGFyZ3MuaW5zcGVjdFs6OlJhbmdlLm5ldygxLCAtMildfSlcIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJz4nXG4gIGVuZFxuXG4gIGFsaWFzIHdpdGhfb2JqZWN0IGVhY2hfd2l0aF9vYmplY3RcblxuICBhdXRvbG9hZCA6QXJpdGhtZXRpY1NlcXVlbmNlLCAnY29yZWxpYi9lbnVtZXJhdG9yL2FyaXRobWV0aWNfc2VxdWVuY2UnXG4gIGF1dG9sb2FkIDpDaGFpbiwgJ2NvcmVsaWIvZW51bWVyYXRvci9jaGFpbidcbiAgYXV0b2xvYWQgOkdlbmVyYXRvciwgJ2NvcmVsaWIvZW51bWVyYXRvci9nZW5lcmF0b3InXG4gIGF1dG9sb2FkIDpMYXp5LCAnY29yZWxpYi9lbnVtZXJhdG9yL2xhenknXG4gIGF1dG9sb2FkIDpZaWVsZGVyLCAnY29yZWxpYi9lbnVtZXJhdG9yL3lpZWxkZXInXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsImZvciIsIm9iamVjdCIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsIkBjdXJzb3IiLCIwIiwiYmxvY2siLCJAb2JqZWN0IiwibmV3IiwiR2VuZXJhdG9yIiwidG9fcHJvYyIsIkBtZXRob2QiLCJAYXJncyIsIkBzaXplIiwicmVzcG9uZF90bz8iLCJJbnRlZ2VyIiwiZWFjaCIsIm5pbD8iLCJhcmdzIiwiZW1wdHk/IiwiKyIsImNsYXNzIiwiX19zZW5kX18iLCJzaXplIiwiY2FsbCIsIndpdGhfaW5kZXgiLCJvZmZzZXQiLCJlbnVtX2ZvciIsImJsb2NrIGluIHdpdGhfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIHdpdGhfaW5kZXgiLCJPcGFsIiwiZGVzdHJ1Y3R1cmUiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9ja19naXZlbj8iLCJibG9jayBpbiBlYWNoX3dpdGhfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfd2l0aF9pbmRleCIsInJld2luZCIsInBlZWtfdmFsdWVzIiwiQHZhbHVlcyIsIiRyZXRfb3JfMSIsIm1hcCIsImJsb2NrIGluIHBlZWtfdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwZWVrX3ZhbHVlcyIsImkiLCI+PSIsImxlbmd0aCIsIktlcm5lbCIsInJhaXNlIiwiU3RvcEl0ZXJhdGlvbiIsIltdIiwicGVlayIsInZhbHVlcyIsIjw9IiwiMSIsIm5leHRfdmFsdWVzIiwib3V0IiwibmV4dCIsImZlZWQiLCJhcmciLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwib3RoZXIiLCJFbnVtZXJhdG9yOjpDaGFpbiIsIkVudW1lcmF0b3IiLCJpbnNwZWN0IiwicmVzdWx0IiwiYW55PyIsIlJhbmdlIiwiLTIiLCJhdXRvbG9hZCJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7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QUEsR0FBZ0IwQyxJQUFoQixHQUFBLENBQW9CeEQsV0FBT3dELFNBQUFBLENBQUFBLENBQTNCLENBQUEsR0FBb0NBLEdBQXBDLEdBQUEsQ0FBdUNwRCxXQUF2QztNQUVULElBQUEsUUFBR0MsU0FBS3FELFNBQUFBLENBQUFBLENBQVIsQ0FBQTtRQUNFRCxTQUFPNUMsU0FBUDRDLE1BQU81QyxFQUFJMkMsR0FBRCxHQUFBLENBQUluRCxTQUFLbUQsU0FBQUEsQ0FBQUEsQ0FBUWQsT0FBQUEsQ0FBQ2lCLFlBQU8xRCxLQUFBQSxDQUFLNkMsQ0FBWixFQUFlYyxFQUFSM0QsQ0FBUnlDLENBQWpCLENBQUEsR0FBc0NjLEdBQXpDM0M7TUFEVDtNQUlBMkMsT0FBTzNDLFNBQVA0QyxNQUFPNUMsRUFBRTJDLEdBQUYzQztJQVBUMkMsQ0FBQUE7SUFVQSxhQUFNLGFBQU4sRUFBa0Isa0JBQWxCO0lBRUFwRSxJQUFBeUUsVUFBQUEsQ0FBUyxvQkFBVCxFQUE4QnZFLHdDQUE5QnVFO0lBQ0F6RSxJQUFBeUUsVUFBQUEsQ0FBUyxPQUFULEVBQWlCdkUsMEJBQWpCdUU7SUFDQXpFLElBQUF5RSxVQUFBQSxDQUFTLFdBQVQsRUFBcUJ2RSw4QkFBckJ1RTtJQUNBekUsSUFBQXlFLFVBQUFBLENBQVMsTUFBVCxFQUFnQnZFLHlCQUFoQnVFO0lBQ0F2RSxPQUFBRixJQUFBeUUsVUFBQUEsQ0FBUyxTQUFULEVBQW1CdkUsNEJBQW5CdUU7RUExSUZ2RSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjIwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbnVtZXJpYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5cbmNsYXNzIDo6TnVtZXJpY1xuICBpbmNsdWRlIDo6Q29tcGFyYWJsZVxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgaWYgb3RoZXIuaW5zdGFuY2Vfb2Y/IHNlbGYuY2xhc3NcbiAgICAgIHJldHVybiBbb3RoZXIsIHNlbGZdXG4gICAgZW5kXG5cbiAgICBbOjpLZXJuZWwuRmxvYXQob3RoZXIpLCA6Oktlcm5lbC5GbG9hdChzZWxmKV1cbiAgZW5kXG5cbiAgZGVmIF9fY29lcmNlZF9fKG1ldGhvZCwgb3RoZXIpXG4gICAgaWYgb3RoZXIucmVzcG9uZF90bz8oOmNvZXJjZSlcbiAgICAgIGEsIGIgPSBvdGhlci5jb2VyY2Uoc2VsZilcbiAgICAgIGEuX19zZW5kX18gbWV0aG9kLCBiXG4gICAgZWxzZVxuICAgICAgY2FzZSBtZXRob2RcbiAgICAgIHdoZW4gOissIDotLCA6KiwgOi8sIDolLCA6JiwgOnwsIDpeLCA6KipcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tvdGhlci5jbGFzc30gY2FuJ3QgYmUgY29lcmNlZCBpbnRvIE51bWVyaWNcIlxuICAgICAgd2hlbiA6PiwgOj49LCA6PCwgOjw9LCA6PD0+XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje290aGVyLmNsYXNzfSBmYWlsZWRcIlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgZXF1YWw/IG90aGVyXG4gICAgICByZXR1cm4gMFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgMCAtIHNlbGZcbiAgZW5kXG5cbiAgZGVmICUob3RoZXIpXG4gICAgc2VsZiAtIG90aGVyICogZGl2KG90aGVyKVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgc2VsZiA8IDAgPyAtc2VsZiA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBzZWxmICogc2VsZlxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICBzZWxmIDwgMCA/IDo6TWF0aDo6UEkgOiAwXG4gIGVuZFxuXG4gIGRlZiBjZWlsKG5kaWdpdHMgPSAwKVxuICAgIHRvX2YuY2VpbChuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgY29ualxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgdG9fci5kZW5vbWluYXRvclxuICBlbmRcblxuICBkZWYgZGl2KG90aGVyKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IG8nIGlmIG90aGVyID09IDBcblxuICAgIChzZWxmIC8gb3RoZXIpLmZsb29yXG4gIGVuZFxuXG4gIGRlZiBkaXZtb2Qob3RoZXIpXG4gICAgW2RpdihvdGhlciksIHNlbGYgJSBvdGhlcl1cbiAgZW5kXG5cbiAgZGVmIGZkaXYob3RoZXIpXG4gICAgdG9fZiAvIG90aGVyXG4gIGVuZFxuXG4gIGRlZiBmbG9vcihuZGlnaXRzID0gMClcbiAgICB0b19mLmZsb29yKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiBpXG4gICAgOjpLZXJuZWwuQ29tcGxleCgwLCBzZWxmKVxuICBlbmRcblxuICBkZWYgaW1hZ1xuICAgIDBcbiAgZW5kXG5cbiAgZGVmIGludGVnZXI/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgemVybz8gPyBuaWwgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICB0b19yLm51bWVyYXRvclxuICBlbmRcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIGRlZiBxdW8ob3RoZXIpXG4gICAgOjpPcGFsLmNvZXJjZV90byEoc2VsZiwgOjpSYXRpb25hbCwgOnRvX3IpIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIHJlYWxcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZWFsP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIHJlY3RcbiAgICBbc2VsZiwgMF1cbiAgZW5kXG5cbiAgZGVmIHJvdW5kKGRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICB0b19mLnJvdW5kKGRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIHN0ZXAobGltaXQgPSB1bmRlZmluZWQsIHN0ZXAgPSB1bmRlZmluZWQsIHRvOiB1bmRlZmluZWQsIGJ5OiB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0byBpcyBnaXZlbiB0d2ljZSd9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVwICE9PSB1bmRlZmluZWQgJiYgYnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3N0ZXAgaXMgZ2l2ZW4gdHdpY2UnfVxuICAgICAgfVxuXG4gICAgICBpZiAodG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IHRvO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGVwID0gYnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbWl0ID0gbmlsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmIChzdGVwID09PSBuaWwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnc3RlcCBtdXN0IGJlIG51bWVyaWMnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgIT0gbnVsbCAmJiAje3N0ZXAgPT0gMH0pIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwID09PSBuaWwgfHwgc3RlcCA9PSBudWxsKSB7XG4gICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2lnbiA9ICN7c3RlcCA8PT4gMH07XG5cbiAgICAgICAgaWYgKHNpZ24gPT09IG5pbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIjAgY2FuJ3QgYmUgY29lcmNlZCBpbnRvICN7c3RlcC5jbGFzc31cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PT0gbmlsIHx8IGxpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICBsaW1pdCA9IHNpZ24gPiAwID8gI3s6OkZsb2F0OjpJTkZJTklUWX0gOiAjey06OkZsb2F0OjpJTkZJTklUWX07XG4gICAgICAgIH1cblxuICAgICAgICAjezo6T3BhbC5jb21wYXJlKHNlbGYsIGxpbWl0KX1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RlcEZsb2F0U2l6ZSgpIHtcbiAgICAgICAgaWYgKChzdGVwID4gMCAmJiBzZWxmID4gbGltaXQpIHx8IChzdGVwIDwgMCAmJiBzZWxmIDwgbGltaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gSW5maW5pdHkgfHwgc3RlcCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgICAgICAgIGVyciA9IChhYnMoc2VsZikgKyBhYnMobGltaXQpICsgYWJzKGxpbWl0IC0gc2VsZikpIC8gYWJzKHN0ZXApICogI3s6OkZsb2F0OjpFUFNJTE9OfTtcblxuICAgICAgICAgIGlmIChlcnIgPT09IEluZmluaXR5IHx8IGVyciA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVyciA+IDAuNSkge1xuICAgICAgICAgICAgICBlcnIgPSAwLjU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbG9vcigobGltaXQgLSBzZWxmKSAvIHN0ZXAgKyBlcnIpICsgMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwU2l6ZSgpIHtcbiAgICAgICAgdmFsaWRhdGVQYXJhbWV0ZXJzKCk7XG5cbiAgICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCAlIDEgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc3RlcEZsb2F0U2l6ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKChzdGVwID4gMCAmJiBzZWxmID4gbGltaXQpIHx8IChzdGVwIDwgMCAmJiBzZWxmIDwgbGltaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNlaWwgPSBNYXRoLmNlaWwsIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgICBsaHMgPSBhYnMoc2VsZiAtIGxpbWl0KSArIDEsXG4gICAgICAgICAgICAgIHJocyA9IGFicyhzdGVwKTtcblxuICAgICAgICAgIHJldHVybiBjZWlsKGxocyAvIHJocyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIGlmICghbGltaXQgfHwgbGltaXQuaXNfYT8oOjpOdW1lcmljKSkgJiZcbiAgICAgICAgICghc3RlcCB8fCBzdGVwLmlzX2E/KDo6TnVtZXJpYykpXG5cbiAgICAgICAgcmV0dXJuIDo6RW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlLm5ldyhcbiAgICAgICAgICBbbGltaXQsIHN0ZXAsICgndG86ICcgaWYgdG8pLCAoJ2J5OiAnIGlmIGJ5KV0sIHNlbGZcbiAgICAgICAgKVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZW51bV9mb3IoOnN0ZXAsIGxpbWl0LCBzdGVwLCAmYHN0ZXBTaXplYClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YWxpZGF0ZVBhcmFtZXRlcnMoKTtcblxuICAgICAgdmFyIGlzRGVzYyA9ICN7c3RlcC5uZWdhdGl2ZT99LFxuICAgICAgICAgIGlzSW5mID0gI3tzdGVwID09IDB9IHx8XG4gICAgICAgICAgICAgICAgICAobGltaXQgPT09IEluZmluaXR5ICYmICFpc0Rlc2MpIHx8XG4gICAgICAgICAgICAgICAgICAobGltaXQgPT09IC1JbmZpbml0eSAmJiBpc0Rlc2MpO1xuXG4gICAgICBpZiAoc2VsZi4kJGlzX251bWJlciAmJiBzdGVwLiQkaXNfbnVtYmVyICYmIGxpbWl0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChzZWxmICUgMSA9PT0gMCAmJiAoaXNJbmYgfHwgbGltaXQgJSAxID09PSAwKSAmJiBzdGVwICUgMSA9PT0gMCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNlbGY7XG5cbiAgICAgICAgICBpZiAoaXNJbmYpIHtcbiAgICAgICAgICAgIGZvciAoOzsgdmFsdWUgKz0gc3RlcCkge1xuICAgICAgICAgICAgICBibG9jayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0Rlc2MpIHtcbiAgICAgICAgICAgIGZvciAoOyB2YWx1ZSA+PSBsaW1pdDsgdmFsdWUgKz0gc3RlcCkge1xuICAgICAgICAgICAgICBibG9jayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoOyB2YWx1ZSA8PSBsaW1pdDsgdmFsdWUgKz0gc3RlcCkge1xuICAgICAgICAgICAgICBibG9jayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGJlZ2luID0gI3t0b19mfS52YWx1ZU9mKCk7XG4gICAgICAgICAgc3RlcCA9ICN7c3RlcC50b19mfS52YWx1ZU9mKCk7XG4gICAgICAgICAgbGltaXQgPSAje2xpbWl0LnRvX2Z9LnZhbHVlT2YoKTtcblxuICAgICAgICAgIHZhciBuID0gc3RlcEZsb2F0U2l6ZSgpO1xuXG4gICAgICAgICAgaWYgKCFpc0Zpbml0ZShzdGVwKSkge1xuICAgICAgICAgICAgaWYgKG4gIT09IDApIGJsb2NrKGJlZ2luKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGJsb2NrKGJlZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSBpICogc3RlcCArIHNlbGY7XG4gICAgICAgICAgICAgIGlmIChzdGVwID49IDAgPyBsaW1pdCA8IGQgOiBsaW1pdCA+IGQpIHtcbiAgICAgICAgICAgICAgICBkID0gbGltaXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYmxvY2soZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb3VudGVyID0gc2VsZlxuXG4gICAgd2hpbGUgYGlzRGVzYyA/ICN7Y291bnRlciA+PSBsaW1pdH0gOiAje2NvdW50ZXIgPD0gbGltaXR9YFxuICAgICAgeWllbGQgY291bnRlclxuICAgICAgY291bnRlciArPSBzdGVwXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19jXG4gICAgOjpLZXJuZWwuQ29tcGxleChzZWxmLCAwKVxuICBlbmRcblxuICBkZWYgdG9faW50XG4gICAgdG9faVxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUobmRpZ2l0cyA9IDApXG4gICAgdG9fZi50cnVuY2F0ZShuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgemVybz9cbiAgICBzZWxmID09IDBcbiAgZW5kXG5cbiAgZGVmIHBvc2l0aXZlP1xuICAgIHNlbGYgPiAwXG4gIGVuZFxuXG4gIGRlZiBuZWdhdGl2ZT9cbiAgICBzZWxmIDwgMFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICBuaWxcbiAgZW5kXG5cbiAgYWxpYXMgYXJnIGFuZ2xlXG4gIGFsaWFzIGNvbmp1Z2F0ZSBjb25qXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcbiAgYWxpYXMgbW9kdWxvICVcbiAgYWxpYXMgcGhhc2UgYXJnXG4gIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpOdW1lcmljPiIsImluY2x1ZGUiLCJDb21wYXJhYmxlIiwiY29lcmNlIiwib3RoZXIiLCJpbnN0YW5jZV9vZj8iLCJjbGFzcyIsIktlcm5lbCIsIkZsb2F0IiwiX19jb2VyY2VkX18iLCJtZXRob2QiLCJyZXNwb25kX3RvPyIsImEiLCJiIiwiX19zZW5kX18iLCJyYWlzZSIsIlR5cGVFcnJvciIsIkFyZ3VtZW50RXJyb3IiLCI8PT4iLCJlcXVhbD8iLCIwIiwiK0AiLCItQCIsIi0iLCIlIiwiKiIsImRpdiIsImFicyIsIjwiLCJhYnMyIiwiYW5nbGUiLCJNYXRoOjpQSSIsIk1hdGgiLCJjZWlsIiwibmRpZ2l0cyIsInRvX2YiLCJjb25qIiwiZGVub21pbmF0b3IiLCJ0b19yIiwiWmVyb0RpdmlzaW9uRXJyb3IiLCIvIiwiZmxvb3IiLCJkaXZtb2QiLCJmZGl2IiwiaSIsIkNvbXBsZXgiLCJpbWFnIiwiaW50ZWdlcj8iLCJub256ZXJvPyIsInplcm8/IiwibnVtZXJhdG9yIiwicG9sYXIiLCJhcmciLCJxdW8iLCJPcGFsIiwiY29lcmNlX3RvISIsIlJhdGlvbmFsIiwicmVhbCIsInJlYWw/IiwicmVjdCIsInJvdW5kIiwiZGlnaXRzIiwic3RlcCIsIj09IiwiRmxvYXQ6OklORklOSVRZIiwiY29tcGFyZSIsImxpbWl0IiwiRmxvYXQ6OkVQU0lMT04iLCJibG9ja19naXZlbj8iLCJpc19hPyIsIk51bWVyaWMiLCJFbnVtZXJhdG9yOjpBcml0aG1ldGljU2VxdWVuY2UiLCJFbnVtZXJhdG9yIiwibmV3IiwidG8iLCJieSIsImVudW1fZm9yIiwidG9fcHJvYyIsIm5lZ2F0aXZlPyIsImNvdW50ZXIiLCI+PSIsIjw9IiwiKyIsInRvX2MiLCJ0b19pbnQiLCJ0b19pIiwidHJ1bmNhdGUiLCJwb3NpdGl2ZT8iLCI+IiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwiZmluaXRlPyIsImluZmluaXRlPyJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7Ozs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEOztBQUVBRSxJQUFBQSxzQkFBQUEsa0JBQVdDLEtBQVhEO0FBQUFBLE1BQUFBOzs7TUFDRSxJQUFBLFFBQUdDLEtBQUtDLGlCQUFBQSxDQUFjUCxJQUFJUSxPQUFBQSxDQUFBQSxDQUFsQkQsQ0FBUixDQUFBO1FBQ0UsT0FBTyxDQUFDRCxLQUFELEVBQVFOLElBQVI7TUFEVDtNQUlBSyxPQUFBLENBQUNJLE9BQVFDLE9BQUFBLENBQU9KLEtBQVBJLENBQVQsRUFBd0JELE9BQVFDLE9BQUFBLENBQU9WLElBQVBVLENBQWhDO0lBTEZMLENBQUFBOztBQVFBTSxJQUFBQSwyQkFBQUEsdUJBQWdCQyxNQUFELEVBQVNOLEtBQXhCSztBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdMLEtBQUtPLGdCQUFBQSxDQUFhLFFBQWJBLENBQVIsQ0FBQTs7UUFDRSxLQUFPUCxLQUFLRCxRQUFBQSxDQUFRTCxJQUFSSyxDQUFaLGtCQUFBLEVBQUFTLENBQUFBLElBQUEsNkJBQUFBLENBQUEsRUFBR0MsQ0FBQUEsSUFBSCw2QkFBR0EsQ0FBSDtRQUNBSixPQUFBRyxDQUFDRSxVQUFBQSxDQUFVSixNQUFYLEVBQW1CRyxDQUFsQkM7TUFGSDtNQUtFLFFBREtKLE1BQ0w7UUFBQSxLQUFLLEdBQUw7UUFBQSxLQUFTLEdBQVQ7UUFBQSxLQUFhLEdBQWI7UUFBQSxLQUFpQixHQUFqQjtRQUFBLEtBQXFCLEdBQXJCO1FBQUEsS0FBeUIsR0FBekI7UUFBQSxLQUE2QixHQUE3QjtRQUFBLEtBQWlDLEdBQWpDO1FBQUEsS0FBcUMsSUFBckM7VUFDRUQsT0FBQUYsT0FBUVEsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNEIsRUFBQSxHQUFBLENBQUdaLEtBQUtFLE9BQUFBLENBQUFBLENBQVIsQ0FBQSxHQUFlRyxnQ0FBbkNNO1FBQ1YsS0FBSyxHQUFMO1FBQUEsS0FBUyxJQUFUO1FBQUEsS0FBYyxHQUFkO1FBQUEsS0FBa0IsSUFBbEI7UUFBQSxLQUF1QixLQUF2QjtVQUNFTixPQUFBRixPQUFRUSxPQUFBQSxDQUFPRSxvQkFBZixFQUFpQ1IsZ0JBQUQsR0FBQSxDQUFpQlgsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBckIsQ0FBQSxHQUE0QkcsUUFBNUIsR0FBQSxDQUFvQ0wsS0FBS0UsT0FBQUEsQ0FBQUEsQ0FBekMsQ0FBQSxHQUFnREcsU0FBeEVNO1FBRFY7VUFIQU4sT0FBQTtNQUNBO0lBTkpBLENBQUFBOztBQWNBUyxJQUFBQSxtQkFBQUEsOEJBQVFkLEtBQVJjO0FBQUFBLE1BQUFBOzs7TUFDRSxJQUFBLFFBQUdwQixJQUFBcUIsV0FBQUEsQ0FBT2YsS0FBUGUsQ0FBSCxDQUFBO1FBQ0UsT0FBT0M7TUFEVDtNQUlBRixPQUFBO0lBTEZBLENBQUFBOztBQVFBRyxJQUFBQSxrQkFBQUEsWUFBQUE7O0FBSUFDLElBQUFBLGtCQUFBQSw0QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUVDLFVBQUZILENBQUVHLEVBQUV6QixJQUFGeUI7SUFESkQsQ0FBQUE7O0FBSUFFLElBQUFBLGlCQUFBQSw2QkFBTXBCLEtBQU5vQjtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBS0QsVUFBTHpCLElBQUt5QixFQUFRRSxVQUFOckIsS0FBTXFCLEVBQUUzQixJQUFBNEIsS0FBQUEsQ0FBSXRCLEtBQUpzQixDQUFGRCxDQUFSRjtJQURQQyxDQUFBQTs7QUFJQUcsSUFBQUEsbUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUtDLE9BQUw5QixJQUFLOEIsRUFBRVIsQ0FBRlEsQ0FBTDtRQUFXRCxPQUFDN0IsSUFBRHdCLE9BQUFBLENBQUFBO01BQVg7UUFBbUJLLE9BQUE3QjtNQUFuQjtJQURGNkIsQ0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUtKLFVBQUwzQixJQUFLMkIsRUFBRTNCLElBQUYyQjtJQURQSSxDQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFLRixPQUFMOUIsSUFBSzhCLEVBQUVSLENBQUZRLENBQUw7UUFBV0UsT0FBQUMsSUFBQUMsV0FBQUQ7TUFBWDtRQUF3QkQsT0FBQVY7TUFBeEI7SUFERlUsQ0FBQUE7O0FBSUFHLElBQUFBLG9CQUFBQSxnQkFBU0MsT0FBVEQ7QUFBQUEsTUFBQUE7OztNQUFTLCtCQUFVYjtNQUNqQmEsT0FBQW5DLElBQUFxQyxNQUFBQSxDQUFBQSxDQUFJRixNQUFBQSxDQUFNQyxPQUFORDtJQUROQSxDQUFBQSxJQUFBQTs7QUFJQUcsSUFBQUEsb0JBQUFBLFlBQUFBOztBQUlBQyxJQUFBQSwyQkFBQUEsdUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBdkMsSUFBQXdDLE1BQUFBLENBQUFBLENBQUlELGFBQUFBLENBQUFBO0lBRE5BLENBQUFBOztBQUlBWCxJQUFBQSxtQkFBQUEsZUFBUXRCLEtBQVJzQjtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxNQUFzRHRCLEtBQXRELEVBQStEZ0IsQ0FBL0QsQ0FBQTtRQUFBYixPQUFRUSxPQUFBQSxDQUFPd0Isd0JBQWYsRUFBb0NiLGNBQTVCWDtNQUFSO01BRUFXLE9BQU1jLFdBQUwxQyxJQUFLMEMsRUFBRXBDLEtBQUZvQyxDQUFRQyxPQUFBQSxDQUFBQTtJQUhoQmYsQ0FBQUE7O0FBTUFnQixJQUFBQSxzQkFBQUEsa0JBQVd0QyxLQUFYc0M7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQzVDLElBQUE0QixLQUFBQSxDQUFJdEIsS0FBSnNCLENBQUQsRUFBYTVCLElBQUswQixNQUFBQSxDQUFFcEIsS0FBRm9CLENBQWxCO0lBREZrQixDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFTdkMsS0FBVHVDO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFLSCxXQUFMMUMsSUFBQXFDLE1BQUFBLENBQUFBLENBQUtLLEVBQUVwQyxLQUFGb0M7SUFEUEcsQ0FBQUE7O0FBSUFGLElBQUFBLHFCQUFBQSxpQkFBVVAsT0FBVk87QUFBQUEsTUFBQUE7OztNQUFVLCtCQUFVckI7TUFDbEJxQixPQUFBM0MsSUFBQXFDLE1BQUFBLENBQUFBLENBQUlNLE9BQUFBLENBQU9QLE9BQVBPO0lBRE5BLENBQUFBLElBQUFBOztBQUlBRyxJQUFBQSxpQkFBQUEsYUFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFyQyxPQUFRc0MsU0FBQUEsQ0FBU3pCLENBQWpCLEVBQW9CdEIsSUFBWitDO0lBRFZELENBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsWUFDRTFCLENBREYwQixDQUFBQTs7QUFJQUMsSUFBQUEsd0JBQUFBLFlBQ0UsS0FERkEsQ0FBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSxpQ0FBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFBbEQsSUFBQW1ELFVBQUFBLENBQUFBLENBQUEsQ0FBQTtRQUFRRCxPQUFBO01BQVI7UUFBY0EsT0FBQWxEO01BQWQ7SUFERmtELENBQUFBOztBQUlBRSxJQUFBQSx5QkFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBcEQsSUFBQXdDLE1BQUFBLENBQUFBLENBQUlZLFdBQUFBLENBQUFBO0lBRE5BLENBQUFBOztBQUlBQyxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLENBQUNyRCxJQUFBNkIsS0FBQUEsQ0FBQUEsQ0FBRCxFQUFNN0IsSUFBQXNELEtBQUFBLENBQUFBLENBQU47SUFERkQsQ0FBQUE7O0FBSUFFLElBQUFBLG1CQUFBQSxlQUFRakQsS0FBUmlEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUEyQ2IsV0FBM0NjLEtBQU1DLGVBQUFBLENBQVl6RCxJQUFsQixFQUF3QjBELGVBQXhCLEVBQW9DLE1BQTlCRCxDQUFxQ2YsRUFBRXBDLEtBQUZvQztJQUQ3Q2EsQ0FBQUE7O0FBSUFJLElBQUFBLG9CQUFBQSxZQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLFlBQ0UsSUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQzdELElBQUQsRUFBT3NCLENBQVA7SUFERnVDLENBQUFBOztBQUlBQyxJQUFBQSxxQkFBQUEsaUJBQVVDLE1BQVZEO0FBQUFBLE1BQUFBOzs7O01BQ0VBLE9BQUE5RCxJQUFBcUMsTUFBQUEsQ0FBQUEsQ0FBSXlCLE9BQUFBLENBQU9DLE1BQVBEO0lBRE5BLENBQUFBLElBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsZ0JBcklGLEVBcUlVLEVBcklWLEVBcUlVLEVBcklWLEVBcUlFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQXJJRjtNQUFBO01BQUE7O01BcUlXOztNQUFtQjs7TUFBa0I7O01BQWU7O0FBRS9EQTtBQUNBQSxRQUFVdkQsT0FBUVEsT0FBQUEsQ0FBT0Usb0JBQWYsRUFBZ0M2QyxtQkFBeEIvQztBQUNsQitDOztBQUVBQTtBQUNBQSxRQUFVdkQsT0FBUVEsT0FBQUEsQ0FBT0Usb0JBQWYsRUFBZ0M2QyxxQkFBeEIvQztBQUNsQitDOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSxVQUFZdkQsT0FBUVEsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNEI4QyxzQkFBcEIvQztBQUNwQitDOztBQUVBQSw0QkFBOEJBLElBQUtDLE9BQUFBLENBQUczQyxDQUFIMkMsQ0FBS0Q7QUFDeENBLFVBQVl2RCxPQUFRUSxPQUFBQSxDQUFPRSxvQkFBZixFQUFnQzZDLGlCQUF4Qi9DO0FBQ3BCK0M7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQSxtQkFBcUJBLElBQUs1QyxRQUFBQSxDQUFJRSxDQUFKRixDQUFNNEM7O0FBRWhDQTtBQUNBQSxVQUFZdkQsT0FBUVEsT0FBQUEsQ0FBT0Usb0JBQWYsRUFBaUM2QywwQkFBRCxHQUFBLENBQTJCQSxJQUFJeEQsT0FBQUEsQ0FBQUEsQ0FBL0IsQ0FBeEJTO0FBQ3BCK0M7O0FBRUFBO0FBQ0FBLDZCQUErQkUsSUFBQXhELFlBQUF3RCxhQUFrQkYsR0FBTUUsSUFBQXhELFlBQUF3RCxhQUFEMUMsT0FBQUEsQ0FBQUEsQ0FBbUJ3QztBQUN6RUE7O0FBRUFBLFFBQVVSLEtBQU1XLFNBQUFBLENBQVNuRSxJQUFmLEVBQXFCb0UsS0FBZkQ7QUFDaEJIOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSwrRUFBaUZLLElBQUEzRCxZQUFBMkQsWUFBaUJMOztBQUVsR0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7TUFFSSxLQUFPTSxlQUFQO1FBQ0UsSUFBRyxDQUFDLENBQUEsS0FBQ0YsS0FBRCxDQUFBLElBQUEsQ0FBQSxRQUFVQSxLQUFLRyxVQUFBQSxDQUFPQyxjQUFQRCxDQUFmLENBQUEsQ0FBQSxDQUFELElBQUEsQ0FDQyxDQUFBLEtBQUNQLElBQUQsQ0FBQSxJQUFBLENBQUEsUUFBU0EsSUFBSU8sVUFBQUEsQ0FBT0MsY0FBUEQsQ0FBYixDQUFBLENBQUEsQ0FERCxDQUFBLENBQUg7VUFHRSxPQUFPRSxJQUFBQyxpQkFBQUQsdUJBQWdDRSxLQUFBQSxDQUNyQyxDQUFDUCxLQUFELEVBQVFKLElBQVIsRUFBZSxDQUFBLFFBQVVZLEVBQVYsQ0FBQSxHQUFBLENBQUFaLE1BQUEsSUFBQSxHQUFBLENBQWYsRUFBK0IsQ0FBQSxRQUFVYSxFQUFWLENBQUEsR0FBQSxDQUFBYixNQUFBLElBQUEsR0FBQSxDQUEvQixDQURLLEVBQzBDaEUsSUFEVjJFO1FBSHpDO1VBT0UsT0FBT0csTUFBQTlFLElBQUE4RSxZQUFBQSxFQUFBQSxDQUFTLE1BQVQsRUFBZ0JWLEtBQWhCLEVBQXVCSixJQUF2QmMsQ0FBQUEsRUFBOEJkLENBQUNBLFFBQURBLENBQURlLFNBQUFBLENBQUFBLENBQTdCRDtRQVBUO01BREY7O0FBYUpkOztBQUVBQSxtQkFBcUJBLElBQUlnQixjQUFBQSxDQUFBQSxDQUFXaEI7QUFDcENBLGtCQUFvQkEsSUFBS0MsT0FBQUEsQ0FBRzNDLENBQUgyQyxDQUFLRDtBQUM5QkE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsc0JBQXdCaEUsSUFBQXFDLE1BQUFBLENBQUFBLENBQUsyQjtBQUM3QkEsaUJBQW1CQSxJQUFJM0IsTUFBQUEsQ0FBQUEsQ0FBTTJCO0FBQzdCQSxrQkFBb0JJLEtBQUsvQixNQUFBQSxDQUFBQSxDQUFNMkI7O0FBRS9CQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BRUlpQixVQUFVakY7TUFFVixPQUFBLFFBQU9nRSxTQUFtQmtCLE9BQVJELE9BQVFDLEVBQUdkLEtBQUhjLENBQVNsQixHQUFhbUIsT0FBUkYsT0FBUUUsRUFBR2YsS0FBSGUsQ0FBaEQsQ0FBQTs7UUFDRSxtQkFBTUYsT0FBTjtRQUNBQSxVQUFRRyxTQUFSSCxPQUFRRyxFQUFHcEIsSUFBSG9CO01BRlY7SUFoS0ZwQixDQUFBQSxJQUFBQTs7QUFzS0FxQixJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBNUUsT0FBUXNDLFNBQUFBLENBQVMvQyxJQUFqQixFQUF1QnNCLENBQWZ5QjtJQURWc0MsQ0FBQUE7O0FBSUFDLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF0RixJQUFBdUYsTUFBQUEsQ0FBQUE7SUFERkQsQ0FBQUE7O0FBSUFFLElBQUFBLHdCQUFBQSxvQkFBYXBELE9BQWJvRDtBQUFBQSxNQUFBQTs7O01BQWEsK0JBQVVsRTtNQUNyQmtFLE9BQUF4RixJQUFBcUMsTUFBQUEsQ0FBQUEsQ0FBSW1ELFVBQUFBLENBQVVwRCxPQUFWb0Q7SUFETkEsQ0FBQUEsSUFBQUE7O0FBSUFyQyxJQUFBQSxxQkFBQUEsOEJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBbkQsSUFBS2lFLE9BQUFBLENBQUczQyxDQUFIMkM7SUFEUGQsQ0FBQUE7O0FBSUFzQyxJQUFBQSx5QkFBQUEsa0NBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFLQyxPQUFMMUYsSUFBSzBGLEVBQUVwRSxDQUFGb0U7SUFEUEQsQ0FBQUE7O0FBSUFULElBQUFBLHlCQUFBQSxrQ0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUtsRCxPQUFMOUIsSUFBSzhCLEVBQUVSLENBQUZRO0lBRFBrRCxDQUFBQTs7QUFJQVcsSUFBQUEsbUJBQUFBLFlBQUFBOztBQUlBQyxJQUFBQSxxQkFBQUEsaUJBdlVGQyxPQXVVRUQ7QUFBQUEsTUFBQUE7OztNQXZVRjs7TUF1VVksa0NBQUEsNkJBQVE7TUFDaEJBLE9BQUE1RjtJQURGNEYsQ0FBQUEsSUFBQUE7O0FBSUFFLElBQUFBLHVCQUFBQSxZQUNFLElBREZBLENBQUFBOztBQUlBQyxJQUFBQSx5QkFBQUEsWUFDRSxHQURGQSxDQUFBQTtJQUlBLGFBQU0sS0FBTixFQUFVLE9BQVY7SUFDQSxhQUFNLFdBQU4sRUFBZ0IsTUFBaEI7SUFDQSxhQUFNLFdBQU4sRUFBZ0IsTUFBaEI7SUFDQSxhQUFNLFdBQU4sRUFBZ0IsS0FBaEI7SUFDQSxhQUFNLFFBQU4sRUFBYSxHQUFiO0lBQ0EsYUFBTSxPQUFOLEVBQVksS0FBWjtJQUNBN0YsT0FBQSxhQUFNLGFBQU4sRUFBa0IsTUFBbEI7RUF2VkZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyNjQ3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9hcnJheS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgZmFsc3ksIGhhc2hfaWRzLCB5aWVsZDEsIGhhc2hfZ2V0LCBoYXNoX3B1dCwgaGFzaF9kZWxldGUsIGNvZXJjZV90bywgcmVzcG9uZF90bywgZGVueV9mcm96ZW5fYWNjZXNzLCBmcmVlemVcblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyA6OkFycmF5IDwgYEFycmF5YFxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gICMgTWFyayBhbGwgamF2YXNjcmlwdCBhcnJheXMgYXMgYmVpbmcgdmFsaWQgcnVieSBhcnJheXNcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19hcnJheScsIHRydWUpYFxuXG4gICV4e1xuICAgIC8vIFJlY2VudCB2ZXJzaW9ucyBvZiBWOCAoPiA3LjEpIG9ubHkgdXNlIGFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyB1bm1vZGlmaWVkLlxuICAgIC8vIEZvciBpbnN0YW5jZSwgXCJhcnJheS1zcGxpY2UudHFcIiBoYXMgYSBcImZhc3QgcGF0aFwiIChFeHRyYWN0RmFzdEpTQXJyYXksIGRlZmluZWQgaW4gXCJzcmMvY29kZWdlbi9jb2RlLXN0dWItYXNzZW1ibGVyLmNjXCIpXG4gICAgLy8gYnV0IGl0J3Mgb25seSBlbmFibGVkIHdoZW4gXCJJc1Byb3RvdHlwZUluaXRpYWxBcnJheVByb3RvdHlwZSgpXCIgaXMgdHJ1ZS5cbiAgICAvL1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIFY4IHdlcmUgdXNpbmcgcmVsYXRpdmVseSBmYXN0IEpTLXdpdGgtZXh0ZW5zaW9ucyBjb2RlIGV2ZW4gd2hlbiBBcnJheS5wcm90b3R5cGUgaXMgbW9kaWZpZWQ6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNy4wLjEvc3JjL2pzL2FycmF5LmpzI0w1OTktTDY0MlxuICAgIC8vXG4gICAgLy8gSW4gc2hvcnQsIEFycmF5IG9wZXJhdGlvbnMgYXJlIHNsb3cgaW4gcmVjZW50IHZlcnNpb25zIG9mIFY4IHdoZW4gdGhlIEFycmF5LnByb3RvdHlwZSBoYXMgYmVlbiB0YW1wZXJlZC5cbiAgICAvLyBTbywgd2hlbiBwb3NzaWJsZSwgd2UgYXJlIHVzaW5nIGZhc3RlciBvcGVuLWNvZGVkIHZlcnNpb24gdG8gYm9vc3QgdGhlIHBlcmZvcm1hbmNlLlxuXG4gICAgLy8gQXMgb2YgVjggOC40LCBkZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgdGhlIGFycmF5LCB0aGlzIGlzIHVwIHRvIH4yNXggdGltZXMgZmFzdGVyIHRoYW4gQXJyYXkjc2hpZnQoKVxuICAgIC8vIEltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgaW5zcGlyZWQgYnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2JhNjg0ODA1YjZjMGVkZWQ3NmU1Y2Q4OWVlMDAzMjhhYzdhNTkzNjUvbGliL2ludGVybmFsL3V0aWwuanMjTDM0MS1MMzQ3XG4gICAgZnVuY3Rpb24gc2hpZnROb0FyZyhsaXN0KSB7XG4gICAgICB2YXIgciA9IGxpc3RbMF07XG4gICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGxpc3RbaW5kZXggLSAxXSA9IGxpc3RbaW5kZXhdO1xuICAgICAgfVxuICAgICAgbGlzdC5wb3AoKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXlTdWJjbGFzcyhvYmosIGtsYXNzKSB7XG4gICAgICBpZiAoa2xhc3MuJCRuYW1lID09PSBPcGFsLkFycmF5KSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2xhc3MuJGFsbG9jYXRlKCkuJHJlcGxhY2UoI3tgb2JqYC50b19hfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQSBoZWxwZXIgZm9yIGtlZXBfaWYgYW5kIGRlbGV0ZV9pZiwgZmlsdGVyIGlzIGVpdGhlciBPcGFsLnRydXRoeVxuICAgIC8vIG9yIE9wYWwuZmFsc3kuXG4gICAgZnVuY3Rpb24gZmlsdGVySWYoc2VsZiwgZmlsdGVyLCBibG9jaykge1xuICAgICAgdmFyIHZhbHVlLCByYWlzZWQgPSBudWxsLCB1cGRhdGVkID0gbmV3IEFycmF5KHNlbGYubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGkyID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXJhaXNlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pXG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgcmFpc2VkID0gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJhaXNlZCB8fCBmaWx0ZXIodmFsdWUpKSB7XG4gICAgICAgICAgdXBkYXRlZFtpMl0gPSBzZWxmW2ldXG4gICAgICAgICAgaTIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaTIgIT09IGkpIHtcbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgWzAsIHVwZGF0ZWQubGVuZ3RoXS5jb25jYXQodXBkYXRlZCkpO1xuICAgICAgICBzZWxmLnNwbGljZShpMiwgdXBkYXRlZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFpc2VkKSB0aHJvdyByYWlzZWQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYuW10oKm9iamVjdHMpXG4gICAgYHRvQXJyYXlTdWJjbGFzcyhvYmplY3RzLCBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoc2l6ZSA9IG5pbCwgb2JqID0gbmlsLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAob2JqICE9PSBuaWwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLndhcm4oJ3dhcm5pbmc6IGJsb2NrIHN1cGVyc2VkZXMgZGVmYXVsdCB2YWx1ZSBhcmd1bWVudCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA+ICN7OjpJbnRlZ2VyOjpNQVh9KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXJyYXkgc2l6ZSB0b28gYmlnJ31cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMilcIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHNpemUuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2EpfVxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9IGVsc2UgaWYgKCN7c2l6ZS5yZXNwb25kX3RvPyA6dG9fYXJ5fSkge1xuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2FyeSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2l6ZSA9ICRjb2VyY2VfdG8oc2l6ZSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfVxuICAgICAgfVxuXG4gICAgICBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICB2YXIgaSwgdmFsdWU7XG5cbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICBzZWxmLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDAsIHZhbHVlOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBibG9jayhpKTtcbiAgICAgICAgICBzZWxmW2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydChvYmopXG4gICAgOjpPcGFsLmNvZXJjZV90bz8gb2JqLCA6OkFycmF5LCA6dG9fYXJ5XG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShoYXNoLCBpdGVtKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBzZWxmW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2guJGtleXMoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIHJldHVybiBqb2luKG90aGVyLnRvX3N0cikgaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX3N0clxuXG4gICAgb3RoZXIgPSBgJGNvZXJjZV90byhvdGhlciwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgb3RoZXIgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJndW1lbnQnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBjb252ZXJ0ZWQgPSAje3RvX2F9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjb252ZXJ0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBpZiA6OkFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAjezo6QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgYHNlbGYuY29uY2F0KG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgb3RoZXIgPSBpZiA6OkFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAjezo6QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICByZXR1cm4gYHNlbGYuc2xpY2UoKWAgaWYgYG90aGVyLmxlbmd0aCA9PT0gMGBcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBpdGVtKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PChvYmplY3QpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG4gICAgYHNlbGYucHVzaChvYmplY3QpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIDo6QXJyYXkgPT09IG90aGVyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FcbiAgICBlbHNpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fYXJ5XG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FyeS50b19hXG4gICAgZWxzZVxuICAgICAgcmV0dXJuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICgje2hhc2h9ID09PSAje290aGVyLmhhc2h9KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihzZWxmLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB0bXAgPSAje2BzZWxmW2ldYCA8PT4gYG90aGVyW2ldYH07XG5cbiAgICAgICAgaWYgKHRtcCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YHNlbGYubGVuZ3RoYCA8PT4gYG90aGVyLmxlbmd0aGB9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKGFycmF5LCBvdGhlcikge1xuICAgICAgICB2YXIgaSwgbGVuZ3RoLCBhLCBiO1xuXG4gICAgICAgIGlmIChhcnJheSA9PT0gb3RoZXIpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgaWYgKCRyZXNwb25kX3RvKG90aGVyLCAnJHRvX2FyeScpKSB7XG4gICAgICAgICAgICByZXR1cm4gI3tgb3RoZXJgID09IGBhcnJheWB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycmF5LiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuICAgICAgICBpZiAob3RoZXIuJCRjb25zdHJ1Y3RvciAhPT0gQXJyYXkpXG4gICAgICAgICAgb3RoZXIgPSAje2BvdGhlcmAudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAgPT0gYGJgfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgaW5kZXgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgZXhjbHVkZSA9IGluZGV4LmV4Y2w7XG4gICAgICBmcm9tICAgID0gaW5kZXguYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcbiAgICAgIHRvICAgICAgPSBpbmRleC5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhpbmRleC5lbmQsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4LmV4Y2xfcmV2ICYmIGluZGV4LmJlZ2luICE9PSBuaWwpIHtcbiAgICAgICAgZnJvbSArPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSA+IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICB0byArPSBzaXplO1xuXG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFleGNsdWRlIHx8IGluZGV4LmVuZCA9PT0gbmlsKSB7XG4gICAgICAgIHRvICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoZnJvbSwgdG8pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfYXJpdGhtZXRpY19zZXEoc2VsZiwgaW5kZXgpIHtcbiAgICAgIHZhciBhcnJheSwgb3V0ID0gW10sIGkgPSAwLCBwc2V1ZG9yYW5nZTtcblxuICAgICAgaWYgKGluZGV4LnN0ZXAgPCAwKSB7XG4gICAgICAgIHBzZXVkb3JhbmdlID0ge1xuICAgICAgICAgIGJlZ2luOiBpbmRleC5yYW5nZS5lbmQsXG4gICAgICAgICAgZW5kOiBpbmRleC5yYW5nZS5iZWdpbixcbiAgICAgICAgICBleGNsOiBmYWxzZSxcbiAgICAgICAgICBleGNsX3JldjogaW5kZXgucmFuZ2UuZXhjbFxuICAgICAgICB9O1xuICAgICAgICBhcnJheSA9ICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBwc2V1ZG9yYW5nZSkuJHJldmVyc2UoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhcnJheSA9ICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleC5yYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIG91dC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgaSArPSBNYXRoLmFicyhpbmRleC5zdGVwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfaW5kZXhfbGVuZ3RoKHNlbGYsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBpbmRleCA+IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICByZXR1cm4gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGluZGV4LiQkaXNfYXJpdGhtZXRpY19zZXEpIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9hcml0aG1ldGljX3NlcShzZWxmLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9pbmRleF9sZW5ndGgoc2VsZiwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSwgZXh0cmEgPSB1bmRlZmluZWQpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBkYXRhID0gbmlsXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc2l6ZSA9IHNlbGYubGVuZ3RoO1xuXG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSlcbiAgICAgICAgICBkYXRhID0gI3t2YWx1ZS50b19hfTtcbiAgICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fYXJ5fSlcbiAgICAgICAgICBkYXRhID0gI3t2YWx1ZS50b19hcnkudG9fYX07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBkYXRhID0gW3ZhbHVlXTtcblxuICAgICAgICB2YXIgZXhjbHVkZSA9IGluZGV4LmV4Y2wsXG4gICAgICAgICAgICBmcm9tICAgID0gaW5kZXguYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKSxcbiAgICAgICAgICAgIHRvICAgICAgPSBpbmRleC5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhpbmRleC5lbmQsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIGZyb20gKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiI3tpbmRleC5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHRvICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUgfHwgaW5kZXguZW5kID09PSBuaWwpIHtcbiAgICAgICAgICB0byArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGZyb207IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIDBdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIHRvIC0gZnJvbV0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChleHRyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3tsZW5ndGggPSAxfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlICA9IGV4dHJhO1xuXG4gICAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpXG4gICAgICAgICAgICBkYXRhID0gI3t2YWx1ZS50b19hfTtcbiAgICAgICAgICBlbHNlIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/IDp0b19hcnl9KVxuICAgICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYXJ5LnRvX2F9O1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRhdGEgPSBbdmFsdWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZDtcblxuICAgICAgICBpbmRleCAgPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgbGVuZ3RoID0gJGNvZXJjZV90byhsZW5ndGgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBvbGQgICAgPSBpbmRleDtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tgb2xkYH0gdG9vIHNtYWxsIGZvciBhcnJheTsgbWluaW11bSAje2Atc2VsZi5sZW5ndGhgfVwifTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm5lZ2F0aXZlIGxlbmd0aCAoI3tsZW5ndGh9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID4gc2l6ZSkge1xuICAgICAgICAgIGZvciAoaSA9IHNpemU7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmW2ldID0gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZltpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNwbGljZS5hcHBseShzZWxmLCBbaW5kZXgsIGxlbmd0aF0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBgaWYgKHNlbGYubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VgXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVtID0gc2VsZltpXSwgaXRlbS5sZW5ndGggJiYgI3tgaXRlbVswXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXQoaW5kZXgpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpXG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2hfaW5kZXgoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6YnNlYXJjaF9pbmRleCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBtaW4gPSAwLFxuICAgICAgICAgIG1heCA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIG1pZCxcbiAgICAgICAgICB2YWwsXG4gICAgICAgICAgcmV0LFxuICAgICAgICAgIHNtYWxsZXIgPSBmYWxzZSxcbiAgICAgICAgICBzYXRpc2ZpZWQgPSBuaWw7XG5cbiAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICAgICAgbWlkID0gbWluICsgTWF0aC5mbG9vcigobWF4IC0gbWluKSAvIDIpO1xuICAgICAgICB2YWwgPSBzZWxmW21pZF07XG4gICAgICAgIHJldCA9ICR5aWVsZDEoYmxvY2ssIHZhbCk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNhdGlzZmllZCA9IG1pZDtcbiAgICAgICAgICBzbWFsbGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQgPT09IGZhbHNlIHx8IHJldCA9PT0gbmlsKSB7XG4gICAgICAgICAgc21hbGxlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJldC4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmIChyZXQgPT09IDApIHsgcmV0dXJuIG1pZDsgfVxuICAgICAgICAgIHNtYWxsZXIgPSAocmV0IDwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YHJldGAuY2xhc3N9IChtdXN0IGJlIG51bWVyaWMsIHRydWUsIGZhbHNlIG9yIG5pbClcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbWFsbGVyKSB7IG1heCA9IG1pZDsgfSBlbHNlIHsgbWluID0gbWlkICsgMTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2F0aXNmaWVkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6YnNlYXJjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBpbmRleCA9IGJzZWFyY2hfaW5kZXgoJmJsb2NrKVxuXG4gICAgJXh7XG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiBpbmRleC4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY3ljbGUobiA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6Y3ljbGUsIG4pIGRvXG4gICAgICAgIGlmIG4ubmlsP1xuICAgICAgICAgIDo6RmxvYXQ6OklORklOSVRZXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gOjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgICAgIG4gPiAwID8gZW51bWVyYXRvcl9zaXplICogbiA6IDBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJldHVybiBpZiBlbXB0eT8gfHwgbiA9PSAwXG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBpZiAobiA9PT0gbmlsKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuID0gI3s6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBvYmplY3QgIT09IHVuZGVmaW5lZGAgfHwgYmxvY2tcbiAgICAgIHN1cGVyXG4gICAgZWxzZVxuICAgICAgc2l6ZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICAgIHJlcGxhY2Ugb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29sbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGJpbm9taWFsX2NvZWZmaWNpZW50KG4sIGspIHtcbiAgICAgIGlmIChuID09PSBrIHx8IGsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChrID4gMCAmJiBuID4gaykge1xuICAgICAgICByZXR1cm4gYmlub21pYWxfY29lZmZpY2llbnQobiAtIDEsIGsgLSAxKSArIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgZGVmIGNvbWJpbmF0aW9uKG4pXG4gICAgbnVtID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudCgje3NlbGZ9Lmxlbmd0aCwgbnVtKWAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHN0YWNrLCBjaG9zZW4sIGxldiwgZG9uZSwgbmV4dDtcblxuICAgICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAje3lpZWxkIFtdfVxuICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7eWllbGQgYFtzZWxmW2ldXWB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5zbGljZSgpYH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA+PSAwICYmIG51bSA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbnVtICsgMTsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNob3NlbiA9IFtdO1xuICAgICAgICBsZXYgPSAwO1xuICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIHN0YWNrWzBdID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW3N0YWNrW2xldisxXV07XG4gICAgICAgICAgd2hpbGUgKGxldiA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgIGxldisrO1xuICAgICAgICAgICAgbmV4dCA9IHN0YWNrW2xldisxXSA9IHN0YWNrW2xldl0gKyAxO1xuICAgICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW25leHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAjeyB5aWVsZCBgY2hvc2VuLnNsaWNlKClgIH1cbiAgICAgICAgICBsZXYrKztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkb25lID0gKGxldiA9PT0gMCk7XG4gICAgICAgICAgICBzdGFja1tsZXZdKys7XG4gICAgICAgICAgICBsZXYtLTtcbiAgICAgICAgICB9IHdoaWxlICggc3RhY2tbbGV2KzFdICsgbnVtID09PSBzZWxmLmxlbmd0aCArIGxldiArIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBlYXRlZF9jb21iaW5hdGlvbihuKVxuICAgIG51bSA9IDo6T3BhbC5jb2VyY2VfdG8hIG4sIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpyZXBlYXRlZF9jb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudChzZWxmLmxlbmd0aCArIG51bSAtIDEsIG51bSlgIH1cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gaXRlcmF0ZShtYXgsIGZyb20sIGJ1ZmZlciwgc2VsZikge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBtYXgpIHtcbiAgICAgICAgICB2YXIgY29weSA9IGJ1ZmZlci5zbGljZSgpO1xuICAgICAgICAgICN7eWllbGQgYGNvcHlgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXIucHVzaChzZWxmW2ldKTtcbiAgICAgICAgICBpdGVyYXRlKG1heCwgaSwgYnVmZmVyLCBzZWxmKTtcbiAgICAgICAgICBidWZmZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG51bSA+PSAwKSB7XG4gICAgICAgIGl0ZXJhdGUobnVtLCAwLCBbXSwgc2VsZik7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChpdGVtID0gc2VsZltpXSkgIT09IG5pbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZltpXSA9PT0gbmlsKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uY2F0KCpvdGhlcnMpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBvdGhlcnMgPSBvdGhlcnMubWFwIGRvIHxvdGhlcnxcbiAgICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgICBpZiBvdGhlci5lcXVhbD8oc2VsZilcbiAgICAgICAgb3RoZXIgPSBvdGhlci5kdXBcbiAgICAgIGVuZFxuXG4gICAgICBvdGhlclxuICAgIGVuZFxuXG4gICAgb3RoZXJzLmVhY2ggZG8gfG90aGVyfFxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvdGhlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShvYmplY3QpXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCkge1xuICAgICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XG4gICAgICAgICAgcmV0dXJuICN7eWllbGR9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9hdChpbmRleClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHNlbGZbaW5kZXhdO1xuXG4gICAgICBzZWxmLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmRlbGV0ZV9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZmlsdGVySWYoc2VsZiwgJGZhbHN5LCBibG9jaylcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGlmZmVyZW5jZSgqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodG9fYS5kdXApIHsgfGEsIGJ8IGEgLSBiIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhpZHgsICppZHhzKVxuICAgIGl0ZW0gPSBzZWxmW2lkeF1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBpZHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcbiAgICBlbmRcblxuICAgIGl0ZW0uZGlnKCppZHhzKVxuICBlbmRcblxuICBkZWYgZHJvcChudW1iZXIpXG4gICAgJXh7XG4gICAgICBudW1iZXIgPSAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShudW1iZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSAmJlxuICAgICAgICAgIHNlbGYuJCRjbGFzcy4kYWxsb2NhdGUuJCRwcmlzdGluZSAmJlxuICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2luZGV4KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxbChhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoIW90aGVyLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9ICN7b3RoZXIudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWwoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZldGNoKGluZGV4LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gaW5kZXg7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhvcmlnaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IDAuLi4wXCJ9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tgb3JpZ2luYWxgfSBvdXRzaWRlIG9mIGFycmF5IGJvdW5kczogLSN7YHNlbGYubGVuZ3RoYH0uLi4je2BzZWxmLmxlbmd0aGB9XCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIGJsb2NrXG4gICAgICBpZiBgYXJncy5sZW5ndGggPiAyYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDAuLjIpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvbmUsIHR3byA9IGFyZ3NcbiAgICBlbHNlXG4gICAgICBpZiBgYXJncy5sZW5ndGggPT0gMGBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknXG4gICAgICBlbHNpZiBgYXJncy5sZW5ndGggPiAzYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDEuLjMpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvYmosIG9uZSwgdHdvID0gYXJnc1xuICAgIGVuZFxuXG4gICAgaWYgOjpSYW5nZSA9PT0gb25lXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2xlbmd0aCBpbnZhbGlkIHdpdGggcmFuZ2UnIGlmIHR3b1xuXG4gICAgICBsZWZ0ICAgPSBgb25lLmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhvbmUuYmVnaW4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYGxlZnQgKz0gdGhpcy5sZW5ndGhgIGlmIGBsZWZ0IDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCIje29uZS5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIiBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIHJpZ2h0ID0gYG9uZS5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhvbmUuZW5kLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGByaWdodCArPSB0aGlzLmxlbmd0aGAgaWYgYHJpZ2h0IDwgMGBcbiAgICAgIGByaWdodCArPSAxYCB1bmxlc3Mgb25lLmV4Y2x1ZGVfZW5kP1xuXG4gICAgICByZXR1cm4gc2VsZiBpZiBgcmlnaHQgPD0gbGVmdGBcbiAgICBlbHNpZiBvbmVcbiAgICAgIGxlZnQgICA9IGAkY29lcmNlX3RvKG9uZSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgbGVmdCArPSB0aGlzLmxlbmd0aGAgaWYgYGxlZnQgPCAwYFxuICAgICAgbGVmdCAgID0gMCBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIGlmIHR3b1xuICAgICAgICByaWdodCA9IGAkY29lcmNlX3RvKHR3bywgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0ID09IDBgXG5cbiAgICAgICAgYHJpZ2h0ICs9IGxlZnRgXG4gICAgICBlbHNlXG4gICAgICAgIHJpZ2h0ID0gYHRoaXMubGVuZ3RoYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgbGVmdCAgPSAwXG4gICAgICByaWdodCA9IGB0aGlzLmxlbmd0aGBcbiAgICBlbmRcblxuICAgIGlmIGBsZWZ0ID4gdGhpcy5sZW5ndGhgXG4gICAgICAleHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGg7IGkgPCByaWdodDsgaSsrKSB7XG4gICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgaWYgYHJpZ2h0ID4gdGhpcy5sZW5ndGhgXG4gICAgICBgdGhpcy5sZW5ndGggPSByaWdodGBcbiAgICBlbmRcblxuICAgIGlmIGJsb2NrXG4gICAgICAleHtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGxlZnQpO1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSAje29ian07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZpcnN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZlswXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4obGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBfZmxhdHRlbihhcnJheSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuZ3RoLFxuICAgICAgICAgICAgaXRlbSwgYXJ5O1xuXG4gICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGFycmF5W2ldO1xuXG4gICAgICAgICAgaWYgKCEkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScsIHRydWUpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFyeSA9ICN7YGl0ZW1gLnRvX2FyeX07XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFyeSA9PT0gc2VsZikge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoX2ZsYXR0ZW4oYXJ5KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX2ZsYXR0ZW4oYXJ5LCBsZXZlbCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwgPSAkY29lcmNlX3RvKGxldmVsLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9mbGF0dGVuKHNlbGYsIGxldmVsKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuIShsZXZlbCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBmbGF0dGVuZWQgPSAje2ZsYXR0ZW4gbGV2ZWx9O1xuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT0gZmxhdHRlbmVkLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzZWxmW2ldICE9PSBmbGF0dGVuZWRbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID09IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3tyZXBsYWNlIGBmbGF0dGVuZWRgfTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XG5cbiAgICBgJGZyZWV6ZShzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoJGhhc2hfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnQSddLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICBpdGVtLCBpLCBrZXk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAkaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGZvciByZWN1cnNpdmUgc3RydWN0dXJlc1xuICAgICAgICBpZiAoJGhhc2hfaWRzW2hhc2hfaWRdKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluICRoYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSAkaGFzaF9pZHNba2V5XTtcbiAgICAgICAgICBpZiAoI3tlcWw/KGBpdGVtYCl9KSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRoYXNoX2lkc1toYXNoX2lkXSA9IHNlbGY7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtLiRoYXNoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsJyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgJGhhc2hfaWRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obWVtYmVyKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG1lbWJlcn0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDppbmRleH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zZXJ0KGluZGV4LCAqb2JqZWN0cylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICN7IDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCIje2luZGV4fSBpcyBvdXQgb2YgYm91bmRzXCIgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5sZW5ndGg7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLnB1c2gobmlsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNwbGljZS5hcHBseShzZWxmLCBbaW5kZXgsIDBdLmNvbmNhdChvYmplY3RzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBgdmFyIGluc3BlY3Rfc3RhY2sgPSBbXWBcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgaWQgPSAje19faWRfX30sXG4gICAgICBwdXNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGJlZ2luXG4gICAgICAleHtcbiAgICAgICAgaWYgKGluc3BlY3Rfc3RhY2suaW5kZXhPZihpZCkgIT09IC0xKSB7XG4gICAgICAgICAgcHVzaGVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuICdbLi4uXSc7XG4gICAgICAgIH1cbiAgICAgICAgaW5zcGVjdF9zdGFjay5wdXNoKGlkKVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSAje3NlbGZbYGlgXX07XG5cbiAgICAgICAgICByZXN1bHQucHVzaCgje09wYWwuaW5zcGVjdChgaXRlbWApfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG4gICAgICB9XG4gICAgICBuaWxcbiAgICBlbnN1cmVcbiAgICAgIGBpZiAocHVzaGVkKSBpbnNwZWN0X3N0YWNrLnBvcCgpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW50ZXJzZWN0aW9uKCphcnJheXMpXG4gICAgYXJyYXlzLnJlZHVjZSh0b19hLmR1cCkgeyB8YSwgYnwgYSAmIGIgfVxuICBlbmRcblxuICBkZWYgaW50ZXJzZWN0PyhvdGhlcilcbiAgICAhaW50ZXJzZWN0aW9uKG90aGVyKS5lbXB0eT9cbiAgZW5kXG5cbiAgZGVmIGpvaW4oc2VwID0gbmlsKVxuICAgIHJldHVybiAnJyBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBpZiBgc2VwID09PSBuaWxgXG4gICAgICBzZXAgPSAkLFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgaSwgbGVuZ3RoLCBpdGVtLCB0bXA7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fc3RyJykpIHtcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19zdHJ9O1xuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgje2B0bXBgLnRvX3N9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fYXJ5JykpIHtcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19hcnl9O1xuXG4gICAgICAgICAgaWYgKHRtcCA9PT0gc2VsZikge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC5qb2luKHNlcCl9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fcycpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc307XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOb01ldGhvZEVycm9yLm5ldyhcIiN7T3BhbC5pbnNwZWN0KGl0ZW0pfSBkb2Vzbid0IHJlc3BvbmQgdG8gI3RvX3N0ciwgI3RvX2FyeSBvciAjdG9fc1wiLCAndG9fc3RyJyl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VwID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oI3s6Ok9wYWwuY29lcmNlX3RvIShzZXAsIDo6U3RyaW5nLCA6dG9fc3RyKS50b19zfSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYga2VlcF9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDprZWVwX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBmaWx0ZXJJZihzZWxmLCAkdHJ1dGh5LCBibG9jaylcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2Uoc2VsZi5sZW5ndGggLSBjb3VudCwgc2VsZi5sZW5ndGgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGBzZWxmLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIG1heChuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgZWFjaC5tYXgobiwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWluKCZibG9jaylcbiAgICBlYWNoLm1pbigmYmxvY2spXG4gIGVuZFxuXG4gICV4e1xuICAgIC8vIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgZnJvbSwgZnJvbS0xLCAuLi4sIGZyb20gLSBob3dfbWFueSArIDEuXG4gICAgZnVuY3Rpb24gZGVzY2VuZGluZ19mYWN0b3JpYWwoZnJvbSwgaG93X21hbnkpIHtcbiAgICAgIHZhciBjb3VudCA9IGhvd19tYW55ID49IDAgPyAxIDogMDtcbiAgICAgIHdoaWxlIChob3dfbWFueSkge1xuICAgICAgICBjb3VudCAqPSBmcm9tO1xuICAgICAgICBmcm9tLS07XG4gICAgICAgIGhvd19tYW55LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIHBlcm11dGF0aW9uKG51bSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6cGVybXV0YXRpb24sIG51bSkgZG9cbiAgICAgICAgYGRlc2NlbmRpbmdfZmFjdG9yaWFsKHNlbGYubGVuZ3RoLCBudW0gPT09IHVuZGVmaW5lZCA/IHNlbGYubGVuZ3RoIDogbnVtKWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcGVybXV0ZSwgb2ZmZW5zaXZlLCBvdXRwdXQ7XG5cbiAgICAgIGlmIChudW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBudW0gPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBudW0gPSAkY29lcmNlX3RvKG51bSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW0gPCAwIHx8IHNlbGYubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIC8vIG5vIHBlcm11dGF0aW9ucywgeWllbGQgbm90aGluZ1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAwKSB7XG4gICAgICAgIC8vIGV4YWN0bHkgb25lIHBlcm11dGF0aW9uOiB0aGUgemVyby1sZW5ndGggYXJyYXlcbiAgICAgICAgI3sgeWllbGQgW10gfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLCBlYXN5IGNhc2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3sgeWllbGQgYFtzZWxmW2ldXWAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZ2VuZXJhbCBjYXNlXG4gICAgICAgICN7IHBlcm0gPSBBcnJheS5uZXcobnVtKSB9O1xuICAgICAgICAjeyB1c2VkID0gQXJyYXkubmV3KGBzZWxmLmxlbmd0aGAsIGZhbHNlKSB9O1xuXG4gICAgICAgIHBlcm11dGUgPSBmdW5jdGlvbihudW0sIHBlcm0sIGluZGV4LCB1c2VkLCBibGspIHtcbiAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZigjeyAhdXNlZFtgaWBdIH0pIHtcbiAgICAgICAgICAgICAgcGVybVtpbmRleF0gPSBpO1xuICAgICAgICAgICAgICBpZihpbmRleCA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCBpbmRleCArIDEsIHVzZWQsIGJsayk7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVybS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2VsZltwZXJtW2pdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR5aWVsZDEoYmxrLCBvdXRwdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICAgIC8vIG9mZmVuc2l2ZSAoYm90aCBkZWZpbml0aW9ucykgY29weS5cbiAgICAgICAgICBvZmZlbnNpdmUgPSBzZWxmLnNsaWNlKCk7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKG9mZmVuc2l2ZSwgbnVtLCBwZXJtLCAwLCB1c2VkLCBibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKHNlbGYsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVwZWF0ZWRfcGVybXV0YXRpb24obilcbiAgICBudW0gPSA6Ok9wYWwuY29lcmNlX3RvISBuLCA6OkludGVnZXIsIDp0b19pbnRcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX3Blcm11dGF0aW9uLCBudW0pIHsgbnVtID49IDAgPyBzaXplKipudW0gOiAwIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpdGVyYXRlKG51bSwgW10sIHNlbGYuc2xpY2UoKSk7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG9wKGNvdW50ID0gdW5kZWZpbmVkKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG4gICAgICByZXR1cm4gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgICAgcmV0dXJuIGBzZWxmLnBvcCgpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgY291bnQgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBpZiBgY291bnQgPT09IDFgXG4gICAgICBgW3NlbGYucG9wKCldYFxuICAgIGVsc2lmIGBjb3VudCA+IHNlbGYubGVuZ3RoYFxuICAgICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcbiAgICBlbHNlXG4gICAgICBgc2VsZi5zcGxpY2Uoc2VsZi5sZW5ndGggLSBjb3VudCwgc2VsZi5sZW5ndGgpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcHJvZHVjdCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICN7YmxvY2tfZ2l2ZW4/fSA/IG51bGwgOiBbXSxcbiAgICAgICAgICBuID0gYXJncy5sZW5ndGggKyAxLFxuICAgICAgICAgIGNvdW50ZXJzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGxlbmd0aHMgID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGFycmF5cyAgID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGksIG0sIHN1YmFycmF5LCBsZW4sIHJlc3VsdGxlbiA9IDE7XG5cbiAgICAgIGFycmF5c1swXSA9IHNlbGY7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXSA9ICRjb2VyY2VfdG8oYXJnc1tpIC0gMV0sICN7OjpBcnJheX0sICd0b19hcnknKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZW4gPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdGxlbiAqPSBsZW47XG4gICAgICAgIGlmIChyZXN1bHRsZW4gPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICd0b28gYmlnIHRvIHByb2R1Y3QnfVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aHNbaV0gPSBsZW47XG4gICAgICAgIGNvdW50ZXJzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgb3V0ZXJfbG9vcDogZm9yICg7Oykge1xuICAgICAgICBzdWJhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgc3ViYXJyYXkucHVzaChhcnJheXNbaV1bY291bnRlcnNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3ViYXJyYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7eWllbGQgYHN1YmFycmF5YH1cbiAgICAgICAgfVxuICAgICAgICBtID0gbiAtIDE7XG4gICAgICAgIGNvdW50ZXJzW21dKys7XG4gICAgICAgIHdoaWxlIChjb3VudGVyc1ttXSA9PT0gbGVuZ3Roc1ttXSkge1xuICAgICAgICAgIGNvdW50ZXJzW21dID0gMDtcbiAgICAgICAgICBpZiAoLS1tIDwgMCkgYnJlYWsgb3V0ZXJfbG9vcDtcbiAgICAgICAgICBjb3VudGVyc1ttXSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwdXNoKCpvYmplY3RzKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5wdXNoKG9iamVjdHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoaXRlbS5sZW5ndGggJiYgaXRlbVsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCN7YGl0ZW1bMV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgb3JpZ2luYWwgPSBsZW5ndGhcbiAgICBkZWxldGVfaWYoJmJsb2NrKVxuXG4gICAgdW5sZXNzIGxlbmd0aCA9PSBvcmlnaW5hbFxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVwbGFjZShvdGhlcilcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgc2VsZi5wdXNoLmFwcGx5KHNlbGYsIG90aGVyKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc2xpY2UoMCkucmV2ZXJzZSgpYFxuICBlbmRcblxuICBkZWYgcmV2ZXJzZSFcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGBzZWxmLnJldmVyc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXZlcnNlX2VhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJldmVyc2UuZWFjaCgmYmxvY2spXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gYG9iamVjdGB9KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChpID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDpyaW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZShuID0gMSlcbiAgICAleHtcbiAgICAgIHZhciBhcnksIGlkeCwgZmlyc3RQYXJ0LCBsYXN0UGFydDtcblxuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3s6OkludGVnZXJ9LCAndG9faW50JylcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XG4gICAgICBpZHggPSBuICUgYXJ5Lmxlbmd0aDtcblxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XG4gICAgICBsYXN0UGFydCA9IGFyeS5zbGljZSgwLCBpZHgpO1xuICAgICAgcmV0dXJuIGZpcnN0UGFydC5jb25jYXQobGFzdFBhcnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGNudCA9ICRjb2VyY2VfdG8oY250LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG4gICAgYXJ5ID0gcm90YXRlKGNudClcbiAgICByZXBsYWNlIGFyeVxuICBlbmRcblxuICBjbGFzcyBzZWxmOjpTYW1wbGVSYW5kb21cbiAgICBkZWYgaW5pdGlhbGl6ZShybmcpXG4gICAgICBAcm5nID0gcm5nXG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZChzaXplKVxuICAgICAgcmFuZG9tID0gYCRjb2VyY2VfdG8oI3tAcm5nLnJhbmQoc2l6ZSl9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlID49IDAnIGlmIGByYW5kb20gPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIEFycmF5IHNpemUnIHVubGVzcyBgcmFuZG9tIDwgc2l6ZWBcblxuICAgICAgcmFuZG9tXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzYW1wbGUoY291bnQgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGF0IDo6S2VybmVsLnJhbmQoYHNlbGYubGVuZ3RoYCkgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG5cbiAgICBpZiBgb3B0aW9ucyA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgKG8gPSA6Ok9wYWwuY29lcmNlX3RvPyBjb3VudCwgOjpIYXNoLCA6dG9faGFzaClcbiAgICAgICAgb3B0aW9ucyA9IG9cbiAgICAgICAgY291bnQgPSBuaWxcbiAgICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucyA9IG5pbFxuICAgICAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgb3B0aW9ucyA9IGAkY29lcmNlX3RvKG9wdGlvbnMsICN7OjpIYXNofSwgJ3RvX2hhc2gnKWBcbiAgICBlbmRcblxuICAgIGlmIGNvdW50ICYmIGBjb3VudCA8IDBgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJ1xuICAgIGVuZFxuXG4gICAgcm5nID0gb3B0aW9uc1s6cmFuZG9tXSBpZiBvcHRpb25zXG4gICAgcm5nID0gaWYgcm5nICYmIHJuZy5yZXNwb25kX3RvPyg6cmFuZClcbiAgICAgICAgICAgIFNhbXBsZVJhbmRvbS5uZXcgcm5nXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgOjpLZXJuZWxcbiAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBgc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1gIHVubGVzcyBjb3VudFxuXG4gICAgJXh7XG5cbiAgICAgIHZhciBhYmFuZG9uLCBzcGluLCByZXN1bHQsIGksIGosIGssIHRhcmdldEluZGV4LCBvbGRWYWx1ZTtcblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFtzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaiA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoIC0gMWApfTtcbiAgICAgICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbc2VsZltpXSwgc2VsZltqXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHNlbGYubGVuZ3RoIC8gY291bnQgPiAzKSB7XG4gICAgICAgICAgICBhYmFuZG9uID0gZmFsc2U7XG4gICAgICAgICAgICBzcGluID0gMDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gI3sgQXJyYXkubmV3KGNvdW50KSB9O1xuICAgICAgICAgICAgaSA9IDE7XG5cbiAgICAgICAgICAgIHJlc3VsdFswXSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICBrID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgaSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChrID09PSByZXN1bHRbal0pIHtcbiAgICAgICAgICAgICAgICAgIHNwaW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzcGluID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYW5kb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaztcblxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWJhbmRvbikge1xuICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGZbcmVzdWx0W2ldXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aCAtIGNgKX0gKyBjO1xuICAgICAgICAgICAgb2xkVmFsdWUgPSByZXN1bHRbY107XG4gICAgICAgICAgICByZXN1bHRbY10gPSByZXN1bHRbdGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0W3RhcmdldEluZGV4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3VudCA9PT0gc2VsZi5sZW5ndGggPyByZXN1bHQgOiAje2ByZXN1bHRgWzAsIGNvdW50XX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGl0ZW0pO1xuXG4gICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilcblxuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG4gICAgICAjeyBrZWVwX2lmKCZibG9jaykgfTtcbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwgPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNoaWZ0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG4gICAgICByZXR1cm4gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgICAgcmV0dXJuIGBzaGlmdE5vQXJnKHNlbGYpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgY291bnQgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBgc2VsZi5zcGxpY2UoMCwgY291bnQpYFxuICBlbmRcblxuICBkZWYgc2h1ZmZsZShybmcgPSB1bmRlZmluZWQpXG4gICAgZHVwLnRvX2Euc2h1ZmZsZSEocm5nKVxuICBlbmRcblxuICBkZWYgc2h1ZmZsZSEocm5nID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIHJhbmRnZW4sIGkgPSBzZWxmLmxlbmd0aCwgaiwgdG1wO1xuXG4gICAgICBpZiAocm5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm5nID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhybmcsIDo6SGFzaCwgOnRvX2hhc2gpfTtcblxuICAgICAgICBpZiAocm5nICE9PSBuaWwpIHtcbiAgICAgICAgICBybmcgPSAje3JuZ1s6cmFuZG9tXX07XG5cbiAgICAgICAgICBpZiAocm5nICE9PSBuaWwgJiYgI3tybmcucmVzcG9uZF90bz8oOnJhbmQpfSkge1xuICAgICAgICAgICAgcmFuZGdlbiA9IHJuZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgaWYgKHJhbmRnZW4pIHtcbiAgICAgICAgICBqID0gcmFuZGdlbi4kcmFuZChpKS4kdG9faW50KCk7XG5cbiAgICAgICAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcInJhbmRvbSBudW1iZXIgdG9vIHNtYWxsICN7YGpgfVwifVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChqID49IGkpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcInJhbmRvbSBudW1iZXIgdG9vIGJpZyAje2BqYH1cIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaiA9ICN7cmFuZChgaWApfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCA9IHNlbGZbLS1pXTtcbiAgICAgICAgc2VsZltpXSA9IHNlbGZbal07XG4gICAgICAgIHNlbGZbal0gPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNsaWNlIShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgcmVzdWx0ID0gbmlsXG5cbiAgICBpZiBgbGVuZ3RoID09PSB1bmRlZmluZWRgXG4gICAgICBpZiA6OlJhbmdlID09PSBpbmRleFxuICAgICAgICByYW5nZSA9IGluZGV4XG4gICAgICAgIHJlc3VsdCA9IHNlbGZbcmFuZ2VdXG5cbiAgICAgICAgcmFuZ2Vfc3RhcnQgPSBgcmFuZ2UuYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKHJhbmdlLmJlZ2luLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgcmFuZ2VfZW5kID0gYHJhbmdlLmVuZCA9PT0gbmlsID8gLTEgOiAkY29lcmNlX3RvKHJhbmdlLmVuZCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKHJhbmdlX3N0YXJ0IDwgMCkge1xuICAgICAgICAgICAgcmFuZ2Vfc3RhcnQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJhbmdlX2VuZCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlX2VuZCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kID0gc2VsZi5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmV4Y2wpIHtcbiAgICAgICAgICAgICAgcmFuZ2VfZW5kICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJhbmdlX2xlbmd0aCA9IHJhbmdlX2VuZCAtIHJhbmdlX3N0YXJ0O1xuICAgICAgICAgIGlmIChyYW5nZS5leGNsICYmIHJhbmdlLmVuZCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgLT0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2VfbGVuZ3RoICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJhbmdlX3N0YXJ0IDwgc2VsZi5sZW5ndGggJiYgcmFuZ2Vfc3RhcnQgPj0gMCAmJiByYW5nZV9lbmQgPCBzZWxmLmxlbmd0aCAmJiByYW5nZV9lbmQgPj0gMCAmJiByYW5nZV9sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxmLnNwbGljZShyYW5nZV9zdGFydCwgcmFuZ2VfbGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgc3RhcnQgPSBgJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZltzdGFydF07XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGYuc2hpZnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2Uoc3RhcnQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgc3RhcnQgPSBgJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBsZW5ndGggPSBgJGNvZXJjZV90byhsZW5ndGgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAleHtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgbGVuZ3RoO1xuXG4gICAgICAgIHJlc3VsdCA9ICN7c2VsZltzdGFydCwgbGVuZ3RoXX07XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgIHN0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0ICsgbGVuZ3RoID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgc2VsZi5sZW5ndGggJiYgc3RhcnQgPj0gMCkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlKHN0YXJ0LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICByZXR1cm4gc2VsZiB1bmxlc3MgYHNlbGYubGVuZ3RoID4gMWBcblxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgYmxvY2sgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuICN7YGFgIDw9PiBgYmB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgpLnNvcnQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgcmV0ID0gYmxvY2soeCwgeSk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gbmlsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2B4YC5pbnNwZWN0fSB3aXRoICN7YHlgLmluc3BlY3R9IGZhaWxlZFwifTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAje2ByZXRgID4gMH0gPyAxIDogKCN7YHJldGAgPCAwfSA/IC0xIDogMCk7XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzb3J0ISgmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpXG5cbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0KCZibG9jayl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYubGVuZ3RoID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gocmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydF9ieSEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c29ydF9ieSEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgcmVwbGFjZSBzb3J0X2J5KCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRha2UoY291bnQpXG4gICAgJXh7XG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRha2Vfd2hpbGUoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW0sIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgdmFsdWUgPSBibG9jayhpdGVtKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5BcnJheS4kbmV3KHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2FyeVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX2goJmJsb2NrKVxuICAgIGFycmF5ID0gc2VsZlxuICAgIGFycmF5ID0gYXJyYXkubWFwKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW4gPSBhcnJheS5sZW5ndGgsIGFyeSwga2V5LCB2YWwsIGhhc2ggPSAje3t9fTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFyeSA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYGFycmF5W2ldYCwgOjpBcnJheSwgOnRvX2FyeSl9O1xuICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBlbGVtZW50IHR5cGUgI3tgYXJ5YC5jbGFzc30gYXQgI3tgaWB9IChleHBlY3RlZCBhcnJheSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJ5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIGFycmF5IGxlbmd0aCBhdCAje2BpYH0gKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zcG9zZVxuICAgIHJldHVybiBbXSBpZiBlbXB0eT9cblxuICAgIHJlc3VsdCA9IFtdXG4gICAgbWF4ICAgID0gbmlsXG5cbiAgICBlYWNoIGRvIHxyb3d8XG4gICAgICByb3cgPSBpZiA6OkFycmF5ID09PSByb3dcbiAgICAgICAgICAgICAgcm93LnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ocm93LCAjezo6QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgICBtYXggfHw9IGByb3cubGVuZ3RoYFxuXG4gICAgICBpZiBgcm93Lmxlbmd0aGAgIT0gbWF4XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJlbGVtZW50IHNpemUgZGlmZmVycyAoI3tgcm93Lmxlbmd0aGB9IHNob3VsZCBiZSAje21heH0pXCJcbiAgICAgIGVuZFxuXG4gICAgICBgcm93Lmxlbmd0aGAudGltZXMgZG8gfGl8XG4gICAgICAgIGVudHJ5ID0gKHJlc3VsdFtpXSB8fD0gW10pXG4gICAgICAgIGVudHJ5IDw8IHJvdy5hdChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIHVuaW9uKCphcnJheXMpXG4gICAgYXJyYXlzLnJlZHVjZSh1bmlxKSB7IHxhLCBifCBhIHwgYiB9XG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbSwga2V5O1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBpdGVtKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwgaXRlbSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGtleSA9ICR5aWVsZDEoYmxvY2ssIGl0ZW0pO1xuICAgICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YGhhc2hgLnZhbHVlc307XG4gICAgfVxuICBlbmRcblxuICBkZWYgdW5pcSEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIG9yaWdpbmFsX2xlbmd0aCA9IHNlbGYubGVuZ3RoLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbSwga2V5O1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvcmlnaW5hbF9sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAga2V5ID0gKGJsb2NrID09PSBuaWwgPyBpdGVtIDogJHlpZWxkMShibG9jaywgaXRlbSkpO1xuXG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgaXRlbSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbF9sZW5ndGggPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVuc2hpZnQoKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgc2VsZkxlbmd0aCA9IHNlbGYubGVuZ3RoXG4gICAgICB2YXIgb2JqZWN0c0xlbmd0aCA9IG9iamVjdHMubGVuZ3RoXG4gICAgICBpZiAob2JqZWN0c0xlbmd0aCA9PSAwKSByZXR1cm4gc2VsZjtcbiAgICAgIHZhciBpbmRleCA9IHNlbGZMZW5ndGggLSBvYmplY3RzTGVuZ3RoXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHNMZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2goc2VsZltpbmRleCArIGldKVxuICAgICAgfVxuICAgICAgdmFyIGxlbiA9IHNlbGZMZW5ndGggLSAxXG4gICAgICB3aGlsZSAobGVuIC0gb2JqZWN0c0xlbmd0aCA+PSAwKSB7XG4gICAgICAgIHNlbGZbbGVuXSA9IHNlbGZbbGVuIC0gb2JqZWN0c0xlbmd0aF1cbiAgICAgICAgbGVuLS1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0c0xlbmd0aDsgaisrKSB7XG4gICAgICAgIHNlbGZbal0gPSBvYmplY3RzW2pdXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgb3V0ID0gW11cblxuICAgIGFyZ3MuZWFjaCBkbyB8ZWxlbXxcbiAgICAgIGlmIGVsZW0uaXNfYT8gOjpSYW5nZVxuICAgICAgICBmaW5pc2ggPSBgI3tlbGVtLmVuZH0gPT09IG5pbCA/IC0xIDogJGNvZXJjZV90bygje2VsZW0uZW5kfSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHN0YXJ0ID0gYCN7ZWxlbS5iZWdpbn0gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKCN7ZWxlbS5iZWdpbn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyBzZWxmLmxlbmd0aDtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKGZpbmlzaCA8IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCA9IGZpbmlzaCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tlbGVtLmV4Y2x1ZGVfZW5kP30gJiYgI3tlbGVtLmVuZH0gIT09IG5pbCkge1xuICAgICAgICAgICAgZmluaXNoLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaW5pc2ggPCBzdGFydCkge1xuICAgICAgICAgICAgI3tuZXh0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydC51cHRvKGZpbmlzaCkgeyB8aXwgb3V0IDw8IGF0KGkpIH1cbiAgICAgIGVsc2VcbiAgICAgICAgaSA9IGAkY29lcmNlX3RvKGVsZW0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICBvdXQgPDwgYXQoaSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgb3V0XG4gIGVuZFxuXG4gIGRlZiB6aXAoKm90aGVycywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBzaXplID0gc2VsZi5sZW5ndGgsIHBhcnQsIG8sIGksIGosIGpqO1xuXG4gICAgICBmb3IgKGogPSAwLCBqaiA9IG90aGVycy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIG8gPSBvdGhlcnNbal07XG4gICAgICAgIGlmIChvLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby4kJGlzX3JhbmdlIHx8IG8uJCRpc19lbnVtZXJhdG9yKSB7XG4gICAgICAgICAgb3RoZXJzW2pdID0gby4kdGFrZShzaXplKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcnNbal0gPSAjeyhcbiAgICAgICAgICA6Ok9wYWwuY29lcmNlX3RvPyhgb2AsIDo6QXJyYXksIDp0b19hcnkpIHx8XG4gICAgICAgICAgOjpPcGFsLmNvZXJjZV90byEoYG9gLCA6OkVudW1lcmF0b3IsIDp0b19lbnVtLCA6ZWFjaClcbiAgICAgICAgKS50b19hfTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBwYXJ0ID0gW3NlbGZbaV1dO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICBvID0gb3RoZXJzW2pdW2ldO1xuXG4gICAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0W2ogKyAxXSA9IG87XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbaV0gPSBwYXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHJlc3VsdFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5oZXJpdGVkKGtsYXNzKVxuICAgICV4e1xuICAgICAga2xhc3MuJCRwcm90b3R5cGUuJHRvX2EgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIHN1cGVyLnJlamVjdCB7IHxpdmFyfCBgL15AXFxkKyQvLnRlc3QoI3tpdmFyfSlgIHx8IGl2YXIgPT0gJ0BsZW5ndGgnIH1cbiAgZW5kXG5cbiAgZGVmIHBhY2soKmFyZ3MpXG4gICAgOjpLZXJuZWwucmFpc2UgXCJUbyB1c2UgQXJyYXkjcGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9hcnJheS9wYWNrJy5cIlxuICBlbmRcblxuICBhbGlhcyBhcHBlbmQgcHVzaFxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuICBhbGlhcyBtYXAgY29sbGVjdFxuICBhbGlhcyBtYXAhIGNvbGxlY3QhXG4gIGFsaWFzIHByZXBlbmQgdW5zaGlmdFxuICBhbGlhcyBzaXplIGxlbmd0aFxuICBhbGlhcyBzbGljZSBbXVxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICA6Ok9wYWwucHJpc3RpbmUgc2luZ2xldG9uX2NsYXNzLCA6YWxsb2NhdGVcbiAgOjpPcGFsLnByaXN0aW5lIHNlbGYsIDpjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcywgOmluaXRpYWxpemVfZHVwXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6QXJyYXk+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJ0b19hIiwiW10iLCJpbml0aWFsaXplIiwic2l6ZSIsIm9iaiIsIktlcm5lbCIsIndhcm4iLCJJbnRlZ2VyOjpNQVgiLCJJbnRlZ2VyIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwicmVwbGFjZSIsInJlc3BvbmRfdG8/IiwidG9fYXJ5IiwidHJ5X2NvbnZlcnQiLCJPcGFsIiwiY29lcmNlX3RvPyIsIkFycmF5IiwiJiIsIm90aGVyIiwifCIsIioiLCJqb2luIiwidG9fc3RyIiwiKyIsIi0iLCI8PCIsIm9iamVjdCIsIjw9PiIsImhhc2giLCI9PSIsIm9iamVjdF9pZCIsImluZGV4IiwibGVuZ3RoIiwiW109IiwidmFsdWUiLCJleHRyYSIsImRhdGEiLCJSYW5nZUVycm9yIiwiaW5zcGVjdCIsIjEiLCJJbmRleEVycm9yIiwiYW55PyIsInBhdHRlcm4iLCJhc3NvYyIsImF0IiwiYnNlYXJjaF9pbmRleCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiVHlwZUVycm9yIiwiY2xhc3MiLCJic2VhcmNoIiwiYmxvY2siLCJ0b19wcm9jIiwiY3ljbGUiLCJuIiwiYmxvY2sgaW4gY3ljbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGN5Y2xlIiwibmlsPyIsIkZsb2F0OjpJTkZJTklUWSIsIkZsb2F0IiwiY29lcmNlX3RvISIsIj4iLCIwIiwiZW51bWVyYXRvcl9zaXplIiwiZW1wdHk/IiwiY2xlYXIiLCJjb3VudCIsImluaXRpYWxpemVfY29weSIsImNvbGxlY3QiLCJibG9jayBpbiBjb2xsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0IiwiY29sbGVjdCEiLCJibG9jayBpbiBjb2xsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCEiLCJjb21iaW5hdGlvbiIsIm51bSIsImJsb2NrIGluIGNvbWJpbmF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb21iaW5hdGlvbiIsInJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiYmxvY2sgaW4gcmVwZWF0ZWRfY29tYmluYXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiY29tcGFjdCIsImNvbXBhY3QhIiwiY29uY2F0Iiwib3RoZXJzIiwibWFwIiwiYmxvY2sgaW4gY29uY2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb25jYXQiLCJlcXVhbD8iLCJkdXAiLCJlYWNoIiwiZGVsZXRlIiwiZGVsZXRlX2F0IiwiZGVsZXRlX2lmIiwiYmxvY2sgaW4gZGVsZXRlX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWxldGVfaWYiLCJkaWZmZXJlbmNlIiwicmVkdWNlIiwiYXJyYXlzIiwiYmxvY2sgaW4gZGlmZmVyZW5jZSIsImEiLCJiIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkaWZmZXJlbmNlIiwiZGlnIiwiaWR4IiwiaXRlbSIsImlkeHMiLCJkcm9wIiwibnVtYmVyIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsImVhY2hfaW5kZXgiLCJibG9jayBpbiBlYWNoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2luZGV4IiwiZXFsPyIsImZldGNoIiwiZGVmYXVsdHMiLCJmaWxsIiwiYXJncyIsIm9uZSIsInR3byIsIlJhbmdlIiwibGVmdCIsInJpZ2h0IiwiZXhjbHVkZV9lbmQ/IiwiZmlyc3QiLCJmbGF0dGVuIiwibGV2ZWwiLCJmbGF0dGVuISIsImZyZWV6ZSIsImZyb3plbj8iLCJpbmNsdWRlPyIsIm1lbWJlciIsImluc2VydCIsIl9faWRfXyIsImludGVyc2VjdGlvbiIsImJsb2NrIGluIGludGVyc2VjdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gaW50ZXJzZWN0aW9uIiwiaW50ZXJzZWN0PyIsIiEiLCJzZXAiLCIkLCIsInRvX3MiLCJOb01ldGhvZEVycm9yIiwibmV3IiwiU3RyaW5nIiwia2VlcF9pZiIsImJsb2NrIGluIGtlZXBfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGtlZXBfaWYiLCJsYXN0IiwibWF4IiwibWluIiwicGVybXV0YXRpb24iLCJibG9jayBpbiBwZXJtdXRhdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcGVybXV0YXRpb24iLCJwZXJtIiwidXNlZCIsInJlcGVhdGVkX3Blcm11dGF0aW9uIiwiYmxvY2sgaW4gcmVwZWF0ZWRfcGVybXV0YXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHJlcGVhdGVkX3Blcm11dGF0aW9uIiwiPj0iLCIqKiIsInBvcCIsInByb2R1Y3QiLCJwdXNoIiwicmFzc29jIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZWplY3QhIiwiYmxvY2sgaW4gcmVqZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0ISIsIm9yaWdpbmFsIiwicmV2ZXJzZSIsInJldmVyc2UhIiwicmV2ZXJzZV9lYWNoIiwiYmxvY2sgaW4gcmV2ZXJzZV9lYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXZlcnNlX2VhY2giLCJyaW5kZXgiLCJyb3RhdGUiLCJyb3RhdGUhIiwiY250IiwiYXJ5IiwiPGNsYXNzOnNlbGY6OlNhbXBsZVJhbmRvbT4iLCJyYW5kIiwicmFuZG9tIiwiQHJuZyIsInNhbXBsZSIsIm9wdGlvbnMiLCJvIiwiSGFzaCIsInJuZyIsIlNhbXBsZVJhbmRvbSIsInNlbGVjdCIsImJsb2NrIGluIHNlbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0Iiwic2VsZWN0ISIsImJsb2NrIGluIHNlbGVjdCEiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbGVjdCEiLCJzaGlmdCIsInNodWZmbGUiLCJzaHVmZmxlISIsInNsaWNlISIsInJlc3VsdCIsInJhbmdlIiwicmFuZ2Vfc3RhcnQiLCJyYW5nZV9lbmQiLCJzdGFydCIsInNvcnQiLCI8Iiwic29ydCEiLCJzb3J0X2J5ISIsImJsb2NrIGluIHNvcnRfYnkhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0X2J5ISIsInNvcnRfYnkiLCJ0YWtlIiwidGFrZV93aGlsZSIsInRvX2giLCJhcnJheSIsInRyYW5zcG9zZSIsImJsb2NrIGluIHRyYW5zcG9zZSIsInJvdyIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNwb3NlIiwiJHJldF9vcl8xIiwidGltZXMiLCJpIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiB0cmFuc3Bvc2UiLCJlbnRyeSIsInVuaW9uIiwidW5pcSIsImJsb2NrIGluIHVuaW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB1bmlvbiIsInZhbHVlcyIsInVuaXEhIiwidW5zaGlmdCIsInZhbHVlc19hdCIsIm91dCIsImJsb2NrIGluIHZhbHVlc19hdCIsImVsZW0iLCJibG9jayAoMiBsZXZlbHMpIGluIHZhbHVlc19hdCIsImlzX2E/IiwiZmluaXNoIiwiZW5kIiwiYmVnaW4iLCJ1cHRvIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiB2YWx1ZXNfYXQiLCJ6aXAiLCJFbnVtZXJhdG9yIiwiaW5oZXJpdGVkIiwia2xhc3MiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJibG9jayBpbiBpbnN0YW5jZV92YXJpYWJsZXMiLCJpdmFyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnN0YW5jZV92YXJpYWJsZXMiLCJwYWNrIiwicHJpc3RpbmUiLCJzaW5nbGV0b25fY2xhc3MiXSwibWFwcGluZ3MiOiJBQUFBQSxnQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFRixJQUFBRyxT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RVc7TUFDUEEsT0FBQTFQLE9BQVFJLE9BQUFBLENBQU9zUCxpRUFBUHRQO0lBRFZzUCxDQUFBQSxJQUFBQTtJQUlBLGFBQU0sUUFBTixFQUFhLE1BQWI7SUFDQSxhQUFNLFFBQU4sRUFBYSxRQUFiO0lBQ0EsYUFBTSxTQUFOLEVBQWMsU0FBZDtJQUNBLGFBQU0sS0FBTixFQUFVLFNBQVY7SUFDQSxhQUFNLE1BQU4sRUFBVyxVQUFYO0lBQ0EsYUFBTSxTQUFOLEVBQWMsU0FBZDtJQUNBLGFBQU0sTUFBTixFQUFXLFFBQVg7SUFDQSxhQUFNLE9BQU4sRUFBWSxJQUFaO0lBQ0EsYUFBTSxNQUFOLEVBQVcsU0FBWDtJQUVBaFAsS0FBTWlQLFVBQUFBLENBQVVyUSxJQUFBc1EsaUJBQUFBLENBQUFBLENBQWhCLEVBQWlDLFVBQTNCRDtJQUNOblEsT0FBQWtCLEtBQU1pUCxVQUFBQSxDQUFVclEsSUFBaEIsRUFBc0IseUJBQXRCLEVBQWdELGdCQUExQ3FRO0VBLzhFUm5RLEdBQU0sSUFBTkEsRUFBaUJILEtBQWpCRztBQUxBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTU1OTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2hhc2gucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB5aWVsZDEsIGhhc2gsIGhhc2hfaW5pdCwgaGFzaF9nZXQsIGhhc2hfcHV0LCBoYXNoX2RlbGV0ZSwgZGVueV9mcm96ZW5fYWNjZXNzLCBmcmVlemVcblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG4jIC0tLVxuIyBJbnRlcm5hbCBwcm9wZXJ0aWVzOlxuI1xuIyAtICQkbWFwICAgICAgICAgW0pTOjpPYmplY3Q8U3RyaW5nID0+IGhhc2gtYnVja2V0Pl0gdGhlIGhhc2ggdGFibGUgZm9yIG9yZGluYXJ5IGtleXNcbiMgLSAkJHNtYXAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBzdHJpbmcga2V5c1xuIyAtICQka2V5cyAgICAgICAgW0FycmF5PGhhc2gtYnVja2V0Pl0gdGhlIGxpc3Qgb2YgYWxsIGtleXNcbiMgLSAkJHByb2MgICAgICAgIFtQcm9jLG51bGwsbmlsXSB0aGUgZGVmYXVsdCBwcm9jIHVzZWQgZm9yIG1pc3Npbmcga2V5c1xuIyAtIGhhc2gtYnVja2V0ICAgW0pTOjpPYmplY3RdIGFuIGVsZW1lbnQgb2YgYSBsaW5rZWQgbGlzdCB0aGF0IGhvbGRzIGhhc2ggdmFsdWVzLCBrZXlzIGFyZSBge2tleTosa2V5X2hhc2g6LHZhbHVlOixuZXh0On1gXG5jbGFzcyA6Okhhc2hcbiAgaW5jbHVkZSA6OkVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGhhc2ggaW5zdGFuY2VzIGFzIHZhbGlkIGhhc2hlcyAodXNlZCB0byBjaGVjayBrZXl3b3JkIGFyZ3MsIGV0YylcbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19oYXNoID0gdHJ1ZWBcblxuICBkZWYgc2VsZi5bXSgqYXJndilcbiAgICAleHtcbiAgICAgIHZhciBoYXNoLCBhcmdjID0gYXJndi5sZW5ndGgsIGk7XG5cbiAgICAgIGlmIChhcmdjID09PSAxKSB7XG4gICAgICAgIGhhc2ggPSAjezo6T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIDo6SGFzaCwgOnRvX2hhc2gpfTtcbiAgICAgICAgaWYgKGhhc2ggIT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiAje2FsbG9jYXRlLm1lcmdlIShgaGFzaGApfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3YgPSAjezo6T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIDo6QXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKGFyZ3YgPT09IG5pbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnb2RkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIEhhc2gnfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJnYyA9IGFyZ3YubGVuZ3RoO1xuICAgICAgICBoYXNoID0gI3thbGxvY2F0ZX07XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkrKykge1xuICAgICAgICAgIGlmICghYXJndltpXS4kJGlzX2FycmF5KSBjb250aW51ZTtcbiAgICAgICAgICBzd2l0Y2goYXJndltpXS5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBoYXNoLiRzdG9yZShhcmd2W2ldWzBdLCBuaWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXVswXSwgYXJndltpXVsxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBudW1iZXIgb2YgZWxlbWVudHMgKCN7YGFyZ3ZbaV0ubGVuZ3RoYH0gZm9yIDEuLjIpXCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdjICUgMiAhPT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgIH1cblxuICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSArPSAyKSB7XG4gICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV0sIGFyZ3ZbaSArIDFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG5cbiAgICAgICRoYXNoX2luaXQoaGFzaCk7XG5cbiAgICAgIGhhc2guJCRub25lID0gbmlsO1xuICAgICAgaGFzaC4kJHByb2MgPSBuaWw7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqKVxuICAgIDo6T3BhbC5jb2VyY2VfdG8/KG9iaiwgOjpIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgxIGZvciAwKSd9XG4gICAgICB9XG4gICAgICBzZWxmLiQkbm9uZSA9IChkZWZhdWx0cyA9PT0gdW5kZWZpbmVkID8gbmlsIDogZGVmYXVsdHMpO1xuICAgICAgc2VsZi4kJHByb2MgPSBibG9jaztcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3RoZXIuJCRpc19oYXNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuJCRrZXlzLmxlbmd0aCAhPT0gb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvdGhlcl92YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IG90aGVyLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gJGhhc2hfZ2V0KG90aGVyLCBrZXkua2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdGhlcl92YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF2YWx1ZVsnJGVxbD8nXShvdGhlcl92YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRrZXlzLmxlbmd0aCA8IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gdHJ1ZVxuXG4gICAgb3RoZXIuZWFjaCBkbyB8b3RoZXJfa2V5LCBvdGhlcl92YWx8XG4gICAgICB2YWwgPSBmZXRjaChvdGhlcl9rZXksIGBudWxsYClcblxuICAgICAgJXh7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgIT09IG90aGVyX3ZhbCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIG90aGVyID0gOjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPD0gb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmID49IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIG90aGVyID0gOjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SGFzaCwgOnRvX2hhc2gpXG4gICAgb3RoZXIgPiBzZWxmXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxuICAgIG90aGVyID49IHNlbGZcbiAgZW5kXG5cbiAgZGVmIFtdKGtleSlcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRkZWZhdWx0KGtleSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgW109KGtleSwgdmFsdWUpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICAkaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIGlmICgje2BrZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LCBzZWxmLiQkc21hcFtrZXldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCN7YGtleS5rZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LmtleSwga2V5LnZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgJGhhc2hfaW5pdChzZWxmKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsb25lXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IG5ldyBzZWxmLiQkY2xhc3MoKTtcblxuICAgICAgJGhhc2hfaW5pdChoYXNoKTtcbiAgICAgIE9wYWwuaGFzaF9jbG9uZShzZWxmLCBoYXNoKTtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAkaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0IVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIGNoYW5nZXNfd2VyZV9tYWRlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXNfd2VyZV9tYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlc193ZXJlX21hZGUgPyBzZWxmIDogbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHlcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBpLCBpaSwga2V5LCBrZXlzID0gc2VsZi4kJGtleXMsIGlkZW50aXR5X2hhc2g7XG5cbiAgICAgIGlmIChzZWxmLiQkYnlfaWRlbnRpdHkpIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkYnlfaWRlbnRpdHkgPSB0cnVlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZGVudGl0eV9oYXNoID0gI3sge30uY29tcGFyZV9ieV9pZGVudGl0eSB9O1xuICAgICAgZm9yKGkgPSAwLCBpaSA9IGtleXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIWtleS4kJGlzX3N0cmluZykga2V5ID0ga2V5LmtleTtcbiAgICAgICAgJGhhc2hfcHV0KGlkZW50aXR5X2hhc2gsIGtleSwgJGhhc2hfZ2V0KHNlbGYsIGtleSkpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLiQkYnlfaWRlbnRpdHkgPSB0cnVlO1xuICAgICAgc2VsZi4kJG1hcCA9IGlkZW50aXR5X2hhc2guJCRtYXA7XG4gICAgICBzZWxmLiQkc21hcCA9IGlkZW50aXR5X2hhc2guJCRzbWFwO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eT9cbiAgICBgc2VsZi4kJGJ5X2lkZW50aXR5ID09PSB0cnVlYFxuICBlbmRcblxuICBkZWYgZGVmYXVsdChrZXkgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgc2VsZi4kJHByb2MgIT09IG5pbCAmJiBzZWxmLiQkcHJvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkcHJvYy4kY2FsbChzZWxmLCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuJCRub25lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkbm9uZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0PShvYmplY3QpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBzZWxmLiQkcHJvYyA9IG5pbDtcbiAgICAgIHNlbGYuJCRub25lID0gb2JqZWN0O1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHRfcHJvY1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRwcm9jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRwcm9jO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0X3Byb2M9KGRlZmF1bHRfcHJvYylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBwcm9jID0gZGVmYXVsdF9wcm9jO1xuXG4gICAgICBpZiAocHJvYyAhPT0gbmlsKSB7XG4gICAgICAgIHByb2MgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBwcm9jYCwgOjpQcm9jLCA6dG9fcHJvYyl9O1xuXG4gICAgICAgIGlmICgje2Bwcm9jYC5sYW1iZGE/fSAmJiAje2Bwcm9jYC5hcml0eS5hYnN9ICE9PSAyKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2RlZmF1bHRfcHJvYyB0YWtlcyB0d28gYXJndW1lbnRzJ307XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kJG5vbmUgPSBuaWw7XG4gICAgICBzZWxmLiQkcHJvYyA9IHByb2M7XG5cbiAgICAgIHJldHVybiBkZWZhdWx0X3Byb2M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlKGtleSwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcbiAgICAgIHZhciB2YWx1ZSA9ICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAje3lpZWxkIGtleX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmRlbGV0ZV9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkaWcoa2V5LCAqa2V5cylcbiAgICBpdGVtID0gc2VsZltrZXldXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMuc2xpY2UoKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgICR5aWVsZDEoYmxvY2ssIFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfa2V5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfa2V5KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cy5zbGljZSgpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF92YWx1ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3ZhbHVlKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cy5zbGljZSgpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBzZWxmLiQkc21hcFtrZXldIDoga2V5LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdCgqa2V5cylcbiAgICBkdXAuZXhjZXB0ISgqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdCEoKmtleXMpXG4gICAga2V5cy5lYWNoIHsgfGtleXwgZGVsZXRlKGtleSkgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZldGNoKGtleSwgZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhrZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpLZXlFcnJvci5uZXcoXCJrZXkgbm90IGZvdW5kOiAje2tleS5pbnNwZWN0fVwiLCBrZXk6IGtleSwgcmVjZWl2ZXI6IHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBmZXRjaF92YWx1ZXMoKmtleXMsICZibG9jaylcbiAgICBrZXlzLm1hcCB7IHxrZXl8IGZldGNoKGtleSwgJmJsb2NrKSB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gMSlcbiAgICBsZXZlbCA9IDo6T3BhbC5jb2VyY2VfdG8hKGxldmVsLCA6OkludGVnZXIsIDp0b19pbnQpXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoI3tgdmFsdWVgLmZsYXR0ZW4oYGxldmVsIC0gMmApfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xuXG4gICAgYCRmcmVlemUoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhrZXkpXG4gICAgYCRoYXNoX2dldChzZWxmLCBrZXkpICE9PSB1bmRlZmluZWRgXG4gIGVuZFxuXG4gIGRlZiBoYXNfdmFsdWU/KHZhbHVlKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKCN7YChrZXkuJCRpc19zdHJpbmcgPyBzZWxmLiQkc21hcFtrZXldIDoga2V5LnZhbHVlKWAgPT0gdmFsdWV9KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoT3BhbC5oYXNoX2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICBoYXNoX2lkID0gc2VsZi4kb2JqZWN0X2lkKCksXG4gICAgICAgICAgcmVzdWx0ID0gWydIYXNoJ10sXG4gICAgICAgICAga2V5LCBpdGVtO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX2lkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT3BhbFtoYXNoX2lkXSkge1xuICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiBPcGFsLmhhc2hfaWRzKSB7XG4gICAgICAgICAgaXRlbSA9IE9wYWwuaGFzaF9pZHNba2V5XTtcbiAgICAgICAgICBpZiAoI3tlcWw/KGBpdGVtYCl9KSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9pZHNbaGFzaF9pZF0gPSBzZWxmO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2tleSwgc2VsZi4kJHNtYXBba2V5XS4kaGFzaCgpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXkua2V5X2hhc2gsIGtleS52YWx1ZS4kaGFzaCgpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zb3J0KCkuam9pbigpO1xuXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4KG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXhlcygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gYXJnc1tpXTtcbiAgICAgICAgdmFsdWUgPSAkaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7ZGVmYXVsdH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYHZhciBpbnNwZWN0X2lkc2BcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9IChpbnNwZWN0X2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICBoYXNoX2lkID0gc2VsZi4kb2JqZWN0X2lkKCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgfVxuXG4gICAgYmVnaW5cbiAgICAgICV4e1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgaW5zcGVjdF9pZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnNwZWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShoYXNoX2lkKSkge1xuICAgICAgICAgIHJldHVybiAney4uLn0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zcGVjdF9pZHNbaGFzaF9pZF0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2V5ID0gI3tPcGFsLmluc3BlY3QoYGtleWApfVxuICAgICAgICAgIHZhbHVlID0gI3tPcGFsLmluc3BlY3QoYHZhbHVlYCl9XG5cbiAgICAgICAgICByZXN1bHQucHVzaChrZXkgKyAnPT4nICsgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICd7JyArIHJlc3VsdC5qb2luKCcsICcpICsgJ30nO1xuICAgICAgfVxuICAgICAgbmlsXG4gICAgZW5zdXJlXG4gICAgICBgaWYgKHRvcCkgaW5zcGVjdF9pZHMgPSB1bmRlZmluZWRgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbnZlcnRcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgICRoYXNoX3B1dChoYXNoLCB2YWx1ZSwga2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYga2VlcF9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDprZWVwX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtleXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi4kJGtleXMubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgbWVyZ2UoKm90aGVycywgJmJsb2NrKVxuICAgIGR1cC5tZXJnZSEoKm90aGVycywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWVyZ2UhKCpvdGhlcnMsICZibG9jaylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG4gICAgICB2YXIgaSwgaiwgb3RoZXIsIG90aGVyX2tleXMsIGxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG90aGVyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgb3RoZXJzW2ldYCwgOjpIYXNoLCA6dG9faGFzaCl9O1xuICAgICAgICBvdGhlcl9rZXlzID0gb3RoZXIuJCRrZXlzLCBsZW5ndGggPSBvdGhlcl9rZXlzLmxlbmd0aDtcblxuICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAga2V5ID0gb3RoZXJfa2V5c1tqXTtcblxuICAgICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IG90aGVyLiQkc21hcFtrZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2pdO1xuXG4gICAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSAkaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgb3RoZXJfdmFsdWUpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgYmxvY2soa2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVoYXNoXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuICAgICAgT3BhbC5oYXNoX3JlaGFzaChzZWxmKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICRoYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIGlmICgkaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzX3dlcmVfbWFkZSA9IHRydWU7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZXNfd2VyZV9tYWRlID8gc2VsZiA6IG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXBsYWNlKG90aGVyKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO2BcblxuICAgIG90aGVyID0gOjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgICRoYXNoX2luaXQoc2VsZik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBvdGhlcl9rZXlzID0gb3RoZXIuJCRrZXlzLCBsZW5ndGggPSBvdGhlcl9rZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IG90aGVyLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICAkaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgICBzZWxmLmRlZmF1bHRfcHJvYyA9IG90aGVyLmRlZmF1bHRfcHJvY1xuICAgIGVsc2VcbiAgICAgIHNlbGYuZGVmYXVsdCA9IG90aGVyLmRlZmF1bHRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICRoYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XG4gICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciByZXN1bHQgPSBuaWw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2hpZnRcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG4gICAgICB2YXIga2V5cyA9IHNlbGYuJCRrZXlzLFxuICAgICAgICAgIGtleTtcblxuICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICBrZXkgPSBrZXlzWzBdO1xuXG4gICAgICAgIGtleSA9IGtleS4kJGlzX3N0cmluZyA/IGtleSA6IGtleS5rZXk7XG5cbiAgICAgICAgcmV0dXJuIFtrZXksICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzbGljZSgqa2V5cylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAkaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXSwgdmFsdWUgPSAkaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICRoYXNoX3B1dChyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5IYXNoKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcblxuICAgICAgJGhhc2hfaW5pdChoYXNoKTtcbiAgICAgIE9wYWwuaGFzaF9jbG9uZShzZWxmLCBoYXNoKTtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faGFzaFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBwcm9jIGRvIHxrZXkgPSB1bmRlZmluZWR8XG4gICAgICAleHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyBrZXkgZ2l2ZW4nfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZba2V5XVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX2tleXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9ICR5aWVsZDEoYmxvY2ssIGtleSk7XG5cbiAgICAgICAgJGhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX2tleXMhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV9rZXlzISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBrZXlzID0gT3BhbC5zbGljZShzZWxmLiQka2V5cyksXG4gICAgICAgICAgaSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG5ld19rZXk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld19rZXkgPSAkeWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuICAgICAgICAkaGFzaF9wdXQoc2VsZiwgbmV3X2tleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fdmFsdWVzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV92YWx1ZXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICRoYXNoX3B1dChyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV92YWx1ZXMhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdmFsdWVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmLiQkc21hcFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBkdXAgY2xvbmVcbiAgYWxpYXMgZWFjaF9wYWlyIGVhY2hcbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuICBhbGlhcyBpbmNsdWRlPyBoYXNfa2V5P1xuICBhbGlhcyBpbmRpY2VzIGluZGV4ZXNcbiAgYWxpYXMga2V5IGluZGV4XG4gIGFsaWFzIGtleT8gaGFzX2tleT9cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuICBhbGlhcyBzaXplIGxlbmd0aFxuICBhbGlhcyBzdG9yZSBbXT1cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG4gIGFsaWFzIHVwZGF0ZSBtZXJnZSFcbiAgYWxpYXMgdmFsdWU/IGhhc192YWx1ZT9cbiAgYWxpYXMgdmFsdWVzX2F0IGluZGV4ZXNcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpIYXNoPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiW10iLCJPcGFsIiwiY29lcmNlX3RvPyIsImFyZ3YiLCIwIiwiSGFzaCIsImFsbG9jYXRlIiwibWVyZ2UhIiwiQXJyYXkiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0cnlfY29udmVydCIsIm9iaiIsImluaXRpYWxpemUiLCJkZWZhdWx0cyIsIj09Iiwib3RoZXIiLCI+PSIsImNvZXJjZV90byEiLCJyZXN1bHQiLCJlYWNoIiwiYmxvY2sgaW4gPj0iLCJvdGhlcl9rZXkiLCJvdGhlcl92YWwiLCJibG9jayAoMiBsZXZlbHMpIGluID49IiwidmFsIiwiZmV0Y2giLCI+IiwiPCIsIjw9Iiwia2V5IiwiW109IiwidmFsdWUiLCJhc3NvYyIsIm9iamVjdCIsImNsZWFyIiwiY2xvbmUiLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCJkZWZhdWx0IiwiZGVmYXVsdD0iLCJkZWZhdWx0X3Byb2MiLCJkZWZhdWx0X3Byb2M9IiwiUHJvYyIsImxhbWJkYT8iLCJhcml0eSIsImFicyIsIlR5cGVFcnJvciIsImRlbGV0ZSIsImRlbGV0ZV9pZiIsImJsb2NrIiwiZW51bV9mb3IiLCJibG9jayBpbiBkZWxldGVfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZV9pZiIsInNpemUiLCJkaWciLCJpdGVtIiwicmVzcG9uZF90bz8iLCJjbGFzcyIsImtleXMiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9rZXkiLCJibG9jayBpbiBlYWNoX2tleSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9rZXkiLCJlYWNoX3ZhbHVlIiwiYmxvY2sgaW4gZWFjaF92YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF92YWx1ZSIsImVtcHR5PyIsImV4Y2VwdCIsImV4Y2VwdCEiLCJkdXAiLCJibG9jayBpbiBleGNlcHQhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBleGNlcHQhIiwiS2V5RXJyb3IiLCJuZXciLCJpbnNwZWN0IiwiZmV0Y2hfdmFsdWVzIiwibWFwIiwiYmxvY2sgaW4gZmV0Y2hfdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmZXRjaF92YWx1ZXMiLCJ0b19wcm9jIiwiZmxhdHRlbiIsImxldmVsIiwiMSIsIkludGVnZXIiLCJmcmVlemUiLCJmcm96ZW4/IiwiaGFzX2tleT8iLCJoYXNfdmFsdWU/IiwiaGFzaCIsImVxbD8iLCJpbmRleCIsImluZGV4ZXMiLCJpbnZlcnQiLCJrZWVwX2lmIiwiYmxvY2sgaW4ga2VlcF9pZiIsImJsb2NrICgyIGxldmVscykgaW4ga2VlcF9pZiIsImxlbmd0aCIsIm1lcmdlIiwib3RoZXJzIiwicmFzc29jIiwicmVoYXNoIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZWplY3QhIiwiYmxvY2sgaW4gcmVqZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0ISIsInJlcGxhY2UiLCJzZWxlY3QiLCJibG9jayBpbiBzZWxlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbGVjdCIsInNlbGVjdCEiLCJibG9jayBpbiBzZWxlY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QhIiwic2hpZnQiLCJzbGljZSIsInRvX2EiLCJ0b19oIiwiYmxvY2tfZ2l2ZW4/IiwidG9faGFzaCIsInByb2MiLCJibG9jayBpbiB0b19wcm9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19wcm9jIiwidHJhbnNmb3JtX2tleXMiLCJibG9jayBpbiB0cmFuc2Zvcm1fa2V5cyIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX2tleXMiLCJ0cmFuc2Zvcm1fa2V5cyEiLCJibG9jayBpbiB0cmFuc2Zvcm1fa2V5cyEiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV9rZXlzISIsInRyYW5zZm9ybV92YWx1ZXMiLCJibG9jayBpbiB0cmFuc2Zvcm1fdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fdmFsdWVzIiwidHJhbnNmb3JtX3ZhbHVlcyEiLCJibG9jayBpbiB0cmFuc2Zvcm1fdmFsdWVzISIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX3ZhbHVlcyEiLCJ2YWx1ZXMiXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBVUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDtJQUdDRDtJQUVERyxNQUFJTCxJQUFKSyxTQUFBQSxvQkFsQkYsRUFrQkVBO0FBQUFBLE1BQUFBOzs7TUFsQkY7TUFrQmM7O0FBRWRBOztBQUVBQTtBQUNBQSxlQUFpQkMsS0FBTUMsZUFBQUEsQ0FBWUMsSUFBSUgsT0FBQUEsQ0FBQ0ksQ0FBREosQ0FBdEIsRUFBMkJLLFdBQTNCLEVBQW1DLFNBQTdCSCxDQUF1Q0Y7QUFDOURBO0FBQ0FBLGlCQUFtQkwsSUFBQVcsVUFBQUEsQ0FBQUEsQ0FBUUMsV0FBQUEsQ0FBU1AsSUFBVE8sQ0FBZ0JQO0FBQzNDQTs7QUFFQUEsZUFBaUJDLEtBQU1DLGVBQUFBLENBQVlDLElBQUlILE9BQUFBLENBQUNJLENBQURKLENBQXRCLEVBQTJCUSxZQUEzQixFQUFvQyxRQUE5Qk4sQ0FBdUNGO0FBQzlEQTtBQUNBQSxVQUFZUyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ1gsa0NBQXhCVTtBQUNwQlY7O0FBRUFBO0FBQ0FBLGVBQWlCTCxJQUFBVyxVQUFBQSxDQUFBQSxDQUFTTjs7QUFFMUJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FB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In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3MDk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1iZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyA6Ok51bWJlciA8IDo6TnVtZXJpY1xuICA6Ok9wYWwuYnJpZGdlKGBOdW1iZXJgLCBzZWxmKVxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX251bWJlcicsIHRydWUpYFxuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIgPT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tvdGhlci5jbGFzc30gaW50byBGbG9hdFwifTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbI3s6Oktlcm5lbC5GbG9hdChvdGhlcil9LCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8oOnRvX2YpfSkge1xuICAgICAgICByZXR1cm4gWyN7OjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6RmxvYXQsIDp0b19mKX0sIHNlbGZdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIFtvdGhlciwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYChzZWxmICogMikgKyAxYFxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiArIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDorLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAtIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDotLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAqIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDoqLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAvIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDovLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgJShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyID09IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA8IDAgfHwgc2VsZiA8IDApIHtcbiAgICAgICAgICByZXR1cm4gKHNlbGYgJSBvdGhlciArIG90aGVyKSAlIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmICUgb3RoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6JSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgJiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Jiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgfCBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6fCwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgXiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Xiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPCBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PCwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIDw9IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8PSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Piwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmID49IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+PSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgIyBDb21wdXRlIHRoZSByZXN1bHQgb2YgdGhlIHNwYWNlc2hpcCBvcGVyYXRvciBpbnNpZGUgaXRzIG93biBmdW5jdGlvbiBzbyBpdFxuICAjIGNhbiBiZSBvcHRpbWl6ZWQgZGVzcGl0ZSBhIHRyeS9maW5hbGx5IGNvbnN0cnVjdC5cbiAgJXh7XG4gICAgdmFyIHNwYWNlc2hpcF9vcGVyYXRvciA9IGZ1bmN0aW9uKHNlbGYsIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKGlzTmFOKHNlbGYpIHx8IGlzTmFOKG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZiA+IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZiA8IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjw9PiwgYG90aGVyYH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBgc3BhY2VzaGlwX29wZXJhdG9yKHNlbGYsIG90aGVyKWBcbiAgcmVzY3VlIDo6QXJndW1lbnRFcnJvclxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgPDwoY291bnQpXG4gICAgY291bnQgPSA6Ok9wYWwuY29lcmNlX3RvISBjb3VudCwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBgI3tjb3VudH0gPiAwID8gc2VsZiA8PCAje2NvdW50fSA6IHNlbGYgPj4gLSN7Y291bnR9YFxuICBlbmRcblxuICBkZWYgPj4oY291bnQpXG4gICAgY291bnQgPSA6Ok9wYWwuY29lcmNlX3RvISBjb3VudCwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBgI3tjb3VudH0gPiAwID8gc2VsZiA+PiAje2NvdW50fSA6IHNlbGYgPDwgLSN7Y291bnR9YFxuICBlbmRcblxuICBkZWYgW10oYml0KVxuICAgIGJpdCA9IDo6T3BhbC5jb2VyY2VfdG8hIGJpdCwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAleHtcbiAgICAgIGlmICgje2JpdH0gPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKCN7Yml0fSA+PSAzMikge1xuICAgICAgICByZXR1cm4gI3sgc2VsZiB9IDwgMCA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzZWxmID4+ICN7Yml0fSkgJiAxO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICtAXG4gICAgYCtzZWxmYFxuICBlbmRcblxuICBkZWYgLUBcbiAgICBgLXNlbGZgXG4gIGVuZFxuXG4gIGRlZiB+XG4gICAgYH5zZWxmYFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgOjpJbnRlZ2VyID09PSBvdGhlclxuICAgICAgaWYgISg6OkludGVnZXIgPT09IHNlbGYpIHx8IG90aGVyID4gMFxuICAgICAgICBgTWF0aC5wb3coc2VsZiwgb3RoZXIpYFxuICAgICAgZWxzZVxuICAgICAgICA6OlJhdGlvbmFsLm5ldyhzZWxmLCAxKSoqb3RoZXJcbiAgICAgIGVuZFxuICAgIGVsc2lmIHNlbGYgPCAwICYmICg6OkZsb2F0ID09PSBvdGhlciB8fCA6OlJhdGlvbmFsID09PSBvdGhlcilcbiAgICAgIDo6Q29tcGxleC5uZXcoc2VsZiwgMCkqKm90aGVyLnRvX2ZcbiAgICBlbHNpZiBgb3RoZXIuJCRpc19udW1iZXIgIT0gbnVsbGBcbiAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/IDo9PX0pIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgPT09ID09XG5cbiAgZGVmIGFic1xuICAgIGBNYXRoLmFicyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBgTWF0aC5hYnMoc2VsZiAqIHNlbGYpYFxuICBlbmRcblxuICBkZWYgYWxsYml0cz8obWFzaylcbiAgICBtYXNrID0gOjpPcGFsLmNvZXJjZV90byEgbWFzaywgOjpJbnRlZ2VyLCA6dG9faW50XG4gICAgYChzZWxmICYgbWFzaykgPT0gbWFza2BcbiAgZW5kXG5cbiAgZGVmIGFueWJpdHM/KG1hc2spXG4gICAgbWFzayA9IDo6T3BhbC5jb2VyY2VfdG8hIG1hc2ssIDo6SW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spICE9PSAwYFxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICByZXR1cm4gc2VsZiBpZiBuYW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgaWYgKDEgLyBzZWxmID4gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBiaXRfbGVuZ3RoXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOb01ldGhvZEVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYGJpdF9sZW5ndGhgIGZvciAje3NlbGZ9OkZsb2F0XCIsICdiaXRfbGVuZ3RoJylcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IDAgfHwgc2VsZiA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgIHZhbHVlICA9IHNlbGYgPCAwID8gfnNlbGYgOiBzZWxmO1xuXG4gICAgICB3aGlsZSAodmFsdWUgIT0gMCkge1xuICAgICAgICByZXN1bHQgICArPSAxO1xuICAgICAgICB2YWx1ZSAgPj4+PSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNlaWwobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gTWF0aC5jZWlsKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNocihlbmNvZGluZyA9IHVuZGVmaW5lZClcbiAgICBgT3BhbC5lbmMoU3RyaW5nLmZyb21DaGFyQ29kZShzZWxmKSwgZW5jb2RpbmcgfHwgXCJCSU5BUllcIilgXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIGlmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICAxXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGRvd250byhzdG9wLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpkb3dudG8sIHN0b3ApIGRvXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwiIHVubGVzcyA6Ok51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA+IHNlbGYgPyAwIDogc2VsZiAtIHN0b3AgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA+PSBzdG9wOyBpLS0pIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZXF1YWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXIgfHwgYGlzTmFOKHNlbGYpICYmIGlzTmFOKG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIGV2ZW4/XG4gICAgYHNlbGYgJSAyID09PSAwYFxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gTWF0aC5mbG9vcihmICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnY2Qob3RoZXIpXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGFuIGludGVnZXInXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW4gPSBNYXRoLmFicyhzZWxmKSxcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhvdGhlcik7XG5cbiAgICAgIHdoaWxlIChtaW4gPiAwKSB7XG4gICAgICAgIHZhciB0bXAgPSBtaW47XG5cbiAgICAgICAgbWluID0gbWF4ICUgbWluO1xuICAgICAgICBtYXggPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2NkbGNtKG90aGVyKVxuICAgIFtnY2Qob3RoZXIpLCBsY20ob3RoZXIpXVxuICBlbmRcblxuICBkZWYgaW50ZWdlcj9cbiAgICBgc2VsZiAlIDEgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkludGVnZXIgJiYgOjpJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6RmxvYXQgJiYgOjpGbG9hdCA9PT0gc2VsZlxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkludGVnZXIgJiYgOjpJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6RmxvYXQgJiYgOjpGbG9hdCA9PT0gc2VsZlxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGxjbShvdGhlcilcbiAgICB1bmxlc3MgOjpJbnRlZ2VyID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYW4gaW50ZWdlcidcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gMCB8fCBvdGhlciA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhzZWxmICogb3RoZXIgLyAje2djZChvdGhlcil9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuZXh0XG4gICAgYHNlbGYgKyAxYFxuICBlbmRcblxuICBkZWYgbm9iaXRzPyhtYXNrKVxuICAgIG1hc2sgPSA6Ok9wYWwuY29lcmNlX3RvISBtYXNrLCA6OkludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSA9PSAwYFxuICBlbmRcblxuICBkZWYgbm9uemVybz9cbiAgICBgc2VsZiA9PSAwID8gbmlsIDogc2VsZmBcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIGlmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICBzZWxmXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG9kZD9cbiAgICBgc2VsZiAlIDIgIT09IDBgXG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwb3coYiwgbSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgIH1cblxuICAgICAgaWYgKG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tzZWxmKipifTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKCN7OjpJbnRlZ2VyID09PSBifSkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAybmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGEgMXN0IGFyZ3VtZW50IGlzIGludGVnZXInfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIgPCAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMXN0IGFyZ3VtZW50IGNhbm5vdCBiZSBuZWdhdGl2ZSB3aGVuIDJuZCBhcmd1bWVudCBzcGVjaWZpZWQnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoI3s6OkludGVnZXIgPT09IG19KSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDJuZCBhcmd1bWVudCBub3QgYWxsb3dlZCB1bmxlc3MgYWxsIGFyZ3VtZW50cyBhcmUgaW50ZWdlcnMnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0gPT09IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7KHNlbGYqKmIpICUgbX1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcmVkXG4gICAgYHNlbGYgLSAxYFxuICBlbmRcblxuICBkZWYgcXVvKG90aGVyKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgc3VwZXJcbiAgICBlbHNlXG4gICAgICBzZWxmIC8gb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgOjpSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2lmIG5hbj9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICBlbHNpZiBgZXBzID09IG51bGxgXG4gICAgICBmLCBuICA9IDo6TWF0aC5mcmV4cCBzZWxmXG4gICAgICBmICAgICA9IDo6TWF0aC5sZGV4cChmLCA6OkZsb2F0OjpNQU5UX0RJRykudG9faVxuICAgICAgbiAgICAtPSA6OkZsb2F0OjpNQU5UX0RJR1xuXG4gICAgICA6OlJhdGlvbmFsLm5ldygyICogZiwgMSA8PCAoMSAtIG4pKS5yYXRpb25hbGl6ZSg6OlJhdGlvbmFsLm5ldygxLCAxIDw8ICgxIC0gbikpKVxuICAgIGVsc2VcbiAgICAgIHRvX3IucmF0aW9uYWxpemUoZXBzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVtYWluZGVyKHkpXG4gICAgc2VsZiAtIHkgKiAoc2VsZiAvIHkpLnRydW5jYXRlXG4gIGVuZFxuXG4gIGRlZiByb3VuZChuZGlnaXRzID0gdW5kZWZpbmVkKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgaWYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBpZiA6OkZsb2F0ID09PSBuZGlnaXRzICYmIG5kaWdpdHMuaW5maW5pdGU/XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ0luZmluaXR5J1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSA6Ok9wYWwuY29lcmNlX3RvIShuZGlnaXRzLCA6OkludGVnZXIsIDp0b19pbnQpXG5cbiAgICAgIGlmIG5kaWdpdHMgPCA6OkludGVnZXI6Ok1JTlxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdvdXQgb2YgYm91bmRzJ1xuICAgICAgZW5kXG5cbiAgICAgIGlmIGBuZGlnaXRzID49IDBgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IC1uZGlnaXRzXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAoMC40MTUyNDEgKiBuZGlnaXRzIC0gMC4xMjUgPiAje3NpemV9KSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKChNYXRoLmFicyhzZWxmKSArIGYgLyAyKSAvIGYpICogZjtcblxuICAgICAgICByZXR1cm4gc2VsZiA8IDAgPyAteCA6IHg7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgaWYgbmFuPyAmJiBgbmRpZ2l0cyA9PSBudWxsYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IDo6T3BhbC5jb2VyY2VfdG8hKGBuZGlnaXRzIHx8IDBgLCA6OkludGVnZXIsIDp0b19pbnQpXG5cbiAgICAgIGlmIG5kaWdpdHMgPD0gMFxuICAgICAgICBpZiBuYW4/XG4gICAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnTmFOJ1xuICAgICAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBuZGlnaXRzID09IDBcbiAgICAgICAgcmV0dXJuIGBNYXRoLnJvdW5kKHNlbGYpYFxuICAgICAgZWxzaWYgbmFuPyB8fCBpbmZpbml0ZT9cbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBfLCBleHAgPSA6Ok1hdGguZnJleHAoc2VsZilcblxuICAgICAgaWYgbmRpZ2l0cyA+PSAoOjpGbG9hdDo6RElHICsgMikgLSAoZXhwID4gMCA/IGV4cCAvIDQgOiBleHAgLyAzIC0gMSlcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuZGlnaXRzIDwgLShleHAgPiAwID8gZXhwIC8gMyArIDEgOiBleHAgLyA0KVxuICAgICAgICByZXR1cm4gMFxuICAgICAgZW5kXG5cbiAgICAgIGBNYXRoLnJvdW5kKHNlbGYgKiBNYXRoLnBvdygxMCwgbmRpZ2l0cykpIC8gTWF0aC5wb3coMTAsIG5kaWdpdHMpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdGltZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dGltZXMpIHsgc2VsZiB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGY7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIGBzZWxmIDwgMCA/IE1hdGguY2VpbChzZWxmKSA6IE1hdGguZmxvb3Ioc2VsZilgXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgaWYgOjpJbnRlZ2VyID09PSBzZWxmXG4gICAgICA6OlJhdGlvbmFsLm5ldyhzZWxmLCAxKVxuICAgIGVsc2VcbiAgICAgIGYsIGUgID0gOjpNYXRoLmZyZXhwKHNlbGYpXG4gICAgICBmICAgICA9IDo6TWF0aC5sZGV4cChmLCA6OkZsb2F0OjpNQU5UX0RJRykudG9faVxuICAgICAgZSAgICAtPSA6OkZsb2F0OjpNQU5UX0RJR1xuXG4gICAgICAoZiAqICg6OkZsb2F0OjpSQURJWCoqZSkpLnRvX3JcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3MoYmFzZSA9IDEwKVxuICAgIGJhc2UgPSA6Ok9wYWwuY29lcmNlX3RvISBiYXNlLCA6OkludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGJhc2UgPCAyIHx8IGJhc2UgPiAzNlxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICAjIERvbid0IGxvc2UgdGhlIG5lZ2F0aXZlIHplcm9cbiAgICBpZiBzZWxmID09IDAgJiYgYDEvc2VsZiA9PT0gLUluZmluaXR5YFxuICAgICAgcmV0dXJuICctMC4wJ1xuICAgIGVuZFxuXG4gICAgYHNlbGYudG9TdHJpbmcoYmFzZSlgXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBwYXJzZUludChmICogZmFjdG9yLCAxMCkgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGlnaXRzKGJhc2UgPSAxMClcbiAgICBpZiBzZWxmIDwgMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpNYXRoOjpEb21haW5FcnJvciwgJ291dCBvZiBkb21haW4nXG4gICAgZW5kXG5cbiAgICBiYXNlID0gOjpPcGFsLmNvZXJjZV90byEgYmFzZSwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBiYXNlIDwgMlxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmICE9IHBhcnNlSW50KHNlbGYpKSAjezo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvciwgXCJ1bmRlZmluZWQgbWV0aG9kIGBkaWdpdHMnIGZvciAje2luc3BlY3R9XCJ9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHNlbGYsIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgIHJldHVybiBbMF07XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh2YWx1ZSAhPSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlICUgYmFzZSk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUgLyBiYXNlLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIGlmIG5hbj8gfHwgb3RoZXIubmFuP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHVwdG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6dXB0bywgc3RvcCkgZG9cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCIgdW5sZXNzIDo6TnVtZXJpYyA9PT0gc3RvcFxuICAgICAgICBzdG9wIDwgc2VsZiA/IDAgOiBzdG9wIC0gc2VsZiArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIXN0b3AuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIn1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBzZWxmOyBpIDw9IHN0b3A7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIGBzZWxmID09IDBgXG4gIGVuZFxuXG4gICMgU2luY2UgYml0d2lzZSBvcGVyYXRpb25zIGFyZSAzMiBiaXQsIGRlY2xhcmUgaXQgdG8gYmUgc28uXG4gIGRlZiBzaXplXG4gICAgNFxuICBlbmRcblxuICBkZWYgbmFuP1xuICAgIGBpc05hTihzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBgc2VsZiAhPSBJbmZpbml0eSAmJiBzZWxmICE9IC1JbmZpbml0eSAmJiAhaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiArMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlbGYgPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHBvc2l0aXZlP1xuICAgIGBzZWxmICE9IDAgJiYgKHNlbGYgPT0gSW5maW5pdHkgfHwgMSAvIHNlbGYgPiAwKWBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIGBzZWxmID09IC1JbmZpbml0eSB8fCAxIC8gc2VsZiA8IDBgXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIG51bWJlclRvVWludDhBcnJheShudW0pIHtcbiAgICAgIHZhciB1aW50OGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICBuZXcgRGF0YVZpZXcodWludDhhcnJheS5idWZmZXIpLnNldEZsb2F0NjQoMCwgbnVtLCB0cnVlKTtcbiAgICAgIHJldHVybiB1aW50OGFycmF5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb051bWJlcihhcnIpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlcikuZ2V0RmxvYXQ2NCgwLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmNyZW1lbnROdW1iZXJCaXQobnVtKSB7XG4gICAgICB2YXIgYXJyID0gbnVtYmVyVG9VaW50OEFycmF5KG51bSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09PSAweGZmKSB7XG4gICAgICAgICAgYXJyW2ldID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJbaV0rKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb051bWJlcihhcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY3JlbWVudE51bWJlckJpdChudW0pIHtcbiAgICAgIHZhciBhcnIgPSBudW1iZXJUb1VpbnQ4QXJyYXkobnVtKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT09IDApIHtcbiAgICAgICAgICBhcnJbaV0gPSAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycltpXS0tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdWludDhBcnJheVRvTnVtYmVyKGFycik7XG4gICAgfVxuICB9XG5cbiAgZGVmIG5leHRfZmxvYXRcbiAgICByZXR1cm4gOjpGbG9hdDo6SU5GSU5JVFkgaWYgc2VsZiA9PSA6OkZsb2F0OjpJTkZJTklUWVxuICAgIHJldHVybiA6OkZsb2F0OjpOQU4gaWYgbmFuP1xuXG4gICAgaWYgc2VsZiA+PSAwXG4gICAgICAjIE1hdGguYWJzKCkgaXMgbmVlZGVkIHRvIGhhbmRsZSAtMC4wXG4gICAgICBgaW5jcmVtZW50TnVtYmVyQml0KE1hdGguYWJzKHNlbGYpKWBcbiAgICBlbHNlXG4gICAgICBgZGVjcmVtZW50TnVtYmVyQml0KHNlbGYpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcHJldl9mbG9hdFxuICAgIHJldHVybiAtOjpGbG9hdDo6SU5GSU5JVFkgaWYgc2VsZiA9PSAtOjpGbG9hdDo6SU5GSU5JVFlcbiAgICByZXR1cm4gOjpGbG9hdDo6TkFOIGlmIG5hbj9cblxuICAgIGlmIHNlbGYgPiAwXG4gICAgICBgZGVjcmVtZW50TnVtYmVyQml0KHNlbGYpYFxuICAgIGVsc2VcbiAgICAgIGAtaW5jcmVtZW50TnVtYmVyQml0KE1hdGguYWJzKHNlbGYpKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgYXJnIGFuZ2xlXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgZmRpdiAvXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuICBhbGlhcyBraW5kX29mPyBpc19hP1xuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG4gIGFsaWFzIG1vZHVsbyAlXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cbiAgYWxpYXMgcGhhc2UgYW5nbGVcbiAgYWxpYXMgc3VjYyBuZXh0XG4gIGFsaWFzIHRvX2ludCB0b19pXG5lbmRcblxuOjpGaXhudW0gPSA6Ok51bWJlclxuXG5jbGFzcyA6OkludGVnZXIgPCA6Ok51bWVyaWNcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuICBgc2VsZi4kJGlzX2ludGVnZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuXG4gICAgZGVmIHNxcnQobilcbiAgICAgIG4gPSA6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok1hdGg6OkRvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImlzcXJ0XCInfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KE1hdGguc3FydChuKSwgMTApO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIHRyeV9jb252ZXJ0KG9iamVjdClcbiAgICAgIE9wYWwuY29lcmNlX3RvPyhvYmplY3QsIHNlbGYsIDp0b19pbnQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIHNlbGY6Ok1BWCA9IGBNYXRoLnBvdygyLCAzMCkgLSAxYFxuICBzZWxmOjpNSU4gPSBgLU1hdGgucG93KDIsIDMwKWBcbmVuZFxuXG5jbGFzcyA6OkZsb2F0IDwgOjpOdW1lcmljXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcblxuICAgIGRlZiA9PT0ob3RoZXIpXG4gICAgICBgISFvdGhlci4kJGlzX251bWJlcmBcbiAgICBlbmRcbiAgZW5kXG5cbiAgc2VsZjo6SU5GSU5JVFkgPSBgSW5maW5pdHlgXG4gIHNlbGY6Ok1BWCAgICAgID0gYE51bWJlci5NQVhfVkFMVUVgXG4gIHNlbGY6Ok1JTiAgICAgID0gYE51bWJlci5NSU5fVkFMVUVgXG4gIHNlbGY6Ok5BTiAgICAgID0gYE5hTmBcblxuICBzZWxmOjpESUcgICAgICA9IDE1XG4gIHNlbGY6Ok1BTlRfRElHID0gNTNcbiAgc2VsZjo6UkFESVggICAgPSAyXG5cbiAgc2VsZjo6RVBTSUxPTiA9IGBOdW1iZXIuRVBTSUxPTiB8fCAyLjIyMDQ0NjA0OTI1MDMxMzA4MDg0NzI2MzMzNjE4MTZFLTE2YFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOk51bWJlcj4iLCJPcGFsIiwiYnJpZGdlIiwiYWxsb2NhdGUiLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5hbWUiLCJjb2VyY2UiLCJvdGhlciIsImNsYXNzIiwiRmxvYXQiLCJyZXNwb25kX3RvPyIsImNvZXJjZV90byEiLCJfX2lkX18iLCIrIiwiX19jb2VyY2VkX18iLCItIiwiKiIsIi8iLCIlIiwiWmVyb0RpdmlzaW9uRXJyb3IiLCImIiwifCIsIl4iLCI8IiwiPD0iLCI+IiwiPj0iLCI8PT4iLCJBcmd1bWVudEVycm9yIiwiPDwiLCJjb3VudCIsIkludGVnZXIiLCI+PiIsIltdIiwiYml0IiwiK0AiLCItQCIsIn4iLCIqKiIsIj09PSIsIjAiLCJSYXRpb25hbCIsIm5ldyIsIjEiLCJDb21wbGV4IiwidG9fZiIsIj09IiwiYWJzIiwiYWJzMiIsImFsbGJpdHM/IiwibWFzayIsImFueWJpdHM/IiwiYW5nbGUiLCJuYW4/IiwiYml0X2xlbmd0aCIsIk5vTWV0aG9kRXJyb3IiLCJjZWlsIiwibmRpZ2l0cyIsImNociIsImVuY29kaW5nIiwiZGVub21pbmF0b3IiLCJpbmZpbml0ZT8iLCJkb3dudG8iLCJzdG9wIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJibG9jayBpbiBkb3dudG8iLCJibG9jayAoMiBsZXZlbHMpIGluIGRvd250byIsIk51bWVyaWMiLCJlcXVhbD8iLCIkcmV0X29yXzEiLCJldmVuPyIsImZsb29yIiwiZ2NkIiwiZ2NkbGNtIiwibGNtIiwiaW50ZWdlcj8iLCJpc19hPyIsImtsYXNzIiwiaW5zdGFuY2Vfb2Y/IiwibmV4dCIsIm5vYml0cz8iLCJub256ZXJvPyIsIm51bWVyYXRvciIsIm9kZD8iLCJvcmQiLCJwb3ciLCJiIiwibSIsInByZWQiLCJxdW8iLCJyYXRpb25hbGl6ZSIsImVwcyIsIkZsb2F0RG9tYWluRXJyb3IiLCJNYXRoIiwiZnJleHAiLCJmIiwibiIsImxkZXhwIiwiRmxvYXQ6Ok1BTlRfRElHIiwidG9faSIsIjIiLCJ0b19yIiwicmVtYWluZGVyIiwieSIsInRydW5jYXRlIiwicm91bmQiLCJSYW5nZUVycm9yIiwiSW50ZWdlcjo6TUlOIiwic2l6ZSIsIl8iLCJleHAiLCJGbG9hdDo6RElHIiwiNCIsIjMiLCJ0aW1lcyIsImJsb2NrIiwiYmxvY2sgaW4gdGltZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIHRpbWVzIiwiZSIsIkZsb2F0OjpSQURJWCIsInRvX3MiLCJiYXNlIiwiMTAiLCIzNiIsImRpZ2l0cyIsIk1hdGg6OkRvbWFpbkVycm9yIiwiaW5zcGVjdCIsImRpdm1vZCIsInVwdG8iLCJibG9jayBpbiB1cHRvIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB1cHRvIiwiemVybz8iLCJmaW5pdGU/IiwicG9zaXRpdmU/IiwibmVnYXRpdmU/IiwibmV4dF9mbG9hdCIsIkZsb2F0OjpJTkZJTklUWSIsIkZsb2F0OjpOQU4iLCJwcmV2X2Zsb2F0IiwiTnVtYmVyIiwiPGNsYXNzOkludGVnZXI+Iiwic3FydCIsInRyeV9jb252ZXJ0Iiwib2JqZWN0IiwiY29lcmNlX3RvPyIsIjxjbGFzczpGbG9hdD4iLCIxNSIsIjUzIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUVB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QUEsQ0FBQUEsQ0FBM0IsQ0FBcEJGO01BRFZGLENBQUFBOztNQUlBLHNCQUFNLEtBQU47TUFFQSxPQUFBc0MsbUJBQUFBLHNCQUFRaEMsS0FBUmdDO0FBQUFBO1FBQ0VBLE9BQUNBLG1CQUFEQTtNQURGQSxDQUFBQTtJQVBGLDRCQUFTM0MsSUFBVDtJQVlBLFdBQUFBLElBQUEsY0FBa0JzSixRQUFsQjtJQUNBLFdBQUF0SixJQUFBLFNBQWtCc0osZ0JBQWxCO0lBQ0EsV0FBQXRKLElBQUEsU0FBa0JzSixnQkFBbEI7SUFDQSxXQUFBdEosSUFBQSxTQUFrQnNKLEdBQWxCO0lBRUEsV0FBQXRKLElBQUEsU0FBaUJ1SixFQUFqQjtJQUNBLFdBQUF2SixJQUFBLGNBQWlCd0osRUFBakI7SUFDQSxXQUFBeEosSUFBQSxXQUFpQnlHLENBQWpCO0lBRUE2QyxPQUFBLFdBQUF0SixJQUFBLGFBQWlCc0osdURBQWpCO0VBeEJGQSxHQUFNLElBQU5BLEVBQWdCOUUsY0FBaEI4RTtBQWw1QkF2SjsifX0seyJvZmZzZXQiOnsibGluZSI6MTgyNTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgOjpSYW5nZVxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfcmFuZ2UgPSB0cnVlYFxuXG4gIGF0dHJfcmVhZGVyIDpiZWdpbiwgOmVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGZpcnN0LCBsYXN0LCBleGNsdWRlID0gZmFsc2UpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwiJ2luaXRpYWxpemUnIGNhbGxlZCB0d2ljZVwiIGlmIEBiZWdpblxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2JhZCB2YWx1ZSBmb3IgcmFuZ2UnIHVubGVzcyBmaXJzdCA8PT4gbGFzdCB8fCBmaXJzdC5uaWw/IHx8IGxhc3QubmlsP1xuXG4gICAgQGJlZ2luID0gZmlyc3RcbiAgICBAZW5kICAgPSBsYXN0XG4gICAgQGV4Y2wgID0gZXhjbHVkZVxuICBlbmRcblxuICBkZWYgPT09KHZhbHVlKVxuICAgIGluY2x1ZGU/IHZhbHVlXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGlzX2luZmluaXRlKHNlbGYpIHtcbiAgICAgIGlmIChzZWxmLmJlZ2luID09PSBuaWwgfHwgc2VsZi5lbmQgPT09IG5pbCB8fFxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IC1JbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICBzZWxmLmJlZ2luID09PSBJbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gLUluZmluaXR5KSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkZWYgY291bnQoJmJsb2NrKVxuICAgIGlmICFibG9ja19naXZlbj8gJiYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgICAgcmV0dXJuIDo6RmxvYXQ6OklORklOSVRZXG4gICAgZW5kXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2Nhbm5vdCBjb252ZXJ0IGVuZGxlc3MgcmFuZ2UgdG8gYW4gYXJyYXknIGlmIGBpc19pbmZpbml0ZShzZWxmKWBcbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgY292ZXI/KHZhbHVlKVxuICAgIGJlZ19jbXAgPSAoQGJlZ2luLm5pbD8gJiYgLTEpIHx8IChAYmVnaW4gPD0+IHZhbHVlKSB8fCBmYWxzZVxuICAgIGVuZF9jbXAgPSAoQGVuZC5uaWw/ICYmIC0xKSB8fCAodmFsdWUgPD0+IEBlbmQpIHx8IGZhbHNlXG4gICAgaWYgQGV4Y2xcbiAgICAgIGVuZF9jbXAgJiYgZW5kX2NtcCA8IDBcbiAgICBlbHNlXG4gICAgICBlbmRfY21wICYmIGVuZF9jbXAgPD0gMFxuICAgIGVuZCAmJiBiZWdfY21wICYmIGJlZ19jbXAgPD0gMFxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsaW1pdDtcblxuICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX251bWJlciAmJiAje0BlbmR9LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmICgje0BiZWdpbn0gJSAxICE9PSAwIHx8ICN7QGVuZH0gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBpdGVyYXRlIGZyb20gRmxvYXRcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9ICN7QGJlZ2lufSwgbGltaXQgPSAje0BlbmR9ICsgI3tAZXhjbCA/IDAgOiAxfTsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICBibG9jayhpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tAYmVnaW4udXB0byhAZW5kLCBAZXhjbCwgJmJsb2NrKX1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudCA9IEBiZWdpblxuICAgIGxhc3QgICAgPSBAZW5kXG5cbiAgICB1bmxlc3MgY3VycmVudC5yZXNwb25kX3RvPyg6c3VjYylcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGl0ZXJhdGUgZnJvbSAje2N1cnJlbnQuY2xhc3N9XCJcbiAgICBlbmRcblxuICAgIHdoaWxlIEBlbmQubmlsPyB8fCAoY3VycmVudCA8PT4gbGFzdCkgPCAwXG4gICAgICB5aWVsZCBjdXJyZW50XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnN1Y2NcbiAgICBlbmRcblxuICAgIHlpZWxkIGN1cnJlbnQgaWYgIUBleGNsICYmIGN1cnJlbnQgPT0gbGFzdFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIDo6UmFuZ2UgPT09IG90aGVyXG5cbiAgICBAZXhjbCA9PT0gb3RoZXIuZXhjbHVkZV9lbmQ/ICYmXG4gICAgICBAYmVnaW4uZXFsPyhvdGhlci5iZWdpbikgJiZcbiAgICAgIEBlbmQuZXFsPyhvdGhlci5lbmQpXG4gIGVuZFxuXG4gIGRlZiBleGNsdWRlX2VuZD9cbiAgICBAZXhjbFxuICBlbmRcblxuICBkZWYgZmlyc3QobiA9IHVuZGVmaW5lZClcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtaW5pbXVtIG9mIGJlZ2lubGVzcyByYW5nZScgaWYgQGJlZ2luLm5pbD9cbiAgICByZXR1cm4gQGJlZ2luIGlmIGBuID09IG51bGxgXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGxhc3QobiA9IHVuZGVmaW5lZClcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtYXhpbXVtIG9mIGVuZGxlc3MgcmFuZ2UnIGlmIEBlbmQubmlsP1xuICAgIHJldHVybiBAZW5kIGlmIGBuID09IG51bGxgXG4gICAgdG9fYS5sYXN0KG4pXG4gIGVuZFxuXG4gICMgRklYTUU6IGN1cnJlbnRseSBoYXJkY29kZWQgdG8gYXNzdW1lIHJhbmdlIGhvbGRzIG51bWVyaWNzXG4gIGRlZiBtYXhcbiAgICBpZiBAZW5kLm5pbD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBiZWdpbi5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBAZXhjbCAmJiBAYmVnaW4gPT0gQGVuZClcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIGAje0BleGNsfSA/ICN7QGVuZH0gLSAxIDogI3tAZW5kfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG1pblxuICAgIGlmIEBiZWdpbi5uaWw/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtaW5pbXVtIG9mIGJlZ2lubGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBlbmQubmlsPyAmJiAoQGJlZ2luID4gQGVuZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgQGJlZ2luXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgaW5maW5pdHkgPSA6OkZsb2F0OjpJTkZJTklUWVxuXG4gICAgcmV0dXJuIDAgaWYgKEBiZWdpbiA9PSBpbmZpbml0eSAmJiAhQGVuZC5uaWw/KSB8fCAoQGVuZCA9PSAtaW5maW5pdHkgJiYgIUBiZWdpbi5uaWw/KVxuICAgIHJldHVybiBpbmZpbml0eSBpZiBgaXNfaW5maW5pdGUoc2VsZilgXG4gICAgcmV0dXJuIG5pbCB1bmxlc3MgOjpOdW1lcmljID09PSBAYmVnaW4gJiYgOjpOdW1lcmljID09PSBAZW5kXG5cbiAgICByYW5nZV9iZWdpbiA9IEBiZWdpblxuICAgIHJhbmdlX2VuZCAgID0gQGVuZFxuICAgIHJhbmdlX2VuZCAgLT0gMSBpZiBAZXhjbFxuXG4gICAgcmV0dXJuIDAgaWYgcmFuZ2VfZW5kIDwgcmFuZ2VfYmVnaW5cblxuICAgIGBNYXRoLmFicyhyYW5nZV9lbmQgLSByYW5nZV9iZWdpbikgKyAxYC50b19pXG4gIGVuZFxuXG4gIGRlZiBzdGVwKG4gPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBjb2VyY2VTdGVwU2l6ZSgpIHtcbiAgICAgICAgaWYgKG4gPT0gbnVsbCkge1xuICAgICAgICAgIG4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFuLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgbiA9ICN7OjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KX1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgbmVnYXRpdmVcIn1cbiAgICAgICAgfSBlbHNlIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCJ9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW51bWVyYXRvclNpemUoKSB7XG4gICAgICAgIGlmICghI3tAYmVnaW4ucmVzcG9uZF90bz8oOnN1Y2MpfSkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gJSAxID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICN7KHNpemUgLyBuKS5jZWlsfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBuIGlzIGEgZmxvYXRcbiAgICAgICAgICB2YXIgYmVnaW4gPSBzZWxmLmJlZ2luLCBlbmQgPSBzZWxmLmVuZCxcbiAgICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgICAgICAgZXJyID0gKGFicyhiZWdpbikgKyBhYnMoZW5kKSArIGFicyhlbmQgLSBiZWdpbikpIC8gYWJzKG4pICogI3s6OkZsb2F0OjpFUFNJTE9OfSxcbiAgICAgICAgICAgICAgc2l6ZTtcblxuICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5leGNsKSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gLSBlcnIpO1xuICAgICAgICAgICAgaWYgKHNpemUgKiBuICsgYmVnaW4gPCBlbmQpIHtcbiAgICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gKyBlcnIpICsgMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgaWYgKEBiZWdpbi5pc19hPyhOdW1lcmljKSB8fCBAYmVnaW4ubmlsPykgJiZcbiAgICAgICAgIChAZW5kLmlzX2E/KE51bWVyaWMpIHx8IEBlbmQubmlsPykgJiZcbiAgICAgICAgICEoQGJlZ2luLm5pbD8gJiYgQGVuZC5uaWw/KVxuXG4gICAgICAgIHJldHVybiA6OkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZS5uZXcoc2VsZiwgbiwgOnN0ZXApXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBlbnVtX2Zvcig6c3RlcCwgbikgZG9cbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGNvZXJjZVN0ZXBTaXplKCk7XG4gICAgICAgICAgICByZXR1cm4gZW51bWVyYXRvclNpemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBgY29lcmNlU3RlcFNpemUoKWBcblxuICAgIGlmIGBzZWxmLmJlZ2luLiQkaXNfbnVtYmVyICYmIHNlbGYuZW5kLiQkaXNfbnVtYmVyYFxuICAgICAgaSA9IDBcbiAgICAgIGxvb3AgZG9cbiAgICAgICAgY3VycmVudCA9IEBiZWdpbiArIGkgKiBuXG4gICAgICAgIGlmIEBleGNsXG4gICAgICAgICAgYnJlYWsgaWYgY3VycmVudCA+PSBAZW5kXG4gICAgICAgIGVsc2lmIGN1cnJlbnQgPiBAZW5kXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZW5kXG4gICAgICAgIHlpZWxkKGN1cnJlbnQpXG4gICAgICAgIGkgKz0gMVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZyAmJiBuICUgMSAhPT0gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGZsb2F0IGZyb20gc3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWFjaF93aXRoX2luZGV4IGRvIHx2YWx1ZSwgaWR4fFxuICAgICAgICB5aWVsZCh2YWx1ZSkgaWYgaWR4ICUgbiA9PSAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiAlKG4pXG4gICAgaWYgQGJlZ2luLmlzX2E/KE51bWVyaWMpICYmIEBlbmQuaXNfYT8oTnVtZXJpYylcbiAgICAgIDo6RW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlLm5ldyhzZWxmLCBuLCA6JSlcbiAgICBlbHNlXG4gICAgICBzdGVwKG4pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmJzZWFyY2gpIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGlmIGBpc19pbmZpbml0ZShzZWxmKSAmJiAoc2VsZi5iZWdpbi4kJGlzX251bWJlciB8fCBzZWxmLmVuZC4kJGlzX251bWJlcilgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3IsIFwiQ2FuJ3QgI2JzZWFyY2ggYW4gaW5maW5pdGUgcmFuZ2VcIlxuICAgIGVuZFxuXG4gICAgdW5sZXNzIGBzZWxmLmJlZ2luLiQkaXNfbnVtYmVyICYmIHNlbGYuZW5kLiQkaXNfbnVtYmVyYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgZG8gYmluYXJ5IHNlYXJjaCBmb3IgI3tAYmVnaW4uY2xhc3N9XCJcbiAgICBlbmRcblxuICAgIHRvX2EuYnNlYXJjaCgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIje0BiZWdpbiB8fCAnJ30je0BleGNsID8gJy4uLicgOiAnLi4nfSN7QGVuZCB8fCAnJ31cIlxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiI3tAYmVnaW4gJiYgQGJlZ2luLmluc3BlY3R9I3tAZXhjbCA/ICcuLi4nIDogJy4uJ30je0BlbmQgJiYgQGVuZC5pbnNwZWN0fVwiXG4gIGVuZFxuXG4gIGRlZiBtYXJzaGFsX2xvYWQoYXJncylcbiAgICBAYmVnaW4gPSBhcmdzWzpiZWdpbl1cbiAgICBAZW5kID0gYXJnc1s6ZW5kXVxuICAgIEBleGNsID0gYXJnc1s6ZXhjbF1cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBbQGJlZ2luLCBAZW5kLCBAZXhjbF0uaGFzaFxuICBlbmRcblxuICBhbGlhcyA9PSBlcWw/XG4gIGFsaWFzIGluY2x1ZGU/IGNvdmVyP1xuICBhbGlhcyBtZW1iZXI/IGNvdmVyP1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlJhbmdlPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiZmlyc3QiLCJsYXN0IiwiZXhjbHVkZSIsIkBiZWdpbiIsIktlcm5lbCIsInJhaXNlIiwiTmFtZUVycm9yIiwiPD0+IiwibmlsPyIsIkFyZ3VtZW50RXJyb3IiLCJAZW5kIiwiQGV4Y2wiLCI9PT0iLCJ2YWx1ZSIsImluY2x1ZGU/IiwiY291bnQiLCJibG9ja19naXZlbj8iLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsInRvX2EiLCJUeXBlRXJyb3IiLCJjb3Zlcj8iLCJiZWdfY21wIiwiJHJldF9vcl8xIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwiLTEiLCJlbmRfY21wIiwiPCIsIjAiLCI8PSIsImVhY2giLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJzaXplIiwiMSIsInVwdG8iLCJibG9jayIsInRvX3Byb2MiLCJjdXJyZW50IiwicmVzcG9uZF90bz8iLCJjbGFzcyIsInN1Y2MiLCJlcWw/Iiwib3RoZXIiLCJSYW5nZSIsImV4Y2x1ZGVfZW5kPyIsImJlZ2luIiwiZW5kIiwibiIsIlJhbmdlRXJyb3IiLCJtYXgiLCI+IiwibWluIiwiaW5maW5pdHkiLCItQCIsIk51bWVyaWMiLCJyYW5nZV9iZWdpbiIsInJhbmdlX2VuZCIsIi0iLCJ0b19pIiwic3RlcCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsIi8iLCJjZWlsIiwiRmxvYXQ6OkVQU0lMT04iLCJpc19hPyIsIkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZSIsIkVudW1lcmF0b3IiLCJuZXciLCJibG9jayBpbiBzdGVwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdGVwIiwiaSIsImxvb3AiLCIrIiwiKiIsIj49IiwiZWFjaF93aXRoX2luZGV4IiwiaWR4IiwiJSIsImJzZWFyY2giLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwidG9fcyIsImluc3BlY3QiLCJtYXJzaGFsX2xvYWQiLCJhcmdzIiwiW10iLCJoYXNoIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVB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QUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxDQUFDdkYsVUFBRCxFQUFTTyxRQUFULEVBQWVDLFNBQWYsQ0FBcUIrRSxNQUFBQSxDQUFBQTtJQUR2QkEsQ0FBQUE7SUFJQSxhQUFNLElBQU4sRUFBUyxNQUFUO0lBQ0EsYUFBTSxVQUFOLEVBQWUsUUFBZjtJQUNBL0YsT0FBQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0VBMVNGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODY1NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlXG5cbmNsYXNzIDo6UHJvYyA8IGBGdW5jdGlvbmBcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19wcm9jJywgdHJ1ZSlgXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbGFtYmRhJywgZmFsc2UpYFxuXG4gIGRlZiBzZWxmLm5ldygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgYSBQcm9jIG9iamVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgZW5kXG5cbiAgICBibG9ja1xuICBlbmRcblxuICBkZWYgY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kJHAgPSBibG9jaztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCwgJGJyayA9IHNlbGYuJCRicmssICRyZXQgPSBzZWxmLiQkcmV0O1xuXG4gICAgICBpZiAoJGJyayB8fCAoJHJldCAmJiBzZWxmLiQkaXNfbGFtYmRhKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gJGJyaykge1xuICAgICAgICAgICAgcmV0dXJuIGVyci4kdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBlcnIgPT09ICRyZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIuJHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBPcGFsLnlpZWxkWChzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID4+KG90aGVyKVxuICAgIDo6S2VybmVsLnByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICBvdXQgPSBjYWxsKCphcmdzLCAmYmxvY2spXG4gICAgICBvdGhlci5jYWxsKG91dClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw8KG90aGVyKVxuICAgIDo6S2VybmVsLnByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICBvdXQgPSBvdGhlci5jYWxsKCphcmdzLCAmYmxvY2spXG4gICAgICBjYWxsKG91dClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsYW1iZGE/XG4gICAgIyBUaGlzIG1ldGhvZCBzaG91bGQgdGVsbCB0aGUgdXNlciBpZiB0aGUgcHJvYyB0cmlja3MgYXJlIHVuYXZhaWxhYmxlLFxuICAgICMgKHNlZSBQcm9jI2xhbWJkYT8gb24gcnVieSBkb2NzIHRvIGZpbmQgb3V0IG1vcmUpLlxuICAgIGAhIXNlbGYuJCRpc19sYW1iZGFgXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi4kJGFyaXR5ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRhcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7IHJldHVybiBuaWw7IH1gXG4gICAgYHNlbGYuJCRzb3VyY2VfbG9jYXRpb25gIHx8IG5pbFxuICBlbmRcblxuICBkZWYgYmluZGluZ1xuICAgIGBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiQ2FuJ3QgY3JlYXRlIEJpbmRpbmdcIn0gfWBcblxuICAgIGlmIGRlZmluZWQ/IDo6QmluZGluZ1xuICAgICAgOjpCaW5kaW5nLm5ldyhuaWwsIFtdLCBgc2VsZi4kJHNgLCBzb3VyY2VfbG9jYXRpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBwYXJhbWV0ZXJzKGxhbWJkYTogdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAje1tbOnJlc3RdXX07XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmIChsYW1iZGEgPT0gbnVsbCA/IHNlbGYuJCRpc19sYW1iZGEgOiBsYW1iZGEpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJHBhcmFtZXRlcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLiQkcGFyYW1ldGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHNlbGYuJCRwYXJhbWV0ZXJzW2ldO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyWzBdID09PSAncmVxJykge1xuICAgICAgICAgICAgICAvLyByZXF1aXJlZCBhcmd1bWVudHMgYWx3YXlzIGhhdmUgbmFtZVxuICAgICAgICAgICAgICBwYXJhbWV0ZXIgPSBbJ29wdCcsIHBhcmFtZXRlclsxXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtZXRlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN1cnJ5KGFyaXR5ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXJpdHkgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhcml0eSA9ICN7OjpPcGFsLmNvZXJjZV90byEoYXJpdHksIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBhcml0eSAhPT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcml0eWB9IGZvciAje2BzZWxmLmxlbmd0aGB9KVwifVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGN1cnJpZWQgKCkge1xuICAgICAgICB2YXIgYXJncyA9ICRzbGljZShhcmd1bWVudHMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IGFyaXR5ICYmIHNlbGYuJCRpc19sYW1iZGEgJiYgIXNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgbGVuZ3RoYH0gZm9yICN7YGFyaXR5YH0pXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoID49IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJGNhbGwuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJpZWQuYXBwbHkobnVsbCxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KCRzbGljZShhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgICAgcmVzdWx0LiQkaXNfY3VycmllZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIGN1cnJpZWQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xuICAgICAgY3VycmllZC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGN1cnJpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfcHJvYyA9IHNlbGYuJCRvcmlnaW5hbF9wcm9jIHx8IHNlbGYsXG4gICAgICAgICAgcHJvYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF9wcm9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgcHJvY1twcm9wXSA9IHNlbGZbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyA9PT0gY2FsbFxuICBhbGlhcyBjbG9uZSBkdXBcbiAgYWxpYXMgeWllbGQgY2FsbFxuICBhbGlhcyBbXSBjYWxsXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlByb2M+IiwibmV3Iiwic2VsZiIsImJsb2NrIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiY2FsbCIsIj4+Iiwib3RoZXIiLCJwcm9jIiwiYmxvY2sgaW4gPj4iLCJibG9jayAoMiBsZXZlbHMpIGluID4+Iiwib3V0IiwiYXJncyIsInRvX3Byb2MiLCI8PCIsImJsb2NrIGluIDw8IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8PCIsImxhbWJkYT8iLCJhcml0eSIsInNvdXJjZV9sb2NhdGlvbiIsIiRyZXRfb3JfMSIsImJpbmRpbmciLCJCaW5kaW5nIiwicGFyYW1ldGVycyIsIiRrd2FyZ3MiLCJjdXJyeSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsImR1cCJdLCJtYXBwaW5ncyI6IkFBQUFBLCtCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOzs7O0lBQ0dBO0lBQ0FBO0lBRURDLE1BQUlDLElBQUpELFVBQUFBLHFCQUFBQTtBQUFBQSxNQUFB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RkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODkwOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbWV0aG9kLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6TWV0aG9kXG4gIGF0dHJfcmVhZGVyIDpvd25lciwgOnJlY2VpdmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHJlY2VpdmVyLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gICAgQG93bmVyICAgID0gb3duZXJcbiAgICBAbmFtZSAgICAgPSBuYW1lXG4gICAgQG1ldGhvZCAgID0gbWV0aG9kXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgI3tAbWV0aG9kfS4kJHAgPSBibG9jaztcblxuICAgICAgcmV0dXJuICN7QG1ldGhvZH0uYXBwbHkoI3tAcmVjZWl2ZXJ9LCBhcmdzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICBAbWV0aG9kLmN1cnJ5KGFyaXR5KVxuICBlbmRcblxuICBkZWYgPj4ob3RoZXIpXG4gICAgQG1ldGhvZCA+PiBvdGhlclxuICBlbmRcblxuICBkZWYgPDwob3RoZXIpXG4gICAgQG1ldGhvZCA8PCBvdGhlclxuICBlbmRcblxuICBkZWYgdW5iaW5kXG4gICAgOjpVbmJvdW5kTWV0aG9kLm5ldyhAcmVjZWl2ZXIuY2xhc3MsIEBvd25lciwgQG1ldGhvZCwgQG5hbWUpXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgJXh7XG4gICAgICB2YXIgcHJvYyA9IHNlbGYuJGNhbGwuYmluZChzZWxmKTtcbiAgICAgIHByb2MuJCR1bmJvdW5kID0gI3tAbWV0aG9kfTtcbiAgICAgIHByb2MuJCRpc19sYW1iZGEgPSB0cnVlO1xuICAgICAgcHJvYy4kJGFyaXR5ID0gI3tAbWV0aG9kfS4kJGFyaXR5ID09IG51bGwgPyAje0BtZXRob2R9Lmxlbmd0aCA6ICN7QG1ldGhvZH0uJCRhcml0eTtcbiAgICAgIHByb2MuJCRwYXJhbWV0ZXJzID0gI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnM7XG4gICAgICByZXR1cm4gcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QHJlY2VpdmVyLmNsYXNzfSMje0BuYW1lfSAoZGVmaW5lZCBpbiAje0Bvd25lcn0gaW4gI3tzb3VyY2VfbG9jYXRpb24uam9pbignOicpfSk+XCJcbiAgZW5kXG5cbiAgYWxpYXMgW10gY2FsbFxuICBhbGlhcyA9PT0gY2FsbFxuZW5kXG5cbmNsYXNzIDo6VW5ib3VuZE1ldGhvZFxuICBhdHRyX3JlYWRlciA6c291cmNlLCA6b3duZXIsIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUoc291cmNlLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEBzb3VyY2UgPSBzb3VyY2VcbiAgICBAb3duZXIgID0gb3duZXJcbiAgICBAbWV0aG9kID0gbWV0aG9kXG4gICAgQG5hbWUgICA9IG5hbWVcbiAgZW5kXG5cbiAgZGVmIGFyaXR5XG4gICAgQG1ldGhvZC5hcml0eVxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgIGAje0BtZXRob2R9LiQkcGFyYW1ldGVyc2BcbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGAje0BtZXRob2R9LiQkc291cmNlX2xvY2F0aW9uYCB8fCBbJyhldmFsKScsIDBdXG4gIGVuZFxuXG4gIGRlZiBjb21tZW50c1xuICAgIGAje0BtZXRob2R9LiQkY29tbWVudHNgIHx8IFtdXG4gIGVuZFxuXG4gIGRlZiBiaW5kKG9iamVjdClcbiAgICAleHtcbiAgICAgIGlmICgje0Bvd25lcn0uJCRpc19tb2R1bGUgfHwgT3BhbC5pc19hKCN7b2JqZWN0fSwgI3tAb3duZXJ9KSkge1xuICAgICAgICByZXR1cm4gI3s6Ok1ldGhvZC5uZXcob2JqZWN0LCBAb3duZXIsIEBtZXRob2QsIEBuYW1lKX07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBiaW5kIHNpbmdsZXRvbiBtZXRob2QgdG8gYSBkaWZmZXJlbnQgY2xhc3MgKGV4cGVjdGVkICN7b2JqZWN0fS5raW5kX29mPygje0Bvd25lcn0gdG8gYmUgdHJ1ZSlcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYmluZF9jYWxsKG9iamVjdCwgKmFyZ3MsICZibG9jaylcbiAgICBiaW5kKG9iamVjdCkuY2FsbCgqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0Bzb3VyY2V9IyN7QG5hbWV9IChkZWZpbmVkIGluICN7QG93bmVyfSBpbiAje3NvdXJjZV9sb2NhdGlvbi5qb2luKCc6Jyl9KT5cIlxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6TWV0aG9kPiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJyZWNlaXZlciIsIm93bmVyIiwibWV0aG9kIiwibmFtZSIsIkByZWNlaXZlciIsIkBvd25lciIsIkBuYW1lIiwiQG1ldGhvZCIsImFyaXR5IiwicGFyYW1ldGVycyIsInNvdXJjZV9sb2NhdGlvbiIsIiRyZXRfb3JfMSIsIjAiLCJjb21tZW50cyIsImNhbGwiLCJjdXJyeSIsIj4+Iiwib3RoZXIiLCI8PCIsInVuYmluZCIsIlVuYm91bmRNZXRob2QiLCJuZXciLCJjbGFzcyIsInRvX3Byb2MiLCJpbnNwZWN0Iiwiam9pbiIsIjxjbGFzczpVbmJvdW5kTWV0aG9kPiIsInNvdXJjZSIsIkBzb3VyY2UiLCJiaW5kIiwib2JqZWN0IiwiTWV0aG9kIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJiaW5kX2NhbGwiLCJhcmdzIiwiYmxvY2siXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsSUFBQUMsYUFBQUEsQ0FBWSxPQUFaLEVBQW9CLFVBQXBCLEVBQStCLE1BQS9CQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxRQUFELEVBQVdDLEtBQVgsRUFBa0JDLE1BQWxCLEVBQTBCQyxJQUF4Q0o7QUFBQUEsTUFBQUE7OztNQUNFSyxnQkFBWUo7TUFDWkssYUFBWUo7TUFDWkssWUFBWUg7TUFDWkosT0FBQVEsQ0FBQUEsY0FBWUwsTUFBWks7SUFKRlIsQ0FBQUE7O0FBT0FTLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFELFdBQU9DLE9BQUFBLENBQUFBO0lBRFRBLENBQUFBOztBQUlBQyxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFHRixXQUFRRTtJQURiQSxDQUFBQTs7QUFJQUMsSUFBQUEsK0JBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFDLENBQUFBLFlBQUdKLFdBQVFHLGtCQUFYQyxDQUFBLENBQUE7UUFBQUQsT0FBQTtNQUFBO1FBQWtDQSxPQUFBLENBQUNBLFFBQUQsRUFBV0UsQ0FBWDtNQUFsQztJQURGRixDQUFBQTs7QUFJQUcsSUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFGLENBQUFBLFlBQUdKLFdB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bkIsVUFBcEQsQ0FBQSxHQUEyRG1CLE1BQTNELEdBQUEsQ0FBaUUzQixJQUFBYSxpQkFBQUEsQ0FBQUEsQ0FBZWUsTUFBQUEsQ0FBTUQsR0FBTkMsQ0FBaEYsQ0FBQSxHQUEyRkQ7SUFEN0ZBLENBQUFBO0VBekNGRSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBckVBL0I7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5MTA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi92YXJpYWJsZXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyByZWdleHAgbWF0Y2hlc1xuJXh7JGd2YXJzWycmJ10gPSAkZ3ZhcnNbJ34nXSA9ICRndmFyc1snYCddID0gJGd2YXJzW1wiJ1wiXSA9IG5pbH1cblxuIyByZXF1aXJlc1xuJExPQURFRF9GRUFUVVJFUyA9ICRcIiA9IGBPcGFsLmxvYWRlZF9mZWF0dXJlc2BcbiRMT0FEX1BBVEggICAgICAgPSAkOiA9IFtdXG5cbiMgc3BsaXQgbGluZXNcbiQvID0gXCJcXG5cIlxuJCwgPSBuaWxcblxuOjpBUkdWID0gW11cbjo6QVJHRiA9IDo6T2JqZWN0Lm5ld1xuOjpFTlYgID0ge31cblxuJFZFUkJPU0UgPSBmYWxzZVxuJERFQlVHICAgPSBmYWxzZVxuJFNBRkUgICAgPSAwXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIiRMT0FERURfRkVBVFVSRVMiLCIkXCIiLCIkTE9BRF9QQVRIIiwiJDoiLCIkLyIsIiQsIiwiT2JqZWN0IiwibmV3IiwiJFZFUkJPU0UiLCIkREVCVUciLCIkU0FGRSIsIjAiXSwibWFwcGluZ3MiOiJBQUFBQSxvQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFDR0E7RUFHSEMseUJBQW1CQyxDQUFBQSxlQUFNRixvQkFBTkU7RUFDbkJDLG1CQUFtQkMsQ0FBQUEsY0FBSyxFQUFMQTtFQUduQkMsY0FBS0w7RUFDTE0sY0FBSztFQUVMLFdBQUEsSUFBQSxVQUFTLEVBQVQ7RUFDQSxXQUFBLElBQUEsVUFBU0MsT0FBUUMsS0FBQUEsQ0FBQUEsQ0FBakI7RUFDQSxXQUFBLElBQUEsU0FBUyxZQUFBLEVBQVQ7RUFFQUMsaUJBQVc7RUFDWEMsZUFBVztFQUNYVixPQUFBVyxDQUFBQSxjQUFXQyxDQUFYRDtBQWpCQVg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5MTI2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6OklPXG4gIHNlbGY6OlNFRUtfU0VUID0gMFxuICBzZWxmOjpTRUVLX0NVUiA9IDFcbiAgc2VsZjo6U0VFS19FTkQgPSAyXG4gIHNlbGY6OlNFRUtfREFUQSA9IDNcbiAgc2VsZjo6U0VFS19IT0xFID0gNFxuXG4gIHNlbGY6OlJFQURBQkxFID0gMVxuICBzZWxmOjpXUklUQUJMRSA9IDRcblxuICBhdHRyX3JlYWRlciA6ZW9mXG5cbiAgYXR0cl9hY2Nlc3NvciA6cmVhZF9wcm9jLCAgOnN5bmMsIDp0dHksIDp3cml0ZV9wcm9jXG5cbiAgZGVmIGluaXRpYWxpemUoZmQsIGZsYWdzID0gJ3InKVxuICAgIEBmZCA9IGZkXG4gICAgQGZsYWdzID0gZmxhZ3NcbiAgICBAZW9mID0gZmFsc2VcblxuICAgIGlmIGZsYWdzLmluY2x1ZGU/KCdyJykgJiYgIWZsYWdzLm1hdGNoPygvW3dhK10vKVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVsc2lmIGZsYWdzLm1hdGNoPygvW3dhXS8pICYmICFmbGFncy5tYXRjaD8oL1tyK10vKVxuICAgICAgQGNsb3NlZCA9IDpyZWFkXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBmaWxlbm9cbiAgICBAZmRcbiAgZW5kXG5cbiAgZGVmIHR0eT9cbiAgICBgc2VsZi50dHkgPT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIHdyaXRlKHN0cmluZylcbiAgICBgc2VsZi53cml0ZV9wcm9jKHN0cmluZylgXG4gICAgc3RyaW5nLnNpemVcbiAgZW5kXG5cbiAgZGVmIGZsdXNoXG4gICAgIyBub29wXG4gIGVuZFxuXG4gIGRlZiA8PChzdHJpbmcpXG4gICAgd3JpdGUoc3RyaW5nKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByaW50KCphcmdzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSAjezo6S2VybmVsLlN0cmluZyhgYXJnc1tpXWApfVxuICAgICAgfVxuICAgICAgc2VsZi4kd3JpdGUoYXJncy5qb2luKCN7JCx9KSk7XG4gICAgfVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcHV0cygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBsaW5lXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3t3cml0ZSBcIlxcblwifTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGlmIChhcmdzW2ldLiQkaXNfYXJyYXkpe1xuICAgICAgICAgICAgdmFyIGFyeSA9ICN7YGFyZ3NbaV1gLmZsYXR0ZW59XG4gICAgICAgICAgICBpZiAoYXJ5Lmxlbmd0aCA+IDApICN7cHV0cygqYGFyeWApfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnc1tpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICBsaW5lID0gYXJnc1tpXS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsaW5lID0gI3s6Oktlcm5lbC5TdHJpbmcoYGFyZ3NbaV1gKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxpbmUuZW5kc1dpdGgoXCJcXG5cIikpIGxpbmUgKz0gXCJcXG5cIlxuICAgICAgICAgICAgI3t3cml0ZSBgbGluZWB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5pbFxuICBlbmRcblxuICAjIFJlYWRpbmdcblxuICBkZWYgZ2V0Y1xuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcbiAgICBwYXJ0cyA9ICcnXG5cbiAgICAjIFdpbGwgZXhlY3VyZSBhdCBtb3N0IHR3aWNlIC0gb25lIHRpbWUgcmVhZGluZyBmcm9tIGEgYnVmZmVyXG4gICAgIyBzZWNvbmQgdGltZSBleGVjdXRpbmcgcmVhZCBwcm9jXG4gICAgYmVnaW5cbiAgICAgIEByZWFkX2J1ZmZlciArPSBwYXJ0c1xuICAgICAgaWYgQHJlYWRfYnVmZmVyICE9ICcnXG4gICAgICAgIHJldCA9IEByZWFkX2J1ZmZlclswXVxuICAgICAgICBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXJbMS4uLTFdXG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIGVuZFxuICAgIGVuZCB3aGlsZSBwYXJ0cyA9IHN5c3JlYWRfbm9yYWlzZSgxKVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBnZXRieXRlXG4gICAgZ2V0YyYub3JkXG4gIGVuZFxuXG4gIGRlZiByZWFkYnl0ZVxuICAgIHJlYWRjaGFyLm9yZFxuICBlbmRcblxuICBkZWYgcmVhZGNoYXJcbiAgICBnZXRjIHx8IDo6S2VybmVsLnJhaXNlKDo6RU9GRXJyb3IsICdlbmQgb2YgZmlsZSByZWFjaGVkJylcbiAgZW5kXG5cbiAgZGVmIHJlYWRsaW5lKCphcmdzKVxuICAgIGdldHMoKmFyZ3MpIHx8IDo6S2VybmVsLnJhaXNlKDo6RU9GRXJyb3IsICdlbmQgb2YgZmlsZSByZWFjaGVkJylcbiAgZW5kXG5cbiAgZGVmIGdldHMoc2VwID0gZmFsc2UsIGxpbWl0ID0gbmlsLCBvcHRzID0ge30pXG4gICAgaWYgYHNlcC4kJGlzX251bWJlcmAgJiYgIWxpbWl0XG4gICAgICBzZXAsIGxpbWl0LCBvcHRzID0gZmFsc2UsIHNlcCwgbGltaXRcbiAgICBlbmRcbiAgICBpZiBgc2VwLiQkaXNfaGFzaGAgJiYgIWxpbWl0ICYmIG9wdHMgPT0ge31cbiAgICAgIHNlcCwgbGltaXQsIG9wdHMgPSBmYWxzZSwgbmlsLCBzZXBcbiAgICBlbHNpZiBgbGltaXQuJCRpc19oYXNoYCAmJiBvcHRzID09IHt9XG4gICAgICBzZXAsIGxpbWl0LCBvcHRzID0gc2VwLCBuaWwsIGxpbWl0XG4gICAgZW5kXG5cbiAgICBvcmlnX3NlcCA9IHNlcFxuXG4gICAgc2VwID0gJC8gaWYgc2VwID09IGZhbHNlXG4gICAgc2VwID0gL1xccj9cXG5cXHI/XFxuLyBpZiBzZXAgPT0gJydcbiAgICBzZXAgfHw9ICcnXG4gICAgc2VwID0gc2VwLnRvX3N0ciB1bmxlc3Mgb3JpZ19zZXAgPT0gJydcblxuICAgICMgVHJ5IHRvIGRlZHVjZSBsZW5ndGggb2YgYSByZWdleHBcbiAgICBzZXBsZW4gPSBvcmlnX3NlcCA9PSAnJyA/IDIgOiBzZXAubGVuZ3RoXG5cbiAgICBzZXAgPSAvIC8gaWYgc2VwID09ICcgJyAjIFdURiBpcyB0aGlzLCBTdHJpbmcjc3BsaXQoXCIgXCIpIG1hdGNoZXMgYWxsIHdoaXRlc3BhY2VzPz8/XG5cbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgZGF0YSA9ICcnXG4gICAgcmV0ID0gbmlsXG5cbiAgICBiZWdpblxuICAgICAgQHJlYWRfYnVmZmVyICs9IGRhdGFcbiAgICAgIGlmIHNlcCAhPSAnJyAmJiAoYHNlcC4kJGlzX3JlZ2V4cGAgPyBAcmVhZF9idWZmZXIubWF0Y2g/KHNlcCkgOiBAcmVhZF9idWZmZXIuaW5jbHVkZT8oc2VwKSlcbiAgICAgICAgb3JpZ19idWZmZXIgPSBAcmVhZF9idWZmZXJcbiAgICAgICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIuc3BsaXQoc2VwLCAyKVxuICAgICAgICByZXQgKz0gb3JpZ19idWZmZXJbcmV0Lmxlbmd0aCwgc2VwbGVuXSBpZiByZXQgIT0gb3JpZ19idWZmZXJcbiAgICAgICAgYnJlYWtcbiAgICAgIGVuZFxuICAgIGVuZCB3aGlsZSBkYXRhID0gc3lzcmVhZF9ub3JhaXNlKHNlcCA9PSAnJyA/IDY1XzUzNiA6IDEpXG5cbiAgICB1bmxlc3MgcmV0XG4gICAgICByZXQsIEByZWFkX2J1ZmZlciA9IChAcmVhZF9idWZmZXIgfHwgJycpLCAnJ1xuICAgICAgcmV0ID0gbmlsIGlmIHJldCA9PSAnJ1xuICAgIGVuZFxuXG4gICAgaWYgcmV0XG4gICAgICBpZiBsaW1pdFxuICAgICAgICByZXQgPSByZXRbMC4uLmxpbWl0XVxuICAgICAgICBAcmVhZF9idWZmZXIgPSByZXRbbGltaXQuLi0xXSArIEByZWFkX2J1ZmZlclxuICAgICAgZW5kXG4gICAgICByZXQgPSByZXQuc3ViKC9cXHI/XFxuXFx6LywgJycpIGlmIG9wdHNbOmNob21wXVxuICAgICAgcmV0ID0gcmV0LnN1YigvXFxBW1xcclxcbl0rLywgJycpIGlmIG9yaWdfc2VwID09ICcnXG4gICAgZW5kXG5cbiAgICAkXyA9IHJldCBpZiBvcmlnX3NlcCA9PSBmYWxzZVxuICAgIHJldFxuICBlbmRcblxuICAjIFRoaXMgbWV0aG9kIGlzIHRvIGJlIG92ZXJsb2FkZWQsIG9yIHJlYWRfcHJvYyBjYW4gYmUgY2hhbmdlZFxuICBkZWYgc3lzcmVhZChpbnRlZ2VyKVxuICAgIGBzZWxmLnJlYWRfcHJvYyhpbnRlZ2VyKWAgfHwgYmVnaW5cbiAgICAgIEBlb2YgPSB0cnVlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkVPRkVycm9yLCAnZW5kIG9mIGZpbGUgcmVhY2hlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgc3lzcmVhZF9ub3JhaXNlKGludGVnZXIpXG4gICAgc3lzcmVhZChpbnRlZ2VyKVxuICByZXNjdWUgOjpFT0ZFcnJvclxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcmVhZHBhcnRpYWwoaW50ZWdlcilcbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgcGFydCA9IHN5c3JlYWQoaW50ZWdlcilcbiAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlciArIChwYXJ0IHx8ICcnKSwgJydcbiAgICByZXQgPSBuaWwgaWYgcmV0ID09ICcnXG4gICAgcmV0XG4gIGVuZFxuXG4gIGRlZiByZWFkKGludGVnZXIgPSBuaWwpXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xuICAgIHBhcnRzID0gJydcbiAgICByZXQgPSBuaWxcblxuICAgIGJlZ2luXG4gICAgICBAcmVhZF9idWZmZXIgKz0gcGFydHNcbiAgICAgIGlmIGludGVnZXIgJiYgQHJlYWRfYnVmZmVyLmxlbmd0aCA+IGludGVnZXJcbiAgICAgICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXJbMC4uLmludGVnZXJdLCBAcmVhZF9idWZmZXJbaW50ZWdlci4uLTFdXG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIGVuZFxuICAgIGVuZCB3aGlsZSBwYXJ0cyA9IHN5c3JlYWRfbm9yYWlzZShpbnRlZ2VyIHx8IDY1XzUzNilcblxuICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyLCAnJ1xuICAgIHJldFxuICBlbmRcblxuICAjIEVhY2hlc1xuXG4gIGRlZiByZWFkbGluZXMoc2VwYXJhdG9yID0gJC8pXG4gICAgZWFjaF9saW5lKHNlcGFyYXRvcikudG9fYVxuICBlbmRcblxuICBkZWYgZWFjaChzZXAgPSAkLywgKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2gsIHNlcCwgKmFyZ3MgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgd2hpbGUgKHMgPSBnZXRzKHNlcCwgKmFyZ3MpKVxuICAgICAgeWllbGQocylcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2J5dGUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgd2hpbGUgKHMgPSBnZXRieXRlKVxuICAgICAgeWllbGQocylcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2NoYXIgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgd2hpbGUgKHMgPSBnZXRjKVxuICAgICAgeWllbGQocylcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBDbG9zZWRuZXNzXG5cbiAgZGVmIGNsb3NlXG4gICAgQGNsb3NlZCA9IDpib3RoXG4gIGVuZFxuXG4gIGRlZiBjbG9zZV9yZWFkXG4gICAgaWYgQGNsb3NlZCA9PSA6d3JpdGVcbiAgICAgIEBjbG9zZWQgPSA6Ym90aFxuICAgIGVsc2VcbiAgICAgIEBjbG9zZWQgPSA6cmVhZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xvc2Vfd3JpdGVcbiAgICBpZiBAY2xvc2VkID09IDpyZWFkXG4gICAgICBAY2xvc2VkID0gOmJvdGhcbiAgICBlbHNlXG4gICAgICBAY2xvc2VkID0gOndyaXRlXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjbG9zZWQ/XG4gICAgQGNsb3NlZCA9PSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VkX3JlYWQ/XG4gICAgQGNsb3NlZCA9PSA6cmVhZCB8fCBAY2xvc2VkID09IDpib3RoXG4gIGVuZFxuXG4gIGRlZiBjbG9zZWRfd3JpdGU/XG4gICAgQGNsb3NlZCA9PSA6d3JpdGUgfHwgQGNsb3NlZCA9PSA6Ym90aFxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBjaGVja193cml0YWJsZVxuICAgIGlmIGNsb3NlZF93cml0ZT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SU9FcnJvciwgJ25vdCBvcGVuZWQgZm9yIHdyaXRpbmcnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIGNoZWNrX3JlYWRhYmxlXG4gICAgaWYgY2xvc2VkX3JlYWQ/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OklPRXJyb3IsICdub3Qgb3BlbmVkIGZvciByZWFkaW5nJ1xuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBlYWNoX2xpbmUgZWFjaFxuICBhbGlhcyBlb2Y/IGVvZlxuZW5kXG5cbjo6U1RESU4gID0gJHN0ZGluICA9IDo6SU8ubmV3KDAsICdyJylcbjo6U1RET1VUID0gJHN0ZG91dCA9IDo6SU8ubmV3KDEsICd3Jylcbjo6U1RERVJSID0gJHN0ZGVyciA9IDo6SU8ubmV3KDIsICd3JylcblxuYHZhciBjb25zb2xlID0gT3BhbC5nbG9iYWwuY29uc29sZWBcbjo6U1RET1VULndyaXRlX3Byb2MgPSBgdHlwZW9mKHByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocHJvY2Vzcy5zdGRvdXQpID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKHMpe3Byb2Nlc3Muc3Rkb3V0LndyaXRlKHMpfSA6IGZ1bmN0aW9uKHMpe2NvbnNvbGUubG9nKHMpfWBcbjo6U1RERVJSLndyaXRlX3Byb2MgPSBgdHlwZW9mKHByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocHJvY2Vzcy5zdGRlcnIpID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKHMpe3Byb2Nlc3Muc3RkZXJyLndyaXRlKHMpfSA6IGZ1bmN0aW9uKHMpe2NvbnNvbGUud2FybihzKX1gXG5cbjo6U1RESU4ucmVhZF9wcm9jID0gYGZ1bmN0aW9uKHMpIHsgdmFyIHAgPSBwcm9tcHQoKTsgaWYgKHAgIT09IG51bGwpIHJldHVybiBwICsgXCJcXG5cIjsgcmV0dXJuIG5pbDsgfWBcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOklPPiIsInNlbGYiLCIwIiwiMSIsIjIiLCIzIiwiNCIsImF0dHJfcmVhZGVyIiwiYXR0cl9hY2Nlc3NvciIsImluaXRpYWxpemUiLCJmZCIsImZsYWdzIiwiQGZkIiwiQGZsYWdzIiwiQGVvZiIsImluY2x1ZGU/IiwibWF0Y2g/IiwiQGNsb3NlZCIsImZpbGVubyIsInR0eT8iLCJ3cml0ZSIsInN0cmluZyIsInNpemUiLCJmbHVzaCIsIjw8IiwicHJpbnQiLCJLZXJuZWwiLCJTdHJpbmciLCIkLCIsInB1dHMiLCJmbGF0dGVuIiwiZ2V0YyIsIkByZWFkX2J1ZmZlciIsIiRyZXRfb3JfMSIsInBhcnRzIiwiKyIsInJldCIsIltdIiwiLTEiLCJzeXNyZWFkX25vcmFpc2UiLCJnZXRieXRlIiwicmVhZGJ5dGUiLCJyZWFkY2hhciIsIm9yZCIsInJhaXNlIiwiRU9GRXJyb3IiLCJyZWFkbGluZSIsImdldHMiLCJhcmdzIiwic2VwIiwibGltaXQiLCJvcHRzIiwib3JpZ19zZXAiLCIkLyIsInRvX3N0ciIsInNlcGxlbiIsImxlbmd0aCIsImRhdGEiLCJvcmlnX2J1ZmZlciIsInNwbGl0IiwiNjU1MzYiLCJzdWIiLCIkXyIsInN5c3JlYWQiLCJpbnRlZ2VyIiwicmVhZHBhcnRpYWwiLCJwYXJ0IiwicmVhZCIsIj4iLCJyZWFkbGluZXMiLCJzZXBhcmF0b3IiLCJlYWNoX2xpbmUiLCJ0b19hIiwiZWFjaCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwicyIsImVhY2hfYnl0ZSIsImVhY2hfY2hhciIsImNsb3NlIiwiY2xvc2VfcmVhZCIsImNsb3NlX3dyaXRlIiwiY2xvc2VkPyIsIj09IiwiY2xvc2VkX3JlYWQ/IiwiY2xvc2VkX3dyaXRlPyIsImNoZWNrX3dyaXRhYmxlIiwiSU9FcnJvciIsImNoZWNrX3JlYWRhYmxlIiwiJHN0ZGluIiwiSU8iLCJuZXciLCIkc3Rkb3V0IiwiJHN0ZGVyciIsIlNURE9VVCIsIndyaXRlX3Byb2M9IiwiU1RERVJSIiwicmVhZF9wcm9jPSIsIlNURElOIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0UsV0FBQUMsSUFBQSxjQUFpQkMsQ0FBakI7SUFDQSxXQUFBRCxJQUFBLGNBQWlCRSxDQUFqQjtJQUNBLFdBQUFGLElBQUEsY0FBaUJHLENBQWpCO0lBQ0EsV0FBQUgsSUFBQSxlQUFrQkksQ0FBbEI7SUFDQSxXQUFBSixJQUFB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Y29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvcmVnZXhwX2FuY2hvcnMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIE9wYWxcbiAgc2VsZjo6UkVHRVhQX1NUQVJUID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gJ14nIDogJ1xcQSdcbiAgc2VsZjo6UkVHRVhQX0VORCA9IFJVQllfRU5HSU5FID09ICdvcGFsJyA/ICckJyA6ICdcXHonXG5cbiAgIyBVbmljb2RlIGNoYXJhY3RlcnMgaW4gcmFuZ2VzXG4gICMgXFx1MDAwMSAtIFxcdTAwMkYgKGJsYW5rIHVuaWNvZGUgY2hhcmFjdGVycyArIHNwYWNlICsgIVwiIyQlJicoKSorLC0uLyBjaGFycylcbiAgIyBcXHUwMDNBIC0gXFx1MDA0MCAoOjs8PT4/QCBjaGFycylcbiAgIyBcXHUwMDVCIC0gXFx1MDA1RSAoW1xcXV4gY2hhcnMpXG4gICMgXFx1MDA2MCAgICAgICAgICAoYCBjaGFyKVxuICAjIFxcdTAwN0IgLSBcXHUwMDdGICh7fH1+IGNoYXJzfSlcbiAgIyBhcmUgbm90IGFsbG93ZWQgdG8gYmUgdXNlZCBpbiBpZGVudGlmaWVyIGluIHRoZSBiZWdnaW5pbmcgb3IgbWlkZGxlIG9mIGl0cyBuYW1lXG4gIHNlbGY6OkZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTID0gJ1xcdTAwMDEtXFx1MDAyRlxcdTAwM0EtXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG5cbiAgIyBVbmljb2RlIGNoYXJhY3RlcnMgaW4gcmFuZ2VzXG4gICMgXFx1MDAwMSAtIFxcdTAwMjAgKGJsYW5rIHVuaWNvZGUgY2hhcmFjdGVycyArIHNwYWNlKVxuICAjIFxcdTAwMjIgLSBcXHUwMDJGIChcIiMkJSYnKCkqKywtLi8gY2hhcnMpXG4gICMgXFx1MDAzQSAtIFxcdTAwM0UgKDo7PD0+IGNoYXJzKVxuICAjIFxcdTAwNDAgICAgICAgICAgKEAgY2hhcilcbiAgIyBcXHUwMDVCIC0gXFx1MDA1RSAoW1xcXV4gY2hhcnMpXG4gICMgXFx1MDA2MCAgICAgICAgICAoYCBjaGFyKVxuICAjIFxcdTAwN0IgLSBcXHUwMDdGICh7fH1+IGNoYXJzfSlcbiAgIyBhcmUgbm90IGFsbG93ZWQgdG8gYmUgdXNlZCBpbiBpZGVudGlmaWVyIGluIHRoZSBlbmQgb2YgaXRzIG5hbWVcbiAgIyBJbiBmYWN0LCBGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSUyA9IEZPUkJJRERFTl9FTkRJTkdfSURFTlRJRklFUl9DSEFSUyArIFxcdTAwMjEgKCc/JykgKyBcXHUwMDNGICgnIScpXG4gIHNlbGY6OkZPUkJJRERFTl9FTkRJTkdfSURFTlRJRklFUl9DSEFSUyAgID0gJ1xcdTAwMDEtXFx1MDAyMFxcdTAwMjItXFx1MDAyRlxcdTAwM0EtXFx1MDAzRVxcdTAwNDBcXHUwMDVCLVxcdTAwNUVcXHUwMDYwXFx1MDA3Qi1cXHUwMDdGJ1xuICBzZWxmOjpJTkxJTkVfSURFTlRJRklFUl9SRUdFWFAgPSBSZWdleHAubmV3KFwiW14je3NlbGY6OkZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTfV0qW14je3NlbGY6OkZPUkJJRERFTl9FTkRJTkdfSURFTlRJRklFUl9DSEFSU31dXCIpXG5cbiAgIyBGb3IgY29uc3RhbnRzIHJ1bGVzIGFyZSBwcmV0dHkgbXVjaCB0aGUgc2FtZSwgYnV0ICc6JyBpcyBhbGxvd2VkIGFuZCAnPyEnIGFyZSBub3QuXG4gICMgUGx1cyBpdCBtYXkgc3RhcnQgd2l0aCBhICc6Oicgd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlIGNvbnN0YW50IGNvbWVzIGZyb20gdG9wbGV2ZWwuXG4gIHNlbGY6OkZPUkJJRERFTl9DT05TVF9OQU1FX0NIQVJTID0gJ1xcdTAwMDEtXFx1MDAyMFxcdTAwMjEtXFx1MDAyRlxcdTAwM0ItXFx1MDAzRlxcdTAwNDBcXHUwMDVCLVxcdTAwNUVcXHUwMDYwXFx1MDA3Qi1cXHUwMDdGJ1xuICBzZWxmOjpDT05TVF9OQU1FX1JFR0VYUCA9IFJlZ2V4cC5uZXcoXCIje3NlbGY6OlJFR0VYUF9TVEFSVH0oOjopP1tBLVpdW14je3NlbGY6OkZPUkJJRERFTl9DT05TVF9OQU1FX0NIQVJTfV0qI3tzZWxmOjpSRUdFWFBfRU5EfVwiKVxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6T3BhbD4iLCJzZWxmIiwiUmVnZXhwIiwibmV3Iiwic2VsZjo6Rk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMiLCJzZWxmOjpGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMiLCJzZWxmOjpSRUdFWFBfU1RBUlQiLCJzZWxmOjpGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSUyIsInNlbGY6OlJFR0VYUF9FTkQiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLFdBQUFDLElBQUEsa0JBQTZDRCxHQUE3QztJQUNBLFdBQUFDLElBQUEsZ0JBQTJDRCxHQUEzQztJQVNBLFdBQUFDLElBQUEseUNBQTRDRCxxRUFBNUM7SUFZQSxXQUFBQyxJQUFBLHVDQUE0Q0QsMkZBQTVDO0lBQ0EsV0FBQUMsSUFBQSw4QkFBaUNDLFlBQU1DLEtBQUFBLENBQU1ILElBQUQsR0FBQSxDQUFLSSxJQUFBSCxJQUFBRyx3Q0FBTCxDQUFBLEdBQStDSixNQUEvQyxHQUFBLENBQXFESyxJQUFBSixJQUFBSSxzQ0FBckQsQ0FBQSxHQUE2RkwsR0FBbEdHLENBQXZDO0lBSUEsV0FBQUYsSUFBQSxnQ0FBbUNELDJGQUFuQztJQUNBQSxPQUFBLFdBQUFDLElBQUEsdUJBQTBCQyxZQUFNQyxLQUFBQSxDQUFLLEVBQUEsR0FBQSxDQUFHRyxJQUFBTCxJQUFBSyxpQkFBSCxDQUFBLEdBQXNCTixjQUF0QixHQUFBLENBQW9DTyxJQUFBTixJQUFBTSwrQkFBcEMsQ0FBQSxHQUFxRVAsSUFBckUsR0FBQSxDQUF5RVEsSUFBQVAsSUFBQU8sZUFBekUsQ0FBTEwsQ0FBaEM7RUE3QkZILEdBQUFBLFdBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTU4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvbWluaS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyI6Ok9iamVjdC5yZXF1aXJlICdvcGFsL2Jhc2UnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvbmlsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9ib29sZWFuJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2VudW1lcmF0b3InXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2FycmF5J1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9oYXNoJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9udW1iZXInXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JhbmdlJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9wcm9jJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9tZXRob2QnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JlZ2V4cCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvdmFyaWFibGVzJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9pbydcbjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvcmVnZXhwX2FuY2hvcnMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIk9iamVjdCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQSw0QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFFUkQsT0FBUUMsU0FBQUEsQ0FBU0YsYUFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsaUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixvQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0Ysb0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLG9CQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixlQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixjQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZUFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixtQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsWUFBVEU7RUFDUkYsT0FBQUMsT0FBUUMsU0FBQUEsQ0FBU0YscUJBQVRFO0FBakJSRjsifX0seyJvZmZzZXQiOnsibGluZSI6MTk2MDgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC9mb3JtYXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG9cblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiBmb3JtYXQoZm9ybWF0X3N0cmluZywgKmFyZ3MpXG4gICAgaWYgYXJncy5sZW5ndGggPT0gMSAmJiBhcmdzWzBdLnJlc3BvbmRfdG8/KDp0b19hcnkpXG4gICAgICBhcnkgPSA6Ok9wYWwuY29lcmNlX3RvPyhhcmdzWzBdLCA6OkFycmF5LCA6dG9fYXJ5KVxuICAgICAgYXJncyA9IGFyeS50b19hIHVubGVzcyBhcnkubmlsP1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgLy91c2VkIGZvciBzbGljaW5nOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gMCxcbiAgICAgICAgICBlbmRfc2xpY2UsXG4gICAgICAgICAgLy91c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZm9ybWF0IHN0cmluZzpcbiAgICAgICAgICBpLFxuICAgICAgICAgIGxlbiA9IGZvcm1hdF9zdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBmaWVsZCB2YWx1ZXM6XG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHN0cixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWcgYW5kICVHIGZpZWxkczpcbiAgICAgICAgICBleHBvbmVudCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2lkdGggYW5kIHByZWNpc2lvbjpcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgLy91c2VkIGZvciBob2xkaW5nIHRlbXBvcmFyeSB2YWx1ZXM6XG4gICAgICAgICAgdG1wX251bSxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJXt9IGFuZCAlPD4gZmlsZWRzOlxuICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSxcbiAgICAgICAgICBjbG9zaW5nX2JyYWNlX2NoYXIsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nICViLCAlQiwgJW8sICV4LCBhbmQgJVggZmllbGRzOlxuICAgICAgICAgIGJhc2VfbnVtYmVyLFxuICAgICAgICAgIGJhc2VfcHJlZml4LFxuICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgIG5leHRfYXJnLFxuICAgICAgICAgIHNlcV9hcmdfbnVtID0gMSxcbiAgICAgICAgICBwb3NfYXJnX251bSA9IDAsXG4gICAgICAgICAgLy91c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGZsYWdzOlxuICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgIEZOT05FICA9IDAsXG4gICAgICAgICAgRlNIQVJQID0gMSxcbiAgICAgICAgICBGTUlOVVMgPSAyLFxuICAgICAgICAgIEZQTFVTICA9IDQsXG4gICAgICAgICAgRlpFUk8gID0gOCxcbiAgICAgICAgICBGU1BBQ0UgPSAxNixcbiAgICAgICAgICBGV0lEVEggPSAzMixcbiAgICAgICAgICBGUFJFQyAgPSA2NCxcbiAgICAgICAgICBGUFJFQzAgPSAxMjg7XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9GTEFHUygpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgd2lkdGgnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdmbGFnIGFmdGVyIHByZWNpc2lvbid9IH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gQ0hFQ0tfRk9SX1dJRFRIKCkge1xuICAgICAgICBpZiAoZmxhZ3MmRldJRFRIKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd2lkdGggZ2l2ZW4gdHdpY2UnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3aWR0aCBhZnRlciBwcmVjaXNpb24nfSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9OVEhfQVJHKG51bSkge1xuICAgICAgICBpZiAobnVtID49IGFyZ3MubGVuZ3RoKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndG9vIGZldyBhcmd1bWVudHMnfSB9XG4gICAgICAgIHJldHVybiBhcmdzW251bV07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9ORVhUX0FSRygpIHtcbiAgICAgICAgc3dpdGNoIChwb3NfYXJnX251bSkge1xuICAgICAgICBjYXNlIC0xOiAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ1bm51bWJlcmVkKCN7YHNlcV9hcmdfbnVtYH0pIG1peGVkIHdpdGggbnVtYmVyZWRcIn0gLy8gcmFpc2VcbiAgICAgICAgY2FzZSAtMjogI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwidW5udW1iZXJlZCgje2BzZXFfYXJnX251bWB9KSBtaXhlZCB3aXRoIG5hbWVkXCJ9IC8vIHJhaXNlXG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSBzZXFfYXJnX251bSsrO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcocG9zX2FyZ19udW0gLSAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX1BPU19BUkcobnVtKSB7XG4gICAgICAgIGlmIChwb3NfYXJnX251bSA+IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJudW1iZXJlZCgje2BudW1gfSkgYWZ0ZXIgdW5udW1iZXJlZCgje2Bwb3NfYXJnX251bWB9KVwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NfYXJnX251bSA9PT0gLTIpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJudW1iZXJlZCgje2BudW1gfSkgYWZ0ZXIgbmFtZWRcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtIDwgMSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgaW5kZXggLSAje2BudW1gfSRcIn1cbiAgICAgICAgfVxuICAgICAgICBwb3NfYXJnX251bSA9IC0xO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcobnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9BUkcoKSB7XG4gICAgICAgIHJldHVybiAobmV4dF9hcmcgPT09IHVuZGVmaW5lZCA/IEdFVF9ORVhUX0FSRygpIDogbmV4dF9hcmcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBSRUFEX05VTShsYWJlbCkge1xuICAgICAgICB2YXIgbnVtLCBzdHIgPSAnJztcbiAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSpbMC05XSd9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJDb2RlQXQoaSkgPCA0OCB8fCBmb3JtYXRfc3RyaW5nLmNoYXJDb2RlQXQoaSkgPiA1Nykge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgbnVtID0gcGFyc2VJbnQoc3RyLCAxMCkgfHwgMDtcbiAgICAgICAgICAgIGlmIChudW0gPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIiN7YGxhYmVsYH0gdG9vIGJpZ1wifVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFJFQURfTlVNX0FGVEVSX0FTVEVSKGxhYmVsKSB7XG4gICAgICAgIHZhciBhcmcsIG51bSA9IFJFQURfTlVNKGxhYmVsKTtcbiAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gJyQnKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGFyZyA9IEdFVF9QT1NfQVJHKG51bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJnID0gR0VUX05FWFRfQVJHKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7YGFyZ2AudG9faW50fTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJyk7IGkgIT09IC0xOyBpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJywgaSkpIHtcbiAgICAgICAgc3RyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGZsYWdzID0gRk5PTkU7XG4gICAgICAgIHdpZHRoID0gLTE7XG4gICAgICAgIHByZWNpc2lvbiA9IC0xO1xuICAgICAgICBuZXh0X2FyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICBlbmRfc2xpY2UgPSBpO1xuXG4gICAgICAgIGkrKztcblxuICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gaTtcbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXDAnOlxuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdF9zZXF1ZW5jZTogZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcblxuICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGU1BBQ0U7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlNIQVJQO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZQTFVTO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGWkVSTztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgIGNhc2UgJzUnOlxuICAgICAgICAgIGNhc2UgJzYnOlxuICAgICAgICAgIGNhc2UgJzcnOlxuICAgICAgICAgIGNhc2UgJzgnOlxuICAgICAgICAgIGNhc2UgJzknOlxuICAgICAgICAgICAgdG1wX251bSA9IFJFQURfTlVNKCd3aWR0aCcpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgIGlmIChpICsgMiA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5leHRfYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ2YWx1ZSBnaXZlbiB0d2ljZSAtICUje2B0bXBfbnVtYH0kXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV4dF9hcmcgPSBHRVRfUE9TX0FSRyh0bXBfbnVtKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgQ0hFQ0tfRk9SX1dJRFRIKCk7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgICAgd2lkdGggPSB0bXBfbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgY2FzZSAnXFx7JzpcbiAgICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhciA9IChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJzwnID8gJz4nIDogJ1xcfScpO1xuICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ID0gJyc7XG5cbiAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIG5hbWUgLSB1bm1hdGNoZWQgcGFyZW50aGVzaXMnfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gY2xvc2luZ19icmFjZV9jaGFyKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJuYW1lZCAje2BoYXNoX3BhcmFtZXRlcl9rZXlgfSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NfYXJnX251bSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm5hbWVkICN7YGhhc2hfcGFyYW1ldGVyX2tleWB9IGFmdGVyIG51bWJlcmVkXCJ9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc19hcmdfbnVtID0gLTI7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnc1swXSA9PT0gdW5kZWZpbmVkIHx8ICFhcmdzWzBdLiQkaXNfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdvbmUgaGFzaCByZXF1aXJlZCd9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV4dF9hcmcgPSAje2BhcmdzWzBdYC5mZXRjaChgaGFzaF9wYXJhbWV0ZXJfa2V5YCl9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsb3NpbmdfYnJhY2VfY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IG5leHRfYXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmFpc2VcblxuICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgQ0hFQ0tfRk9SX1dJRFRIKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGV0lEVEg7XG4gICAgICAgICAgICB3aWR0aCA9IFJFQURfTlVNX0FGVEVSX0FTVEVSKCd3aWR0aCcpO1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgICBmbGFncyB8PSBGTUlOVVM7XG4gICAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRlBSRUMwKSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAncHJlY2lzaW9uIGdpdmVuIHR3aWNlJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYWdzIHw9IEZQUkVDfEZQUkVDMDtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09ICcqJykge1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHByZWNpc2lvbiA9IFJFQURfTlVNX0FGVEVSX0FTVEVSKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBmbGFncyAmPSB+RlBSRUM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU0oJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICBhcmcgPSAjezo6S2VybmVsLkludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAyO1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwYic7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXjErLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICcxJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSA4O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMz83Ky87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnNyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAxNjtcbiAgICAgICAgICAgICAgYmFzZV9wcmVmaXggPSAnMHgnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL15mKy87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnZic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0gI3s6Oktlcm5lbC5JbnRlZ2VyKGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDApIHtcbiAgICAgICAgICAgICAgc3RyID0gYXJnLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkgLSAoKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSAtIChmbGFncyZGU0hBUlAgPyAyIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IChhcmcgPj4+IDApLnRvU3RyaW5nKGJhc2VfbnVtYmVyKS5yZXBsYWNlKGJhc2VfbmVnX3plcm9fcmVnZXgsIGJhc2VfbmVnX3plcm9fZGlnaXQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uIC0gMikgeyBzdHIgPSBiYXNlX25lZ196ZXJvX2RpZ2l0ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAyIC0gKGZsYWdzJkZTSEFSUCA/IGJhc2VfcHJlZml4Lmxlbmd0aCA6IDApKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICBhcmcgPSAjezo6S2VybmVsLkZsb2F0KGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDAgfHwgaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHN0ciA9ICdJbmYnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0ZpeGVkKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbCgpO1xuICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChzdHIuc3BsaXQoJ2UnKVsxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoZXhwb25lbnQgPCAtNCB8fCBleHBvbmVudCA+PSAocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9QcmVjaXNpb24ocHJlY2lzaW9uID09PSAtMSA/IChmbGFncyZGU0hBUlAgPyA2IDogdW5kZWZpbmVkKSA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkudG9VcHBlckNhc2UoKSAmJiBhcmcgIT09IEluZmluaXR5ICYmIGFyZyAhPT0gLUluZmluaXR5ICYmICFpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhbZUVdWy0rXT8pKFswLTldKSQvLCAnJDEwJDInKTtcbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgLy8gTm90IGltcGxlbWVudGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIHNwZWNzIGZvciB0aGlzIGZpZWxkIHR5cGUuXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvciwgJ2BBYCBhbmQgYGFgIGZvcm1hdCBmaWVsZCB0eXBlcyBhcmUgbm90IGltcGxlbWVudGVkIGluIE9wYWwgeWV0J31cbiAgICAgICAgICAgIC8vIHJhaXNlXG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGFyZyA9IEdFVF9BUkcoKTtcbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19hcnkpfSkgeyBhcmcgPSAje2BhcmdgLnRvX2FyeX1bMF07IH1cbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgICAgICBzdHIgPSAje2BhcmdgLnRvX3N0cn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCRjb2VyY2VfdG8oYXJnLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJyVjIHJlcXVpcmVzIGEgY2hhcmFjdGVyJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIHN0ciA9ICN7YEdFVF9BUkcoKWAuaW5zcGVjdH07XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgc3RyID0gI3tgR0VUX0FSRygpYC50b19zfTtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm1hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSN7YGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpYH1cIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSd9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gZm9ybWF0X3N0cmluZy5zbGljZShiZWdpbl9zbGljZSwgZW5kX3NsaWNlKSArIHN0cjtcbiAgICAgICAgYmVnaW5fc2xpY2UgPSBpICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JERFQlVHfSAmJiBwb3NfYXJnX251bSA+PSAwICYmIHNlcV9hcmdfbnVtIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0b28gbWFueSBhcmd1bWVudHMgZm9yIGZvcm1hdCBzdHJpbmcnfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0ICsgZm9ybWF0X3N0cmluZy5zbGljZShiZWdpbl9zbGljZSk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzcHJpbnRmIGZvcm1hdFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsImZvcm1hdCIsImZvcm1hdF9zdHJpbmciLCJhcmdzIiwibGVuZ3RoIiwiMSIsIltdIiwiMCIsInJlc3BvbmRfdG8/IiwiYXJ5IiwiT3BhbCIsImNvZXJjZV90bz8iLCJBcnJheSIsIm5pbD8iLCJ0b19hIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwidG9faW50IiwiZmV0Y2giLCJJbnRlZ2VyIiwiRmxvYXQiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwidG9fYXJ5IiwidG9fc3RyIiwiaW5zcGVjdCIsInRvX3MiLCIkREVCVUciXSwibWFwcGluZ3MiOiJBQUFBQSx3Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7Ozs7QUFDRUMsSUFBQUEsc0JBQUFBLGtCQUFXQyxhQUFELEVBSFosRUFHRUQ7QUFBQUEsTUFBQUE7QUFBQUE7OztNQUhGO01BRzRCO01BQ3hCLElBQUcsQ0FBQSxNQUFBRSxJQUFJQyxRQUFBQSxDQUFBQSxDQUFKLEVBQWVDLENBQWYsQ0FBQSxJQUFBLENBQUEsUUFBb0JGLElBQUlHLE9BQUFBLENBQUNDLENBQURELENBQUdFLGdCQUFBQSxDQUFhLFFBQWJBLENBQTNCLENBQUEsQ0FBQSxDQUFIOztRQUNFQyxNQUFNQyxLQUFNQyxlQUFBQSxDQUFZUixJQUFJRyxPQUFBQSxDQUFDQyxDQUFERCxDQUF0QixFQUEyQk0sWUFBM0IsRUFBb0MsUUFBOUJEO1FBQ1osS0FBQSxRQUF1QkYsR0FBR0ksU0FBQUEsQ0FBQUEsQ0FBMUIsQ0FBQTtVQUFBVixPQUFPTSxH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QixRQUFBQSxDQUFBQSxDQUFRdkI7QUFDbkNBO0FBQ0FBLHdEQUEwRG1CLGNBQVVuQjtBQUNwRUE7QUFDQUE7QUFDQUEsY0FBZ0JjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIseUJBQXhCZTtBQUN4QmY7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsU0FBREEsQ0FBV3dCLFNBQUFBLENBQUFBLENBQVN4QjtBQUN4Q0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsU0FBREEsQ0FBV3lCLE1BQUFBLENBQUFBLENBQU16QjtBQUNyQ0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFlBQWNjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDaEIsNkJBQUQsR0FBQSxDQUErQkEsdUJBQS9CLENBQXhCZTtBQUN0QmY7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVljLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIsNkJBQXhCZTtBQUNwQmY7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQSxVQUFZMEIsWUFBTzFCO0FBQ25CQSxRQUFVYyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2hCLHNDQUF4QmU7QUFDbEJmOztBQUVBQTtBQUNBQTtJQTdoQkVBLENBQUFBLElBQUFBO0lBZ2lCQUQsT0FBQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0VBamlCRkEsR0FBTyxJQUFQQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjAxNzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cmluZy9lbmNvZGluZy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL3N0cmluZydcblxuY2xhc3MgOjpFbmNvZGluZ1xuICBkZWYgc2VsZi5yZWdpc3RlcihuYW1lLCBvcHRpb25zID0ge30sICZibG9jaylcbiAgICBuYW1lcyA9IFtuYW1lXSArIChvcHRpb25zWzphbGlhc2VzXSB8fCBbXSlcbiAgICBhc2NpaSA9IG9wdGlvbnNbOmFzY2lpXSB8fCBmYWxzZVxuICAgIGR1bW15ID0gb3B0aW9uc1s6ZHVtbXldIHx8IGZhbHNlXG5cbiAgICBpZiBvcHRpb25zWzppbmhlcml0c11cbiAgICAgIGVuY29kaW5nID0gb3B0aW9uc1s6aW5oZXJpdHNdLmNsb25lXG4gICAgICBlbmNvZGluZy5pbml0aWFsaXplKG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgZWxzZVxuICAgICAgZW5jb2RpbmcgPSBuZXcobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcbiAgICBlbmRcbiAgICBlbmNvZGluZy5pbnN0YW5jZV9ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICByZWdpc3RlciA9IGBPcGFsLmVuY29kaW5nc2BcbiAgICBuYW1lcy5lYWNoIGRvIHxlbmNvZGluZ19uYW1lfFxuICAgICAgY29uc3Rfc2V0IGVuY29kaW5nX25hbWUudHIoJy0nLCAnXycpLCBlbmNvZGluZ1xuICAgICAgcmVnaXN0ZXIuSlNbZW5jb2RpbmdfbmFtZV0gPSBlbmNvZGluZ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5maW5kKG5hbWUpXG4gICAgcmV0dXJuIGRlZmF1bHRfZXh0ZXJuYWwgaWYgbmFtZSA9PSA6ZGVmYXVsdF9leHRlcm5hbFxuICAgIGByZXR1cm4gT3BhbC5maW5kX2VuY29kaW5nKG5hbWUpYFxuICBlbmRcblxuICBzaW5nbGV0b25fY2xhc3MuYXR0cl9hY2Nlc3NvciA6ZGVmYXVsdF9leHRlcm5hbFxuXG4gIGF0dHJfcmVhZGVyIDpuYW1lLCA6bmFtZXNcblxuICBkZWYgaW5pdGlhbGl6ZShuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIEBuYW1lICA9IG5hbWVcbiAgICBAbmFtZXMgPSBuYW1lc1xuICAgIEBhc2NpaSA9IGFzY2lpXG4gICAgQGR1bW15ID0gZHVtbXlcbiAgZW5kXG5cbiAgZGVmIGFzY2lpX2NvbXBhdGlibGU/XG4gICAgQGFzY2lpXG4gIGVuZFxuXG4gIGRlZiBkdW1teT9cbiAgICBAZHVtbXlcbiAgZW5kXG5cbiAgZGVmIGJpbmFyeT9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIEBuYW1lXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPEVuY29kaW5nOiN7QG5hbWV9I3snIChkdW1teSknIGlmIEBkdW1teX0+XCJcbiAgZW5kXG5cbiAgIyBtZXRob2RzIHRvIGltcGxlbWVudCBwZXIgZW5jb2RpbmdcbiAgZGVmIGNoYXJzaXplKHN0cmluZylcbiAgICAleHtcbiAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKCEoY2hhcmNvZGUgPj0gMHhEODAwICYmIGNoYXJjb2RlIDw9IDB4REJGRikpIHtcbiAgICAgICAgICBsZW4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgbG93X3N1cnJvZ2F0ZSA9IFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgY2hyID0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNoYXJjb2RlID49IDB4REMwMCAmJiBjaGFyY29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICBsb3dfc3Vycm9nYXRlID0gY2hyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlID49IDB4RDgwMCAmJiBjaGFyY29kZSA8PSAweERCRkYpIHtcbiAgICAgICAgICBjaHIgPSBsb3dfc3Vycm9nYXRlICsgY2hyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmcuZW5jb2RpbmcubmFtZSAhPSBcIlVURi04XCIpIHtcbiAgICAgICAgICBjaHIgPSBuZXcgU3RyaW5nKGNocik7XG4gICAgICAgICAgY2hyLmVuY29kaW5nID0gc3RyaW5nLmVuY29kaW5nO1xuICAgICAgICB9XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBjaHIpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZSgqKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoKilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgY2xhc3MgOjpFbmNvZGluZ0Vycm9yIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbiAgY2xhc3MgOjpDb21wYXRpYmlsaXR5RXJyb3IgPCA6OkVuY29kaW5nRXJyb3I7IGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi04JywgYWxpYXNlczogWydDUDY1MDAxJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAvLyBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iL2Y1MmRmZmQ5ZGYwNDQ1YjkzYzBjOTA2NWMyZjhmMGY0NmIyYzcyOWEvaW5kZXguanMjTDE5NTQtTDIwMzJcbiAgICAgIHZhciB1bml0cyA9IEluZmluaXR5O1xuICAgICAgdmFyIGNvZGVQb2ludDtcbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkRgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gZW5jb2RlIHV0ZjhcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50YH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiB8IDB4QzBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4QyB8IDB4RTBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW52YWxpZCBjb2RlIHBvaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgc3RyaW5nLmJ5dGVzLmxlbmd0aFxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMTZMRScgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgYHN0cmluZy5sZW5ndGggKiAyYFxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMTZCRScsIGluaGVyaXRzOiA6OkVuY29kaW5nOjpVVEZfMTZMRSBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTMyTEUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICAgICN7eWllbGQgMH07XG4gICAgICAgICN7eWllbGQgMH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoICogNGBcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTMyQkUnLCBpbmhlcml0czogOjpFbmNvZGluZzo6VVRGXzMyTEUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ0FTQ0lJLThCSVQnLCBhbGlhc2VzOiBbJ0JJTkFSWSddLCBhc2NpaTogdHJ1ZSBkb1xuICBkZWYgZWFjaF9jaGFyKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hyID0gbmV3IFN0cmluZyhzdHJpbmcuY2hhckF0KGkpKTtcbiAgICAgICAgY2hyLmVuY29kaW5nID0gc3RyaW5nLmVuY29kaW5nO1xuICAgICAgICAje3lpZWxkIGBjaHJgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaGFyc2l6ZShzdHJpbmcpXG4gICAgYHN0cmluZy5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgYmluYXJ5P1xuICAgIHRydWVcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnSVNPLTg4NTktMScsIGFsaWFzZXM6IFsnSVNPODg1OS0xJ10sIGFzY2lpOiB0cnVlLCBpbmhlcml0czogOjpFbmNvZGluZzo6QVNDSUlfOEJJVFxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVMtQVNDSUknLCBhbGlhc2VzOiBbJ0FTQ0lJJ10sIGFzY2lpOiB0cnVlLCBpbmhlcml0czogOjpFbmNvZGluZzo6QVNDSUlfOEJJVFxuXG5jbGFzcyA6OlN0cmluZ1xuICBhdHRyX3JlYWRlciA6ZW5jb2RpbmdcbiAgYXR0cl9yZWFkZXIgOmludGVybmFsX2VuY29kaW5nXG4gIGBPcGFsLnByb3AoU3RyaW5nLnByb3RvdHlwZSwgJ2J5dGVzJywgbmlsKWBcbiAgYE9wYWwucHJvcChTdHJpbmcucHJvdG90eXBlLCAnZW5jb2RpbmcnLCAjezo6RW5jb2Rpbmc6OlVURl84fSlgXG4gIGBPcGFsLnByb3AoU3RyaW5nLnByb3RvdHlwZSwgJ2ludGVybmFsX2VuY29kaW5nJywgI3s6OkVuY29kaW5nOjpVVEZfOH0pYFxuXG4gIGRlZiBiXG4gICAgZHVwLmZvcmNlX2VuY29kaW5nKCdiaW5hcnknKVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemVcbiAgICBAaW50ZXJuYWxfZW5jb2RpbmcuYnl0ZXNpemUoc2VsZilcbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2J5dGUpIHsgYnl0ZXNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAaW50ZXJuYWxfZW5jb2RpbmcuZWFjaF9ieXRlKHNlbGYsICZibG9jaylcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzXG4gICAgIyBSRU1JTkQ6IHJlcXVpcmVkIHdoZW4gcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgb3RoZXJ3aXNlIHRoZSBmb2xsb3dpbmcgZXJyb3Igd2lsbCBiZSB0aHJvd246XG4gICAgIyBDYW5ub3QgY3JlYXRlIHByb3BlcnR5ICdieXRlcycgb24gc3RyaW5nICdhYmMnXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAje2BuZXcgU3RyaW5nKHNlbGYpYC5lYWNoX2J5dGUudG9fYX07XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGJ5dGVzIHx8PSBlYWNoX2J5dGUudG9fYVxuICAgIEBieXRlcy5kdXBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2NoYXIpIHsgbGVuZ3RoIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgQGVuY29kaW5nLmVhY2hfY2hhcihzZWxmLCAmYmxvY2spXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjaGFycygmYmxvY2spXG4gICAgcmV0dXJuIGVhY2hfY2hhci50b19hIHVubGVzcyBibG9ja1xuXG4gICAgZWFjaF9jaGFyKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29kZXBvaW50KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfY29kZXBvaW50IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICN7eWllbGQgYHNlbGYuY29kZVBvaW50QXQoaSlgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29kZXBvaW50cygmYmxvY2spXG4gICAgIyBJZiBhIGJsb2NrIGlzIGdpdmVuLCB3aGljaCBpcyBhIGRlcHJlY2F0ZWQgZm9ybSwgd29ya3MgdGhlIHNhbWUgYXMgZWFjaF9jb2RlcG9pbnQuXG4gICAgcmV0dXJuIGVhY2hfY29kZXBvaW50KCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgZWFjaF9jb2RlcG9pbnQudG9fYVxuICBlbmRcblxuICBkZWYgZW5jb2RlKGVuY29kaW5nKVxuICAgIGBPcGFsLmVuYyhzZWxmLCBlbmNvZGluZylgXG4gIGVuZFxuXG4gIGRlZiBmb3JjZV9lbmNvZGluZyhlbmNvZGluZylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHN0ci5lbmNvZGluZykgeyByZXR1cm4gc3RyOyB9XG5cbiAgICAgIGVuY29kaW5nID0gI3s6Ok9wYWwuY29lcmNlX3RvIShlbmNvZGluZywgOjpTdHJpbmcsIDp0b19zKX07XG4gICAgICBlbmNvZGluZyA9ICN7OjpFbmNvZGluZy5maW5kKGVuY29kaW5nKX07XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc3RyLmVuY29kaW5nKSB7IHJldHVybiBzdHI7IH1cblxuICAgICAgc3RyID0gT3BhbC5zZXRfZW5jb2Rpbmcoc3RyLCBlbmNvZGluZyk7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2V0Ynl0ZShpZHgpXG4gICAgc3RyaW5nX2J5dGVzID0gYnl0ZXNcbiAgICBpZHggPSA6Ok9wYWwuY29lcmNlX3RvIShpZHgsIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICByZXR1cm4gaWYgc3RyaW5nX2J5dGVzLmxlbmd0aCA8IGlkeFxuXG4gICAgc3RyaW5nX2J5dGVzW2lkeF1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICAle1xuICAgICAgc2VsZi5lbmNvZGluZyA9IG90aGVyLmVuY29kaW5nO1xuICAgICAgc2VsZi5pbnRlcm5hbF9lbmNvZGluZyA9IG90aGVyLmludGVybmFsX2VuY29kaW5nO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBzdHViXG4gIGRlZiB2YWxpZF9lbmNvZGluZz9cbiAgICB0cnVlXG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcuZGVmYXVsdF9leHRlcm5hbCA9IF9fRU5DT0RJTkdfX1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpFbmNvZGluZz4iLCJyZWdpc3RlciIsIm5hbWUiLCJvcHRpb25zIiwibmFtZXMiLCIrIiwiJHJldF9vcl8xIiwiW10iLCJhc2NpaSIsImR1bW15IiwiZW5jb2RpbmciLCJjbG9uZSIsImluaXRpYWxpemUiLCJuZXciLCJibG9ja19naXZlbj8iLCJpbnN0YW5jZV9ldmFsIiwiYmxvY2siLCJ0b19wcm9jIiwiZWFjaCIsImJsb2NrIGluIHJlZ2lzdGVyIiwiZW5jb2RpbmdfbmFtZSIsImJsb2NrICgyIGxldmVscykgaW4gcmVnaXN0ZXIiLCJjb25zdF9zZXQiLCJ0ciIsImZpbmQiLCJkZWZhdWx0X2V4dGVybmFsIiwic2luZ2xldG9uX2NsYXNzIiwiYXR0cl9hY2Nlc3NvciIsImF0dHJfcmVhZGVyIiwiQG5hbWUiLCJAbmFtZXMiLCJAYXNjaWkiLCJAZHVtbXkiLCJhc2NpaV9jb21wYXRpYmxlPyIsImR1bW15PyIsImJpbmFyeT8iLCJ0b19zIiwiaW5zcGVjdCIsImNoYXJzaXplIiwic3RyaW5nIiwiZWFjaF9jaGFyIiwiZWFjaF9ieXRlIiwiS2VybmVsIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwiYnl0ZXNpemUiLCI8Y2xhc3M6RW5jb2RpbmdFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOkNvbXBhdGliaWxpdHlFcnJvcj4iLCJFbmNvZGluZ0Vycm9yIiwiRW5jb2RpbmciLCJibG9jayBpbiA8dG9wIChyZXF1aXJlZCk+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8dG9wIChyZXF1aXJlZCk+IiwiYnl0ZXMiLCJsZW5ndGgiLCJFbmNvZGluZzo6VVRGXzE2TEUiLCIwIiwiRW5jb2Rpbmc6OlVURl8zMkxFIiwiRW5jb2Rpbmc6OkFTQ0lJXzhCSVQiLCI8Y2xhc3M6U3RyaW5nPiIsIkVuY29kaW5nOjpVVEZfOCIsImIiLCJkdXAiLCJmb3JjZV9lbmNvZGluZyIsIkBpbnRlcm5hbF9lbmNvZGluZyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaF9ieXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2J5dGUiLCJ0b19hIiwiQGJ5dGVzIiwiYmxvY2sgaW4gZWFjaF9jaGFyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2NoYXIiLCJAZW5jb2RpbmciLCJjaGFycyIsImVhY2hfY29kZXBvaW50IiwiY29kZXBvaW50cyIsImVuY29kZSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiU3RyaW5nIiwiZ2V0Ynl0ZSIsImlkeCIsInN0cmluZ19ieXRlcyIsIkludGVnZXIiLCI8IiwiaW5pdGlhbGl6ZV9jb3B5Iiwib3RoZXIiLCJ2YWxpZF9lbmNvZGluZz8iLCJkZWZhdWx0X2V4dGVybmFsPSJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsTUFBSUgsSUFBSkcsZUFBQUEsb0JBQWtCQyxJQUFELEVBQU9DLE9BQXhCRjtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUF3QiwrQkFBVSxZQUFBO01BQ2hDRyxRQUFlQyxTQUFQLENBQUNILElBQUQsQ0FBT0csRUFBRyxDQUFBLFFBQUFDLENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsU0FBREEsQ0FBUEQsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBcUIsRUFBckIsQ0FBQSxDQUFIRDtNQUNmRyxRQUFRLENBQUEsUUFBQUYsQ0FBQUEsWUFBQUgsT0FBT0ksT0FBQUEsQ0FBQyxPQUFEQSxDQUFQRCxDQUFB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LEVBQUVILEdBQUZHLENBQTlCLENBQUE7UUFBQSxPQUFBO01BQUE7TUFFQUosT0FBQUUsWUFBWTNFLE9BQUFBLENBQUMwRSxHQUFEMUU7SUFMZHlFLENBQUFBOztBQVFBSyxJQUFBQSwrQkFBQUEsMkJBQW9CQyxLQUFwQkQ7QUFBQUE7TUFDRUEsT0FBRUEsSUFBRixHQUNKQSx5Q0FESSxHQUVKQSwyREFGSSxHQUdKQTtJQUpFQSxDQUFBQTtJQVFBMUIsT0FBQTRCLCtCQUFBQSxZQUNFLElBREZBLENBQUFBO0VBdkdGNUIsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQTRHQTlELE9BQVUyRixNQUFBQSxDQUFvQjVCLElBM1o5QlYsY0EyWjhCVSxVQUFwQjRCLENBQUFBLEVBQUFBLE1BQVZ0QyxlQUFVc0MscUJBQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBO0FBM1pWM0Y7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwNjk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYXRoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvclxuXG5tb2R1bGUgOjpNYXRoXG4gIHNlbGY6OkUgID0gYE1hdGguRWBcbiAgc2VsZjo6UEkgPSBgTWF0aC5QSWBcblxuICBzZWxmOjpEb21haW5FcnJvciA9IDo6Q2xhc3MubmV3KDo6U3RhbmRhcmRFcnJvcilcblxuICBkZWYgc2VsZi5jaGVja2VkKG1ldGhvZCwgKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNOYU4oYXJnc1sxXSkpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBNYXRoW21ldGhvZF0uYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgRG9tYWluRXJyb3IsIFwiTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcXFwiI3ttZXRob2R9XFxcIlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZsb2F0ISh2YWx1ZSlcbiAgICA6Oktlcm5lbC5GbG9hdCh2YWx1ZSlcbiAgcmVzY3VlIDo6QXJndW1lbnRFcnJvclxuICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih2YWx1ZSwgI3s6OkZsb2F0fSlgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmludGVnZXIhKHZhbHVlKVxuICAgIDo6S2VybmVsLkludGVnZXIodmFsdWUpXG4gIHJlc2N1ZSA6OkFyZ3VtZW50RXJyb3JcbiAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IodmFsdWUsICN7OjpJbnRlZ2VyfSlgXG4gIGVuZFxuXG4gIG1vZHVsZV9mdW5jdGlvblxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5lcmZgKVxuICAgICV4e1xuICAgICAgT3BhbC5wcm9wKE1hdGgsICdlcmYnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBBMSA9ICAwLjI1NDgyOTU5MixcbiAgICAgICAgICAgIEEyID0gLTAuMjg0NDk2NzM2LFxuICAgICAgICAgICAgQTMgPSAgMS40MjE0MTM3NDEsXG4gICAgICAgICAgICBBNCA9IC0xLjQ1MzE1MjAyNyxcbiAgICAgICAgICAgIEE1ID0gIDEuMDYxNDA1NDI5LFxuICAgICAgICAgICAgUCAgPSAgMC4zMjc1OTExO1xuXG4gICAgICAgIHZhciBzaWduID0gMTtcblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBNYXRoLmFicyh4KTtcblxuICAgICAgICB2YXIgdCA9IDEuMCAvICgxLjAgKyBQICogeCk7XG4gICAgICAgIHZhciB5ID0gMS4wIC0gKCgoKChBNSAqIHQgKyBBNCkgKiB0KSArIEEzKSAqIHQgKyBBMikgKiB0ICsgQTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgICAgICAgcmV0dXJuIHNpZ24gKiB5O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguZXJmY2ApXG4gICAgJXh7XG4gICAgICBPcGFsLnByb3AoTWF0aCwgJ2VyZmMnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciB6ID0gTWF0aC5hYnMoeCksXG4gICAgICAgICAgICB0ID0gMS4wIC8gKDAuNSAqIHogKyAxLjApO1xuXG4gICAgICAgIHZhciBBMSA9IHQgKiAwLjE3MDg3Mjc3ICsgLTAuODIyMTUyMjMsXG4gICAgICAgICAgICBBMiA9IHQgKiBBMSArIDEuNDg4NTE1ODcsXG4gICAgICAgICAgICBBMyA9IHQgKiBBMiArIC0xLjEzNTIwMzk4LFxuICAgICAgICAgICAgQTQgPSB0ICogQTMgKyAwLjI3ODg2ODA3LFxuICAgICAgICAgICAgQTUgPSB0ICogQTQgKyAtMC4xODYyODgwNixcbiAgICAgICAgICAgIEE2ID0gdCAqIEE1ICsgMC4wOTY3ODQxOCxcbiAgICAgICAgICAgIEE3ID0gdCAqIEE2ICsgMC4zNzQwOTE5NixcbiAgICAgICAgICAgIEE4ID0gdCAqIEE3ICsgMS4wMDAwMjM2OCxcbiAgICAgICAgICAgIEE5ID0gdCAqIEE4LFxuICAgICAgICAgICAgQTEwID0gLXogKiB6IC0gMS4yNjU1MTIyMyArIEE5O1xuXG4gICAgICAgIHZhciBhID0gdCAqIE1hdGguZXhwKEExMCk7XG5cbiAgICAgICAgaWYgKHggPCAwLjApIHtcbiAgICAgICAgICByZXR1cm4gMi4wIC0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICAjIFNpbmdsZSBhcmd1bWVudCBlcXVpdmFsZW50IGZ1bmN0aW9uc1xuICAlaVtcbiAgICBhY29zIGFjb3NoIGFzaW4gYXNpbmggYXRhbiBhdGFuaCBjYnJ0XG4gICAgY29zIGNvc2ggZXJmIGVyZmMgZXhwIHNpbiBzaW5oIHNxcnQgdGFuaFxuICBdLmVhY2ggZG8gfG1ldGhvZHxcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZCBkbyB8eHxcbiAgICAgIDo6TWF0aC5jaGVja2VkIG1ldGhvZCwgOjpNYXRoLmZsb2F0ISh4KVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYXRhbjIoeSwgeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6YXRhbjIsIDo6TWF0aC5mbG9hdCEoeSksIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGh5cG90KHgsIHkpXG4gICAgOjpNYXRoLmNoZWNrZWQgOmh5cG90LCA6Ok1hdGguZmxvYXQhKHgpLCA6Ok1hdGguZmxvYXQhKHkpXG4gIGVuZFxuXG4gIGRlZiBmcmV4cCh4KVxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgcmV0dXJuIFtOYU4sIDBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXggICA9IE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnMoeCkpIC8gTWF0aC5sb2coMikpICsgMSxcbiAgICAgICAgICBmcmFjID0geCAvIE1hdGgucG93KDIsIGV4KTtcblxuICAgICAgcmV0dXJuIFtmcmFjLCBleF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2FtbWEobilcbiAgICBuID0gTWF0aC5mbG9hdCEobilcblxuICAgICV4e1xuICAgICAgdmFyIGksIHQsIHgsIHZhbHVlLCByZXN1bHQsIHR3b04sIHRocmVlTiwgZm91ck4sIGZpdmVOO1xuXG4gICAgICB2YXIgRyA9IDQuNzQyMTg3NTtcblxuICAgICAgdmFyIFAgPSBbXG4gICAgICAgICAwLjk5OTk5OTk5OTk5OTk5NzA5MTgyLFxuICAgICAgICAgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LFxuICAgICAgICAtNTkuNTk3OTYwMzU1NDc1NDkxMjQ4LFxuICAgICAgICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LFxuICAgICAgICAtMC40OTE5MTM4MTYwOTc2MjAxOTk3OCxcbiAgICAgICAgIDAuMzM5OTQ2NDk5ODQ4MTE4ODg2OTllLTQsXG4gICAgICAgICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LFxuICAgICAgICAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgICAgICAgIDAuMTU4MDg4NzAzMjI0OTEyNDg4ODRlLTMsXG4gICAgICAgIC0wLjIxMDI2NDQ0MTcyNDEwNDg4MzE5ZS0zLFxuICAgICAgICAgMC4yMTc0Mzk2MTgxMTUyMTI2NDMyMGUtMyxcbiAgICAgICAgLTAuMTY0MzE4MTA2NTM2NzYzODkwMjJlLTMsXG4gICAgICAgICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LFxuICAgICAgICAtMC4yNjE5MDgzODQwMTU4MTQwODY3MGUtNCxcbiAgICAgICAgIDAuMzY4OTkxODI2NTk1MzE2MjI3MDRlLTVcbiAgICAgIF07XG5cblxuICAgICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gLTEgfHwgbiA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgRG9tYWluRXJyb3IsICdOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFwiZ2FtbWFcIid9O1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tJbnRlZ2VyID09PSBufSkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmluaXRlKG4pID8gSW5maW5pdHkgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiA+IDE3MSkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICA9IG4gLSAyO1xuICAgICAgICByZXN1bHQgPSBuIC0gMTtcblxuICAgICAgICB3aGlsZSAodmFsdWUgPiAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ID09IDApIHtcbiAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgLyAoTWF0aC5zaW4oTWF0aC5QSSAqIG4pICogI3s6Ok1hdGguZ2FtbWEoMSAtIG4pfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID49IDE3MS4zNSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID4gODUuMCkge1xuICAgICAgICB0d29OICAgPSBuICogbjtcbiAgICAgICAgdGhyZWVOID0gdHdvTiAqIG47XG4gICAgICAgIGZvdXJOICA9IHRocmVlTiAqIG47XG4gICAgICAgIGZpdmVOICA9IGZvdXJOICogbjtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJIC8gbikgKiBNYXRoLnBvdygobiAvIE1hdGguRSksIG4pICpcbiAgICAgICAgICAoMSArIDEgLyAoMTIgKiBuKSArIDEgLyAoMjg4ICogdHdvTikgLSAxMzkgLyAoNTE4NDAgKiB0aHJlZU4pIC1cbiAgICAgICAgICA1NzEgLyAoMjQ4ODMyMCAqIGZvdXJOKSArIDE2Mzg3OSAvICgyMDkwMTg4ODAgKiBmaXZlTikgK1xuICAgICAgICAgIDUyNDY4MTkgLyAoNzUyNDY3OTY4MDAgKiBmaXZlTiAqIG4pKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSAxO1xuICAgICAgeCAgPSBQWzBdO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgUC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4ICs9IFBbaV0gLyAobiArIGkpO1xuICAgICAgfVxuXG4gICAgICB0ID0gbiArIEcgKyAwLjU7XG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkpICogTWF0aC5wb3codCwgbiArIDAuNSkgKiBNYXRoLmV4cCgtdCkgKiB4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxkZXhwKG1hbnRpc3NhLCBleHBvbmVudClcbiAgICBtYW50aXNzYSA9IE1hdGguZmxvYXQhKG1hbnRpc3NhKVxuICAgIGV4cG9uZW50ID0gTWF0aC5pbnRlZ2VyIShleHBvbmVudClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKGV4cG9uZW50KSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Zsb2F0IE5hTiBvdXQgb2YgcmFuZ2Ugb2YgaW50ZWdlcid9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGdhbW1hKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiA9PSAtMSkge1xuICAgICAgICByZXR1cm4gW0luZmluaXR5LCAxXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW01hdGgubG9nKE1hdGguYWJzKCN7OjpNYXRoLmdhbW1hKG4pfSkpLCAjezo6TWF0aC5nYW1tYShuKX0gPCAwID8gLTEgOiAxXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2coeCwgYmFzZSA9IHVuZGVmaW5lZClcbiAgICBpZiA6OlN0cmluZyA9PT0geFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgaWYgYGJhc2UgPT0gbnVsbGBcbiAgICAgIDo6TWF0aC5jaGVja2VkIDpsb2csIDo6TWF0aC5mbG9hdCEoeClcbiAgICBlbHNlXG4gICAgICBpZiA6OlN0cmluZyA9PT0gYmFzZVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IoYmFzZSwgI3s6OkZsb2F0fSlgXG4gICAgICBlbmRcblxuICAgICAgOjpNYXRoLmNoZWNrZWQoOmxvZywgOjpNYXRoLmZsb2F0ISh4KSkgLyA6Ok1hdGguY2hlY2tlZCg6bG9nLCA6Ok1hdGguZmxvYXQhKGJhc2UpKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbG9nMTAoeClcbiAgICBpZiA6OlN0cmluZyA9PT0geFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgOjpNYXRoLmNoZWNrZWQgOmxvZzEwLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBsb2cyKHgpXG4gICAgaWYgOjpTdHJpbmcgPT09IHhcbiAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih4LCAjezo6RmxvYXR9KWBcbiAgICBlbmRcblxuICAgIDo6TWF0aC5jaGVja2VkIDpsb2cyLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiB0YW4oeClcbiAgICB4ID0gOjpNYXRoLmZsb2F0ISh4KVxuXG4gICAgaWYgeC5pbmZpbml0ZT9cbiAgICAgIHJldHVybiA6OkZsb2F0OjpOQU5cbiAgICBlbmRcblxuICAgIDo6TWF0aC5jaGVja2VkIDp0YW4sIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpNYXRoPiIsInNlbGYiLCJDbGFzcyIsIm5ldyIsIlN0YW5kYXJkRXJyb3IiLCJjaGVja2VkIiwibWV0aG9kIiwiS2VybmVsIiwicmFpc2UiLCJEb21haW5FcnJvciIsImZsb2F0ISIsInZhbHVlIiwiRmxvYXQiLCJBcmd1bWVudEVycm9yIiwiaW50ZWdlciEiLCJJbnRlZ2VyIiwibW9kdWxlX2Z1bmN0aW9uIiwiZWFjaCIsImJsb2NrIGluIDxtb2R1bGU6TWF0aD4iLCJibG9jayAoMiBsZXZlbHMpIGluIDxtb2R1bGU6TWF0aD4iLCJkZWZpbmVfbWV0aG9kIiwieCIsImJsb2NrICgzIGxldmVscykgaW4gPG1vZHVsZTpNYXRoPiIsIk1hdGgiLCJhdGFuMiIsInkiLCJoeXBvdCIsImZyZXhwIiwiZ2FtbWEiLCJuIiwiPT09IiwiLSIsIjEiLCJsZGV4cCIsIm1hbnRpc3NhIiwiZXhwb25lbnQiLCJSYW5nZUVycm9yIiwibGdhbW1hIiwibG9nIiwiYmFzZSIsIlN0cmluZyIsIi8iLCJsb2cxMCIsImxvZzIiLCJ0YW4iLCJpbmZpbml0ZT8iLCJGbG9hdDo6TkFOIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRSxXQUFBQyxJQUFBLE9BQVlELE1BQVo7SUFDQSxXQUFBQyxJQUFBLFFBQVlELE9BQVo7SUFFQSxXQUFBQyxJQUFBLGlCQUFvQkMsTUFBT0MsS0FBQUEsQ0FBS0Msb0JBQUxELENBQTNCO0lBRUFFLE1BQUlKLElBQUpJLGNBQUFBLG1CQUFpQkMsTUFBRCxFQVJsQixFQVFFRDtBQUFBQSxNQUFBQTs7O01BUkY7TUFRMkI7O0FBRTNCQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLFFBQVVFLE9BQVFDLE9BQUFBLENBQU9DLGlCQUFmLEVBQTZCSiwwQ0FBRCxHQUFBLENBQTJDQyxNQUEzQyxDQUFBLEdBQWtERCxJQUF0RUcsQ0FBMEVIO0FBQzVGQTs7QUFFQUE7QUFDQUE7SUFiRUEsQ0FBQUEsSUFBQUE7SUFnQkFLLE1BQUlULElBQUpTLGFBQUFBLDRCQUFnQkMsS0FBaEJEO0FBQUFBO01BQ0U7UUFBQUEsT0FBQUgsT0FBUUssT0FBQUEsQ0FBT0QsS0FBUEM7TUFBUjtRQUNGLHNCQUFPLENBQUFDLG9CQUFBLENBQVA7VUFBQTtZQUNFSCxPQUFBSCxPQUFRQyxPQUFBQSxDQUFRRSxtQkFBcUJFLFlBQVFGLENBQXJDRjtVQURWO1FBQUEsQ0FERTtNQUFBO0lBREZF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QkFBQUEsZUFBUXZCLENBQVJ1QjtBQUFBQTs7TUFDRXZCLElBQUlFLFdBQU1iLFdBQUFBLENBQVFXLENBQVJYO01BRVYsSUFBQSxRQUFHVyxDQUFDd0IsY0FBQUEsQ0FBQUEsQ0FBSixDQUFBO1FBQ0UsT0FBT0MsSUFBQWxDLFlBQUFrQztNQURUO01BSUFGLE9BQUFyQixXQUFNbEIsU0FBQUEsQ0FBUyxLQUFmLEVBQXFCa0IsV0FBTWIsV0FBQUEsQ0FBUVcsQ0FBUlgsQ0FBckJMO0lBUFJ1QyxDQUFBQTtFQXBSRjVDLEdBQU8sSUFBUEE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxMDEzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wbGV4L2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIDo6S2VybmVsXG4gIGRlZiBDb21wbGV4KHJlYWwsIGltYWcgPSBuaWwpXG4gICAgaWYgaW1hZ1xuICAgICAgQ29tcGxleC5uZXcocmVhbCwgaW1hZylcbiAgICBlbHNlXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCAwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OlN0cmluZ1xuICBkZWYgdG9fY1xuICAgIENvbXBsZXguZnJvbV9zdHJpbmcoc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiQ29tcGxleCIsInJlYWwiLCJpbWFnIiwibmV3IiwiMCIsIjxjbGFzczpTdHJpbmc+IiwidG9fYyIsImZyb21fc3RyaW5nIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDLHVCQUFBQSxtQkFBWUMsSUFBRCxFQUFPQyxJQUFsQkY7QUFBQUE7O01BQWtCLHlCQUFPO01BQ3ZCLElBQUEsUUFBR0UsSUFBSCxDQUFBO1FBQ0VGLE9BQUFBLGFBQU9HLEtBQUFBLENBQUtGLElBQVosRUFBa0JDLElBQVhDO01BRFQ7UUFHRUgsT0FBQUEsYUFBT0csS0FBQUEsQ0FBS0YsSUFBWixFQUFrQkcsQ0FBWEQ7TUFIVDtJQURGSCxDQUFBQSxJQUFBQTtFQURGRCxHQUFPLElBQVBBO0VBVUFELE9BQUFPO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQU4sYUFBT08sYUFBQUEsQ0FBYUMsSUFBYkQ7SUFEVEQsQ0FBQUE7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQVZBUDsifX0seyJvZmZzZXQiOnsibGluZSI6MjEwNDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBsZXgucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xucmVxdWlyZSAnY29yZWxpYi9jb21wbGV4L2Jhc2UnXG5cbmNsYXNzIDo6Q29tcGxleCA8IDo6TnVtZXJpY1xuICBkZWYgc2VsZi5yZWN0KHJlYWwsIGltYWcgPSAwKVxuICAgIHVubGVzcyA6Ok51bWVyaWMgPT09IHJlYWwgJiYgcmVhbC5yZWFsPyAmJiA6Ok51bWVyaWMgPT09IGltYWcgJiYgaW1hZy5yZWFsP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHJlYWwsIGltYWcpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBvbGFyKHIsIHRoZXRhID0gMClcbiAgICB1bmxlc3MgOjpOdW1lcmljID09PSByICYmIHIucmVhbD8gJiYgOjpOdW1lcmljID09PSB0aGV0YSAmJiB0aGV0YS5yZWFsP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHIgKiA6Ok1hdGguY29zKHRoZXRhKSwgciAqIDo6TWF0aC5zaW4odGhldGEpKVxuICBlbmRcblxuICBhdHRyX3JlYWRlciA6cmVhbCwgOmltYWdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWFsLCBpbWFnID0gMClcbiAgICBAcmVhbCA9IHJlYWxcbiAgICBAaW1hZyA9IGltYWdcbiAgICBmcmVlemVcbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICBbb3RoZXIsIHNlbGZdXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgWzo6Q29tcGxleC5uZXcob3RoZXIsIDApLCBzZWxmXVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIEByZWFsID09IG90aGVyLnJlYWwgJiYgQGltYWcgPT0gb3RoZXIuaW1hZ1xuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIEByZWFsID09IG90aGVyICYmIEBpbWFnID09IDBcbiAgICBlbHNlXG4gICAgICBvdGhlciA9PSBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIDo6S2VybmVsLkNvbXBsZXgoLUByZWFsLCAtQGltYWcpXG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKyBvdGhlci5yZWFsLCBAaW1hZyArIG90aGVyLmltYWcpXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCArIG90aGVyLCBAaW1hZylcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCAtIG90aGVyLnJlYWwsIEBpbWFnIC0gb3RoZXIuaW1hZylcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsIC0gb3RoZXIsIEBpbWFnKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsICogb3RoZXIucmVhbCAtIEBpbWFnICogb3RoZXIuaW1hZyxcbiAgICAgICAgQHJlYWwgKiBvdGhlci5pbWFnICsgQGltYWcgKiBvdGhlci5yZWFsLFxuICAgICAgKVxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKiBvdGhlciwgQGltYWcgKiBvdGhlcilcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgaWYgKDo6TnVtYmVyID09PSBAcmVhbCAmJiBAcmVhbC5uYW4/KSB8fCAoOjpOdW1iZXIgPT09IEBpbWFnICYmIEBpbWFnLm5hbj8pIHx8XG4gICAgICAgICAoOjpOdW1iZXIgPT09IG90aGVyLnJlYWwgJiYgb3RoZXIucmVhbC5uYW4/KSB8fCAoOjpOdW1iZXIgPT09IG90aGVyLmltYWcgJiYgb3RoZXIuaW1hZy5uYW4/KVxuICAgICAgICA6OkNvbXBsZXgubmV3KDo6RmxvYXQ6Ok5BTiwgOjpGbG9hdDo6TkFOKVxuICAgICAgZWxzZVxuICAgICAgICBzZWxmICogb3RoZXIuY29uaiAvIG90aGVyLmFiczJcbiAgICAgIGVuZFxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwucXVvKG90aGVyKSwgQGltYWcucXVvKG90aGVyKSlcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Lywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGlmIG90aGVyID09IDBcbiAgICAgIHJldHVybiA6OkNvbXBsZXgubmV3KDEsIDApXG4gICAgZW5kXG5cbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICByLCB0aGV0YSA9IHBvbGFyXG4gICAgICBvcmUgICAgICA9IG90aGVyLnJlYWxcbiAgICAgIG9pbSAgICAgID0gb3RoZXIuaW1hZ1xuICAgICAgbnIgICAgICAgPSA6Ok1hdGguZXhwKG9yZSAqIDo6TWF0aC5sb2cocikgLSBvaW0gKiB0aGV0YSlcbiAgICAgIG50aGV0YSAgID0gdGhldGEgKiBvcmUgKyBvaW0gKiA6Ok1hdGgubG9nKHIpXG5cbiAgICAgIDo6Q29tcGxleC5wb2xhcihuciwgbnRoZXRhKVxuICAgIGVsc2lmIDo6SW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmIG90aGVyID4gMFxuICAgICAgICB4ID0gc2VsZlxuICAgICAgICB6ID0geFxuICAgICAgICBuID0gb3RoZXIgLSAxXG5cbiAgICAgICAgd2hpbGUgbiAhPSAwXG4gICAgICAgICAgZGl2LCBtb2QgPSBuLmRpdm1vZCgyKVxuICAgICAgICAgIHdoaWxlIG1vZCA9PSAwXG4gICAgICAgICAgICB4ID0gOjpLZXJuZWwuQ29tcGxleCh4LnJlYWwgKiB4LnJlYWwgLSB4LmltYWcgKiB4LmltYWcsIDIgKiB4LnJlYWwgKiB4LmltYWcpXG4gICAgICAgICAgICBuID0gZGl2XG4gICAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICB6ICo9IHhcbiAgICAgICAgICBuIC09IDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgelxuICAgICAgZWxzZVxuICAgICAgICAoOjpSYXRpb25hbC5uZXcoMSwgMSkgLyBzZWxmKSoqLW90aGVyXG4gICAgICBlbmRcbiAgICBlbHNpZiA6OkZsb2F0ID09PSBvdGhlciB8fCA6OlJhdGlvbmFsID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuXG4gICAgICA6OkNvbXBsZXgucG9sYXIocioqb3RoZXIsIHRoZXRhICogb3RoZXIpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgOjpNYXRoLmh5cG90KEByZWFsLCBAaW1hZylcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBAcmVhbCAqIEByZWFsICsgQGltYWcgKiBAaW1hZ1xuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICA6Ok1hdGguYXRhbjIoQGltYWcsIEByZWFsKVxuICBlbmRcblxuICBkZWYgY29ualxuICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgQHJlYWwuZGVub21pbmF0b3IubGNtKEBpbWFnLmRlbm9taW5hdG9yKVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBDb21wbGV4ID09PSBvdGhlciAmJiBAcmVhbC5jbGFzcyA9PSBAaW1hZy5jbGFzcyAmJiBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHVubGVzcyA6Ok51bWVyaWMgPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gQ29tcGxleFwiXG4gICAgZW5kXG5cbiAgICBzZWxmIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBAcmVhbC5maW5pdGU/ICYmIEBpbWFnLmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBcIkNvbXBsZXg6I3tAcmVhbH06I3tAaW1hZ31cIlxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgQHJlYWwuaW5maW5pdGU/IHx8IEBpbWFnLmluZmluaXRlP1xuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiKCN7c2VsZn0pXCJcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIGQgPSBkZW5vbWluYXRvclxuXG4gICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbC5udW1lcmF0b3IgKiAoZCAvIEByZWFsLmRlbm9taW5hdG9yKSxcbiAgICAgIEBpbWFnLm51bWVyYXRvciAqIChkIC8gQGltYWcuZGVub21pbmF0b3IpLFxuICAgIClcbiAgZW5kXG5cbiAgZGVmIHBvbGFyXG4gICAgW2FicywgYXJnXVxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoZXBzID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgQGltYWcgIT0gMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIFJhdGlvbmFsXCJcbiAgICBlbmRcblxuICAgIHJlYWwucmF0aW9uYWxpemUoZXBzKVxuICBlbmRcblxuICBkZWYgcmVhbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgcmVjdFxuICAgIFtAcmVhbCwgQGltYWddXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgdW5sZXNzIEBpbWFnID09IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBGbG9hdFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19mXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgdW5sZXNzIEBpbWFnID09IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIFJhdGlvbmFsXCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX3JcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICByZXN1bHQgPSBAcmVhbC5pbnNwZWN0XG5cbiAgICByZXN1bHQgKz1cbiAgICAgIGlmICg6Ok51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHwgQGltYWcucG9zaXRpdmU/IHx8IEBpbWFnLnplcm8/XG4gICAgICAgICcrJ1xuICAgICAgZWxzZVxuICAgICAgICAnLSdcbiAgICAgIGVuZFxuXG4gICAgcmVzdWx0ICs9IEBpbWFnLmFicy5pbnNwZWN0XG5cbiAgICBpZiA6Ok51bWJlciA9PT0gQGltYWcgJiYgKEBpbWFnLm5hbj8gfHwgQGltYWcuaW5maW5pdGU/KVxuICAgICAgcmVzdWx0ICs9ICcqJ1xuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJ2knXG4gIGVuZFxuXG4gIEkgPSBuZXcoMCwgMSlcblxuICBkZWYgc2VsZi5mcm9tX3N0cmluZyhzdHIpXG4gICAgJXh7XG4gICAgICB2YXIgcmUgPSAvWystXT9bXFxkX10rKFxcLltcXGRfXSspPyhlXFxkKyk/LyxcbiAgICAgICAgICBtYXRjaCA9IHN0ci5tYXRjaChyZSksXG4gICAgICAgICAgcmVhbCwgaW1hZywgZGVub21pbmF0b3I7XG5cbiAgICAgIGZ1bmN0aW9uIGlzRmxvYXQoKSB7XG4gICAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGN1dEZsb2F0KCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmUpO1xuICAgICAgICB2YXIgbnVtYmVyID0gbWF0Y2hbMF07XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShudW1iZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG51bWJlci5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlcyBib3RoIGZsb2F0cyBhbmQgcmF0aW9uYWxzXG4gICAgICBmdW5jdGlvbiBjdXROdW1iZXIoKSB7XG4gICAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcblxuICAgICAgICAgIGlmIChzdHJbMF0gPT09ICcvJykge1xuICAgICAgICAgICAgLy8gcmF0aW9uYWwgcmVhbCBwYXJ0XG4gICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG5cbiAgICAgICAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYG51bWVyYXRvcmAsIGBkZW5vbWluYXRvcmApfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJldmVydGluZyAnLydcbiAgICAgICAgICAgICAgc3RyID0gJy8nICsgc3RyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVtZXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmbG9hdCByZWFsIHBhcnQsIG5vIGRlbm9taW5hdG9yXG4gICAgICAgICAgICByZXR1cm4gbnVtZXJhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWFsID0gY3V0TnVtYmVyKCk7XG5cbiAgICAgIGlmICghcmVhbCkge1xuICAgICAgICBpZiAoc3RyWzBdID09PSAnaScpIHtcbiAgICAgICAgICAvLyBpID0+IENvbXBsZXgoMCwgMSlcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KDAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyWzBdID09PSAnLScgJiYgc3RyWzFdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAtaSA9PiBDb21wbGV4KDAsIC0xKVxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgLTEpfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyWzBdID09PSAnKycgJiYgc3RyWzFdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAraSA9PiBDb21wbGV4KDAsIDEpXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCAxKX07XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW55dGhpbmcgPT4gQ29tcGxleCgwLCAwKVxuICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KDAsIDApfTtcbiAgICAgIH1cblxuICAgICAgaW1hZyA9IGN1dE51bWJlcigpO1xuICAgICAgaWYgKCFpbWFnKSB7XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICdpJykge1xuICAgICAgICAgIC8vIDNpID0+IENvbXBsZXgoMCwgMylcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KDAsIGByZWFsYCl9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDMgPT4gQ29tcGxleCgzLCAwKVxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoYHJlYWxgLCAwKX07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDMrMmkgPT4gQ29tcGxleCgzLCAyKVxuICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KGByZWFsYCwgYGltYWdgKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcbiAgYWxpYXMgY29uanVnYXRlIGNvbmpcbiAgYWxpYXMgZGl2aWRlIC9cbiAgYWxpYXMgaW1hZ2luYXJ5IGltYWdcbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuICBhbGlhcyBwaGFzZSBhcmdcbiAgYWxpYXMgcXVvIC9cbiAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuXG4gIHVuZGVmIG5lZ2F0aXZlP1xuICB1bmRlZiBwb3NpdGl2ZT9cbiAgdW5kZWYgc3RlcFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkNvbXBsZXg+IiwicmVjdCIsInJlYWwiLCJpbWFnIiwiMCIsIk51bWVyaWMiLCJyZWFsPyIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwibmV3IiwicG9sYXIiLCJyIiwidGhldGEiLCIqIiwiTWF0aCIsImNvcyIsInNpbiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkByZWFsIiwiQGltYWciLCJmcmVlemUiLCJjb2VyY2UiLCJvdGhlciIsIkNvbXBsZXgiLCJjbGFzcyIsIj09IiwiJHJldF9vcl8xIiwiLUAiLCIrIiwiX19jb2VyY2VkX18iLCItIiwiLyIsIk51bWJlciIsIm5hbj8iLCJGbG9hdDo6TkFOIiwiRmxvYXQiLCJjb25qIiwiYWJzMiIsInF1byIsIioqIiwiMSIsIm9yZSIsIm9pbSIsIm5yIiwiZXhwIiwibG9nIiwibnRoZXRhIiwiSW50ZWdlciIsIj4iLCJ4IiwieiIsIm4iLCJkaXZtb2QiLCIyIiwiZGl2IiwibW9kIiwiUmF0aW9uYWwiLCJhYnMiLCJoeXBvdCIsImFuZ2xlIiwiYXRhbjIiLCJkZW5vbWluYXRvciIsImxjbSIsImVxbD8iLCIkcmV0X29yXzIiLCI9PT0iLCJmZGl2IiwiZmluaXRlPyIsImhhc2giLCJpbmZpbml0ZT8iLCJpbnNwZWN0IiwibnVtZXJhdG9yIiwiZCIsImFyZyIsInJhdGlvbmFsaXplIiwiZXBzIiwiQXJndW1lbnRFcnJvciIsIlJhbmdlRXJyb3IiLCJ0b19mIiwidG9faSIsInRvX3IiLCJ0b19zIiwicmVzdWx0IiwicG9zaXRpdmU/IiwiemVybz8iLCJmcm9tX3N0cmluZyIsInN0ciIsIi0xIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixzQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsTUFBSUgsSUFBSkcsV0FBQUEsZ0JBQWNDLElBQUQsRUFBT0MsSUFBcEJGO0FBQUFBLE1BQUFBOzs7TUFBb0IseUJBQU9HO01BQ3pCLEtBQU8sQ0FBQSxDQUFBLENBQUEsUUFBQUMsY0FBQSxFQUFjSCxJQUFkLENBQUEsSUFBQSxDQUFBLFFBQXNCQSxJQUFJSSxVQUFBQSxDQUFBQSxDQUExQixDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsUUFBb0NELGNBQXBDLEVBQWtERixJQUFsRCxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsUUFBMERBLElBQUlHLFVBQUFBLENBQUFBLENBQTlELENBQUEsQ0FBQSxDQUFQO1FBQ0VDLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCUixZQUFwQk87TUFEVjtNQUlBUCxPQUFBSCxJQUFBWSxLQUFBQSxDQUFJUixJQUFKLEVBQVVDLElBQVZPO0lBTEZULENBQUFBLElBQUFBO0lBUUFVLE1BQUliLElBQUphLFlBQUFBLGlC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LFFBQU4sRUFBYSxHQUFiO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLEtBQWhCO0lBQ0EsYUFBTSxPQUFOLEVBQVksS0FBWjtJQUNBLGFBQU0sS0FBTixFQUFVLEdBQVY7SUFDQSxhQUFNLGFBQU4sRUFBa0IsTUFBbEI7O0lBRUEsc0JBQU0sV0FBTjs7SUFDQSxzQkFBTSxXQUFOOzs7SUFDQSxzQkFBTSxNQUFOO0lBM1dGRSxPQUFBO0VBR0FBLEdBQU0sSUFBTkEsRUFBa0JLLGNBQWxCTDtBQUhBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjE0OTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhdGlvbmFsL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIDo6S2VybmVsXG4gIGRlZiBSYXRpb25hbChudW1lcmF0b3IsIGRlbm9taW5hdG9yID0gMSlcbiAgICA6OlJhdGlvbmFsLmNvbnZlcnQobnVtZXJhdG9yLCBkZW5vbWluYXRvcilcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpTdHJpbmdcbiAgZGVmIHRvX3JcbiAgICA6OlJhdGlvbmFsLmZyb21fc3RyaW5nKHNlbGYpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsIlJhdGlvbmFsIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCIxIiwiY29udmVydCIsIjxjbGFzczpTdHJpbmc+IiwidG9fciIsImZyb21fc3RyaW5nIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUFBLHdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQztFQUFBQTs7O0lBQ0VBLE9BQUFDLHdCQUFBQSxvQkFBYUMsU0FBRCxFQUFZQyxXQUF4QkY7QUFBQUE7O01BQXdCLHVDQUFjRztNQUNwQ0gsT0FBQUEsZUFBVUksU0FBQUEsQ0FBU0gsU0FBbkIsRUFBOEJDLFdBQXBCRTtJQURaSixDQUFBQSxJQUFBQTtFQURGRCxHQUFPLElBQVBBO0VBTUFELE9BQUFPO0VBQUFBOzs7SUFDRUEsT0FBQUMsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQU4sZUFBVU8sYUFBQUEsQ0FBYUMsSUFBYkQ7SUFEWkQsQ0FBQUE7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQU5BUDsifX0seyJvZmZzZXQiOnsibGluZSI6MjE1MjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhdGlvbmFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcbnJlcXVpcmUgJ2NvcmVsaWIvcmF0aW9uYWwvYmFzZSdcblxuY2xhc3MgOjpSYXRpb25hbCA8IDo6TnVtZXJpY1xuICBkZWYgc2VsZi5yZWR1Y2UobnVtLCBkZW4pXG4gICAgbnVtID0gbnVtLnRvX2lcbiAgICBkZW4gPSBkZW4udG9faVxuXG4gICAgaWYgZGVuID09IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnXG4gICAgZWxzaWYgZGVuIDwgMFxuICAgICAgbnVtID0gLW51bVxuICAgICAgZGVuID0gLWRlblxuICAgIGVsc2lmIGRlbiA9PSAxXG4gICAgICByZXR1cm4gbmV3KG51bSwgZGVuKVxuICAgIGVuZFxuXG4gICAgZ2NkID0gbnVtLmdjZChkZW4pXG5cbiAgICBuZXcobnVtIC8gZ2NkLCBkZW4gLyBnY2QpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnZlcnQobnVtLCBkZW4pXG4gICAgaWYgbnVtLm5pbD8gfHwgZGVuLm5pbD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgbmlsIGludG8gUmF0aW9uYWwnXG4gICAgZW5kXG5cbiAgICBpZiA6OkludGVnZXIgPT09IG51bSAmJiA6OkludGVnZXIgPT09IGRlblxuICAgICAgcmV0dXJuIHJlZHVjZShudW0sIGRlbilcbiAgICBlbmRcblxuICAgIGlmIDo6RmxvYXQgPT09IG51bSB8fCA6OlN0cmluZyA9PT0gbnVtIHx8IDo6Q29tcGxleCA9PT0gbnVtXG4gICAgICBudW0gPSBudW0udG9fclxuICAgIGVuZFxuXG4gICAgaWYgOjpGbG9hdCA9PT0gZGVuIHx8IDo6U3RyaW5nID09PSBkZW4gfHwgOjpDb21wbGV4ID09PSBkZW5cbiAgICAgIGRlbiA9IGRlbi50b19yXG4gICAgZW5kXG5cbiAgICBpZiBkZW4uZXF1YWw/KDEpICYmICEoOjpJbnRlZ2VyID09PSBudW0pXG4gICAgICA6Ok9wYWwuY29lcmNlX3RvIShudW0sIDo6UmF0aW9uYWwsIDp0b19yKVxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gbnVtICYmIDo6TnVtZXJpYyA9PT0gZGVuXG4gICAgICBudW0gLyBkZW5cbiAgICBlbHNlXG4gICAgICByZWR1Y2UobnVtLCBkZW4pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKG51bSwgZGVuKVxuICAgIEBudW0gPSBudW1cbiAgICBAZGVuID0gZGVuXG4gICAgZnJlZXplXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBAbnVtXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIEBkZW5cbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBbb3RoZXIsIHNlbGZdXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgW290aGVyLnRvX3IsIHNlbGZdXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIFtvdGhlciwgdG9fZl1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIEBudW0gPT0gb3RoZXIubnVtZXJhdG9yICYmIEBkZW4gPT0gb3RoZXIuZGVub21pbmF0b3JcblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICBAbnVtID09IG90aGVyICYmIEBkZW4gPT0gMVxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mID09IG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBvdGhlciA9PSBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgQG51bSAqIG90aGVyLmRlbm9taW5hdG9yIC0gQGRlbiAqIG90aGVyLm51bWVyYXRvciA8PT4gMFxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIEBudW0gLSBAZGVuICogb3RoZXIgPD0+IDBcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiA8PT4gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDo8PT4sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvciArIEBkZW4gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtICsgb3RoZXIgKiBAZGVuLCBAZGVuKVxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mICsgb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDorLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgLSBAZGVuICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSAtIG90aGVyICogQGRlbiwgQGRlbilcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiAtIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6LSwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0gKiBvdGhlciwgQGRlbilcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiAqIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIubnVtZXJhdG9yXG5cbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgdG9fZiAvIDAuMFxuICAgICAgZWxzZVxuICAgICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtLCBAZGVuICogb3RoZXIpXG4gICAgICBlbmRcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiAvIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Lywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgaWYgc2VsZiA9PSAwICYmIG90aGVyIDwgMFxuICAgICAgICA6OkZsb2F0OjpJTkZJTklUWVxuICAgICAgZWxzaWYgb3RoZXIgPiAwXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0qKm90aGVyLCBAZGVuKipvdGhlcilcbiAgICAgIGVsc2lmIG90aGVyIDwgMFxuICAgICAgICA6Oktlcm5lbC5SYXRpb25hbChAZGVuKiotb3RoZXIsIEBudW0qKi1vdGhlcilcbiAgICAgIGVsc2VcbiAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVuZFxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mKipvdGhlclxuXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBpZiBvdGhlciA9PSAwXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKDEsIDEpXG4gICAgICBlbHNpZiBvdGhlci5kZW5vbWluYXRvciA9PSAxXG4gICAgICAgIGlmIG90aGVyIDwgMFxuICAgICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBkZW4qKm90aGVyLm51bWVyYXRvci5hYnMsIEBudW0qKm90aGVyLm51bWVyYXRvci5hYnMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtKipvdGhlci5udW1lcmF0b3IsIEBkZW4qKm90aGVyLm51bWVyYXRvcilcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBzZWxmID09IDAgJiYgb3RoZXIgPCAwXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnXG4gICAgICBlbHNlXG4gICAgICAgIHRvX2YqKm90aGVyXG4gICAgICBlbmRcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0uYWJzLCBAZGVuLmFicylcbiAgZW5kXG5cbiAgZGVmIGNlaWwocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuY2VpbFxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDpjZWlsLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBmbG9vcihwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICAoLSgtQG51bSAvIEBkZW4pKS5mbG9vclxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDpmbG9vciwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFwiUmF0aW9uYWw6I3tAbnVtfToje0BkZW59XCJcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIigje3NlbGZ9KVwiXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVwcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZSA9ICN7ZXBzLmFic30sXG4gICAgICAgICAgYSA9ICN7c2VsZiAtIGBlYH0sXG4gICAgICAgICAgYiA9ICN7c2VsZiArIGBlYH07XG5cbiAgICAgIHZhciBwMCA9IDAsXG4gICAgICAgICAgcDEgPSAxLFxuICAgICAgICAgIHEwID0gMSxcbiAgICAgICAgICBxMSA9IDAsXG4gICAgICAgICAgcDIsIHEyO1xuXG4gICAgICB2YXIgYywgaywgdDtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgYyA9ICN7YGFgLmNlaWx9O1xuXG4gICAgICAgIGlmICgje2BjYCA8PSBgYmB9KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBrICA9IGMgLSAxO1xuICAgICAgICBwMiA9IGsgKiBwMSArIHAwO1xuICAgICAgICBxMiA9IGsgKiBxMSArIHEwO1xuICAgICAgICB0ICA9ICN7MSAvIChgYmAgLSBga2ApfTtcbiAgICAgICAgYiAgPSAjezEgLyAoYGFgIC0gYGtgKX07XG4gICAgICAgIGEgID0gdDtcblxuICAgICAgICBwMCA9IHAxO1xuICAgICAgICBxMCA9IHExO1xuICAgICAgICBwMSA9IHAyO1xuICAgICAgICBxMSA9IHEyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgYyAqIHAxICsgcDBgLCBgYyAqIHExICsgcTBgKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcm91bmQocHJlY2lzaW9uID0gMClcbiAgICByZXR1cm4gd2l0aF9wcmVjaXNpb24oOnJvdW5kLCBwcmVjaXNpb24pIHVubGVzcyBwcmVjaXNpb24gPT0gMFxuICAgIHJldHVybiAwIGlmIEBudW0gPT0gMFxuICAgIHJldHVybiBAbnVtIGlmIEBkZW4gPT0gMVxuXG4gICAgbnVtID0gQG51bS5hYnMgKiAyICsgQGRlblxuICAgIGRlbiA9IEBkZW4gKiAyXG5cbiAgICBhcHByb3ggPSAobnVtIC8gZGVuKS50cnVuY2F0ZVxuXG4gICAgaWYgQG51bSA8IDBcbiAgICAgIC1hcHByb3hcbiAgICBlbHNlXG4gICAgICBhcHByb3hcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICBAbnVtIC8gQGRlblxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIHRydW5jYXRlXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIFwiI3tAbnVtfS8je0BkZW59XCJcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgIEBudW0gPCAwID8gY2VpbCA6IGZsb29yXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOnRydW5jYXRlLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB3aXRoX3ByZWNpc2lvbihtZXRob2QsIHByZWNpc2lvbilcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vdCBhbiBJbnRlZ2VyJyB1bmxlc3MgOjpJbnRlZ2VyID09PSBwcmVjaXNpb25cblxuICAgIHAgPSAxMCoqcHJlY2lzaW9uXG4gICAgcyA9IHNlbGYgKiBwXG5cbiAgICBpZiBwcmVjaXNpb24gPCAxXG4gICAgICAocy5zZW5kKG1ldGhvZCkgLyBwKS50b19pXG4gICAgZWxzZVxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwocy5zZW5kKG1ldGhvZCksIHApXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZyb21fc3RyaW5nKHN0cmluZylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzdHJpbmcudHJpbUxlZnQoKSxcbiAgICAgICAgICByZSA9IC9eWystXT9bXFxkX10rKFxcLltcXGRfXSspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG5cbiAgICAgIGZ1bmN0aW9uIGlzRmxvYXQoKSB7XG4gICAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGN1dEZsb2F0KCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmUpO1xuICAgICAgICB2YXIgbnVtYmVyID0gbWF0Y2hbMF07XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShudW1iZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG51bWJlci5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuXG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcvJykge1xuICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcblxuICAgICAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcbiAgICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKDAsIDEpfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGRpdmlkZSAvXG4gIGFsaWFzIHF1byAvXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UmF0aW9uYWw+IiwicmVkdWNlIiwibnVtIiwiZGVuIiwidG9faSIsIjAiLCJLZXJuZWwiLCJyYWlzZSIsIlplcm9EaXZpc2lvbkVycm9yIiwiPCIsIi1AIiwiMSIsIm5ldyIsImdjZCIsIi8iLCJjb252ZXJ0IiwibmlsPyIsIlR5cGVFcnJvciIsIkludGVnZXIiLCJGbG9hdCIsIlN0cmluZyIsIkNvbXBsZXgiLCJ0b19yIiwiZXF1YWw/IiwiPT09IiwiT3BhbCIsImNvZXJjZV90byEiLCJSYXRpb25hbCIsIk51bWVyaWMiLCJpbml0aWFsaXplIiwiQG51bSIsIkBkZW4iLCJmcmVlemUiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImNvZXJjZSIsIm90aGVyIiwiJHJldF9vcl8xIiwidG9fZiIsIj09IiwiJHJldF9vcl8yIiwiPD0+IiwiLSIsIioiLCJfX2NvZXJjZWRfXyIsIisiLCIqKiIsIkZsb2F0OjpJTkZJTklUWSIsIj4iLCJhYnMiLCJjZWlsIiwicHJlY2lzaW9uIiwid2l0aF9wcmVjaXNpb24iLCJmbG9vciIsImhhc2giLCJpbnNwZWN0IiwicmF0aW9uYWxpemUiLCJlcHMiLCJBcmd1bWVudEVycm9yIiwiPD0iLCJyb3VuZCIsIjIiLCJhcHByb3giLCJ0cnVuY2F0ZSIsInRvX3MiLCJtZXRob2QiLCJwIiwiMTAiLCJzIiwic2VuZCIsImZyb21fc3RyaW5nIiwic3RyaW5nIl0sIm1hcHBpbmdzIjoiQUFBQUEsbUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix1QkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsTUFBSUgsSUFBSkcsYUFBQUEsa0JBQWdCQyxHQUFELEVBQU1DLEdBQXJCRjtBQUFBQSxNQUFBQTs7O01BQ0VDLE1BQU1BLEdBQUdFLE1BQUFBLENBQUFBO01BQ1RELE1BQU1BLEdBQUdDLE1BQUFBLENBQUFBO01BRVQsSUFBQSxNQUFHRCxHQUFILEVBQVVFLENBQVYsQ0FBQTtRQUNFQyxPQUFRQyxPQUFBQSxDQUFPQyx3QkFBZixFQUFvQ1AsY0FBNUJNO01BRFYsT0FFQSxJQUFBLFFBQVVFLE9BQUpOLEdBQUlNLEVBQUVKLENBQUZJLENBQVYsQ0FBQTs7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O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsbUJBQXFCaEUsT0FBUXFCLFVBQUFBLENBQVcyQyxTQUFuQixFQUFnQ0EsV0FBeEIzQyxDQUFzQzJDO0FBQ25FQTtBQUNBQSxtQkFBcUJoRSxPQUFRcUIsVUFBQUEsQ0FBVzJDLFNBQW5CLEVBQStCM0QsQ0FBdkJnQixDQUEwQjJDO0FBQ3ZEQTtBQUNBQTtBQUNBQSxpQkFBbUJoRSxPQUFRcUIsVUFBQUEsQ0FBVzJDLFNBQW5CLEVBQStCM0QsQ0FBdkJnQixDQUEwQjJDO0FBQ3JEQTtBQUNBQTtBQUNBQSxlQUFpQmhFLE9BQVFxQixVQUFBQSxDQUFVdEIsQ0FBbEIsRUFBcUJNLENBQWJnQixDQUFnQjJDO0FBQ3pDQTtBQUNBQTtJQXJDRUEsQ0FBQUE7SUF3Q0EsYUFBTSxRQUFOLEVBQWEsR0FBYjtJQUNBdEUsT0FBQSxhQUFNLEtBQU4sRUFBVSxHQUFWO0VBcllGQSxHQUFNLElBQU5BLEVBQW1CNEIsY0FBbkI1QjtBQUhBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjE5NTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3RpbWUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZSwgZGVueV9mcm96ZW5fYWNjZXNzXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgOjpUaW1lIDwgYERhdGVgXG4gIGluY2x1ZGUgOjpDb21wYXJhYmxlXG5cbiAgJXh7XG4gICAgdmFyIGRheXNfb2Zfd2VlayA9ICN7JXdbU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXkgU3VuZGF5XX0sXG4gICAgICAgIHNob3J0X2RheXMgICA9ICN7JXdbU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0XX0sXG4gICAgICAgIHNob3J0X21vbnRocyA9ICN7JXdbSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNdfSxcbiAgICAgICAgbG9uZ19tb250aHMgID0gI3sld1tKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXX07XG4gIH1cblxuICBkZWYgc2VsZi5hdChzZWNvbmRzLCBmcmFjID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKCN7OjpUaW1lID09PSBzZWNvbmRzfSkge1xuICAgICAgICBpZiAoZnJhYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IFRpbWUgaW50byBhbiBleGFjdCBudW1iZXJcIn1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBuZXcgRGF0ZShzZWNvbmRzLmdldFRpbWUoKSk7XG4gICAgICAgIHJlc3VsdC50aW1lem9uZSA9IHNlY29uZHMudGltZXpvbmU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2Vjb25kcy4kJGlzX251bWJlcikge1xuICAgICAgICBzZWNvbmRzID0gI3s6Ok9wYWwuY29lcmNlX3RvIShzZWNvbmRzLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyYWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgZnJhYyA9ICN7OjpPcGFsLmNvZXJjZV90byEoZnJhYywgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZShzZWNvbmRzICogMTAwMCArIChmcmFjIC8gMTAwMCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpIHtcbiAgICAgIGlmICh5ZWFyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHllYXIgPSBwYXJzZUludCh5ZWFyLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ZWFyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgeWVhcmAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPT09IG5pbCkge1xuICAgICAgICBtb250aCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFtb250aC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoI3tgbW9udGhgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgIG1vbnRoID0gI3tgbW9udGhgLnRvX3N0cn07XG4gICAgICAgICAgc3dpdGNoIChtb250aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnamFuJzogbW9udGggPSAgMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZmViJzogbW9udGggPSAgMjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWFyJzogbW9udGggPSAgMzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXByJzogbW9udGggPSAgNDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF5JzogbW9udGggPSAgNTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVuJzogbW9udGggPSAgNjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVsJzogbW9udGggPSAgNzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXVnJzogbW9udGggPSAgODsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VwJzogbW9udGggPSAgOTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb2N0JzogbW9udGggPSAxMDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbm92JzogbW9udGggPSAxMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGVjJzogbW9udGggPSAxMjsgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogbW9udGggPSAje2Btb250aGAudG9faX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vbnRoID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgbW9udGhgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibW9udGggb3V0IG9mIHJhbmdlOiAje2Btb250aGB9XCJ9XG4gICAgICB9XG4gICAgICBtb250aCA9IG1vbnRoIC0gMTtcblxuICAgICAgaWYgKGRheSA9PT0gbmlsKSB7XG4gICAgICAgIGRheSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGRheS4kJGlzX3N0cmluZykge1xuICAgICAgICBkYXkgPSBwYXJzZUludChkYXksIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRheSA9ICN7OjpPcGFsLmNvZXJjZV90byEoYGRheWAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF5IDwgMSB8fCBkYXkgPiAzMSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJkYXkgb3V0IG9mIHJhbmdlOiAje2BkYXlgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA9PT0gbmlsKSB7XG4gICAgICAgIGhvdXIgPSAwO1xuICAgICAgfSBlbHNlIGlmIChob3VyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGhvdXIgPSBwYXJzZUludChob3VyLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3VyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgaG91cmAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA8IDAgfHwgaG91ciA+IDI0KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImhvdXIgb3V0IG9mIHJhbmdlOiAje2Bob3VyYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA9PT0gbmlsKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1pbi4kJGlzX3N0cmluZykge1xuICAgICAgICBtaW4gPSBwYXJzZUludChtaW4sIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbiA9ICN7OjpPcGFsLmNvZXJjZV90byEoYG1pbmAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobWluIDwgMCB8fCBtaW4gPiA1OSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJtaW4gb3V0IG9mIHJhbmdlOiAje2BtaW5gfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VjID09PSBuaWwpIHtcbiAgICAgICAgc2VjID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoIXNlYy4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoc2VjLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgc2VjID0gcGFyc2VJbnQoc2VjLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VjID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgc2VjYCwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA8IDAgfHwgc2VjID4gNjApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic2VjIG91dCBvZiByYW5nZTogI3tgc2VjYH1cIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlY107XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYubmV3KHllYXIgPSB1bmRlZmluZWQsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCB1dGNfb2Zmc2V0ID0gbmlsKVxuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdCwgdGltZXpvbmUsIHV0Y19kYXRlO1xuXG4gICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgaWYgKHV0Y19vZmZzZXQgPT09IG5pbCkge1xuICAgICAgICByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApO1xuICAgICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB0aW1lem9uZSA9ICN7X3BhcnNlX29mZnNldCh1dGNfb2Zmc2V0KX07XG4gICAgICB1dGNfZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCkpO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgdXRjX2RhdGUuc2V0VVRDRnVsbFllYXIoeWVhcik7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHV0Y19kYXRlLmdldFRpbWUoKSAtIHRpbWV6b25lICogMzYwMDAwMCk7XG4gICAgICByZXN1bHQudGltZXpvbmUgPSB0aW1lem9uZTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIHNlbGYuX3BhcnNlX29mZnNldCh1dGNfb2Zmc2V0KVxuICAgICV4e1xuICAgICAgdmFyIHRpbWV6b25lO1xuICAgICAgaWYgKHV0Y19vZmZzZXQuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKHV0Y19vZmZzZXQgPT0gJ1VUQycpIHtcbiAgICAgICAgICB0aW1lem9uZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZigvXlsrLV1cXGRcXGQ6WzAtNV1cXGQkLy50ZXN0KHV0Y19vZmZzZXQpKSB7XG4gICAgICAgICAgdmFyIHNpZ24sIGhvdXJzLCBtaW51dGVzO1xuICAgICAgICAgIHNpZ24gPSB1dGNfb2Zmc2V0WzBdO1xuICAgICAgICAgIGhvdXJzID0gKyh1dGNfb2Zmc2V0WzFdICsgdXRjX29mZnNldFsyXSk7XG4gICAgICAgICAgbWludXRlcyA9ICsodXRjX29mZnNldFs0XSArIHV0Y19vZmZzZXRbNV0pO1xuXG4gICAgICAgICAgdGltZXpvbmUgPSAoc2lnbiA9PSAnLScgPyAtMSA6IDEpICogKGhvdXJzICsgbWludXRlcyAvIDYwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBVbnN1cHBvcnRlZDogXCJBXCIuLlwiSVwiLFwiS1wiLi5cIlpcIlxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAlJ1wiK0hIOk1NXCIsIFwiLUhIOk1NXCIsIFwiVVRDXCIgZXhwZWN0ZWQgZm9yIHV0Y19vZmZzZXQ6ICN7dXRjX29mZnNldH0nfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh1dGNfb2Zmc2V0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHRpbWV6b25lID0gdXRjX29mZnNldCAvIDM2MDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiT3BhbCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgdHlwZXMgZm9yIGEgdGltZXpvbmUgYXJndW1lbnQgdGhhbiBJbnRlZ2VyIGFuZCBTdHJpbmdcIn1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1lem9uZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmxvY2FsKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGFyZ3MgID0gJHNsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdtKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGFyZ3MgID0gJHNsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRVVENGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubm93XG4gICAgbmV3XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGlmIDo6VGltZSA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndGltZSArIHRpbWU/J1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIG90aGVyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAob3RoZXIgKiAxMDAwKSk7XG4gICAgICByZXN1bHQudGltZXpvbmUgPSBzZWxmLnRpbWV6b25lO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGlmIDo6VGltZSA9PT0gb3RoZXJcbiAgICAgIHJldHVybiBgKHNlbGYuZ2V0VGltZSgpIC0gb3RoZXIuZ2V0VGltZSgpKSAvIDEwMDBgXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAjezo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSAtIChvdGhlciAqIDEwMDApKTtcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IHNlbGYudGltZXpvbmU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiA6OlRpbWUgPT09IG90aGVyXG4gICAgICB0b19mIDw9PiBvdGhlci50b19mXG4gICAgZWxzZVxuICAgICAgciA9IG90aGVyIDw9PiBzZWxmXG4gICAgICBpZiByLm5pbD9cbiAgICAgICAgbmlsXG4gICAgICBlbHNpZiByID4gMFxuICAgICAgICAtMVxuICAgICAgZWxzaWYgciA8IDBcbiAgICAgICAgMVxuICAgICAgZWxzZVxuICAgICAgICAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIDo6VGltZSA9PT0gb3RoZXIgJiYgYCN7dG9fZn0gPT09ICN7b3RoZXIudG9fZn1gXG4gIGVuZFxuXG4gIGRlZiBhc2N0aW1lXG4gICAgc3RyZnRpbWUgJyVhICViICVlICVIOiVNOiVTICVZJ1xuICBlbmRcblxuICBbXG4gICAgWzp5ZWFyLCAnZ2V0RnVsbFllYXInLCAnZ2V0VVRDRnVsbFllYXInXSxcbiAgICBbOm1vbiwgJ2dldE1vbnRoJywgJ2dldFVUQ01vbnRoJywgMV0sXG4gICAgWzp3ZGF5LCAnZ2V0RGF5JywgJ2dldFVUQ0RheSddLFxuICAgIFs6ZGF5LCAnZ2V0RGF0ZScsICdnZXRVVENEYXRlJ10sXG4gICAgWzpob3VyLCAnZ2V0SG91cnMnLCAnZ2V0VVRDSG91cnMnXSxcbiAgICBbOm1pbiwgJ2dldE1pbnV0ZXMnLCAnZ2V0VVRDTWludXRlcyddLFxuICAgIFs6c2VjLCAnZ2V0U2Vjb25kcycsICdnZXRVVENTZWNvbmRzJ10sXG4gIF0uZWFjaCBkbyB8bWV0aG9kLCBnZXR0ZXIsIHV0Y2dldHRlciwgZGlmZmVyZW5jZSA9IDB8XG4gICAgZGVmaW5lX21ldGhvZCBtZXRob2QgZG9cbiAgICAgICV4e1xuICAgICAgICByZXR1cm4gZGlmZmVyZW5jZSArICgoc2VsZi50aW1lem9uZSAhPSBudWxsKSA/XG4gICAgICAgICAgKG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpICsgc2VsZi50aW1lem9uZSAqIDM2MDAwMDApKVt1dGNnZXR0ZXJdKCkgOlxuICAgICAgICAgIHNlbGZbZ2V0dGVyXSgpKVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgeWRheVxuICAgICMgaHR0cDovL2phdmFzY3JpcHQuYWJvdXQuY29tL2xpYnJhcnkvYmxkYXl5ZWFyLmh0bVxuICAgICMgYWxzbyBzZWUgbW9tZW50LmpzIGltcGxlbWVudGF0aW9uOiBodHRwOi8vZ2l0LmlvL3ZDS05FXG5cbiAgICBzdGFydF9vZl95ZWFyID0gVGltZS5uZXcoeWVhcikudG9faVxuICAgIHN0YXJ0X29mX2RheSAgPSBUaW1lLm5ldyh5ZWFyLCBtb250aCwgZGF5KS50b19pXG4gICAgb25lX2RheSAgICAgICA9IDg2XzQwMFxuXG4gICAgKChzdGFydF9vZl9kYXkgLSBzdGFydF9vZl95ZWFyKSAvIG9uZV9kYXkpLnJvdW5kICsgMVxuICBlbmRcblxuICBkZWYgaXNkc3RcbiAgICAleHtcbiAgICAgIHZhciBqYW4gPSBuZXcgRGF0ZShzZWxmLmdldEZ1bGxZZWFyKCksIDAsIDEpLFxuICAgICAgICAgIGp1bCA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gICAgICByZXR1cm4gc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpIDwgTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gYG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKWBcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIG90aGVyLmlzX2E/KDo6VGltZSkgJiYgKHNlbGYgPD0+IG90aGVyKS56ZXJvP1xuICBlbmRcblxuICBbXG4gICAgWzpzdW5kYXk/LCAwXSxcbiAgICBbOm1vbmRheT8sIDFdLFxuICAgIFs6dHVlc2RheT8sIDJdLFxuICAgIFs6d2VkbmVzZGF5PywgM10sXG4gICAgWzp0aHVyc2RheT8sIDRdLFxuICAgIFs6ZnJpZGF5PywgNV0sXG4gICAgWzpzYXR1cmRheT8sIDZdXG4gIF0uZWFjaCBkbyB8bWV0aG9kLCB3ZWVrZGF5fFxuICAgIGRlZmluZV9tZXRob2QgbWV0aG9kIGRvXG4gICAgICBgI3t3ZGF5fSA9PT0gd2Vla2RheWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBgJ1RpbWU6JyArIHNlbGYuZ2V0VGltZSgpYFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGlmIHV0Yz9cbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyBVVEMnXG4gICAgZWxzZVxuICAgICAgc3RyZnRpbWUgJyVZLSVtLSVkICVIOiVNOiVTICV6J1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc3VjY1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpICsgMTAwMCk7XG4gICAgICByZXN1bHQudGltZXpvbmUgPSBzZWxmLnRpbWV6b25lO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1c2VjXG4gICAgYHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwYFxuICBlbmRcblxuICBkZWYgem9uZVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudGltZXpvbmUgPT09IDApIHJldHVybiBcIlVUQ1wiO1xuICAgICAgZWxzZSBpZiAoc2VsZi50aW1lem9uZSAhPSBudWxsKSByZXR1cm4gbmlsO1xuXG4gICAgICB2YXIgc3RyaW5nID0gc2VsZi50b1N0cmluZygpLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcoJykgPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKC9bQS1aXXszLDR9LylbMF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKC9cXCgoLispXFwpKD86XFxzfCQpLylbMV1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCA9PSBcIkdNVFwiICYmIC8oR01UXFxXKlxcZHs0fSkvLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gUmVnRXhwLiQxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2V0Z21cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSk7XG4gICAgICByZXN1bHQudGltZXpvbmUgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnbXRpbWVcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLnRpbWV6b25lICE9PSAwKSB7XG4gICAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG4gICAgICAgIHNlbGYudGltZXpvbmUgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ210P1xuICAgIGBzZWxmLnRpbWV6b25lID09PSAwYFxuICBlbmRcblxuICBkZWYgZ210X29mZnNldFxuICAgIGAoc2VsZi50aW1lem9uZSAhPSBudWxsKSA/IHNlbGYudGltZXpvbmUgKiA2MCA6IC1zZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MGBcbiAgZW5kXG5cbiAgZGVmIHN0cmZ0aW1lKGZvcm1hdClcbiAgICAleHtcbiAgICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJShbXFwtXyNeMF0qOnswLDJ9KShcXGQrKT8oW0VPXSopKC4pL2csIGZ1bmN0aW9uKGZ1bGwsIGZsYWdzLCB3aWR0aCwgXywgY29udikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIiwgamQsIGMsIHMsXG4gICAgICAgICAgICB6ZXJvICAgPSBmbGFncy5pbmRleE9mKCcwJykgIT09IC0xLFxuICAgICAgICAgICAgcGFkICAgID0gZmxhZ3MuaW5kZXhPZignLScpID09PSAtMSxcbiAgICAgICAgICAgIGJsYW5rICA9IGZsYWdzLmluZGV4T2YoJ18nKSAhPT0gLTEsXG4gICAgICAgICAgICB1cGNhc2UgPSBmbGFncy5pbmRleE9mKCdeJykgIT09IC0xLFxuICAgICAgICAgICAgaW52ZXJ0ID0gZmxhZ3MuaW5kZXhPZignIycpICE9PSAtMSxcbiAgICAgICAgICAgIGNvbG9ucyA9IChmbGFncy5tYXRjaCgnOicpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICAgICAgd2lkdGggPSBwYXJzZUludCh3aWR0aCwgMTApO1xuXG4gICAgICAgIGlmICh6ZXJvICYmIGJsYW5rKSB7XG4gICAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJzAnKSA8IGZsYWdzLmluZGV4T2YoJ18nKSkge1xuICAgICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsYW5rID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjb252KSB7XG4gICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZWFyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGgucm91bmQoI3t5ZWFyfSAvIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t5ZWFyfSAlIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21vbn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgcmVzdWx0ICs9IGxvbmdfbW9udGhzWyN7bW9ufSAtIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFua1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm9cbiAgICAgICAgICAgIHJlc3VsdCArPSAje2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gJSAxMiB8fCAxMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ID49IDEyID8gXCJwbVwiIDogXCJhbVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3ttaW59O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzZWN9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gOSA6IHdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7YHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKWAucmp1c3QoMywgJzAnKX07XG4gICAgICAgICAgICByZXN1bHQgID0gI3tgcmVzdWx0YC5sanVzdChgd2lkdGhgLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ICA9IChzZWxmLnRpbWV6b25lID09IG51bGwpID8gc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpIDogKC1zZWxmLnRpbWV6b25lICogNjApLFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZnNldCkgLyA2MCksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguYWJzKG9mZnNldCkgJSA2MDtcblxuICAgICAgICAgICAgcmVzdWx0ICs9IG9mZnNldCA8IDAgPyBcIitcIiA6IFwiLVwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gaG91cnM7XG5cbiAgICAgICAgICAgIGlmIChjb2xvbnMgPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIjpcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ICs9IG1pbnV0ZXMgPCAxMCA/IFwiMFwiIDogXCJcIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBtaW51dGVzO1xuXG4gICAgICAgICAgICBpZiAoY29sb25zID4gMSkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI6MDBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3pvbmV9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBkYXlzX29mX3dlZWtbI3t3ZGF5fV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X2RheXNbI3t3ZGF5fV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3dkYXl9ICsgMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7d2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMF0udG9fcy5yanVzdCgyLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclsxXX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV1bLTIuLi0xXX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7dG9faX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx0XCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJVwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclYSAlYiAlZSAlVCAlWScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJW0vJWQvJXknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVZLSVtLSVkJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclZS0lXmItJTRZJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSTolTTolUyAlcCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUg6JU0nKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNOiVTJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBOb24tc3RhbmRhcmQ6IEpJUyBYIDAzMDEgZGF0ZSBmb3JtYXRcbiAgICAgICAgICBjYXNlICdKJzpcbiAgICAgICAgICAgIGpkID0gI3t0b19kYXRlLmpkfTtcbiAgICAgICAgICAgIGlmIChqZCA8IDI0MDUxNjApIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVZLSVtLSVkJyl9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGpkIDwgMjQxOTYxNClcbiAgICAgICAgICAgICAgYyA9ICdNJywgcyA9IDE4Njc7XG4gICAgICAgICAgICBlbHNlIGlmIChqZCA8IDI0MjQ4NzUpXG4gICAgICAgICAgICAgIGMgPSAnVCcsIHMgPSAxOTExO1xuICAgICAgICAgICAgZWxzZSBpZiAoamQgPCAyNDQ3NTM1KVxuICAgICAgICAgICAgICBjID0gJ1MnLCBzID0gMTkyNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGpkIDwgMjQ1ODYwNSlcbiAgICAgICAgICAgICAgYyA9ICdIJywgcyA9IDE5ODg7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGMgPSAnUicsIHMgPSAyMDE4O1xuXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tmb3JtYXQgJyVjJTAyZCcsIGBjYCwgeWVhciAtIGBzYH07XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnLSVtLSVkJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBjYXNlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1tBLVpdLywgZnVuY3Rpb24oYykgeyBjLnRvTG93ZXJDYXNlKCkgfSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UoL1thLXpdLywgZnVuY3Rpb24oYykgeyBjLnRvVXBwZXJDYXNlKCkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFkICYmICh6ZXJvIHx8IGJsYW5rKSkge1xuICAgICAgICAgIHJlc3VsdCA9ICN7YHJlc3VsdGAucmp1c3QoYGlzTmFOKHdpZHRoKSA/IDIgOiB3aWR0aGAsIGBibGFuayA/IFwiIFwiIDogXCIwXCJgKX07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIFtzZWMsIG1pbiwgaG91ciwgZGF5LCBtb250aCwgeWVhciwgd2RheSwgeWRheSwgaXNkc3QsIHpvbmVdXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgYHNlbGYuZ2V0VGltZSgpIC8gMTAwMGBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICBgcGFyc2VJbnQoc2VsZi5nZXRUaW1lKCkgLyAxMDAwLCAxMClgXG4gIGVuZFxuXG4gIGRlZiBjd2Vla19jeWVhclxuICAgIGphbjAxID0gOjpUaW1lLm5ldyh5ZWFyLCAxLCAxKVxuICAgIGphbjAxX3dkYXkgPSBqYW4wMS53ZGF5XG4gICAgZmlyc3RfbW9uZGF5ID0gMFxuICAgIHllYXIgPSBzZWxmLnllYXJcbiAgICBpZiBqYW4wMV93ZGF5IDw9IDQgJiYgamFuMDFfd2RheSAhPSAwXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhclxuICAgICAgb2Zmc2V0ID0gamFuMDFfd2RheSAtIDFcbiAgICBlbHNlXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgbGFzdCB3ZWVrIG9mIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICBvZmZzZXQgPSBqYW4wMV93ZGF5IC0gNyAtIDFcbiAgICAgIG9mZnNldCA9IC0xIGlmIG9mZnNldCA9PSAtOCAjIEFkanVzdCBpZiBKYW4gMDEgaXMgYSBTdW5kYXlcbiAgICBlbmRcblxuICAgIHdlZWsgPSAoKHlkYXkgKyBvZmZzZXQpIC8gNy4wMCkuY2VpbFxuXG4gICAgaWYgd2VlayA8PSAwXG4gICAgICAjIEdldCB0aGUgbGFzdCB3ZWVrIG9mIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICByZXR1cm4gOjpUaW1lLm5ldyhzZWxmLnllYXIgLSAxLCAxMiwgMzEpLmN3ZWVrX2N5ZWFyXG4gICAgZWxzaWYgd2VlayA9PSA1M1xuICAgICAgIyBGaW5kIG91dCB3aGV0aGVyIHRoaXMgaXMgYWN0dWFsbHkgd2VlayA1MyBvciBhbHJlYWR5IHdlZWsgMDEgb2YgdGhlIGZvbGxvd2luZyB5ZWFyXG4gICAgICBkZWMzMSA9IDo6VGltZS5uZXcoc2VsZi55ZWFyLCAxMiwgMzEpXG4gICAgICBkZWMzMV93ZGF5ID0gZGVjMzEud2RheVxuICAgICAgaWYgZGVjMzFfd2RheSA8PSAzICYmIGRlYzMxX3dkYXkgIT0gMFxuICAgICAgICB3ZWVrID0gMVxuICAgICAgICB5ZWFyICs9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgW3dlZWssIHllYXJdXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyBta3RpbWUgbG9jYWxcbiAgICBhbGlhcyB1dGMgZ21cbiAgZW5kXG5cbiAgYWxpYXMgY3RpbWUgYXNjdGltZVxuICBhbGlhcyBkc3Q/IGlzZHN0XG4gIGFsaWFzIGdldHV0YyBnZXRnbVxuICBhbGlhcyBnbXRvZmYgZ210X29mZnNldFxuICBhbGlhcyBtZGF5IGRheVxuICBhbGlhcyBtb250aCBtb25cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG4gIGFsaWFzIHR2X3NlYyB0b19pXG4gIGFsaWFzIHR2X3VzZWMgdXNlY1xuICBhbGlhcyB1dGMgZ210aW1lXG4gIGFsaWFzIHV0Yz8gZ210P1xuICBhbGlhcyB1dGNfb2Zmc2V0IGdtdF9vZmZzZXRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpUaW1lPiIsImluY2x1ZGUiLCJDb21wYXJhYmxlIiwiYXQiLCJzZWNvbmRzIiwiZnJhYyIsIlRpbWUiLCI9PT0iLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsInJlc3BvbmRfdG8/IiwidG9fc3RyIiwidG9faSIsIkFyZ3VtZW50RXJyb3IiLCJuZXciLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWluIiwic2VjIiwidXRjX29mZnNldCIsIl9wYXJzZV9vZmZzZXQiLCJsb2NhbCIsIm1pbGxpc2Vjb25kIiwiX2R1bW15MSIsIl9kdW1teTIiLCJfZHVtbXkzIiwiZ20iLCJub3ciLCIrIiwib3RoZXIiLCItIiwiPD0+IiwidG9fZiIsInIiLCJuaWw/IiwiPiIsIjAiLCItMSIsIjwiLCIxIiwiPT0iLCIkcmV0X29yXzEiLCJhc2N0aW1lIiwic3RyZnRpbWUiLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOlRpbWU+IiwibWV0aG9kIiwiZ2V0dGVyIiwidXRjZ2V0dGVyIiwiZGlmZmVyZW5jZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOlRpbWU+IiwiZGVmaW5lX21ldGhvZCIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOlRpbWU+IiwieWRheSIsInN0YXJ0X29mX3llYXIiLCJzdGFydF9vZl9kYXkiLCJvbmVfZGF5IiwiODY0MDAiLCIvIiwicm91bmQiLCJpc2RzdCIsImR1cCIsImNvcHkiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImluaXRpYWxpemVfZHVwIiwiZXFsPyIsImlzX2E/IiwiemVybz8iLCIyIiwiMyIsIjQiLCI1IiwiNiIsIndlZWtkYXkiLCJ3ZGF5IiwiaGFzaCIsImluc3BlY3QiLCJ1dGM/Iiwic3VjYyIsInVzZWMiLCJ6b25lIiwiZ2V0Z20iLCJnbXRpbWUiLCJnbXQ/IiwiZ210X29mZnNldCIsImZvcm1hdCIsIm1vbiIsInJqdXN0IiwibGp1c3QiLCJjd2Vla19jeWVhciIsIltdIiwidG9fcyIsIi0yIiwidG9fZGF0ZSIsImpkIiwidG9fYSIsImphbjAxIiwiamFuMDFfd2RheSIsImZpcnN0X21vbmRheSIsIjw9Iiwib2Zmc2V0IiwiNyIsIi04Iiwid2VlayIsImNlaWwiLCIxMiIsIjMxIiwiNTMiLCJkZWMzMSIsImRlYzMxX3dkYXkiXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFHRkQsdUJBQXlCLENBQUdBLFFBQUgsRUFBVUEsUUFBVixFQUFpQkEsU0FBakIsRUFBeUJBLFdBQXpCLEVBQW1DQSxVQUFuQyxFQUE0Q0EsUUFBNUMsRUFBbURBLFVBQW5ELEVBQTREQSxRQUE1RCxDQUFvRUE7QUFDN0ZBLHVCQUF5QixDQUFHQSxLQUFILEVBQU9BLEtBQVAsRUFBV0EsS0FBWCxFQUFlQSxLQUFmLEVBQW1CQSxLQUFuQixFQUF1QkEsS0FBdkIsRUFBMkJBLEtBQTNCLENBQWdDQTtBQUN6REEsdUJBQXlCLENBQUdBLEtBQUgsRUFBT0EsS0FBUCxFQUFXQSxLQUFYLEVBQWVBLEtBQWYsRUFBbUJBLEtBQW5CLEVBQXVCQSxLQUF2QixFQUEyQkEsS0FBM0IsRUFBK0JBLEtBQS9CLEVBQW1DQSxLQUFuQyxFQUF1Q0EsS0FBdkMsRUFBMkNBLEtBQTNDLEVBQStDQSxLQUEvQyxDQUFvREE7QUFDN0VBLHVCQUF5QixDQUFHQSxTQUFILEVBQVdBLFVBQVgsRUFBb0JBLE9BQXBCLEVBQTBCQSxPQUExQixFQUFnQ0EsS0FBaEMsRUFBb0NBLE1BQXBDLEVBQXlDQSxNQUF6QyxFQUE4Q0EsUUFBOUMsRUFBcURBLFdBQXJELEVBQStEQSxTQUEvRCxFQUF1RUEsVUFBdkUsRUFBZ0ZBLFVBQWhGLENBQTBGQTtBQUNuSEE7SUFFRUcsTUFBSUwsSUFBSkssU0FBQUEsY0FBWUMsT0FBRCxFQUFVQyxJQUFyQkY7QUFBQUE7Ozs7QUFFRkE7O0FBRUFBLFVBQVlHLFdBQU9DLFFB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TixFQUFZLEtBQVo7SUFDQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsTUFBYjtJQUNBLGFBQU0sU0FBTixFQUFjLE1BQWQ7SUFDQSxhQUFNLEtBQU4sRUFBVSxRQUFWO0lBQ0EsYUFBTSxNQUFOLEVBQVcsTUFBWDtJQUNBRSxPQUFBLGFBQU0sWUFBTixFQUFpQixZQUFqQjtFQTd3QkZBLEdBQU0sSUFBTkEsRUFBZ0JILElBQWhCRztBQUpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjI4MjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cnVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIDo6U3RydWN0XG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgZGVmIHNlbGYubmV3KGNvbnN0X25hbWUsICphcmdzLCBrZXl3b3JkX2luaXQ6IGZhbHNlLCAmYmxvY2spXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgaWYgY29uc3RfbmFtZS5jbGFzcyA9PSA6OlN0cmluZyAmJiBjb25zdF9uYW1lWzBdLnVwY2FzZSAhPSBjb25zdF9uYW1lWzBdXG4gICAgICAgICMgRmFzdCB0cmFjayBzbyB0aGF0IHdlIHNraXAgbmVlZGxlc3NseSBnb2luZyB0aHJ1IGV4Y2VwdGlvbnNcbiAgICAgICAgIyBpbiBtb3N0IGNhc2VzLlxuICAgICAgICBhcmdzLnVuc2hpZnQoY29uc3RfbmFtZSlcbiAgICAgICAgY29uc3RfbmFtZSA9IG5pbFxuICAgICAgZWxzZVxuICAgICAgICBiZWdpblxuICAgICAgICAgIGNvbnN0X25hbWUgPSA6Ok9wYWwuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICAgICAgcmVzY3VlIDo6VHlwZUVycm9yLCA6Ok5hbWVFcnJvclxuICAgICAgICAgIGFyZ3MudW5zaGlmdChjb25zdF9uYW1lKVxuICAgICAgICAgIGNvbnN0X25hbWUgPSBuaWxcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFyZ3MubWFwIGRvIHxhcmd8XG4gICAgICA6Ok9wYWwuY29lcmNlX3RvIShhcmcsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGVuZFxuXG4gICAga2xhc3MgPSA6OkNsYXNzLm5ldyhzZWxmKSBkb1xuICAgICAgYXJncy5lYWNoIHsgfGFyZ3wgZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUoYXJnKSB9XG5cbiAgICAgIGNsYXNzIDw8IHNlbGZcbiAgICAgICAgZGVmIG5ldygqYXJncylcbiAgICAgICAgICBpbnN0YW5jZSA9IGFsbG9jYXRlXG4gICAgICAgICAgYCN7aW5zdGFuY2V9LiQkZGF0YSA9IHt9YFxuICAgICAgICAgIGluc3RhbmNlLmluaXRpYWxpemUoKmFyZ3MpXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYWxpYXNfbWV0aG9kIDpbXSwgOm5ld1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBrbGFzcy5tb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrXG4gICAgYGtsYXNzLiQka2V5d29yZF9pbml0ID0ga2V5d29yZF9pbml0YFxuXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgOjpTdHJ1Y3QuY29uc3Rfc2V0KGNvbnN0X25hbWUsIGtsYXNzKVxuICAgIGVuZFxuXG4gICAga2xhc3NcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUobmFtZSlcbiAgICBpZiBzZWxmID09IDo6U3RydWN0XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd5b3UgY2Fubm90IGRlZmluZSBhdHRyaWJ1dGVzIHRvIHRoZSBTdHJ1Y3QgY2xhc3MnXG4gICAgZW5kXG5cbiAgICBtZW1iZXJzIDw8IG5hbWVcblxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdYFxuICAgIGVuZFxuXG4gICAgZGVmaW5lX21ldGhvZCBcIiN7bmFtZX09XCIgZG8gfHZhbHVlfFxuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm1lbWJlcnNcbiAgICBpZiBzZWxmID09IDo6U3RydWN0XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0aGUgU3RydWN0IGNsYXNzIGhhcyBubyBtZW1iZXJzJ1xuICAgIGVuZFxuXG4gICAgQG1lbWJlcnMgfHw9IFtdXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluaGVyaXRlZChrbGFzcylcbiAgICBtZW1iZXJzID0gQG1lbWJlcnNcblxuICAgIGtsYXNzLmluc3RhbmNlX2V2YWwgZG9cbiAgICAgIEBtZW1iZXJzID0gbWVtYmVyc1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICBpZiBgI3tzZWxmLmNsYXNzfS4kJGtleXdvcmRfaW5pdGBcbiAgICAgIGt3YXJncyA9IGFyZ3MubGFzdCB8fCB7fVxuXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IDEgfHwgYChhcmdzLmxlbmd0aCA9PT0gMSAmJiAha3dhcmdzLiQkaXNfaGFzaClgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAje2FyZ3MubGVuZ3RofSwgZXhwZWN0ZWQgMClcIlxuICAgICAgZW5kXG5cbiAgICAgIGV4dHJhID0ga3dhcmdzLmtleXMgLSBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgICAgIGlmIGV4dHJhLmFueT9cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVua25vd24ga2V5d29yZHM6ICN7ZXh0cmEuam9pbignLCAnKX1cIlxuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICBzZWxmW25hbWVdID0ga3dhcmdzW25hbWVdXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnc3RydWN0IHNpemUgZGlmZmVycydcbiAgICAgIGVuZFxuXG4gICAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX2luZGV4IGRvIHxuYW1lLCBpbmRleHxcbiAgICAgICAgc2VsZltuYW1lXSA9IGFyZ3NbaW5kZXhdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShmcm9tKVxuICAgICV4e1xuICAgICAgc2VsZi4kJGRhdGEgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tLiQkZGF0YSksIGksIG1heCwgbmFtZTtcbiAgICAgIGZvciAoaSA9IDAsIG1heCA9IGtleXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgbmFtZSA9IGtleXNbaV07XG4gICAgICAgIHNlbGYuJCRkYXRhW25hbWVdID0gZnJvbS4kJGRhdGFbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5rZXl3b3JkX2luaXQ/XG4gICAgYHNlbGYuJCRrZXl3b3JkX2luaXRgXG4gIGVuZFxuXG4gIGRlZiBtZW1iZXJzXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgSGFzaC5uZXcoYHNlbGYuJCRkYXRhYCkuaGFzaFxuICBlbmRcblxuICBkZWYgW10obmFtZSlcbiAgICBpZiA6OkludGVnZXIgPT09IG5hbWVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIDo6U3RyaW5nID09PSBuYW1lXG4gICAgICAleHtcbiAgICAgICAgaWYoIXNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXWBcbiAgZW5kXG5cbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSlcbiAgICBpZiA6OkludGVnZXIgPT09IG5hbWVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIDo6U3RyaW5nID09PSBuYW1lXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKSB1bmxlc3Mgc2VsZi5jbGFzcy5tZW1iZXJzLmluY2x1ZGU/KG5hbWUudG9fc3ltKVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7OjpTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7OjpTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgLmVxbD8oYGJgKX0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIHNlbGZbbmFtZV0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfcGFpclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9wYWlyKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCB7IHxuYW1lfCB5aWVsZCBbbmFtZSwgc2VsZltuYW1lXV0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMubWFwIHsgfG5hbWV8IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBgdmFyIGluc3BlY3Rfc3RhY2sgPSBbXWBcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9ICcjPHN0cnVjdCAnXG5cbiAgICBpZiBgaW5zcGVjdF9zdGFja2AuaW5jbHVkZT8gX19pZF9fXG4gICAgICByZXN1bHQgKyAnOi4uLj4nXG4gICAgZWxzZVxuICAgICAgYGluc3BlY3Rfc3RhY2tgIDw8IF9faWRfX1xuICAgICAgcHVzaGVkID0gdHJ1ZVxuXG4gICAgICBpZiA6OlN0cnVjdCA9PT0gc2VsZiAmJiBzZWxmLmNsYXNzLm5hbWVcbiAgICAgICAgcmVzdWx0ICs9IFwiI3tzZWxmLmNsYXNzfSBcIlxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdCArPSBlYWNoX3BhaXIubWFwIGRvIHxuYW1lLCB2YWx1ZXxcbiAgICAgICAgXCIje25hbWV9PSN7T3BhbC5pbnNwZWN0KHZhbHVlKX1cIlxuICAgICAgZW5kLmpvaW4gJywgJ1xuXG4gICAgICByZXN1bHQgKz0gJz4nXG5cbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbnN1cmVcbiAgICBgaW5zcGVjdF9zdGFjay5wb3AoKWAgaWYgcHVzaGVkXG4gIGVuZFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIGFyZ3MgPSBhcmdzLm1hcCB7IHxhcmd8IGBhcmcuJCRpc19yYW5nZSA/ICN7YXJnLnRvX2F9IDogYXJnYCB9LmZsYXR0ZW5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYXJnc1tpXS4kJGlzX251bWJlcikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje2BhcmdzW2ldYC5jbGFzc30gaW50byBJbnRlZ2VyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goI3tzZWxmW2BhcmdzW2ldYF19KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGlnKGtleSwgKmtleXMpXG4gICAgaXRlbSA9IGlmIGBrZXkuJCRpc19zdHJpbmcgJiYgc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KWBcbiAgICAgICAgICAgICBgc2VsZi4kJGRhdGFba2V5XSB8fCBuaWxgXG4gICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaXRlbSA9PT0gbmlsIHx8IGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBpdGVtLnJlc3BvbmRfdG8/KDpkaWcpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmtleXMpXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuICBhbGlhcyB2YWx1ZXMgdG9fYVxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlN0cnVjdD4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsIm5ldyIsImNvbnN0X25hbWUiLCJjbGFzcyIsIlN0cmluZyIsIltdIiwiMCIsInVwY2FzZSIsImFyZ3MiLCJ1bnNoaWZ0IiwiT3BhbCIsImNvbnN0X25hbWUhIiwiVHlwZUVycm9yIiwiTmFtZUVycm9yIiwibWFwIiwiYmxvY2sgaW4gbmV3IiwiYXJnIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuZXciLCJjb2VyY2VfdG8hIiwia2xhc3MiLCJDbGFzcyIsImVhY2giLCJibG9jayAoMyBsZXZlbHMpIGluIG5ldyIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwidG9fcHJvYyIsIlN0cnVjdCIsImNvbnN0X3NldCIsIm5hbWUiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJtZW1iZXJzIiwiPDwiLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgaW4gZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwidmFsdWUiLCJAbWVtYmVycyIsIiRyZXRfb3JfMSIsImluaGVyaXRlZCIsImluc3RhbmNlX2V2YWwiLCJibG9jayBpbiBpbmhlcml0ZWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaGVyaXRlZCIsImt3YXJncyIsImxhc3QiLCI+IiwibGVuZ3RoIiwiMSIsImV4dHJhIiwiLSIsImtleXMiLCJhbnk/Iiwiam9pbiIsImJsb2NrIGluIGluaXRpYWxpemUiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJbXT0iLCJlYWNoX3dpdGhfaW5kZXgiLCJpbmRleCIsImluaXRpYWxpemVfY29weSIsImZyb20iLCJrZXl3b3JkX2luaXQ/IiwiaGFzaCIsIkhhc2giLCJJbnRlZ2VyIiwiPCIsInNpemUiLCItQCIsIkluZGV4RXJyb3IiLCI+PSIsImluY2x1ZGU/IiwidG9fc3ltIiwiPT0iLCJvdGhlciIsImluc3RhbmNlX29mPyIsIl9faWRfXyIsIj09PSIsImVxbD8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJlYWNoX3BhaXIiLCJibG9jayBpbiBlYWNoX3BhaXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfcGFpciIsInRvX2EiLCJibG9jayBpbiB0b19hIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19hIiwiaW5zcGVjdCIsInJlc3VsdCIsIisiLCJwdXNoZWQiLCJibG9jayBpbiBpbnNwZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnNwZWN0IiwidG9faCIsImVhY2hfd2l0aF9vYmplY3QiLCJibG9jayBpbiB0b19oIiwiaCIsImJsb2NrICgyIGxldmVscykgaW4gdG9faCIsInZhbHVlc19hdCIsImJsb2NrIGluIHZhbHVlc19hdCIsImJsb2NrICgyIGxldmVscykgaW4gdmFsdWVzX2F0IiwiZmxhdHRlbiIsImRpZyIsImtleSIsIml0ZW0iLCJyZXNwb25kX3RvPyJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBRUFFLE1BQUlMLElBQUpLLFVBQUFBLHVCQUFhQyxVQUFELEVBTGQsRUFLYyxFQUxkLEVBS0VEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BTEY7TUFBQTtNQUFBO01BSzJCOztNQUFPLDhDQUFBLHlDQUFjO01BQzVDLElBQUEsUUFBR0MsVUFBSCxDQUFBO1FBQ0UsSUFBRyxDQUFBLE1BQUFBLFVBQVVDLE9BQUFBLENBQUFBLENBQVYsRUFBb0JDLGFBQXBCLENBQUEsSUFBQSxDQUFBLE9BQWdDRixVQUFVRyxPQUFBQSxDQUFDQyxDQUFERCxDQUFHRSxRQUFBQSxDQUFBQSxDQUE3QyxFQUF3REwsVUFBVUcsT0FBQUEsQ0FBQ0MsQ0FBREQsQ0FBbEUsQ0FBQSxDQUFBLENBQUg7O1VBR0VHLElBQUlDLFNBQUFBLENBQVNQLFVBQVRPO1VBQ0pQLGFBQWE7UUFKZjs7VUFPSTtZQUFBQSxhQUFhUSxLQUFNQyxnQkFBQUEsQ0FBYVQsVUFBYlM7VUFBbkI7WUFDRixzQkFBTyxDQUFBQyxnQkFBQSxFQUFhQyxnQkFBYixDQUFQO2NBQUE7O2dCQUNFTCxJQUFJQyxTQUFBQSxDQUFTUCxVQUFUTztnQkFDSlAsYUFBYTtjQUZmO1lBQUEsQ0FERTtVQUFBO1FB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RSxPQUFJQSxNQUFKRSxJQUFJRixPQUFBQSxFQUFLLE1BQUNwRCxJQUFELENBQUxvRDtJQWZOQSxDQUFBQSxJQUFBQTtJQWtCQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBQ0EsYUFBTSxNQUFOLEVBQVcsU0FBWDtJQUNBOUcsT0FBQSxhQUFNLFFBQU4sRUFBYSxNQUFiO0VBeFVGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzI4MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc2V0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogZnJlZXplXG4jIFBvcnRpb25zIENvcHlyaWdodCAoYykgMjAwMi0yMDEzIEFraW5vcmkgTVVTSEEgPGtudUBpRGFlbW9ucy5vcmc+XG5jbGFzcyA6OlNldFxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gIGRlZiBzZWxmLltdKCphcnkpXG4gICAgbmV3KGFyeSlcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZW51bSA9IG5pbCwgJmJsb2NrKVxuICAgIEBoYXNoID0ge31cblxuICAgIHJldHVybiBpZiBlbnVtLm5pbD9cbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd2YWx1ZSBtdXN0IGJlIGVudW1lcmFibGUnIHVubGVzcyA6OkVudW1lcmFibGUgPT09IGVudW1cblxuICAgIGlmIGJsb2NrXG4gICAgICBlbnVtLmVhY2ggeyB8aXRlbXwgYWRkIHlpZWxkKGl0ZW0pIH1cbiAgICBlbHNlXG4gICAgICBtZXJnZShlbnVtKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgcmVzdWx0ID0gc2VsZi5jbGFzcy5uZXdcbiAgICByZXN1bHQubWVyZ2Uoc2VsZilcbiAgZW5kXG5cbiAgZGVmIC0oZW51bSlcbiAgICB1bmxlc3MgZW51bS5yZXNwb25kX3RvPyA6ZWFjaFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndmFsdWUgbXVzdCBiZSBlbnVtZXJhYmxlJ1xuICAgIGVuZFxuXG4gICAgZHVwLnN1YnRyYWN0KGVudW0pXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPFNldDogeyN7dG9fYS5qb2luKCcsJyl9fT5cIlxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgaWYgZXF1YWw/KG90aGVyKVxuICAgICAgdHJ1ZVxuICAgIGVsc2lmIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxuICAgICAgQGhhc2ggPT0gb3RoZXIuaW5zdGFuY2VfdmFyaWFibGVfZ2V0KDpAaGFzaClcbiAgICBlbHNpZiBvdGhlci5pc19hPyg6OlNldCkgJiYgc2l6ZSA9PSBvdGhlci5zaXplXG4gICAgICBvdGhlci5hbGw/IHsgfG98IEBoYXNoLmluY2x1ZGU/KG8pIH1cbiAgICBlbHNlXG4gICAgICBmYWxzZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYWRkKG8pXG4gICAgQGhhc2hbb10gPSB0cnVlXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xhc3NpZnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y2xhc3NpZnkpIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJlc3VsdCA9IDo6SGFzaC5uZXcgeyB8aCwga3wgaFtrXSA9IHNlbGYuY2xhc3MubmV3IH1cblxuICAgIGVhY2ggeyB8aXRlbXwgcmVzdWx0W3lpZWxkKGl0ZW0pXS5hZGQgaXRlbSB9XG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QhKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgcmVzdWx0ID0gc2VsZi5jbGFzcy5uZXdcbiAgICBlYWNoIHsgfGl0ZW18IHJlc3VsdCA8PCB5aWVsZChpdGVtKSB9XG4gICAgcmVwbGFjZSByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHlcbiAgICBpZiBAaGFzaC5yZXNwb25kX3RvPyg6Y29tcGFyZV9ieV9pZGVudGl0eSlcbiAgICAgIEBoYXNoLmNvbXBhcmVfYnlfaWRlbnRpdHlcbiAgICAgIHNlbGZcbiAgICBlbHNlXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIiN7c2VsZi5jbGFzcy5uYW1lfVxcIyN7X19tZXRob2RfX30gaXMgbm90IGltcGxlbWVudGVkXCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHk/XG4gICAgQGhhc2gucmVzcG9uZF90bz8oOmNvbXBhcmVfYnlfaWRlbnRpdHk/KSAmJiBAaGFzaC5jb21wYXJlX2J5X2lkZW50aXR5P1xuICBlbmRcblxuICBkZWYgZGVsZXRlKG8pXG4gICAgQGhhc2guZGVsZXRlKG8pXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGVsZXRlPyhvKVxuICAgIGlmIGluY2x1ZGU/KG8pXG4gICAgICBkZWxldGUobylcbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZlxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgIyBAaGFzaC5kZWxldGVfaWYgc2hvdWxkIGJlIGZhc3RlciwgYnV0IHVzaW5nIGl0IGJyZWFrcyB0aGUgb3JkZXJcbiAgICAjIG9mIGVudW1lcmF0aW9uIGluIHN1YmNsYXNzZXMuXG4gICAgc2VsZWN0IHsgfG98IHlpZWxkIG8gfS5lYWNoIHsgfG98IEBoYXNoLmRlbGV0ZShvKSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xuXG4gICAgQGhhc2guZnJlZXplXG4gICAgYCRmcmVlemUoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmXG4gICAgcmV0dXJuIGVudW1fZm9yKDprZWVwX2lmKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgcmVqZWN0IHsgfG98IHlpZWxkIG8gfS5lYWNoIHsgfG98IEBoYXNoLmRlbGV0ZShvKSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVqZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgYmVmb3JlID0gc2l6ZVxuICAgIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgc2l6ZSA9PSBiZWZvcmUgPyBuaWwgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCEpIHVubGVzcyBibG9ja19naXZlbj9cbiAgICBiZWZvcmUgPSBzaXplXG4gICAga2VlcF9pZigmYmxvY2spXG4gICAgc2l6ZSA9PSBiZWZvcmUgPyBuaWwgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhZGQ/KG8pXG4gICAgaWYgaW5jbHVkZT8obylcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIGFkZChvKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgQGhhc2guZWFjaF9rZXkoJmJsb2NrKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIEBoYXNoLmVtcHR5P1xuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBAaGFzaC5lcWw/KG90aGVyLmluc3RhbmNlX2V2YWwgeyBAaGFzaCB9KVxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICBAaGFzaC5jbGVhclxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG8pXG4gICAgQGhhc2guaW5jbHVkZT8obylcbiAgZW5kXG5cbiAgZGVmIG1lcmdlKGVudW0pXG4gICAgZW51bS5lYWNoIHsgfGl0ZW18IGFkZCBpdGVtIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBsYWNlKGVudW0pXG4gICAgY2xlYXJcbiAgICBtZXJnZShlbnVtKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgc2l6ZVxuICAgIEBoYXNoLnNpemVcbiAgZW5kXG5cbiAgZGVmIHN1YnRyYWN0KGVudW0pXG4gICAgZW51bS5lYWNoIHsgfGl0ZW18IGRlbGV0ZSBpdGVtIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB8KGVudW0pXG4gICAgdW5sZXNzIGVudW0ucmVzcG9uZF90bz8gOmVhY2hcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3ZhbHVlIG11c3QgYmUgZW51bWVyYWJsZSdcbiAgICBlbmRcbiAgICBkdXAubWVyZ2UoZW51bSlcbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gaXNfc2V0KHNldCkge1xuICAgICAgI3tgc2V0YC5pc19hPyg6OlNldCkgfHwgOjpLZXJuZWwucmFpc2UoOjpBcmd1bWVudEVycm9yLCAndmFsdWUgbXVzdCBiZSBhIHNldCcpfVxuICAgIH1cbiAgfVxuXG4gIGRlZiBzdXBlcnNldD8oc2V0KVxuICAgIGBpc19zZXQoc2V0KWBcbiAgICByZXR1cm4gZmFsc2UgaWYgc2l6ZSA8IHNldC5zaXplXG4gICAgc2V0LmFsbD8geyB8b3wgaW5jbHVkZT8obykgfVxuICBlbmRcblxuICBkZWYgcHJvcGVyX3N1cGVyc2V0PyhzZXQpXG4gICAgYGlzX3NldChzZXQpYFxuICAgIHJldHVybiBmYWxzZSBpZiBzaXplIDw9IHNldC5zaXplXG4gICAgc2V0LmFsbD8geyB8b3wgaW5jbHVkZT8obykgfVxuICBlbmRcblxuICBkZWYgc3Vic2V0PyhzZXQpXG4gICAgYGlzX3NldChzZXQpYFxuICAgIHJldHVybiBmYWxzZSBpZiBzZXQuc2l6ZSA8IHNpemVcbiAgICBhbGw/IHsgfG98IHNldC5pbmNsdWRlPyhvKSB9XG4gIGVuZFxuXG4gIGRlZiBwcm9wZXJfc3Vic2V0PyhzZXQpXG4gICAgYGlzX3NldChzZXQpYFxuICAgIHJldHVybiBmYWxzZSBpZiBzZXQuc2l6ZSA8PSBzaXplXG4gICAgYWxsPyB7IHxvfCBzZXQuaW5jbHVkZT8obykgfVxuICBlbmRcblxuICBkZWYgaW50ZXJzZWN0PyhzZXQpXG4gICAgYGlzX3NldChzZXQpYFxuICAgIGlmIHNpemUgPCBzZXQuc2l6ZVxuICAgICAgYW55PyB7IHxvfCBzZXQuaW5jbHVkZT8obykgfVxuICAgIGVsc2VcbiAgICAgIHNldC5hbnk/IHsgfG98IGluY2x1ZGU/KG8pIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGRpc2pvaW50PyhzZXQpXG4gICAgIWludGVyc2VjdD8oc2V0KVxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIEBoYXNoLmtleXNcbiAgZW5kXG5cbiAgYWxpYXMgKyB8XG4gIGFsaWFzIDwgcHJvcGVyX3N1YnNldD9cbiAgYWxpYXMgPDwgYWRkXG4gIGFsaWFzIDw9IHN1YnNldD9cbiAgYWxpYXMgPiBwcm9wZXJfc3VwZXJzZXQ/XG4gIGFsaWFzID49IHN1cGVyc2V0P1xuICBhbGlhcyBkaWZmZXJlbmNlIC1cbiAgYWxpYXMgZmlsdGVyISBzZWxlY3QhXG4gIGFsaWFzIGxlbmd0aCBzaXplXG4gIGFsaWFzIG1hcCEgY29sbGVjdCFcbiAgYWxpYXMgbWVtYmVyPyBpbmNsdWRlP1xuICBhbGlhcyB1bmlvbiB8XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlNldD4iLCJzZWxmIiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJbXSIsIm5ldyIsImFyeSIsImluaXRpYWxpemUiLCJlbnVtJCIsIkBoYXNoIiwibmlsPyIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImJsb2NrIiwiZWFjaCIsImJsb2NrIGluIGluaXRpYWxpemUiLCJpdGVtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiYWRkIiwibWVyZ2UiLCJkdXAiLCJyZXN1bHQiLCJjbGFzcyIsIi0iLCJyZXNwb25kX3RvPyIsInN1YnRyYWN0IiwiaW5zcGVjdCIsInRvX2EiLCJqb2luIiwiPT0iLCJvdGhlciIsImVxdWFsPyIsImluc3RhbmNlX29mPyIsImluc3RhbmNlX3ZhcmlhYmxlX2dldCIsImlzX2E/IiwiU2V0Iiwic2l6ZSIsImFsbD8iLCJibG9jayBpbiA9PSIsIm8iLCJibG9jayAoMiBsZXZlbHMpIGluID09IiwiaW5jbHVkZT8iLCJbXT0iLCJjbGFzc2lmeSIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiSGFzaCIsImJsb2NrIGluIGNsYXNzaWZ5IiwiaCIsImsiLCJibG9jayAoMiBsZXZlbHMpIGluIGNsYXNzaWZ5IiwiY29sbGVjdCEiLCJibG9jayBpbiBjb2xsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCEiLCI8PCIsInJlcGxhY2UiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiTm90SW1wbGVtZW50ZWRFcnJvciIsIm5hbWUiLCJfX21ldGhvZF9fIiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCIkcmV0X29yXzEiLCJkZWxldGUiLCJkZWxldGU/IiwiZGVsZXRlX2lmIiwic2VsZWN0IiwiYmxvY2sgaW4gZGVsZXRlX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWxldGVfaWYiLCJmcmVlemUiLCJmcm96ZW4/Iiwia2VlcF9pZiIsInJlamVjdCIsImJsb2NrIGluIGtlZXBfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGtlZXBfaWYiLCJyZWplY3QhIiwiYmVmb3JlIiwidG9fcHJvYyIsInNlbGVjdCEiLCJhZGQ/IiwiZWFjaF9rZXkiLCJlbXB0eT8iLCJlcWw/IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIGluIGVxbD8iLCJibG9jayAoMiBsZXZlbHMpIGluIGVxbD8iLCJjbGVhciIsImJsb2NrIGluIG1lcmdlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtZXJnZSIsImJsb2NrIGluIHN1YnRyYWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdWJ0cmFjdCIsInwiLCJzdXBlcnNldD8iLCJzZXQiLCI8IiwiYmxvY2sgaW4gc3VwZXJzZXQ/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdXBlcnNldD8iLCJwcm9wZXJfc3VwZXJzZXQ/IiwiPD0iLCJibG9jayBpbiBwcm9wZXJfc3VwZXJzZXQ/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcm9wZXJfc3VwZXJzZXQ/Iiwic3Vic2V0PyIsImJsb2NrIGluIHN1YnNldD8iLCJibG9jayAoMiBsZXZlbHMpIGluIHN1YnNldD8iLCJwcm9wZXJfc3Vic2V0PyIsImJsb2NrIGluIHByb3Blcl9zdWJzZXQ/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcm9wZXJfc3Vic2V0PyIsImludGVyc2VjdD8iLCJhbnk/IiwiYmxvY2sgaW4gaW50ZXJzZWN0PyIsImJsb2NrICgyIGxldmVscykgaW4gaW50ZXJzZWN0PyIsImRpc2pvaW50PyIsIiEiLCJrZXlzIl0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBRUFFLE1BQUlILElBQUpHLFNBQUFBLG1CQUxGLEVBS0VBO0FBQUFBLE1BQUFBOzs7TUFMRjtNQUtjO01BQ1ZBLE9BQUFILElBQUFJLEtBQUFBLENBQUlDLEdBQUpEO0lBREZELENBQUFBLElBQUFBOztBQUlBRyxJQUFBQSwwQkFBQUEsc0JBQWVDLEtBQWZEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWUsMkJBQU87TUFDcEJFLFlBQVEsWUFBQTtNQUVSLElBQUEsUUFBVUQsS0FBSUUsU0FBQUEsQ0FBQUEsQ0FBZCxDQUFBO1FBQUEsT0FBQTtNQUFBO01BQ0EsS0FBQSxRQUFrRVAsaUJBQWxFLEVBQW1GSyxLQUFuRixDQUFBO1FBQUFHLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDTiwwQkFBeEJLO01BQVI7TUFFQSxJQUFBLFFBQUdFLEtBQUgsQ0FBQTtRQUNFUCxPQUFJUSxNQUFKUCxLQUFJTyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFKQyxhQUFhQyxJQUFiRCxFQUFBRTs7O1VBQWE7VUFB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QyxjQUFZckUsQ0FBWnFFLEVBQUFDOzs7VUFBWTtVQUFHQSxPQUFBN0csSUFBQXlDLGFBQUFBLENBQVNGLENBQVRFLEVBQWZtRSxDQUFBQSxHQUFBQSxTQUFBQSxDQUFHRDtNQUhMO0lBRkZELENBQUFBOztBQVNBSSxJQUFBQSx5QkFBQUEsK0JBQWNsQixHQUFka0I7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUM5RyxJQUFBMEcsZUFBQUEsQ0FBV2QsR0FBWGMsQ0FBREssTUFBQUEsQ0FBQUE7SUFERkQsQ0FBQUE7O0FBSUFuRixJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBbkIsU0FBS3dHLE1BQUFBLENBQUFBO0lBRFByRixDQUFBQTtJQUlBLGFBQU0sR0FBTixFQUFRLEdBQVI7SUFDQSxhQUFNLEdBQU4sRUFBUSxnQkFBUjtJQUNBLGFBQU0sSUFBTixFQUFTLEtBQVQ7SUFDQSxhQUFNLElBQU4sRUFBUyxTQUFUO0lBQ0EsYUFBTSxHQUFOLEVBQVEsa0JBQVI7SUFDQSxhQUFNLElBQU4sRUFBUyxXQUFUO0lBQ0EsYUFBTSxZQUFOLEVBQWlCLEdBQWpCO0lBQ0EsYUFBTSxTQUFOLEVBQWMsU0FBZDtJQUNBLGFBQU0sUUFBTixFQUFhLE1BQWI7SUFDQSxhQUFNLE1BQU4sRUFBVyxVQUFYO0lBQ0EsYUFBTSxTQUFOLEVBQWMsVUFBZDtJQUNBNUIsT0FBQSxhQUFNLE9BQU4sRUFBWSxHQUFaO0VBeFBGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzc1NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZGlyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6RGlyXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgY2hkaXIoZGlyKVxuICAgICAgcHJldl9jd2QgPSBgT3BhbC5jdXJyZW50X2RpcmBcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3tkaXJ9YFxuICAgICAgeWllbGRcbiAgICBlbnN1cmVcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3twcmV2X2N3ZH1gXG4gICAgZW5kXG5cbiAgICBkZWYgcHdkXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciB8fCAnLidgXG4gICAgZW5kXG5cbiAgICBkZWYgaG9tZVxuICAgICAgOjpFTlZbJ0hPTUUnXSB8fCAnLidcbiAgICBlbmRcblxuICAgIGFsaWFzIGdldHdkIHB3ZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RGlyPiIsImNoZGlyIiwiZGlyIiwicHJldl9jd2QiLCJwd2QiLCJob21lIiwiJHJldF9vcl8xIiwiRU5WIiwiW10iLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBOzs7O0FBQ0VDLE1BQUFBLHFCQUFBQSxpQkFBVUMsR0FBVkQ7QUFBQUEsUUFBQUE7O1FBQUFBO1FBQ0VBLE9BQUEsY0FBQTs7UUFBQUUsV0FBWUY7UUFDWEEsbUJBQXFCQztRQUN0QixPQUFBLHFCQUFBLEVBQUE7UUFGQTtVQUlDRCxtQkFBcUJFO1FBSnRCLENBQUE7TUFERkYsQ0FBQUE7O0FBUUFHLE1BQUFBLG1CQUFBQSxlQUFBQTtBQUFBQTtRQUNFQSxPQUFDQSx1QkFBREE7TUFERkEsQ0FBQUE7O0FBSUFDLE1BQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0UsSUFBQSxRQUFBQyxDQUFBQSxZQUFBQyxVQUFLQyxPQUFBQSxDQUFDSCxNQUFERyxDQUFMRixDQUFBLENBQUE7VUFBQUQsT0FBQTtRQUFBO1VBQWlCQSxPQUFBQTtRQUFqQjtNQURGQSxDQUFBQTtNQUlBLE9BQUEsYUFBTSxPQUFOLEVBQVksS0FBWjtJQWpCRiw0QkFBU0ksSUFBVDtFQURGVCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzgwMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZmlsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeVxuXG5jbGFzcyA6OkZpbGUgPCA6OklPXG4gIFNlcGFyYXRvciA9IFNFUEFSQVRPUiA9ICcvJ1xuICBBTFRfU0VQQVJBVE9SID0gbmlsXG4gIFBBVEhfU0VQQVJBVE9SID0gJzonXG4gICMgQXNzdW1pbmcgY2FzZSBpbnNlbnN0aXZlIGZpbGVzeXN0ZW1cbiAgRk5NX1NZU0NBU0UgPSAwXG4gIHdpbmRvd3Nfcm9vdF9yeCA9ICVye15bYS16QS1aXTooPzpcXFxcfFxcLyl9XG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhYnNvbHV0ZV9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuZXdfcGFydHMgPSBbXVxuXG4gICAgICBwYXRoID0gcGF0aC5yZXNwb25kX3RvPyg6dG9fcGF0aCkgPyBwYXRoLnRvX3BhdGggOiBwYXRoXG4gICAgICBwYXRoID0gOjpPcGFsLmNvZXJjZV90byEoYHBhdGhgLCA6OlN0cmluZywgOnRvX3N0cilcblxuICAgICAgYmFzZWRpciB8fD0gOjpEaXIucHdkXG4gICAgICBwYXRoX2FicyAgICA9IGBwYXRoLnN1YnN0cigwLCBzZXAubGVuZ3RoKSA9PT0gc2VwIHx8IHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpYFxuICAgICAgYmFzZWRpcl9hYnMgPSBgYmFzZWRpci5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKWBcblxuICAgICAgaWYgcGF0aF9hYnNcbiAgICAgICAgcGFydHMgICAgICAgPSBwYXRoLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpID8gJycgOiAje3BhdGguc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICBhYnMgICAgICAgICA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgcGFydHMgICAgICAgPSBiYXNlZGlyLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pICsgcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKSA/ICcnIDogI3tiYXNlZGlyLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSBiYXNlZGlyX2Fic1xuICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgcGFydDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwYXJ0ID09PSBuaWwpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJycgICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSkgfHxcbiAgICAgICAgICAgIChwYXJ0ID09PSAnLicgJiYgKChuZXdfcGFydHMubGVuZ3RoID09PSAwKSB8fCBhYnMpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld19wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWJzICYmIHBhcnRzWzBdICE9PSAnLicpIHtcbiAgICAgICAgICAje25ld19wYXJ0cy51bnNoaWZ0ICcuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdfcGF0aCA9IG5ld19wYXJ0cy5qb2luKHNlcClcbiAgICAgIG5ld19wYXRoID0gbGVhZGluZ19zZXAgKyBuZXdfcGF0aCBpZiBhYnNcbiAgICAgIG5ld19wYXRoXG4gICAgZW5kXG5cbiAgICBkZWYgZXhwYW5kX3BhdGgocGF0aCwgYmFzZWRpciA9IG5pbClcbiAgICAgIHNlcCA9IFNFUEFSQVRPUlxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIGlmIGBwYXRoWzBdID09PSAnficgfHwgKGJhc2VkaXIgJiYgYmFzZWRpclswXSA9PT0gJ34nKWBcbiAgICAgICAgaG9tZSA9IERpci5ob21lXG4gICAgICAgIDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgXCJjb3VsZG4ndCBmaW5kIEhPTUUgZW52aXJvbm1lbnQgLS0gZXhwYW5kaW5nIGB+J1wiKSB1bmxlc3MgaG9tZVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChob21lKSA/ICcnIDogI3tob21lLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UoOjpBcmd1bWVudEVycm9yLCAnbm9uLWFic29sdXRlIGhvbWUnKSB1bmxlc3MgaG9tZS5zdGFydF93aXRoPyhsZWFkaW5nX3NlcClcblxuICAgICAgICBob21lICAgICAgICAgICAgKz0gc2VwXG4gICAgICAgIGhvbWVfcGF0aF9yZWdleHAgPSAvXlxcfig/OiN7c2VwfXwkKS9cbiAgICAgICAgcGF0aCAgICAgICAgICAgICA9IHBhdGguc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpXG4gICAgICAgIGJhc2VkaXIgICAgICAgICAgPSBiYXNlZGlyLnN1Yihob21lX3BhdGhfcmVnZXhwLCBob21lKSBpZiBiYXNlZGlyXG4gICAgICBlbmRcbiAgICAgIGFic29sdXRlX3BhdGgocGF0aCwgYmFzZWRpcilcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgLy8gQ29lcmNlIGEgZ2l2ZW4gcGF0aCB0byBhIHBhdGggc3RyaW5nIHVzaW5nICN0b19wYXRoIGFuZCAjdG9fc3RyXG4gICAgICBmdW5jdGlvbiAkY29lcmNlX3RvX3BhdGgocGF0aCkge1xuICAgICAgICBpZiAoJHRydXRoeSgje2BwYXRoYC5yZXNwb25kX3RvPyg6dG9fcGF0aCl9KSkge1xuICAgICAgICAgIHBhdGggPSBwYXRoLiR0b19wYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgcGF0aGAsIDo6U3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBhIFJlZ0V4cCBjb21wYXRpYmxlIGNoYXIgY2xhc3NcbiAgICAgIGZ1bmN0aW9uICRzZXBfY2hhcnMoKSB7XG4gICAgICAgIGlmICgje0FMVF9TRVBBUkFUT1J9ID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gT3BhbC5lc2NhcGVfcmVnZXhwKCN7U0VQQVJBVE9SfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUiArIEFMVF9TRVBBUkFUT1J9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlZiBkaXJuYW1lKHBhdGgsIGxldmVsID0gMSlcbiAgICAgIHJldHVybiBwYXRoIGlmIGxldmVsID09IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJsZXZlbCBjYW4ndCBiZSBuZWdhdGl2ZVwiIGlmIGxldmVsIDwgMFxuXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgcGF0aCA9IGAkY29lcmNlX3RvX3BhdGgocGF0aClgXG4gICAgICAleHtcbiAgICAgICAgdmFyIGFic29sdXRlID0gcGF0aC5tYXRjaChuZXcgUmVnRXhwKCN7XCJeWyN7c2VwX2NoYXJzfV1cIn0pKSwgb3V0O1xuXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiWyN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlcGFyYXRvcnNcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbXiN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIGJhc2VuYW1lXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiWyN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIGZpbmFsIHRyYWlsaW5nIHNlcGFyYXRvcnNcblxuICAgICAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgICAgICBvdXQgPSBhYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvdXQgPSBwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldmVsID09IDEpIHtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiAje2Rpcm5hbWUoYG91dGAsIGxldmVsIC0gMSl9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBiYXNlbmFtZShuYW1lLCBzdWZmaXggPSBuaWwpXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgbmFtZSA9IGAkY29lcmNlX3RvX3BhdGgobmFtZSlgXG4gICAgICAleHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWZmaXggIT09IG5pbCkge1xuICAgICAgICAgIHN1ZmZpeCA9ICN7OjpPcGFsLmNvZXJjZV90byEoc3VmZml4LCA6OlN0cmluZywgOnRvX3N0cil9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VmZml4ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiKC4pWyN7c2VwX2NoYXJzfV0qJFwifSksICckMScpO1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIl4oPzouKlsje3NlcF9jaGFyc31dKT8oW14je3NlcF9jaGFyc31dKykkXCJ9KSwgJyQxJyk7XG5cbiAgICAgICAgaWYgKHN1ZmZpeCA9PT0gXCIuKlwiKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFwuW15cXC5dKyQvLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZihzdWZmaXggIT09IG51bGwpIHtcbiAgICAgICAgICBzdWZmaXggPSBPcGFsLmVzY2FwZV9yZWdleHAoc3VmZml4KTtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIiN7c3VmZml4fSRcIn0pLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBleHRuYW1lKHBhdGgpXG4gICAgICBgcGF0aCA9ICRjb2VyY2VfdG9fcGF0aChwYXRoKWBcbiAgICAgIGZpbGVuYW1lID0gYmFzZW5hbWUocGF0aClcbiAgICAgIHJldHVybiAnJyBpZiBmaWxlbmFtZS5lbXB0eT9cbiAgICAgIGxhc3RfZG90X2lkeCA9IGZpbGVuYW1lWzEuLi0xXS5yaW5kZXgoJy4nKVxuICAgICAgIyBleHRlbnNpb24gbmFtZSBtdXN0IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgLihzb21ldGhpbmcpXG4gICAgICBsYXN0X2RvdF9pZHgubmlsPyB8fCBsYXN0X2RvdF9pZHggKyAxID09IGZpbGVuYW1lLmxlbmd0aCAtIDEgPyAnJyA6IGZpbGVuYW1lWyhsYXN0X2RvdF9pZHggKyAxKS4uLTFdXG4gICAgZW5kXG5cbiAgICBkZWYgZXhpc3Q/KHBhdGgpXG4gICAgICBgT3BhbC5tb2R1bGVzWyN7cGF0aH1dICE9IG51bGxgXG4gICAgZW5kXG5cbiAgICBkZWYgZGlyZWN0b3J5PyhwYXRoKVxuICAgICAgZmlsZXMgPSBbXVxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPcGFsLm1vZHVsZXMpIHtcbiAgICAgICAgICAje2ZpbGVzfS5wdXNoKGtleSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aCA9IHBhdGguZ3N1YigvKF4uI3tTRVBBUkFUT1J9K3wje1NFUEFSQVRPUn0rJCkvKVxuICAgICAgZmlsZSA9IGZpbGVzLmZpbmQgeyB8ZnwgZiA9fiAvXiN7cGF0aH0vIH1cbiAgICAgIGZpbGVcbiAgICBlbmRcblxuICAgIGRlZiBqb2luKCpwYXRocylcbiAgICAgIGlmIHBhdGhzLmVtcHR5P1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIGVuZFxuICAgICAgcmVzdWx0ID0gJydcbiAgICAgIHBhdGhzID0gcGF0aHMuZmxhdHRlbi5lYWNoX3dpdGhfaW5kZXgubWFwIGRvIHxpdGVtLCBpbmRleHxcbiAgICAgICAgaWYgaW5kZXggPT0gMCAmJiBpdGVtLmVtcHR5P1xuICAgICAgICAgIFNFUEFSQVRPUlxuICAgICAgICBlbHNpZiBwYXRocy5sZW5ndGggPT0gaW5kZXggKyAxICYmIGl0ZW0uZW1wdHk/XG4gICAgICAgICAgU0VQQVJBVE9SXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpdGVtXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBwYXRocyA9IHBhdGhzLnJlamVjdCgmOmVtcHR5PylcbiAgICAgIHBhdGhzLmVhY2hfd2l0aF9pbmRleCBkbyB8aXRlbSwgaW5kZXh8XG4gICAgICAgIG5leHRfaXRlbSA9IHBhdGhzW2luZGV4ICsgMV1cbiAgICAgICAgaWYgbmV4dF9pdGVtLm5pbD9cbiAgICAgICAgICByZXN1bHQgPSBcIiN7cmVzdWx0fSN7aXRlbX1cIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgaXRlbS5lbmRfd2l0aD8oU0VQQVJBVE9SKSAmJiBuZXh0X2l0ZW0uc3RhcnRfd2l0aD8oU0VQQVJBVE9SKVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0uc3ViKC8je1NFUEFSQVRPUn0rJC8sICcnKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIHJlc3VsdCA9IGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgfHwgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcbiAgICAgICAgICAgICAgICAgICAgIFwiI3tyZXN1bHR9I3tpdGVtfVwiXG4gICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19I3tTRVBBUkFUT1J9XCJcbiAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuXG4gICAgZGVmIHNwbGl0KHBhdGgpXG4gICAgICBwYXRoLnNwbGl0KFNFUEFSQVRPUilcbiAgICBlbmRcblxuICAgIGFsaWFzIHJlYWxwYXRoIGV4cGFuZF9wYXRoXG4gICAgYWxpYXMgZXhpc3RzPyBleGlzdD9cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkZpbGU+IiwiMCIsIndpbmRvd3Nfcm9vdF9yeCIsImFic29sdXRlX3BhdGgiLCJwYXRoIiwiYmFzZWRpciIsInNlcCIsIlNFUEFSQVRPUiIsInNlcF9jaGFycyIsIm5ld19wYXJ0cyIsInJlc3BvbmRfdG8/IiwidG9fcGF0aCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiU3RyaW5nIiwiJHJldF9vcl8xIiwiRGlyIiwicHdkIiwicGF0aF9hYnMiLCJiYXNlZGlyX2FicyIsInBhcnRzIiwic3BsaXQiLCJsZWFkaW5nX3NlcCIsInN1YiIsImFicyIsIisiLCJ1bnNoaWZ0IiwibmV3X3BhdGgiLCJqb2luIiwiZXhwYW5kX3BhdGgiLCJob21lIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwic3RhcnRfd2l0aD8iLCJob21lX3BhdGhfcmVnZXhwIiwic2VsZiIsIkFMVF9TRVBBUkFUT1IiLCJkaXJuYW1lIiwibGV2ZWwiLCIxIiwiPCIsIi0iLCJiYXNlbmFtZSIsIm5hbWUiLCJzdWZmaXgiLCJleHRuYW1lIiwiZmlsZW5hbWUiLCJlbXB0eT8iLCJsYXN0X2RvdF9pZHgiLCJbXSIsIi0xIiwicmluZGV4IiwibmlsPyIsImxlbmd0aCIsImV4aXN0PyIsImRpcmVjdG9yeT8iLCJmaWxlcyIsImdzdWIiLCJmaW5kIiwiYmxvY2sgaW4gZGlyZWN0b3J5PyIsImYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRpcmVjdG9yeT8iLCI9fiIsInBhdGhzIiwicmVzdWx0IiwibWFwIiwiZmxhdHRlbiIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIGpvaW4iLCJpdGVtIiwiaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGpvaW4iLCJyZWplY3QiLCJ0b19wcm9jIiwibmV4dF9pdGVtIiwiZW5kX3dpdGg/IiwiSU8iXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLHFDQUFZLHFDQUFZQSxHQUFaLENBQVo7SUFDQSx5Q0FBZ0IsR0FBaEI7SUFDQSwwQ0FBaUJBLEdBQWpCO0lBRUEsdUNBQWNDLENBQWQ7SUFDQUMsa0JBQWtCO0lBRWxCRixPQUFBO01BQUE7Ozs7QUFDRUcsTUFBQUEsNkJBQUFBLHlCQUFrQkMsSUFBRCxFQUFPQyxPQUF4QkY7QUFBQUEsUUFBQUE7OztRQUF3QiwrQkFBVTtRQUNoQ0csTUFBTUM7UUFDTkMsWUFBYUw7UUFDYk0sWUFBWTtRQUVaTCxPQUFPLENBQUEsUUFBQUEsSUFBSU0sZ0JBQUFBLENBQWEsU0FBYkEsQ0FBSixDQUFB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QUFBLENBQVdyRSxlQUFYcUUsQ0FBSixDQUFBLElBQUEsQ0FBQSxRQUE2QkQsU0FBU3pDLGdCQUFBQSxDQUFhM0IsZUFBYjJCLENBQXRDLENBQUEsQ0FBQSxDQUFILEdBQUEsQ0FDRSxFQUFBLEdBQUEsQ0FBRytCLE1BQUgsQ0FBQSxHQUFBLENBQVlLLElBQVosQ0FERixJQUFBLENBR0UsRUFBQSxHQUFBLENBQUdMLE1BQUgsQ0FBQSxHQUFBLENBQVlLLElBQVosQ0FBQSxHQUFBLENBQW1CL0QsZUFBbkIsQ0FIRixDQUFBLENBQVQwRDtVQU5GLEVBRkZJLENBQUtEO1FBZUx4QyxPQUFBcUM7TUE5QkZyQyxDQUFBQSxJQUFBQTs7QUFpQ0FQLE1BQUFBLHFCQUFBQSxpQkFBVWpCLElBQVZpQjtBQUFBQTtRQUNFQSxPQUFBakIsSUFBSWlCLE9BQUFBLENBQU9kLGVBQVBjO01BRE5BLENBQUFBO01BSUEsYUFBTSxVQUFOLEVBQWUsYUFBZjtNQUNBLE9BQUEsYUFBTSxTQUFOLEVBQWMsUUFBZDtJQW5ORiw0QkFBU2UsSUFBVDtFQVJGcEMsR0FBTSxJQUFOQSxFQUFlNkUsU0FBZjdFO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDA4MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvY2Vzcy9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6U2lnbmFsXG4gIGRlZiBzZWxmLnRyYXAoKilcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpHQ1xuICBkZWYgc2VsZi5zdGFydFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6U2lnbmFsPiIsInRyYXAiLCJzZWxmIiwiPGNsYXNzOkdDPiIsInN0YXJ0Il0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBLGdCQUFBQTtFQUFBQTs7O0VBQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUMsTUFBSUMsSUFBSkQsV0FBQUEsZ0JBREYsRUFDRUE7QUFBQUEsTUFBQUE7OztNQURGO01BQ2dCO01BRGhCQSxPQUFBO0lBQ0VBLENBQUFBLElBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUFLQUQsT0FBQUk7RUFBQUE7OztJQUNFQSxPQUFBQyxNQUFJRixJQUFKRSxZQUFBQSxZQU5GLEdBTUVBLENBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFMQUo7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MTA1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jZXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSA6OlByb2Nlc3NcbiAgQF9fY2xvY2tzX18gPSBbXVxuICBkZWYgc2VsZi5fX3JlZ2lzdGVyX2Nsb2NrX18obmFtZSwgZnVuYylcbiAgICBjb25zdF9zZXQgbmFtZSwgQF9fY2xvY2tzX18uc2l6ZVxuICAgIEBfX2Nsb2Nrc19fIDw8IGZ1bmNcbiAgZW5kXG5cbiAgX19yZWdpc3Rlcl9jbG9ja19fIDpDTE9DS19SRUFMVElNRSwgYGZ1bmN0aW9uKCkgeyByZXR1cm4gRGF0ZS5ub3coKSB9YFxuXG4gIG1vbm90b25pYyA9IGZhbHNlXG5cbiAgJXh7XG4gICAgaWYgKE9wYWwuZ2xvYmFsLnBlcmZvcm1hbmNlKSB7XG4gICAgICBtb25vdG9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChPcGFsLmdsb2JhbC5wcm9jZXNzICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgICAvLyBsZXQgbm93IGJlIHRoZSBiYXNlIHRvIGdldCBzbWFsbGVyIG51bWJlcnNcbiAgICAgIHZhciBocnRpbWVfYmFzZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG5cbiAgICAgIG1vbm90b25pYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWUoaHJ0aW1lX2Jhc2UpO1xuICAgICAgICB2YXIgdXMgPSAoaHJ0aW1lWzFdIC8gMTAwMCkgfCAwOyAvLyBjdXQgYmVsb3cgbWljcm9zZWNzO1xuICAgICAgICByZXR1cm4gKChocnRpbWVbMF0gKiAxMDAwKSArICh1cyAvIDEwMDApKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgX19yZWdpc3Rlcl9jbG9ja19fKDpDTE9DS19NT05PVE9OSUMsIG1vbm90b25pYykgaWYgbW9ub3RvbmljXG5cbiAgZGVmIHNlbGYucGlkXG4gICAgMFxuICBlbmRcblxuICBkZWYgc2VsZi50aW1lc1xuICAgIHQgPSA6OlRpbWUubm93LnRvX2ZcbiAgICA6OkJlbmNobWFyazo6VG1zLm5ldyh0LCB0LCB0LCB0LCB0KVxuICBlbmRcblxuICBkZWYgc2VsZi5jbG9ja19nZXR0aW1lKGNsb2NrX2lkLCB1bml0ID0gOmZsb2F0X3NlY29uZClcbiAgICAoY2xvY2sgPSBAX19jbG9ja3NfX1tjbG9ja19pZF0pIHx8IDo6S2VybmVsLnJhaXNlKDo6RXJybm86OkVJTlZBTCwgXCJjbG9ja19nZXR0aW1lKCN7Y2xvY2tfaWR9KSAje0BfX2Nsb2Nrc19fW2Nsb2NrX2lkXX1cIilcbiAgICAleHtcbiAgICAgIHZhciBtcyA9IGNsb2NrKCk7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAnZmxvYXRfc2Vjb25kJzogICAgICByZXR1cm4gIChtcyAvIDEwMDApOyAgICAgICAgIC8vIG51bWJlciBvZiBzZWNvbmRzIGFzIGEgZmxvYXQgKGRlZmF1bHQpXG4gICAgICAgIGNhc2UgJ2Zsb2F0X21pbGxpc2Vjb25kJzogcmV0dXJuICAobXMgLyAxKTsgICAgICAgICAgICAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGEgZmxvYXRcbiAgICAgICAgY2FzZSAnZmxvYXRfbWljcm9zZWNvbmQnOiByZXR1cm4gIChtcyAqIDEwMDApOyAgICAgICAgIC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYSBmbG9hdFxuICAgICAgICBjYXNlICdzZWNvbmQnOiAgICAgICAgICAgIHJldHVybiAoKG1zIC8gMTAwMCkgICAgfCAwKTsgLy8gbnVtYmVyIG9mIHNlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICAgICAgIHJldHVybiAoKG1zIC8gMSkgICAgICAgfCAwKTsgLy8gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzogICAgICAgcmV0dXJuICgobXMgKiAxMDAwKSAgICB8IDApOyAvLyBudW1iZXIgb2YgbWljcm9zZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbmFub3NlY29uZCc6ICAgICAgICByZXR1cm4gKChtcyAqIDEwMDAwMDApIHwgMCk7IC8vIG51bWJlciBvZiBuYW5vc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGRlZmF1bHQ6ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVuZXhwZWN0ZWQgdW5pdDogI3t1bml0fVwifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpQcm9jZXNzPiIsIkBfX2Nsb2Nrc19fIiwiX19yZWdpc3Rlcl9jbG9ja19fIiwic2VsZiIsIm5hbWUiLCJmdW5jIiwiY29uc3Rfc2V0Iiwic2l6ZSIsIjw8IiwibW9ub3RvbmljIiwicGlkIiwiMCIsInRpbWVzIiwidCIsIlRpbWUiLCJub3ciLCJ0b19mIiwiQmVuY2htYXJrOjpUbXMiLCJCZW5jaG1hcmsiLCJuZXciLCJjbG9ja19nZXR0aW1lIiwiY2xvY2tfaWQiLCJ1bml0IiwiJHJldF9vcl8xIiwiY2xvY2siLCJbXSIsIktlcm5lbCIsInJhaXNlIiwiRXJybm86OkVJTlZBTCIsIkVycm5vIiwiQXJndW1lbnRFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0VDLGtCQUFjO0lBQ2RDLE1BQUlDLElBQUpELHlCQUFBQSw4QkFBNEJFLElBQUQsRUFBT0MsSUFBbENIO0FBQUFBLE1BQUFBO0FBQUFBOzs7TUFDRUMsSUFBQUcsV0FBQUEsQ0FBVUYsSUFBVixFQUFnQkgsZUFBV00sTUFBQUEsQ0FBQUEsQ0FBM0JEO01BQ0FKLE9BQUFELGVBQVlPLE9BQUFBLENBQUdILElBQUhHO0lBRmROLENBQUFBO0lBS0FDLElBQUFELG9CQUFBQSxDQUFtQixnQkFBbkIsRUFBcUNGLGdDQUFyQ0U7SUFFQU8sWUFBWTs7QUFHZFQ7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBRUUsSUFBQSxRQUFtRFMsU0FBbkQsQ0FBQTtNQUFBTixJQUFBRCxvQkFBQUEsQ0FBbUIsaUJBQW5CLEVBQXFDTyxTQUFyQ1A7SUFBQTtJQUVBUSxNQUFJUCxJQUFKTyxVQUFBQSxZQUNFQyxDQURGRCxDQUFBQTtJQUlBRSxNQUFJVCxJQUFKUyxZQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFQyxJQUFJQyxXQUFNQyxLQUFBQSxDQUFBQSxDQUFJQyxNQUFBQSxDQUFBQTtNQUNkSixPQUFBSyxJQUFBQyxnQkFBQUQsUUFBZ0JFLEtBQUFBLENBQUtOLENBQXJCLEVBQXdCQSxDQUF4QixFQUEyQkEsQ0FBM0IsRUFBOEJBLENBQTlCLEVBQWlDQSxDQUFqQk07SUFGbEJQLENBQUFBO0lBS0FaLE9BQUFvQixNQUFJakIsSUFBSmlCLG9CQUFBQSx5QkFBdUJDLFFBQUQsRUFBV0MsSUFBakNGO0FBQUFBLE1BQUFBO0FBQUFBOzs7TUFBaUMseUJBQU87TUFDdEMsSUFBQSxRQUFBRyxDQUFBQSxZQUFDQyxDQUFBQSxRQUFRdkIsZUFBV3dCLE9BQUFBLENBQUNKLFFBQURJLENBQW5CRCxDQUFERCxDQUFBLENBQUE7UUFBQTtNQUFBO1FBQW1DRyxPQUFRQyxPQUFBQSxDQUFPQyxJQUFBQyxZQUFBRCxXQUFmLEVBQWlDUixnQkFBRCxHQUFBLENBQWlCQyxRQUFqQixDQUFBLEdBQTBCRCxJQUExQixHQUFBLENBQThCbkIsZUFBV3dCLE9BQUFBLENBQUNKLFFBQURJLENBQXpDLENBQXhCRTtNQUEzQzs7QUFFSlA7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsaUJBQW1CTSxPQUFRQyxPQUFBQSxDQUFPRyxvQkFBZixFQUFpQ1YsbUJBQUQsR0FBQSxDQUFvQkUsSUFBcEIsQ0FBeEJLO0FBQzNCUDtBQUNBQTtJQWRFQSxDQUFBQSxJQUFBQTtFQXhDRnBCLEdBQU8sSUFBUEE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MTgyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20vZm9ybWF0dGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6UmFuZG9tXG4gIG1vZHVsZSBzZWxmOjpGb3JtYXR0ZXJcbiAgICBkZWYgaGV4KGNvdW50ID0gbmlsKVxuICAgICAgY291bnQgPSA6OlJhbmRvbS5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICAgJXh7XG4gICAgICAgIHZhciBieXRlcyA9ICN7Ynl0ZXMoY291bnQpfTtcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgI3tjb3VudH07IGkrKykge1xuICAgICAgICAgIG91dCArPSBieXRlcy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje2BvdXRgLmVuY29kZSgnVVMtQVNDSUknKX07XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZG9tX2J5dGVzKGNvdW50ID0gbmlsKVxuICAgICAgYnl0ZXMoY291bnQpXG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZTY0KGNvdW50ID0gbmlsKVxuICAgICAgOjpCYXNlNjQuc3RyaWN0X2VuY29kZTY0KHJhbmRvbV9ieXRlcyhjb3VudCkpLmVuY29kZSgnVVMtQVNDSUknKVxuICAgIGVuZFxuXG4gICAgZGVmIHVybHNhZmVfYmFzZTY0KGNvdW50ID0gbmlsLCBwYWRkaW5nID0gZmFsc2UpXG4gICAgICA6OkJhc2U2NC51cmxzYWZlX2VuY29kZTY0KHJhbmRvbV9ieXRlcyhjb3VudCksIHBhZGRpbmcpLmVuY29kZSgnVVMtQVNDSUknKVxuICAgIGVuZFxuXG4gICAgZGVmIHV1aWRcbiAgICAgIHN0ciA9IGhleCgxNikuc3BsaXQoJycpXG4gICAgICBzdHJbMTJdID0gJzQnXG4gICAgICBzdHJbMTZdID0gYChwYXJzZUludCgje3N0clsxNl19LCAxNikgJiAzIHwgOCkudG9TdHJpbmcoMTYpYFxuICAgICAgc3RyID0gW3N0clswLi4uOF0sIHN0cls4Li4uMTJdLCBzdHJbMTIuLi4xNl0sIHN0clsxNi4uLjIwXSwgc3RyWzIwLi4uMzJdXVxuICAgICAgc3RyID0gc3RyLm1hcCgmOmpvaW4pXG4gICAgICBzdHIuam9pbignLScpXG4gICAgZW5kXG5cbiAgICAjIEltcGxlbWVudGVkIGluIHRlcm1zIG9mIGAjYnl0ZXNgIGZvciBTZWN1cmVSYW5kb20sIGJ1dCBSYW5kb20gb3ZlcnJpZGVzIHRoaXNcbiAgICAjIG1ldGhvZCB0byBpbXBsZW1lbnQgYCNieXRlc2AgaW4gdGVybXMgb2YgYCNyYW5kb21fZmxvYXRgLiBOb3QgcGFydCBvZiBzdGFuZGFyZFxuICAgICMgUnVieSBpbnRlcmZhY2UgLSB1c2UgcmFuZG9tX251bWJlciBmb3IgcG9ydGFiaWxpdHkuXG4gICAgZGVmIHJhbmRvbV9mbG9hdFxuICAgICAgYnMgPSBieXRlcyg0KVxuICAgICAgbnVtID0gMFxuICAgICAgNC50aW1lcyBkbyB8aXxcbiAgICAgICAgbnVtIDw8PSA4XG4gICAgICAgIG51bSB8PSBic1tpXS5vcmRcbiAgICAgIGVuZFxuICAgICAgbnVtLmFicyAvIDB4N2ZmZmZmZmZcbiAgICBlbmRcblxuICAgIGRlZiByYW5kb21fbnVtYmVyKGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICAgJXh7XG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUZsb2F0KCkge1xuICAgICAgICAgIHJldHVybiAje3JhbmRvbV9mbG9hdH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByYW5kb21JbnQobWF4KSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tRmxvYXQoKSAqIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByYW5kb21SYW5nZSgpIHtcbiAgICAgICAgICB2YXIgbWluID0gbGltaXQuYmVnaW4sXG4gICAgICAgICAgICAgIG1heCA9IGxpbWl0LmVuZDtcblxuICAgICAgICAgIGlmIChtaW4gPT09IG5pbCB8fCBtYXggPT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gbWF4IC0gbWluO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF4ICUgMSA9PT0gMCAmJiBtaW4gJSAxID09PSAwICYmICFsaW1pdC5leGNsKSB7XG4gICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxlbmd0aCkgKyBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByYW5kb21GbG9hdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbWl0LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZG9tUmFuZ2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW1pdC4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGltaXQgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCkgKiBsaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGltaXQgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGxpbWl0LCA6OkludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGFscGhhbnVtZXJpYyhjb3VudCA9IG5pbClcbiAgICAgIGNvdW50ID0gUmFuZG9tLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgICBtYXAgPSBbJzAnLi4nOScsICdhJy4uJ3onLCAnQScuLidaJ10ubWFwKCY6dG9fYSkuZmxhdHRlblxuICAgICAgOjpBcnJheS5uZXcoY291bnQpIGRvIHxpfFxuICAgICAgICBtYXBbcmFuZG9tX251bWJlcihtYXAubGVuZ3RoKV1cbiAgICAgIGVuZC5qb2luXG4gICAgZW5kXG4gIGVuZFxuXG4gIGluY2x1ZGUgOjpSYW5kb206OkZvcm1hdHRlclxuICBleHRlbmQgOjpSYW5kb206OkZvcm1hdHRlclxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSYW5kb20+IiwiPG1vZHVsZTpzZWxmOjpGb3JtYXR0ZXI+IiwiaGV4IiwiY291bnQiLCJSYW5kb20iLCJfdmVyaWZ5X2NvdW50Iiwic2VsZiIsImJ5dGVzIiwiZW5jb2RlIiwicmFuZG9tX2J5dGVzIiwiYmFzZTY0IiwiQmFzZTY0Iiwic3RyaWN0X2VuY29kZTY0IiwidXJsc2FmZV9iYXNlNjQiLCJwYWRkaW5nIiwidXJsc2FmZV9lbmNvZGU2NCIsInV1aWQiLCJzdHIiLCIxNiIsInNwbGl0IiwiW109IiwiMTIiLCJbXSIsIjAiLCI4IiwiMjAiLCIzMiIsIm1hcCIsInRvX3Byb2MiLCJqb2luIiwicmFuZG9tX2Zsb2F0IiwiYnMiLCI0IiwibnVtIiwidGltZXMiLCJibG9jayBpbiByYW5kb21fZmxvYXQiLCJpIiwiPDwiLCJibG9jayAoMiBsZXZlbHMpIGluIHJhbmRvbV9mbG9hdCIsInwiLCJvcmQiLCIvIiwiYWJzIiwiMjE0NzQ4MzY0NyIsInJhbmRvbV9udW1iZXIiLCJsaW1pdCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsImFscGhhbnVtZXJpYyIsImZsYXR0ZW4iLCJuZXciLCJBcnJheSIsImJsb2NrIGluIGFscGhhbnVtZXJpYyIsImJsb2NrICgyIGxldmVscykgaW4gYWxwaGFudW1lcmljIiwibGVuZ3RoIiwiaW5jbHVkZSIsIlJhbmRvbTo6Rm9ybWF0dGVyIiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUM7SUFBQUE7O01BQUFBOzs7O0FBQ0VDLE1BQUFBLG1CQUFBQSxlQUFRQyxLQUFSRDtB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QixFQUFBQzs7O1VBQXVCO1VBQ3JCQSxPQUFBOUIsR0FBR0wsT0FBQUEsQ0FBQ2hCLElBQUFzQyxlQUFBQSxDQUFjakIsR0FBRytCLFFBQUFBLENBQUFBLENBQWpCZCxDQUFEdEIsRUFETGtDLENBQUFBLEdBQUFBLFNBQUFBLENBQU9GLENBRUp6QixNQUFBQSxDQUFBQTtNQUxMdUIsQ0FBQUEsSUFBQUE7SUE3R0ZuRCxHQUFPSyxJQUFQTDtJQXNIQUssSUFBQXFELFNBQUFBLENBQVFDLElBQUF4RCxhQUFBd0QsY0FBUkQ7SUFDQTNELE9BQUFNLElBQUF1RCxRQUFBQSxDQUFPRCxJQUFBeEQsYUFBQXdELGNBQVBDO0VBeEhGN0QsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjQzNTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS9tZXJzZW5uZV90d2lzdGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgVGhpcyBpcyBiYXNlZCBvbiBhbiBhZGFwdGF0aW9uIG9mIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEncyBjb2RlXG4jIGRvbmUgYnkgU2VhbiBNY0N1bGxvdWdoIDxiYW5rc2VhbkBnbWFpbC5jb20+IGFuZCBEYXZlIEhlaXR6bWFuXG4jIDxkYXZlaGVpdHptYW5AeWFob28uY29tPiwgc3Vic2VxdWVudGx5IHJlYWRhcHRlZCBmcm9tIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZlxuIyBydWJ5J3MgcmFuZG9tLmMgKHJldiBjMzhhMTgzMDMyYTc4MjZkZjFhZGFiZDhhYTA3MjVjNzEzZDUzZTFjKS5cbiNcbiMgVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZnJvbSByYW5kb20uYyBmb2xsb3dzLlxuI1xuIyAgIFRoaXMgaXMgYmFzZWQgb24gdHJpbW1lZCB2ZXJzaW9uIG9mIE1UMTk5MzcuICBUbyBnZXQgdGhlIG9yaWdpbmFsIHZlcnNpb24sXG4jICAgY29udGFjdCA8aHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvZW10Lmh0bWw+LlxuI1xuIyAgIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgbm90aWNlIGZvbGxvd3MuXG4jXG4jICAgICAgQSBDLXByb2dyYW0gZm9yIE1UMTk5MzcsIHdpdGggaW5pdGlhbGl6YXRpb24gaW1wcm92ZWQgMjAwMi8yLzEwLlxuIyAgICAgIENvZGVkIGJ5IFRha3VqaSBOaXNoaW11cmEgYW5kIE1ha290byBNYXRzdW1vdG8uXG4jICAgICAgVGhpcyBpcyBhIGZhc3RlciB2ZXJzaW9uIGJ5IHRha2luZyBTaGF3biBDb2t1cydzIG9wdGltaXphdGlvbixcbiMgICAgICBNYXR0aGUgQmVsbGV3J3Mgc2ltcGxpZmljYXRpb24sIElzYWt1IFdhZGEncyByZWFsIHZlcnNpb24uXG4jXG4jICAgICAgQmVmb3JlIHVzaW5nLCBpbml0aWFsaXplIHRoZSBzdGF0ZSBieSB1c2luZyBpbml0X2dlbnJhbmQobXQsIHNlZWQpXG4jICAgICAgb3IgaW5pdF9ieV9hcnJheShtdCwgaW5pdF9rZXksIGtleV9sZW5ndGgpLlxuI1xuIyAgICAgIENvcHlyaWdodCAoQykgMTk5NyAtIDIwMDIsIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEsXG4jICAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiNcbiMgICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiMgICAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiMgICAgICBhcmUgbWV0OlxuI1xuIyAgICAgICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiMgICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiNcbiMgICAgICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4jICAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4jICAgICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuI1xuIyAgICAgICAgMy4gVGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZVxuIyAgICAgICAgICAgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuXG4jICAgICAgICAgICBwZXJtaXNzaW9uLlxuI1xuIyAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiMgICAgICBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4jICAgICAgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4jICAgICAgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXG4jICAgICAgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4jICAgICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuIyAgICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuIyAgICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiMgICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIyAgICAgIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuIyAgICAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuI1xuI1xuIyAgICAgIEFueSBmZWVkYmFjayBpcyB2ZXJ5IHdlbGNvbWUuXG4jICAgICAgaHR0cDovL3d3dy5tYXRoLmtlaW8uYWMuanAvbWF0dW1vdG8vZW10Lmh0bWxcbiMgICAgICBlbWFpbDogbWF0dW1vdG9AbWF0aC5rZWlvLmFjLmpwXG5tZXJzZW5uZV90d2lzdGVyID0gJXh7KGZ1bmN0aW9uKCkge1xuICAvKiBQZXJpb2QgcGFyYW1ldGVycyAqL1xuICB2YXIgTiA9IDYyNDtcbiAgdmFyIE0gPSAzOTc7XG4gIHZhciBNQVRSSVhfQSA9IDB4OTkwOGIwZGY7ICAgICAgLyogY29uc3RhbnQgdmVjdG9yIGEgKi9cbiAgdmFyIFVNQVNLID0gMHg4MDAwMDAwMDsgICAgICAgICAvKiBtb3N0IHNpZ25pZmljYW50IHctciBiaXRzICovXG4gIHZhciBMTUFTSyA9IDB4N2ZmZmZmZmY7ICAgICAgICAgLyogbGVhc3Qgc2lnbmlmaWNhbnQgciBiaXRzICovXG4gIHZhciBNSVhCSVRTID0gZnVuY3Rpb24odSx2KSB7IHJldHVybiAoICgodSkgJiBVTUFTSykgfCAoKHYpICYgTE1BU0spICk7IH07XG4gIHZhciBUV0lTVCA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKE1JWEJJVFMoKHUpLCh2KSkgPj4+IDEpIF4gKCh2ICYgMHgxKSA/IE1BVFJJWF9BIDogMHgwKTsgfTtcblxuICBmdW5jdGlvbiBpbml0KHMpIHtcbiAgICB2YXIgbXQgPSB7bGVmdDogMCwgbmV4dDogTiwgc3RhdGU6IG5ldyBBcnJheShOKX07XG4gICAgaW5pdF9nZW5yYW5kKG10LCBzKTtcbiAgICByZXR1cm4gbXQ7XG4gIH1cblxuICAvKiBpbml0aWFsaXplcyBtdFtOXSB3aXRoIGEgc2VlZCAqL1xuICBmdW5jdGlvbiBpbml0X2dlbnJhbmQobXQsIHMpIHtcbiAgICB2YXIgaiwgaTtcbiAgICBtdC5zdGF0ZVswXSA9IHMgPj4+IDA7XG4gICAgZm9yIChqPTE7IGo8TjsgaisrKSB7XG4gICAgICBtdC5zdGF0ZVtqXSA9ICgxODEyNDMzMjUzICogKChtdC5zdGF0ZVtqLTFdIF4gKG10LnN0YXRlW2otMV0gPj4gMzApID4+PiAwKSkgKyBqKTtcbiAgICAgIC8qIFNlZSBLbnV0aCBUQU9DUCBWb2wyLiAzcmQgRWQuIFAuMTA2IGZvciBtdWx0aXBsaWVyLiAqL1xuICAgICAgLyogSW4gdGhlIHByZXZpb3VzIHZlcnNpb25zLCBNU0JzIG9mIHRoZSBzZWVkIGFmZmVjdCAgICovXG4gICAgICAvKiBvbmx5IE1TQnMgb2YgdGhlIGFycmF5IHN0YXRlW10uICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgIC8qIDIwMDIvMDEvMDkgbW9kaWZpZWQgYnkgTWFrb3RvIE1hdHN1bW90byAgICAgICAgICAgICAqL1xuICAgICAgbXQuc3RhdGVbal0gJj0gMHhmZmZmZmZmZjsgIC8qIGZvciA+MzIgYml0IG1hY2hpbmVzICovXG4gICAgfVxuICAgIG10LmxlZnQgPSAxO1xuICAgIG10Lm5leHQgPSBOO1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgTiB3b3JkcyBhdCBvbmUgdGltZSAqL1xuICBmdW5jdGlvbiBuZXh0X3N0YXRlKG10KSB7XG4gICAgdmFyIHAgPSAwLCBfcCA9IG10LnN0YXRlO1xuICAgIHZhciBqO1xuXG4gICAgbXQubGVmdCA9IE47XG4gICAgbXQubmV4dCA9IDA7XG5cbiAgICBmb3IgKGo9Ti1NKzE7IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wW3ArKDEpXSk7XG5cbiAgICBmb3IgKGo9TTsgLS1qOyBwKyspXG4gICAgICBfcFtwXSA9IF9wW3ArKE0tTildIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbMF0pO1xuICB9XG5cbiAgLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwweGZmZmZmZmZmXS1pbnRlcnZhbCAqL1xuICBmdW5jdGlvbiBnZW5yYW5kX2ludDMyKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciB5O1xuXG4gICAgaWYgKC0tbXQubGVmdCA8PSAwKSBuZXh0X3N0YXRlKG10KTtcbiAgICB5ID0gbXQuc3RhdGVbbXQubmV4dCsrXTtcblxuICAgIC8qIFRlbXBlcmluZyAqL1xuICAgIHkgXj0gKHkgPj4+IDExKTtcbiAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICB5IF49ICh5IDw8IDE1KSAmIDB4ZWZjNjAwMDA7XG4gICAgeSBePSAoeSA+Pj4gMTgpO1xuXG4gICAgcmV0dXJuIHkgPj4+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRfcGFpcl90b19yZWFsX2V4Y2x1c2l2ZShhLCBiKSB7XG4gICAgYSA+Pj49IDU7XG4gICAgYiA+Pj49IDY7XG4gICAgcmV0dXJuKGEqNjcxMDg4NjQuMCtiKSooMS4wLzkwMDcxOTkyNTQ3NDA5OTIuMCk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDEpIHdpdGggNTMtYml0IHJlc29sdXRpb25cbiAgZnVuY3Rpb24gZ2VucmFuZF9yZWFsKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciBhID0gZ2VucmFuZF9pbnQzMihtdCksIGIgPSBnZW5yYW5kX2ludDMyKG10KTtcbiAgICByZXR1cm4gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYik7XG4gIH1cblxuICByZXR1cm4geyBnZW5yYW5kX3JlYWw6IGdlbnJhbmRfcmVhbCwgaW5pdDogaW5pdCB9O1xufSkoKX1cblxuY2xhc3MgOjpSYW5kb21cbiAgYHZhciBNQVhfSU5UID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTWF0aC5wb3coMiwgNTMpIC0gMWBcblxuICBzZWxmOjpNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUiA9IGB7XG4gICAgbmV3X3NlZWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogTUFYX0lOVCk7IH0sXG4gICAgcmVzZWVkOiBmdW5jdGlvbihzZWVkKSB7IHJldHVybiBtZXJzZW5uZV90d2lzdGVyLmluaXQoc2VlZCk7IH0sXG4gICAgcmFuZDogZnVuY3Rpb24obXQpIHsgcmV0dXJuIG1lcnNlbm5lX3R3aXN0ZXIuZ2VucmFuZF9yZWFsKG10KTsgfVxuICB9YFxuXG4gIHNlbGYuZ2VuZXJhdG9yID0gc2VsZjo6TUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1JcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJtZXJzZW5uZV90d2lzdGVyIiwiPGNsYXNzOlJhbmRvbT4iLCJzZWxmIiwiZ2VuZXJhdG9yPSIsInNlbGY6Ok1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0RBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBc0RBQyxtQkFBc0JEO0FBQ3RCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0VBRUFBLE9BQUFFO0VBQUFBOztJQUFBQTs7O0lBQ0dBO0lBRUQsV0FBQUMsSUFBQSxnQ0FBb0NEO0FBQ3RDQTtBQUNBQTtBQUNBQTtBQUNBQSxHQUpFO0lBTUFBLE9BQUlFLE1BQUFBLENBQWFDLElBQUFGLElBQUFFLCtCQUFiRCxDQUFBQSxFQUFBQSxNQUFKRCxJQUFJQyxjQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtFQVRORixHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBeElBRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ0NTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeVxuXG5yZXF1aXJlICdjb3JlbGliL3JhbmRvbS9mb3JtYXR0ZXInXG5cbmNsYXNzIDo6UmFuZG9tXG4gIGF0dHJfcmVhZGVyIDpzZWVkLCA6c3RhdGVcblxuICBkZWYgc2VsZi5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICV4e1xuICAgICAgaWYgKCEkdHJ1dGh5KGNvdW50KSkgY291bnQgPSAxNjtcbiAgICAgIGlmICh0eXBlb2YgY291bnQgIT09IFwibnVtYmVyXCIpIGNvdW50ID0gI3tgY291bnRgLnRvX2ludH07XG4gICAgICBpZiAoY291bnQgPCAwKSAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIHN0cmluZyBzaXplIChvciBzaXplIHRvbyBiaWcpJ307XG4gICAgICBjb3VudCA9IE1hdGguZmxvb3IoY291bnQpO1xuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoc2VlZCA9IDo6UmFuZG9tLm5ld19zZWVkKVxuICAgIHNlZWQgPSA6Ok9wYWwuY29lcmNlX3RvIShzZWVkLCA6OkludGVnZXIsIDp0b19pbnQpXG4gICAgQHN0YXRlID0gc2VlZFxuICAgIHJlc2VlZChzZWVkKVxuICBlbmRcblxuICBkZWYgcmVzZWVkKHNlZWQpXG4gICAgQHNlZWQgPSBzZWVkXG4gICAgYHNlbGYuJHJuZyA9IE9wYWwuJCRyYW5kLnJlc2VlZChzZWVkKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYubmV3X3NlZWRcbiAgICBgT3BhbC4kJHJhbmQubmV3X3NlZWQoKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYucmFuZChsaW1pdCA9IHVuZGVmaW5lZClcbiAgICBzZWxmOjpERUZBVUxULnJhbmQobGltaXQpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnNyYW5kKG4gPSA6OlJhbmRvbS5uZXdfc2VlZClcbiAgICBuID0gOjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgcHJldmlvdXNfc2VlZCA9IHNlbGY6OkRFRkFVTFQuc2VlZFxuICAgIHNlbGY6OkRFRkFVTFQucmVzZWVkKG4pXG4gICAgcHJldmlvdXNfc2VlZFxuICBlbmRcblxuICBkZWYgc2VsZi51cmFuZG9tKHNpemUpXG4gICAgOjpTZWN1cmVSYW5kb20uYnl0ZXMoc2l6ZSlcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgOjpSYW5kb20gPT09IG90aGVyXG5cbiAgICBzZWVkID09IG90aGVyLnNlZWQgJiYgc3RhdGUgPT0gb3RoZXIuc3RhdGVcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzKGxlbmd0aClcbiAgICBsZW5ndGggPSA6OlJhbmRvbS5fdmVyaWZ5X2NvdW50KGxlbmd0aClcblxuICAgIDo6QXJyYXkubmV3KGxlbmd0aCkgeyByYW5kKDI1NSkuY2hyIH0uam9pbi5lbmNvZGUoJ0FTQ0lJLThCSVQnKVxuICBlbmRcblxuICBkZWYgc2VsZi5ieXRlcyhsZW5ndGgpXG4gICAgc2VsZjo6REVGQVVMVC5ieXRlcyhsZW5ndGgpXG4gIGVuZFxuXG4gIGRlZiByYW5kKGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgIHJhbmRvbV9udW1iZXIobGltaXQpXG4gIGVuZFxuXG4gICMgTm90IHBhcnQgb2YgdGhlIFJ1YnkgaW50ZXJmYWNlICh1c2UgI3JhbmRvbV9udW1iZXIgZm9yIHBvcnRhYmlsaXR5KSwgYnV0XG4gICMgdXNlZCBieSBSYW5kb206OkZvcm1hdHRlciBhcyBhIHNob3J0Y3V0LCBhcyBmb3IgUmFuZG9tIGludGVyZmFjZSB0aGUgZmxvYXRcbiAgIyBSTkcgaXMgcHJpbWFyeS5cbiAgZGVmIHJhbmRvbV9mbG9hdFxuICAgICV4e1xuICAgICAgc2VsZi5zdGF0ZSsrO1xuICAgICAgcmV0dXJuIE9wYWwuJCRyYW5kLnJhbmQoc2VsZi4kcm5nKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJhbmRvbV9mbG9hdFxuICAgIHNlbGY6OkRFRkFVTFQucmFuZG9tX2Zsb2F0XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdlbmVyYXRvcj0oZ2VuZXJhdG9yKVxuICAgIGBPcGFsLiQkcmFuZCA9ICN7Z2VuZXJhdG9yfWBcblxuICAgIGlmIGNvbnN0X2RlZmluZWQ/IDpERUZBVUxUXG4gICAgICBzZWxmOjpERUZBVUxULnJlc2VlZFxuICAgIGVsc2VcbiAgICAgIGNvbnN0X3NldCA6REVGQVVMVCwgbmV3KG5ld19zZWVkKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5yZXF1aXJlICdjb3JlbGliL3JhbmRvbS9tZXJzZW5uZV90d2lzdGVyJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpSYW5kb20+IiwiYXR0cl9yZWFkZXIiLCJfdmVyaWZ5X2NvdW50IiwiY291bnQiLCJ0b19pbnQiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJpbml0aWFsaXplIiwic2VlZCIsIlJhbmRvbSIsIm5ld19zZWVkIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiQHN0YXRlIiwicmVzZWVkIiwiQHNlZWQiLCJyYW5kIiwibGltaXQiLCJzZWxmOjpERUZBVUxUIiwic3JhbmQiLCJuIiwicHJldmlvdXNfc2VlZCIsInVyYW5kb20iLCJzaXplIiwiU2VjdXJlUmFuZG9tIiwiYnl0ZXMiLCI9PSIsIm90aGVyIiwiJHJldF9vcl8xIiwic3RhdGUiLCJsZW5ndGgiLCJuZXciLCJBcnJheSIsImJsb2NrIGluIGJ5dGVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBieXRlcyIsIjI1NSIsImNociIsImpvaW4iLCJlbmNvZGUiLCJyYW5kb21fbnVtYmVyIiwicmFuZG9tX2Zsb2F0IiwiZ2VuZXJhdG9yPSIsImdlbmVyYXRvciIsImNvbnN0X2RlZmluZWQ/IiwiY29uc3Rfc2V0Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLDBCQUFSRTtFQUVBQztFQUFBQTs7OztJQUNFRixJQUFBRyxhQUFBQSxDQUFZLE1BQVosRUFBbUIsT0FBbkJBO0lBRUFDLE1BQUlKLElBQUpJLG9CQUFBQSx5QkFBdUJDLEtBQXZCRDtBQUFBQTs7QUFFRkE7QUFDQUEsNkNBQStDQSxDQUFDQSxLQUFEQSxDQUFPRSxRQUFBQSxDQUFBQSxDQUFRRjtBQUM5REEscUJBQXVCRyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixF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QTtBQUNBQTtBQUNBQTtJQUpFQSxDQUFBQTtJQU9BQSxNQUFJNUMsSUFBSjRDLG1CQUFBQSx3QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF0QixJQUFBdEIsSUFBQXNCLFlBQWFzQixjQUFBQSxDQUFBQTtJQURmQSxDQUFBQTtJQUlBMUMsT0FBQTJDLE1BQUk3QyxJQUFKNkMsaUJBQUFBLGdDQUFvQkMsU0FBcEJEO0FBQUFBLE1BQUFBOzs7TUFDR0EsY0FBZ0JDO01BRWpCLElBQUEsUUFBRzlDLElBQUErQyxtQkFBQUEsQ0FBZSxTQUFmQSxDQUFILENBQUE7UUFDRUYsT0FBQXZCLElBQUF0QixJQUFBc0IsWUFBYUosUUFBQUEsQ0FBQUE7TUFEZjtRQUdFMkIsT0FBQTdDLElBQUFnRCxXQUFBQSxDQUFVLFNBQVYsRUFBb0JoRCxJQUFBbUMsS0FBQUEsQ0FBSW5DLElBQUFhLFVBQUFBLENBQUFBLENBQUpzQixDQUFwQmE7TUFIRjtJQUhGSCxDQUFBQTtFQTlFRjNDLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUF5RkFILE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLGlDQUFSRTtBQTdGQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NTgzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi91bnN1cHBvcnRlZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgdmFyIHdhcm5pbmdzID0ge307XG5cbiAgZnVuY3Rpb24gaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUobWVzc2FnZSkge1xuICAgIHN3aXRjaCAoT3BhbC5jb25maWcudW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHkpIHtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICAjezo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvciwgYG1lc3NhZ2VgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd2FybmluZyc6XG4gICAgICB3YXJuKG1lc3NhZ2UpXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiAvLyBpZ25vcmVcbiAgICAgIC8vIG5vb3BcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKHN0cmluZykge1xuICAgIGlmICh3YXJuaW5nc1tzdHJpbmddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmluZ3Nbc3RyaW5nXSA9IHRydWU7XG4gICAgI3t3YXJuKGBzdHJpbmdgKX07XG4gIH1cbn1cblxuY2xhc3MgOjpTdHJpbmdcbiAgYHZhciBFUlJPUiA9IFwiU3RyaW5nIyVzIG5vdCBzdXBwb3J0ZWQuIE11dGFibGUgU3RyaW5nIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gT3BhbC5cImBcblxuICAlaVtcbiAgICA8PCBjYXBpdGFsaXplISBjaG9tcCEgY2hvcCEgZG93bmNhc2UhIGdzdWIhIGxzdHJpcCEgbmV4dCEgcmV2ZXJzZSFcbiAgICBzbGljZSEgc3F1ZWV6ZSEgc3RyaXAhIHN1YiEgc3VjYyEgc3dhcGNhc2UhIHRyISB0cl9zISB1cGNhc2UhIHByZXBlbmRcbiAgICBbXT0gY2xlYXIgZW5jb2RlISB1bmljb2RlX25vcm1hbGl6ZSFcbiAgXS5lYWNoIGRvIHxtZXRob2RfbmFtZXxcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZF9uYW1lIGRvIHwqfFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgbWV0aG9kX25hbWVcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIDo6S2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCB0YWludGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgdGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVudGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRhaW50ZWQ/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6Ok1vZHVsZVxuICBkZWYgcHVibGljKCptZXRob2RzKVxuICAgICV4e1xuICAgICAgaWYgKG1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRtb2R1bGVfZnVuY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHM7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJpdmF0ZV9jbGFzc19tZXRob2QoKm1ldGhvZHMpXG4gICAgYHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHNgXG4gIGVuZFxuXG4gIGRlZiBwcml2YXRlX21ldGhvZF9kZWZpbmVkPyhvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfY29uc3RhbnQoKilcbiAgZW5kXG5cbiAgYWxpYXMgbmVzdGluZyBwdWJsaWNcbiAgYWxpYXMgcHJpdmF0ZSBwdWJsaWNcbiAgYWxpYXMgcHJvdGVjdGVkIHB1YmxpY1xuICBhbGlhcyBwcm90ZWN0ZWRfbWV0aG9kX2RlZmluZWQ/IHByaXZhdGVfbWV0aG9kX2RlZmluZWQ/XG4gIGFsaWFzIHB1YmxpY19jbGFzc19tZXRob2QgcHJpdmF0ZV9jbGFzc19tZXRob2RcbiAgYWxpYXMgcHVibGljX2luc3RhbmNlX21ldGhvZCBpbnN0YW5jZV9tZXRob2RcbiAgYWxpYXMgcHVibGljX2luc3RhbmNlX21ldGhvZHMgaW5zdGFuY2VfbWV0aG9kc1xuICBhbGlhcyBwdWJsaWNfbWV0aG9kX2RlZmluZWQ/IG1ldGhvZF9kZWZpbmVkP1xuZW5kXG5cbm1vZHVsZSA6Oktlcm5lbFxuICBkZWYgcHJpdmF0ZV9tZXRob2RzKCptZXRob2RzKVxuICAgIFtdXG4gIGVuZFxuXG4gIGFsaWFzIHByb3RlY3RlZF9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xuICBhbGlhcyBwcml2YXRlX2luc3RhbmNlX21ldGhvZHMgcHJpdmF0ZV9tZXRob2RzXG4gIGFsaWFzIHByb3RlY3RlZF9pbnN0YW5jZV9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xuZW5kXG5cbm1vZHVsZSA6Oktlcm5lbFxuICBkZWYgZXZhbCgqKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvciwgXCJUbyB1c2UgS2VybmVsI2V2YWwsIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ29wYWwtcGFyc2VyJy4gXCJcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9ibG9iLyN7UlVCWV9FTkdJTkVfVkVSU0lPTn0vZG9jcy9vcGFsX3BhcnNlci5tZCBmb3IgZGV0YWlscy5cIlxuICBlbmRcbmVuZFxuXG5kZWYgc2VsZi5wdWJsaWMoKm1ldGhvZHMpXG4gIGByZXR1cm4gKG1ldGhvZHMubGVuZ3RoID09PSAxKSA/IG1ldGhvZHNbMF0gOiBtZXRob2RzYFxuZW5kXG5cbmRlZiBzZWxmLnByaXZhdGUoKm1ldGhvZHMpXG4gIGByZXR1cm4gKG1ldGhvZHMubGVuZ3RoID09PSAxKSA/IG1ldGhvZHNbMF0gOiBtZXRob2RzYFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIktlcm5lbCIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsInNlbGYiLCJ3YXJuIiwiPGNsYXNzOlN0cmluZz4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOlN0cmluZz4iLCJtZXRob2RfbmFtZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOlN0cmluZz4iLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6U3RyaW5nPiIsIiUiLCI8bW9kdWxlOktlcm5lbD4iLCJ0YWludCIsInVudGFpbnQiLCJ0YWludGVkPyIsIjxjbGFzczpNb2R1bGU+IiwicHVibGljIiwicHJpdmF0ZV9jbGFzc19tZXRob2QiLCJwcml2YXRlX21ldGhvZF9kZWZpbmVkPyIsInByaXZhdGVfY29uc3RhbnQiLCJwcml2YXRlX21ldGhvZHMiLCJldmFsIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsInByaXZhdGUiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7O0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxNQUFRQyxPQUFRQyxPQUFBQSxDQUFPQywwQkFBZixFQUF1Q0gsT0FBL0JFO0FBQ2hCRjtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLElBQU1JLElBQUFDLE1BQUFBLENBQU1MLE1BQU5LLENBQWVMO0FBQ3JCQTs7RUFHQU07RUFBQUE7Ozs7SUFDR0E7SUFFREEsT0FJQ0MsTUFKRCxDQUNFLElBREYsRUFDSyxhQURMLEVBQ2lCLFFBRGpCLEVBQ3dCLE9BRHhCLEVBQzhCLFdBRDlCLEVBQ3dDLE9BRHhDLEVBQzhDLFNBRDlDLEVBQ3NELE9BRHRELEVBQzRELFVBRDVELEVBRUUsUUFGRixFQUVTLFVBRlQsRUFFa0IsUUFGbEIsRUFFeUIsTUFGekIsRUFFOEIsT0FGOUIsRUFFb0MsV0FGcEMsRUFFOEMsS0FGOUMsRUFFa0QsT0FGbEQsRUFFd0QsU0FGeEQsRUFFZ0UsU0FGaEUsRUFHRSxLQUhGLEVBR00sT0FITixFQUdZLFNBSFosRUFHb0Isb0JBSHBCLENBSUNBLFFBQUFBLEVBQUFBLEVBQUFBLEVBSkRDLG1CQUlXQyxXQUpYRCxFQUFBRTs7O01BSVc7TUFDVEEsT0FBQUMsTUFBQVAsSUFBQU8saUJBQUFBLEVBQUFBLENBQWNGLFdBQWRFLENBQUFBLEVBQUFELGFBbENKLEVBa0NJQSxFQUFBRTs7O1FBbENKO1FBa0NrQztRQUM1QkEsT0FBQVgsT0FBUUMsT0FBQUEsQ0FBT0MsMEJBQWYsRUFBc0NTLENBQUNBLEtBQURBLENBQVFDLE1BQUFBLENBQUVKLFdBQUZJLENBQXRDWCxFQURWUSxDQUFBQSxJQUFBQyxFQUxGSCxDQUFBQSxHQUFBQSxTQUFBQSxDQUlDRDtFQVBIRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0VBY0FRO0VBQUFBOzs7O0lBQ0dBOztBQUVEQyxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDR0E7TUFDREEsT0FBQVg7SUFGRlcsQ0FBQUE7O0FBS0FDLElBQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNHQTtNQUNEQSxPQUFBWjtJQUZGWSxDQUFBQTtJQUtBRixPQUFBRyx3QkFBQUEsZ0NBQUFBO0FBQUFBOztNQUNHQTtNQUNEQSxPQUFBO0lBRkZBLENBQUFBO0VBYkZILEdBQU8sSUFBUEE7RUFtQkFJO0VBQUFBOzs7OztBQUNFQyxJQUFBQSxzQkFBQUEsMEJBNURGLEVBNERFQTtBQUFBQSxNQUFBQTs7O01BNURGO01BNERhOztBQUViQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVBFQSxDQUFBQSxJQUFBQTs7QUFVQUMsSUFBQUEsb0NBQUFBLGdDQXRFRixFQXNFRUE7QUFBQUEsTUFBQUE7OztNQXRFRjtNQXNFMkI7TUFDdEJBLG9EQUFEQTtJQURGQSxDQUFBQSxJQUFBQTs7QUFJQUMsSUFBQUEsdUNBQUFBLFlBQ0UsS0FERkEsQ0FBQUE7O0FBSUFDLElBQUFBLGdDQUFBQSw0QkE5RUYsRUE4RUVBO0FBQUFBLE1BQUFBOzs7TUE5RUY7TUE4RXVCO01BOUV2QkEsT0FBQTtJQThFRUEsQ0FBQUEsSUFBQUE7SUFHQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0lBQ0EsYUFBTSxTQUFOLEVBQWMsUUFBZDtJQUNBLGFBQU0sV0FBTixFQUFnQixRQUFoQjtJQUNBLGFBQU0sMkJBQU4sRUFBZ0MseUJBQWhDO0lBQ0EsYUFBTSxxQkFBTixFQUEwQixzQkFBMUI7SUFDQSxhQUFNLHdCQUFOLEVBQTZCLGlCQUE3QjtJQUNBLGFBQU0seUJBQU4sRUFBOEIsa0JBQTlCO0lBQ0FKLE9BQUEsYUFBTSx3QkFBTixFQUE2QixpQkFBN0I7RUE3QkZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUFnQ0FKO0VBQUFBOzs7OztBQUNFUyxJQUFBQSwrQkFBQUEsMkJBNUZGLEVBNEZFQTtBQUFBQSxNQUFBQTs7O01BNUZGO01BNEZzQjtNQUNsQkEsT0FBQTtJQURGQSxDQUFBQSxJQUFBQTtJQUlBLGFBQU0sbUJBQU4sRUFBd0IsaUJBQXhCO0lBQ0EsYUFBTSwwQkFBTixFQUErQixpQkFBL0I7SUFDQVQsT0FBQSxhQUFNLDRCQUFOLEVBQWlDLGlCQUFqQztFQVBGQSxHQUFPLElBQVBBO0VBVUFBO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQVUsb0JBQUFBLHdCQXRHRixFQXNHRUE7QUFBQUEsTUFBQUE7OztNQXRHRjtNQXNHVztNQUNQQSxPQUFBdkIsT0FBUUMsT0FBQUEsQ0FBT0MsMEJBQWYsRUFBc0NxQiw0REFBQSxHQUFBLENBQ0NBLHdDQUFELEdBQUEsQ0FBeUNDLHlCQUF6QyxDQUFBLEdBQTZERCxtQ0FEN0QsQ0FBOUJ0QjtJQURWc0IsQ0FBQUEsSUFBQUE7RUFERlYsR0FBTyxJQUFQQTtFQU9BSyxNQUFJZixJQUFKZSxhQUFBQSxtQkE1R0EsRUE0R0FBO0FBQUFBLElBQUFBOzs7SUE1R0E7SUE0R2dCO0lBQ2JBLG9EQUFEQTtFQURGQSxDQUFBQSxJQUFBQTtFQUlBbkIsT0FBQTBCLE1BQUl0QixJQUFKc0IsY0FBQUEsb0JBaEhBLEVBZ0hBQTtBQUFBQSxJQUFBQTs7O0lBaEhBO0lBZ0hpQjtJQUNkQSxvREFBREE7RUFERkEsQ0FBQUEsSUFBQUE7QUFoSEExQjsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ3NTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2JpbmRpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpCaW5kaW5nXG4gICMgQHByaXZhdGVcbiAgZGVmIGluaXRpYWxpemUoanNldmFsLCBzY29wZV92YXJpYWJsZXMgPSBbXSwgcmVjZWl2ZXIgPSB1bmRlZmluZWQsIHNvdXJjZV9sb2NhdGlvbiA9IG5pbClcbiAgICBAanNldmFsLCBAc2NvcGVfdmFyaWFibGVzLCBAcmVjZWl2ZXIsIEBzb3VyY2VfbG9jYXRpb24gPSBcXFxuICAgICAganNldmFsLCBzY29wZV92YXJpYWJsZXMsIHJlY2VpdmVyLCBzb3VyY2VfbG9jYXRpb25cbiAgICByZWNlaXZlciA9IGpzX2V2YWwoJ3NlbGYnKSB1bmxlc3MgYHR5cGVvZiByZWNlaXZlciAhPT0gdW5kZWZpbmVkYFxuICBlbmRcblxuICBkZWYganNfZXZhbCgqYXJncylcbiAgICBpZiBAanNldmFsXG4gICAgICBAanNldmFsLmNhbGwoKmFyZ3MpXG4gICAgZWxzZVxuICAgICAgOjpLZXJuZWwucmFpc2UgJ0V2YWx1YXRpb24gb24gYSBQcm9jI2JpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGxvY2FsX3ZhcmlhYmxlX2dldChzeW1ib2wpXG4gICAganNfZXZhbChzeW1ib2wpXG4gIHJlc2N1ZSA6OkV4Y2VwdGlvblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcImxvY2FsIHZhcmlhYmxlIGAje3N5bWJvbH0nIGlzIG5vdCBkZWZpbmVkIGZvciAje2luc3BlY3R9XCJcbiAgZW5kXG5cbiAgZGVmIGxvY2FsX3ZhcmlhYmxlX3NldChzeW1ib2wsIHZhbHVlKVxuICAgIGBPcGFsLkJpbmRpbmcudG1wX3ZhbHVlID0gdmFsdWVgXG4gICAganNfZXZhbChcIiN7c3ltYm9sfSA9IE9wYWwuQmluZGluZy50bXBfdmFsdWVcIilcbiAgICBgZGVsZXRlIE9wYWwuQmluZGluZy50bXBfdmFsdWVgXG4gICAgdmFsdWVcbiAgZW5kXG5cbiAgZGVmIGxvY2FsX3ZhcmlhYmxlc1xuICAgIEBzY29wZV92YXJpYWJsZXNcbiAgZW5kXG5cbiAgZGVmIGxvY2FsX3ZhcmlhYmxlX2RlZmluZWQ/KHZhbHVlKVxuICAgIEBzY29wZV92YXJpYWJsZXMuaW5jbHVkZT8odmFsdWUpXG4gIGVuZFxuXG4gIGRlZiBldmFsKHN0ciwgZmlsZSA9IG5pbCwgbGluZSA9IG5pbClcbiAgICByZXR1cm4gcmVjZWl2ZXIgaWYgc3RyID09ICdzZWxmJ1xuXG4gICAgOjpLZXJuZWwuZXZhbChzdHIsIHNlbGYsIGZpbGUsIGxpbmUpXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpyZWNlaXZlciwgOnNvdXJjZV9sb2NhdGlvblxuZW5kXG5cbm1vZHVsZSA6Oktlcm5lbFxuICBkZWYgYmluZGluZ1xuICAgIDo6S2VybmVsLnJhaXNlIFwiT3BhbCBkb2Vzbid0IHN1cHBvcnQgZHluYW1pYyBjYWxscyB0byBiaW5kaW5nXCJcbiAgZW5kXG5lbmRcblxuVE9QTEVWRUxfQklORElORyA9IDo6QmluZGluZy5uZXcoXG4gICV4e1xuICAgIGZ1bmN0aW9uKGpzKSB7XG4gICAgICByZXR1cm4gKG5ldyBGdW5jdGlvbihcInNlbGZcIiwgXCJyZXR1cm4gXCIgKyBqcykpKHNlbGYpO1xuICAgIH1cbiAgfSxcbiAgW10sIHNlbGYsIFsnPG1haW4+JywgMF1cbilcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJpbmRpbmc+IiwiaW5pdGlhbGl6ZSIsImpzZXZhbCIsInNjb3BlX3ZhcmlhYmxlcyIsInJlY2VpdmVyIiwic291cmNlX2xvY2F0aW9uIiwiQGpzZXZhbCIsIkBzY29wZV92YXJpYWJsZXMiLCJAcmVjZWl2ZXIiLCJAc291cmNlX2xvY2F0aW9uIiwic2VsZiIsImpzX2V2YWwiLCJjYWxsIiwiYXJncyIsIktlcm5lbCIsInJhaXNlIiwibG9jYWxfdmFyaWFibGVfZ2V0Iiwic3ltYm9sIiwiRXhjZXB0aW9uIiwiTmFtZUVycm9yIiwiaW5zcGVjdCIsImxvY2FsX3ZhcmlhYmxlX3NldCIsInZhbHVlIiwibG9jYWxfdmFyaWFibGVzIiwibG9jYWxfdmFyaWFibGVfZGVmaW5lZD8iLCJpbmNsdWRlPyIsImV2YWwiLCJzdHIiLCJmaWxlIiwibGluZSIsImF0dHJfcmVhZGVyIiwiPG1vZHVsZTpLZXJuZWw+IiwiYmluZGluZyIsIkJpbmRpbmciLCJuZXciLCIwIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7OztBQUVFQyxJQUFBQSwwQkFBQUEsc0JBQWVDLE1BQUQsRUFBU0MsZUFBVCxFQUErQkMsUUFBL0IsRUFBcURDLGVBQW5FSjtBQUFBQSxNQUFBQTs7O01BQXVCLCtDQUFrQjs7TUFBMEIsK0NBQWtCO01BQ25GLEtBQ0UsQ0FBQUMsTUFBQSxFQUFRQyxlQUFSLEVBQXlCQyxRQUF6QixFQUFtQ0MsZUFBbkMsQ0FERixFQUFBQyxDQUFBQSxjQUFBLEtBQUFBLENBQUEsRUFBU0MsQ0FBQUEsdUJBQVQsS0FBU0EsQ0FBVCxFQUEyQkMsQ0FBQUEsZ0JBQTNCLEtBQTJCQSxDQUEzQixFQUFzQ0MsQ0FBQUEsdUJBQXRDLEtBQXNDQSxDQUF0QztNQUVBLElBQUEsUUFBbUNSLDZCQUFuQyxDQUFBO1FBTEpBLE9BQUE7TUFLSTtRQUFBQSxPQUFBRyxDQUFBQSxXQUFXTSxJQUFBQyxTQUFBQSxDQUFRVixNQUFSVSxDQUFYUDtNQUFBO0lBSEZILENBQUFBLElBQUFBOztBQU1BVSxJQUFBQSx1QkFBQUEsbUJBUkYsRUFRRUE7QUFBQUEsTUFBQUE7OztNQVJGO01BUWM7TUFDVixJQUFBLFFBQUdMLFdBQUgsQ0FBQTtRQUNFSyxPQUFPQyxNQUFQTixXQUFPTSxRQUFBQSxFQUFNLE1BQUNDLElBQUQsQ0FBTkQ7TUFEVDtRQUdFRCxPQUFBRyxPQUFRQyxPQUFBQSxDQUFPSiwrQ0FBUEk7TUFIVjtJQURGSixDQUFBQSxJQUFBQTs7QUFRQUssSUFBQUEsa0NBQUFBLDhCQUF1QkMsTUFBdkJEO0FBQUFBLE1BQUFBOztNQUNFO1FBQUFBLE9BQUFOLElBQUFDLFNBQUFBLENBQVFNLE1BQVJOO01BQUE7UUFDRixzQkFBTyxDQUFBTyxnQkFBQSxDQUFQO1VBQUE7WUFDRUYsT0FBQUYsT0FBUUMsT0FBQUEsQ0FBT0ksZ0JBQWYsRUFBNkJILGtCQUFELEdBQUEsQ0FBbUJDLE1BQW5CLENBQUEsR0FBMEJELHVCQUExQixHQUFBLENBQWlETixJQUFBVSxTQUFBQSxDQUFBQSxDQUFqRCxDQUFwQkw7VUFEVjtRQUFBLENBREU7TUFBQTtJQURGQyxDQUFBQTs7QUFNQUssSUFBQUEsa0NBQUFBLDhCQUF1QkosTUFBRCxFQUFTSyxLQUEvQkQ7QUFBQUEsTUFBQUE7OztNQUNHQTtNQUNEWCxJQUFBQyxTQUFBQSxDQUFRLEVBQUEsR0FBQSxDQUFHTSxNQUFILENBQUEsR0FBVUksMkJBQWxCVjtNQUNDVTtNQUNEQSxPQUFBQztJQUpGRCxDQUFBQTs7QUFPQUUsSUFBQUEsK0JBQUFBLGFBQ0UsaUJBREZBLENBQUFBOztBQUlBQyxJQUFBQSx1Q0FBQUEsZ0RBQTRCRixLQUE1QkU7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFqQixvQkFBZ0JrQixhQUFBQSxDQUFVSCxLQUFWRztJQURsQkQsQ0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSx5QkFBU0MsR0FBRCxFQUFNQyxJQUFOLEVBQWtCQyxJQUExQkgsR0FBQUEsTUFBQUEsSUFBQUEsd0NBQUFBO0FBQUFBLE1BQUFBOzs7TUFBYyx5QkFBTztNQUFLLHlCQUFPO01BQy9CLElBQUEsTUFBbUJDLEdBQW5CLEVBQTBCRCxNQUExQixDQUFBO1FBQUEsT0FBT2hCLElBQUFOLFVBQUFBLENBQUFBO01BQVA7TUFFQXNCLE9BQUFaLE9BQVFZLE1BQUFBLENBQU1DLEdBQWQsRUFBbUJqQixJQUFuQixFQUF5QmtCLElBQXpCLEVBQStCQyxJQUF2QkgsRUFIVkE7UUFBQUE7UUFBQUE7TUFBQUE7SUFBQUEsQ0FBQUEsSUFBQUE7SUFNQTFCLE9BQUFVLElBQUFvQixhQUFBQSxDQUFZLFVBQVosRUFBdUIsaUJBQXZCQTtFQTNDRjlCLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUE4Q0ErQjtFQUFBQTs7O0lBQ0VBLE9BQUFDLHVCQUFBQSxtQkFBQUE7QUFBQUE7TUFDRUEsT0FBQWxCLE9BQVFDLE9BQUFBLENBQU9pQiwrQ0FBUGpCO0lBRFZpQixDQUFBQTtFQURGRCxHQUFPLElBQVBBO0VBTUFoQyxPQUFBLDRDQUFtQmtDLGNBQVNDLEtBQUFBO0FBRTVCbkM7QUFDQUE7QUFDQUE7QUFDQUEsRUFMbUIsRUFNakIsRUFOaUIsRUFNYlcsSUFOYSxFQU1QLENBQUNYLFFBQUQsRUFBV29DLENBQVgsQ0FOZ0JELENBQTVCO0FBcERBbkM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0ODYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pcmIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBEZWJ1ZyBpcyBhIGhlbHBlciBtb2R1bGUgdGhhdCBhbGxvd3MgdXMgdG8gY29uZHVjdCBzb21lIGRlYnVnZ2luZyBvblxuIyBhIGxpdmUgY29kZWJhc2UuIEl0IGdvZXMgd2l0aCBhbiBhc3N1bXB0aW9uLCB0aGF0IG9wYWwtcGFyc2VyIG9yXG4jIG9wYWwtcmVwbHV0aWxzIHdpbGwgbm90IGJlIGxvYWRlZCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGRvIHdoYXQgd2UgY2FuXG4jIHRvIHByb3Zpc2lvbiBpdC5cblxubW9kdWxlIE9wYWxcbiAgbW9kdWxlIElSQlxuICAgIGRlZiBzZWxmLmVuc3VyZV9sb2FkZWQobGlicmFyeSlcbiAgICAgIHJldHVybiBpZiBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgLmluY2x1ZGU/IGxpYnJhcnlcblxuICAgICAgdmVyc2lvbiA9IGlmIFJVQllfRU5HSU5FX1ZFUlNJT04uaW5jbHVkZT8gJ2RldidcbiAgICAgICAgICAgICAgICAgICdtYXN0ZXInXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgUlVCWV9FTkdJTkVfVkVSU0lPTlxuICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICB1cmwgPSBcImh0dHBzOi8vY2RuLm9wYWxyYi5jb20vb3BhbC8je3ZlcnNpb259LyN7bGlicmFyeX0uanNcIlxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIGxpYmNvZGU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlclxuICAgICAgICAgIHZhciByID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgci5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpO1xuICAgICAgICAgIHIuc2VuZCgnJyk7XG4gICAgICAgICAgbGliY29kZSA9IHIucmVzcG9uc2VUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgXCJZb3UgbmVlZCB0byBwcm92aXNpb24gI3tsaWJyYXJ5fSB5b3Vyc2VsZiBpbiB0aGlzIGVudmlyb25tZW50XCJ9XG4gICAgICAgIH1cblxuICAgICAgICAobmV3IEZ1bmN0aW9uKCdPcGFsJywgbGliY29kZSkpKE9wYWwpO1xuXG4gICAgICAgIE9wYWwucmVxdWlyZShsaWJyYXJ5KTtcbiAgICAgIH1cblxuICAgICAgOjpLZXJuZWwucmFpc2UgXCJDb3VsZCBub3QgbG9hZCAje2xpYnJhcnl9IGZvciBzb21lIHJlYXNvblwiIHVubGVzcyBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgLmluY2x1ZGU/IGxpYnJhcnlcbiAgICBlbmRcblxuICAgIHNpbmdsZXRvbl9jbGFzcy5hdHRyX2FjY2Vzc29yIDpvdXRwdXRcblxuICAgIGRlZiBzZWxmLnByZXBhcmVfY29uc29sZSgmYmxvY2spXG4gICAgICBzZWxmLm91dHB1dCA9ICcnXG5cbiAgICAgIG9yaWdpbmFsID0ge1xuICAgICAgICAkc3Rkb3V0ID0+IC0+KGkpIHsgJHN0ZG91dCA9IGkgfSxcbiAgICAgICAgJHN0ZGVyciA9PiAtPihpKSB7ICRzdGRlcnIgPSBpIH0sXG4gICAgICB9XG5cbiAgICAgICMgUHJlcGFyZSBhIGJldHRlciBwcm9tcHQgZXhwZXJpZW5jZSBmb3IgYSBicm93c2VyXG4gICAgICBpZiBicm93c2VyP1xuICAgICAgICBvcmlnaW5hbC5lYWNoIGRvIHxwaXBlLCBwaXBlX3NldHRlcnxcbiAgICAgICAgICBuZXdfcGlwZSA9IHBpcGUuZHVwXG4gICAgICAgICAgbmV3X3BpcGUud3JpdGVfcHJvYyA9IHByb2MgZG8gfHN0cnxcbiAgICAgICAgICAgIHNlbGYub3V0cHV0ICs9IHN0clxuICAgICAgICAgICAgc2VsZi5vdXRwdXQgPSBvdXRwdXQuc3BsaXQoXCJcXG5cIikubGFzdCgzMCkuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgc2VsZi5vdXRwdXQgKz0gXCJcXG5cIiBpZiBzdHIuZW5kX3dpdGg/IFwiXFxuXCJcblxuICAgICAgICAgICAgcGlwZS53cml0ZV9wcm9jLmNhbGwoc3RyKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIG5ld19waXBlLnR0eSA9IGZhbHNlXG4gICAgICAgICAgcGlwZV9zZXR0ZXIuY2FsbChuZXdfcGlwZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgb3JpZ2luYWxfcmVhZF9wcm9jID0gJHN0ZGluLnJlYWRfcHJvY1xuICAgICAgICAkc3RkaW4ucmVhZF9wcm9jID0gYGZ1bmN0aW9uKHMpIHsgdmFyIHAgPSBwcm9tcHQoI3tvdXRwdXR9KTsgaWYgKHAgIT09IG51bGwpIHJldHVybiBwICsgXCJcXG5cIjsgcmV0dXJuIG5pbDsgfWBcbiAgICAgIGVuZFxuXG4gICAgICB5aWVsZFxuICAgIGVuc3VyZVxuICAgICAgb3JpZ2luYWwuZWFjaCBkbyB8cGlwZSwgcGlwZV9zZXR0ZXJ8XG4gICAgICAgIHBpcGVfc2V0dGVyLmNhbGwocGlwZSlcbiAgICAgIGVuZFxuICAgICAgJHN0ZGluLnJlYWRfcHJvYyA9IG9yaWdpbmFsX3JlYWRfcHJvY1xuICAgICAgc2VsZi5vdXRwdXQgPSAnJ1xuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuYnJvd3Nlcj9cbiAgICAgIGB0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YocHJvbXB0KSAhPT0gJ3VuZGVmaW5lZCdgXG4gICAgZW5kXG5cbiAgICBMSU5FQlJFQUtTID0gW1xuICAgICAgJ3VuZXhwZWN0ZWQgdG9rZW4gJGVuZCcsXG4gICAgICAndW50ZXJtaW5hdGVkIHN0cmluZyBtZWV0cyBlbmQgb2YgZmlsZSdcbiAgICBdLmZyZWV6ZVxuXG4gICAgY2xhc3MgU2lsZW5jZXJcbiAgICAgIGRlZiBpbml0aWFsaXplXG4gICAgICAgIEBzdGRlcnIgPSAkc3RkZXJyXG4gICAgICBlbmRcblxuICAgICAgZGVmIHNpbGVuY2VcbiAgICAgICAgQGNvbGxlY3RvciA9IDo6U3RyaW5nSU8ubmV3XG4gICAgICAgICRzdGRlcnIgPSBAY29sbGVjdG9yXG4gICAgICAgIHlpZWxkXG4gICAgICBlbnN1cmVcbiAgICAgICAgJHN0ZGVyciA9IEBzdGRlcnJcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgd2FybmluZ3NcbiAgICAgICAgQGNvbGxlY3Rvci5zdHJpbmdcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OkJpbmRpbmdcbiAgZGVmIGlyYlxuICAgIDo6T3BhbDo6SVJCLmVuc3VyZV9sb2FkZWQoJ29wYWwtcmVwbHV0aWxzJylcblxuICAgIHNpbGVuY2VyID0gOjpPcGFsOjpJUkI6OlNpbGVuY2VyLm5ld1xuXG4gICAgOjpPcGFsOjpJUkIucHJlcGFyZV9jb25zb2xlIGRvXG4gICAgICBsb29wIGRvXG4gICAgICAgIHByaW50ICc+PiAnXG4gICAgICAgIGxpbmUgPSBnZXRzXG4gICAgICAgIGJyZWFrIHVubGVzcyBsaW5lXG4gICAgICAgIGNvZGUgPSAnJ1xuXG4gICAgICAgIHB1dHMgbGluZSBpZiA6Ok9wYWw6OklSQi5icm93c2VyP1xuXG4gICAgICAgIGlmIGxpbmUuc3RhcnRfd2l0aD8gJ2xzICdcbiAgICAgICAgICBjb2RlID0gbGluZVszLi4tMV1cbiAgICAgICAgICBtb2RlID0gOmxzXG4gICAgICAgIGVsc2lmIGxpbmUgPT0gXCJsc1xcblwiXG4gICAgICAgICAgY29kZSA9ICdzZWxmJ1xuICAgICAgICAgIG1vZGUgPSA6bHNcbiAgICAgICAgZWxzaWYgbGluZS5zdGFydF93aXRoPyAnc2hvdyAnXG4gICAgICAgICAgY29kZSA9IGxpbmVbNS4uLTFdXG4gICAgICAgICAgbW9kZSA9IDpzaG93XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb2RlID0gbGluZVxuICAgICAgICAgIG1vZGUgPSA6aW5zcGVjdFxuICAgICAgICBlbmRcblxuICAgICAgICBqc19jb2RlID0gbmlsXG5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBzaWxlbmNlci5zaWxlbmNlIGRvXG4gICAgICAgICAgICBqc19jb2RlID0gYE9wYWwuY29tcGlsZShjb2RlLCB7aXJiOiB0cnVlfSlgXG4gICAgICAgICAgZW5kXG4gICAgICAgIHJlc2N1ZSBTeW50YXhFcnJvciA9PiBlXG4gICAgICAgICAgaWYgOjpPcGFsOjpJUkI6OkxJTkVCUkVBS1MuaW5jbHVkZT8oZS5tZXNzYWdlKVxuICAgICAgICAgICAgcHJpbnQgJy4uICdcbiAgICAgICAgICAgIGxpbmUgPSBnZXRzXG4gICAgICAgICAgICByZXR1cm4gdW5sZXNzIGxpbmVcbiAgICAgICAgICAgIHB1dHMgbGluZSBpZiA6Ok9wYWw6OklSQi5icm93c2VyP1xuICAgICAgICAgICAgY29kZSArPSBsaW5lXG4gICAgICAgICAgICByZXRyeVxuICAgICAgICAgIGVsc2lmIHNpbGVuY2VyLndhcm5pbmdzLmVtcHR5P1xuICAgICAgICAgICAgd2FybiBlLmZ1bGxfbWVzc2FnZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICMgTW9zdCBsaWtlbHkgYSBwYXJzZXIgZXJyb3JcbiAgICAgICAgICAgIHdhcm4gc2lsZW5jZXIud2FybmluZ3NcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG5cbiAgICAgICAgaWYgbW9kZSA9PSA6c2hvd1xuICAgICAgICAgIHB1dHMganNfY29kZVxuICAgICAgICAgIHJldHVyblxuICAgICAgICBlbmRcblxuICAgICAgICBwdXRzIDo6UkVQTFV0aWxzLmV2YWxfYW5kX3ByaW50KGpzX2NvZGUsIG1vZGUsIGZhbHNlLCBzZWxmKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbiV4e1xuICAvLyBSdW4gaW4gV2ViVG9vbHMgY29uc29sZSB3aXRoOiBPcGFsLmlyYihjID0+IGV2YWwoYykpXG4gIE9wYWwuaXJiID0gZnVuY3Rpb24oZnVuKSB7XG4gICAgI3s6OkJpbmRpbmcubmV3KGBmdW5gKS5pcmJ9XG4gIH1cblxuICBPcGFsLmxvYWRfcGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgT3BhbC5PcGFsLklSQi4kZW5zdXJlX2xvYWRlZCgnb3BhbC1wYXJzZXInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgT3BhbC5ldmFsID09PSAndW5kZWZpbmVkJykge1xuICAgIE9wYWwuZXZhbCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgT3BhbC5sb2FkX3BhcnNlcigpO1xuICAgICAgcmV0dXJuIE9wYWwuZXZhbChzdHIpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgT3BhbC5jb21waWxlID09PSAndW5kZWZpbmVkJykge1xuICAgIE9wYWwuY29tcGlsZSA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICAgICAgT3BhbC5sb2FkX3BhcnNlcigpO1xuICAgICAgcmV0dXJuIE9wYWwuY29tcGlsZShzdHIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+IiwiPG1vZHVsZTpJUkI+IiwiZW5zdXJlX2xvYWRlZCIsInNlbGYiLCJsaWJyYXJ5IiwiaW5jbHVkZT8iLCJ2ZXJzaW9uIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsInVybCIsIktlcm5lbCIsInJhaXNlIiwic2luZ2xldG9uX2NsYXNzIiwiYXR0cl9hY2Nlc3NvciIsInByZXBhcmVfY29uc29sZSIsIm91dHB1dD0iLCJvcmlnaW5hbCIsIiRzdGRvdXQiLCJibG9jayBpbiBwcmVwYXJlX2NvbnNvbGUiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcmVwYXJlX2NvbnNvbGUiLCIkc3RkZXJyIiwiYnJvd3Nlcj8iLCJlYWNoIiwicGlwZSIsInBpcGVfc2V0dGVyIiwibmV3X3BpcGUiLCJkdXAiLCJ3cml0ZV9wcm9jPSIsInByb2MiLCJzdHIiLCJibG9jayAoMyBsZXZlbHMpIGluIHByZXBhcmVfY29uc29sZSIsIisiLCJvdXRwdXQiLCJzcGxpdCIsImxhc3QiLCIzMCIsImpvaW4iLCJlbmRfd2l0aD8iLCJ3cml0ZV9wcm9jIiwiY2FsbCIsInR0eT0iLCJvcmlnaW5hbF9yZWFkX3Byb2MiLCIkc3RkaW4iLCJyZWFkX3Byb2MiLCJyZWFkX3Byb2M9IiwiZnJlZXplIiwiPGNsYXNzOlNpbGVuY2VyPiIsImluaXRpYWxpemUiLCJAc3RkZXJyIiwic2lsZW5jZSIsIkBjb2xsZWN0b3IiLCJTdHJpbmdJTyIsIm5ldyIsIndhcm5pbmdzIiwic3RyaW5nIiwiPGNsYXNzOkJpbmRpbmc+IiwiaXJiIiwiT3BhbDo6SVJCIiwiT3BhbCIsInNpbGVuY2VyIiwiT3BhbDo6SVJCOjpTaWxlbmNlciIsImJsb2NrIGluIGlyYiIsImJsb2NrICgyIGxldmVscykgaW4gaXJiIiwibG9vcCIsImJsb2NrICgzIGxldmVscykgaW4gaXJiIiwicHJpbnQiLCJsaW5lIiwiZ2V0cyIsImNvZGUiLCJwdXRzIiwic3RhcnRfd2l0aD8iLCJbXSIsIjMiLCItMSIsIm1vZGUiLCI1IiwianNfY29kZSIsImJsb2NrICg0IGxldmVscykgaW4gaXJiIiwiU3ludGF4RXJyb3IiLCJlIiwiT3BhbDo6SVJCOjpMSU5FQlJFQUtTIiwibWVzc2FnZSIsImVtcHR5PyIsIndhcm4iLCJmdWxsX21lc3NhZ2UiLCJSRVBMVXRpbHMiLCJldmFsX2FuZF9wcmludCIsIkJpbmRpbmciXSwibWFwcGluZ3MiOiJB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Z0JBREY7a0JBSUVoRixJQUFBZ0YsTUFBQUEsQ0FBS3hCLFFBQVFOLFVBQUFBLENBQUFBLENBQWI4QjtnQkFKRjtjQVJGO1lBQUEsQ0FIRTtVQUFBLENBQUE7VUFtQkYsSUFBQSxNQUFHVCxJQUFILEVBQVcsTUFBWCxDQUFBOztZQUNFdkUsSUFBQWtFLE1BQUFBLENBQUtPLE9BQUxQO1lBQ0EsU0FBQSxRQUFBO1VBRkY7VUFLQUwsT0FBQTdELElBQUFrRSxNQUFBQSxDQUFLZ0IsZ0JBQVdDLGdCQUFBQSxDQUFnQlYsT0FBM0IsRUFBb0NGLElBQXBDLEVBQTBDLEtBQTFDLEVBQWlEdkUsSUFBdENtRixDQUFoQmpCLEVBakRGUCxDQUFBQSxHQUFBQSwyQkFBQUEsQ0FBQUMsQ0FBQUE7VUFBQUE7VUFBQUE7UUFBQUEsQ0FBQUEsSUFERkYsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBV2hELEVBTGIyQztRQUFBQTtRQUFBQTtNQUFBQTtJQUFBQSxDQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBOztBQStEQXhEO0FBQ0FBO0FBQ0FBLElBQU13RixjQUFTbkMsS0FBQUEsQ0FBTXJELEdBQU5xRCxDQUFXSSxLQUFBQSxDQUFBQTtBQUMxQnpEOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQTlMQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MTE0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvYmFzZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvbWluaSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG46Ok9iamVjdC5hdXRvbG9hZCA6TWF0aCwgJ2NvcmVsaWIvbWF0aCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleC9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkNvbXBsZXgsICdjb3JlbGliL2NvbXBsZXgnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsL2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmF0aW9uYWwsICdjb3JlbGliL3JhdGlvbmFsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlN0cnVjdCwgJ2NvcmVsaWIvc3RydWN0J1xuOjpPYmplY3QuYXV0b2xvYWQgOlNldCwgJ2NvcmVsaWIvc2V0J1xuOjpPYmplY3QuYXV0b2xvYWQgOkRpciwgJ2NvcmVsaWIvZGlyJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkZpbGUsICdjb3JlbGliL2ZpbGUnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcHJvY2Vzcy9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlByb2Nlc3MsICdjb3JlbGliL3Byb2Nlc3MnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmFuZG9tLCAnY29yZWxpYi9yYW5kb20nXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYmluZGluZydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaXJiJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJPYmplY3QiLCJyZXF1aXJlIiwiYXV0b2xvYWQiXSwibWFwcGluZ3MiOiJBQUFBQSx1QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFFUkQsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLHlCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLE1BQWxCLEVBQXlCSCxjQUFqQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0Ysc0JBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsU0FBbEIsRUFBNEJILGlCQUFwQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsVUFBbEIsRUFBNkJILGtCQUFyQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxRQUFsQixFQUEyQkgsZ0JBQW5CRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLEtBQWxCLEVBQXdCSCxhQUFoQkc7RUFDUkYsT0FBUUUsVUFBQUEsQ0FBVSxLQUFsQixFQUF3QkgsYUFBaEJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsTUFBbEIsRUFBeUJILGNBQWpCRztFQUVSRixPQUFRQyxTQUFBQSxDQUFTRixzQkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxTQUFsQixFQUE0QkgsaUJBQXBCRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLFFBQWxCLEVBQTJCSCxnQkFBbkJHO0VBRVJGLE9BQVFDLFNBQUFBLENBQVNGLHFCQUFURTtFQUVSRCxPQUFRQyxTQUFBQSxDQUFTRixpQkFBVEU7RUFDUkYsT0FBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsYUFBVEU7QUF2QlJGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTE0MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vanMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBUaGUgSlMgbW9kdWxlIHByb3ZpZGVzIHN5bnRheCBzdWdhciBmb3IgY2FsbGluZyBuYXRpdmUgamF2YXNjcmlwdFxuIyBvcGVyYXRvcnMgKGUuZy4gdHlwZW9mLCBpbnN0YW5jZW9mLCBuZXcsIGRlbGV0ZSkgYW5kIGdsb2JhbCBmdW5jdGlvbnNcbiMgKGUuZy4gcGFyc2VGbG9hdCwgcGFyc2VJbnQpLlxubW9kdWxlIEpTXG4gICMgVXNlIGRlbGV0ZSB0byByZW1vdmUgYSBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdC5cbiAgZGVmIGRlbGV0ZShvYmplY3QsIHByb3BlcnR5KVxuICAgIGBkZWxldGUgI3tvYmplY3R9WyN7cHJvcGVydHl9XWBcbiAgZW5kXG5cbiAgIyBUaGUgZ2xvYmFsIG9iamVjdFxuICBkZWYgZ2xvYmFsXG4gICAgYE9wYWwuZ2xvYmFsYFxuICBlbmRcblxuICAjIFVzZSBpbiB0byBjaGVjayBmb3IgYSBwcm9wZXJ0eSBpbiBhbiBvYmplY3QuXG4gIGRlZiBpbihwcm9wZXJ0eSwgb2JqZWN0KVxuICAgIGAje3Byb3BlcnR5fSBpbiAje29iamVjdH1gXG4gIGVuZFxuXG4gICMgVXNlIGluc3RhbmNlb2YgdG8gcmV0dXJuIHdoZXRoZXIgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGZ1bmN0aW9uLlxuICBkZWYgaW5zdGFuY2VvZih2YWx1ZSwgZnVuYylcbiAgICBgI3t2YWx1ZX0gaW5zdGFuY2VvZiAje2Z1bmN9YFxuICBlbmRcblxuICAjIFVzZSBuZXcgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBwcm90b3R5cGUgb2YgdGhlIGZ1bmN0aW9uLlxuICBpZiBgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID09ICdmdW5jdGlvbidgXG4gICAgZGVmIG5ldyhmdW5jLCAqYXJncywgJmJsb2NrKVxuICAgICAgYXJncy5pbnNlcnQoMCwgYHRoaXNgKVxuICAgICAgYXJncyA8PCBibG9jayBpZiBibG9ja1xuICAgICAgYG5ldyAoI3tmdW5jfS5iaW5kLmFwcGx5KCN7ZnVuY30sICN7YXJnc30pKSgpYFxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIG5ldyhmdW5jLCAqYXJncywgJmJsb2NrKVxuICAgICAgYXJncyA8PCBibG9jayBpZiBibG9ja1xuICAgICAgZiA9IGBmdW5jdGlvbigpe3JldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpfWBcbiAgICAgIGYuSlNbOnByb3RvdHlwZV0gPSBmdW5jLkpTWzpwcm90b3R5cGVdXG4gICAgICBgbmV3IGYoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBVc2UgdHlwZW9mIHRvIHJldHVybiB0aGUgdW5kZXJseWluZyBqYXZhc2NyaXB0IHR5cGUgb2YgdmFsdWUuXG4gICMgTm90ZSB0aGF0IGZvciB1bmRlZmluZWQgdmFsdWVzLCB0aGlzIHdpbGwgbm90IHdvcmsgZXhhY3RseSBsaWtlXG4gICMgdGhlIGphdmFzY3JpcHQgdHlwZW9mIG9wZXJhdG9yLCBhcyB0aGUgYXJndW1lbnQgaXMgZXZhbHVhdGVkIGJlZm9yZVxuICAjIHRoZSBmdW5jdGlvbiBjYWxsLlxuICBkZWYgdHlwZW9mKHZhbHVlKVxuICAgIGB0eXBlb2YgI3t2YWx1ZX1gXG4gIGVuZFxuXG4gICMgVXNlIHZvaWQgdG8gcmV0dXJuIHVuZGVmaW5lZC5cbiAgZGVmIHZvaWQoZXhwcilcbiAgICAjIENvdWxkIHVzZSBgdW5kZWZpbmVkYCBoZXJlLCBidXQgdGhpcyBpcyBjbG9zZXIgdG8gdGhlIGludGVudCBvZiB0aGUgbWV0aG9kXG4gICAgYHZvaWQgI3tleHByfWBcbiAgZW5kXG5cbiAgIyBDYWxsIHRoZSBnbG9iYWwgamF2YXNjcmlwdCBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gIGRlZiBjYWxsKGZ1bmMsICphcmdzLCAmYmxvY2spXG4gICAgZyA9IGdsb2JhbFxuICAgIGFyZ3MgPDwgYmxvY2sgaWYgYmxvY2tcbiAgICBnLkpTW2Z1bmNdLkpTLmFwcGx5KGcsIGFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBbXShuYW1lKVxuICAgIGBPcGFsLmdsb2JhbFsje25hbWV9XWBcbiAgZW5kXG5cbiAgYWxpYXMgbWV0aG9kX21pc3NpbmcgY2FsbFxuXG4gIGV4dGVuZCBzZWxmXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpKUz4iLCJkZWxldGUiLCJvYmplY3QiLCJwcm9wZXJ0eSIsImdsb2JhbCIsImluIiwiaW5zdGFuY2VvZiIsInZhbHVlIiwiZnVuYyIsIm5ldyIsImFyZ3MiLCJpbnNlcnQiLCIwIiwiYmxvY2siLCI8PCIsImYiLCJ0eXBlb2YiLCJ2b2lkIiwiZXhwciIsImNhbGwiLCJnIiwic2VsZiIsIltdIiwibmFtZSIsImV4dGVuZCJdLCJtYXBwaW5ncyI6IkFBQUFBLHFCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBR0FBLE9BQUFDO0VBQUFBOzs7OztBQUVFQyxJQUFBQSxzQkFBQUEsc0JBQVdDLE1BQUQsRUFBU0MsUUFBbkJGO0FBQUFBO01BQ0VBLE9BQUNBLE9BQVNDLE1BQU9ELENBQUdFLFFBQVNGO0lBRC9CQSxDQUFBQTs7QUFLQUcsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQTtNQUNFQSxPQUFDQSxXQUFEQTtJQURGQSxDQUFBQTs7QUFLQUMsSUFBQUEsa0JBQUFBLGtCQUFPRixRQUFELEVBQVdELE1BQWpCRztBQUFBQTtNQUNFQSxPQUFHRixRQUFTRSxJQUFNSDtJQURwQkcsQ0FBQUE7O0FBS0FDLElBQUFBLDBCQUFBQSwwQkFBZUMsS0FBRCxFQUFRQyxJQUF0QkY7QUFBQUE7TUFDRUEsT0FBR0MsS0FBTUQsWUFBY0U7SUFEekJGLENBQUFBO0lBS0EsSUFBQSxRQUFJTiw0Q0FBSixDQUFBOztBQUNFUyxNQUFBQSxtQkFBQUEsbUJBQVFELElBQUQsRUExQlgsRUEwQklDO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBMUJKO1FBMEJrQjtRQUNaQyxJQUFJQyxRQUFBQSxDQUFRQyxDQUFaLEVBQWdCSCxJQUFaRTtRQUNKLElBQUEsUUFBaUJFLEtBQWpCLENBQUE7VUFBQUgsSUFBS0ksT0FBQUEsQ0FBR0QsS0FBSEM7UUFBTDtRQUNBTCxPQUFDQSxLQUFPRCxJQUFLQyxZQUFjRCxJQUFLQyxFQUFJQyxJQUFLRDtNQUgzQ0EsQ0FBQUEsSUFBQUE7SUFERjs7QUFPRUEsTUFBQUEsbUJBQUFBLG1CQUFRRCxJQUFELEVBaENYLEVBZ0NJQztBQUFBQSxRQUFBQTs7UUFBQUE7OztRQWhDSjtRQWdDa0I7UUFDWixJQUFBLFFBQWlCSSxLQUFqQixDQUFBO1VBQUFILElBQUtJLE9BQUFBLENBQUdELEtBQUhDO1FBQUw7UUFDQUMsSUFBS047UUFDTE0sQ0FBQSxDQUFLLFdBQUwsSUFBbUJQLElBQUEsQ0FBUSxXQUFSO1FBQ25CQyxPQUFDQSxPQUFEQTtNQUpGQSxDQUFBQSxJQUFBQTtJQVBGOztBQW1CQU8sSUFBQUEsc0JBQUFBLHNCQUFXVCxLQUFYUztBQUFBQTtNQUNFQSxPQUFDQSxPQUFTVDtJQURaUyxDQUFBQTs7QUFLQUMsSUFBQUEsb0JBQUFBLG9CQUFTQyxJQUFURDtBQUFBQTtNQUVFQSxPQUFDQSxLQUFPQztJQUZWRCxDQUFBQTs7QUFNQUUsSUFBQUEsb0JBQUFBLGdCQUFTWCxJQUFELEVBdkRWLEVBdURFVztBQUFBQSxNQUFBQTs7TUFBQUE7OztNQXZERjtNQXVEaUI7TUFDYkMsSUFBSUMsSUFBQWpCLFFBQUFBLENBQUFBO01BQ0osSUFBQSxRQUFpQlMsS0FBakIsQ0FBQTtRQUFBSCxJQUFLSSxPQUFBQSxDQUFHRCxLQUFIQztNQUFMO01BQ0FLLE9BQUFDLENBQUEsQ0FBS1osSUFBTCxDQUFBLE1BQUEsQ0FBb0JZLENBQXBCLEVBQXVCVixJQUF2QjtJQUhGUyxDQUFBQSxJQUFBQTs7QUFNQUcsSUFBQUEsa0JBQUFBLGtCQUFPQyxJQUFQRDtBQUFBQTtNQUNFQSxPQUFDQSxZQUFjQyxJQUFLRDtJQUR0QkEsQ0FBQUE7SUFJQSxhQUFNLGdCQUFOLEVBQXFCLE1BQXJCO0lBRUF0QixPQUFBcUIsSUFBQUcsUUFBQUEsQ0FBT0gsSUFBUEc7RUFoRUZ4QixHQUFBQSxXQUFBQTtBQUhBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjUyMzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL25hdGl2ZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFByb3ZpZGVzIGEgY29tcGxldGUgc2V0IG9mIHRvb2xzIHRvIHdyYXAgbmF0aXZlIEphdmFTY3JpcHRcbiMgaW50byBuaWNlIFJ1Ynkgb2JqZWN0cy5cbiNcbiMgQGV4YW1wbGVcbiNcbiMgICAkJC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdwJykuY2xhc3NMaXN0LmFkZCgnYmx1ZScpXG4jICAgIyA9PiBhZGRzIFwiYmx1ZVwiIGNsYXNzIHRvIDxwPlxuI1xuIyAgICQkLmxvY2F0aW9uLmhyZWYgPSAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuIyAgICMgPT4gY2hhbmdlcyBwYWdlIGxvY2F0aW9uXG4jXG4jICAgZG9fbGF0ZXIgPSAkJFs6c2V0VGltZW91dF0gIyBBY2Nlc3NpbmcgdGhlIFwic2V0VGltZW91dFwiIHByb3BlcnR5XG4jICAgZG9fbGF0ZXIuY2FsbCgtPnsgcHV0cyA6aGVsbG99LCA1MDApXG4jXG4jIGAkJGAgYW5kIGAkZ2xvYmFsYCB3cmFwIGBPcGFsLmdsb2JhbGAsIHdoaWNoIHRoZSBPcGFsIEpTIHJ1bnRpbWVcbiMgc2V0cyB0byB0aGUgZ2xvYmFsIGB0aGlzYCBvYmplY3QuXG4jXG5tb2R1bGUgTmF0aXZlXG4gIGRlZiBzZWxmLmlzX2E/KG9iamVjdCwga2xhc3MpXG4gICAgJXh7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gI3tvYmplY3R9IGluc3RhbmNlb2YgI3t0cnlfY29udmVydChrbGFzcyl9O1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQodmFsdWUsIGRlZmF1bHQgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoI3tuYXRpdmU/KHZhbHVlKX0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWV9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fbn0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWUudG9fbn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7ZGVmYXVsdH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5jb252ZXJ0KHZhbHVlKVxuICAgICV4e1xuICAgICAgaWYgKCN7bmF0aXZlPyh2YWx1ZSl9KSB7XG4gICAgICAgIHJldHVybiAje3ZhbHVlfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7dmFsdWUucmVzcG9uZF90bz8gOnRvX259KSB7XG4gICAgICAgIHJldHVybiAje3ZhbHVlLnRvX259O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCIje3ZhbHVlLmluc3BlY3R9IGlzbid0IG5hdGl2ZVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNhbGwob2JqLCBrZXksICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcHJvcCA9ICN7b2JqfVsje2tleX1dO1xuXG4gICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZWQgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3NbaV0sXG4gICAgICAgICAgICAgIGNvbnYgPSAje3RyeV9jb252ZXJ0KGBpdGVtYCl9O1xuXG4gICAgICAgICAgY29udmVydGVkW2ldID0gY29udiA9PT0gbmlsID8gaXRlbSA6IGNvbnY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGNvbnZlcnRlZC5wdXNoKGJsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAje05hdGl2ZShgcHJvcC5hcHBseSgje29ian0sIGNvbnZlcnRlZClgKX07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBwcm9wYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucHJvYygmYmxvY2spXG4gICAgcmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICA6Oktlcm5lbC5wcm9jIHsgfCphcmdzfFxuICAgICAgYXJncy5tYXAhIHsgfGFyZ3wgTmF0aXZlKGFyZykgfVxuICAgICAgaW5zdGFuY2UgPSBOYXRpdmUoYHRoaXNgKVxuXG4gICAgICAleHtcbiAgICAgICAgLy8gaWYgZ2xvYmFsIGlzIGN1cnJlbnQgc2NvcGUsIHJ1biB0aGUgYmxvY2sgaW4gdGhlIHNjb3BlIGl0IHdhcyBkZWZpbmVkXG4gICAgICAgIGlmICh0aGlzID09PSBPcGFsLmdsb2JhbCkge1xuICAgICAgICAgIHJldHVybiBibG9jay5hcHBseShzZWxmLCAje2FyZ3N9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmXyA9IGJsb2NrLiQkcztcbiAgICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBibG9jay5hcHBseSgje2luc3RhbmNlfSwgI3thcmdzfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgYmxvY2suJCRzID0gc2VsZl87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIG1vZHVsZSBIZWxwZXJzXG4gICAgIyBFeHBvc2VzIGEgbmF0aXZlIEphdmFTY3JpcHQgbWV0aG9kIHRvIFJ1YnlcbiAgICAjXG4gICAgI1xuICAgICMgQHBhcmFtIG5ldyBbU3RyaW5nXVxuICAgICMgICAgICAgVGhlIG5hbWUgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgbWV0aG9kLlxuICAgICNcbiAgICAjIEBwYXJhbSBvbGQgW1N0cmluZ11cbiAgICAjICAgICAgIFRoZSBuYW1lIG9mIHRoZSBuYXRpdmUgSmF2YVNjcmlwdCBtZXRob2QgdG8gYmUgZXhwb3NlZC5cbiAgICAjICAgICAgIElmIHRoZSBuYW1lIGVuZHMgd2l0aCBcIj1cIiAoZS5nLiBgZm9vPWApIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXNcbiAgICAjICAgICAgIGEgcHJvcGVydHkgc2V0dGVyLiAoZGVmYXVsdDogdGhlIHZhbHVlIG9mIFwibmV3XCIpXG4gICAgI1xuICAgICMgQHBhcmFtIGFzIFtDbGFzc11cbiAgICAjICAgICAgIElmIHByb3ZpZGVkIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIG9yaWdpbmFsIG1ldGhvZCB3aWxsIGJlXG4gICAgIyAgICAgICByZXR1cm5lZCBhcyBpbnN0YW5jZXMgb2YgdGhlIHBhc3NlZCBjbGFzcy4gVGhlIGNsYXNzIHBhc3NlZCB0byBcImFzXCJcbiAgICAjICAgICAgIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBhIG5hdGl2ZSBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICNcbiAgICAjIEBleGFtcGxlXG4gICAgI1xuICAgICMgICBjbGFzcyBFbGVtZW50XG4gICAgIyAgICAgZXh0ZW5kIE5hdGl2ZTo6SGVscGVyc1xuICAgICNcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOmFkZF9jbGFzcywgOmFkZENsYXNzXG4gICAgIyAgICAgYWxpYXNfbmF0aXZlIDpzaG93XG4gICAgIyAgICAgYWxpYXNfbmF0aXZlIDpoaWRlXG4gICAgI1xuICAgICMgICAgIGRlZiBpbml0aWFsaXplKHNlbGVjdG9yKVxuICAgICMgICAgICAgQG5hdGl2ZSA9IGAkKCN7c2VsZWN0b3J9KWBcbiAgICAjICAgICBlbmRcbiAgICAjICAgZW5kXG4gICAgI1xuICAgICMgICB0aXRsZXMgPSBFbGVtZW50Lm5ldygnaDEnKVxuICAgICMgICB0aXRsZXMuYWRkX2NsYXNzIDpmb29cbiAgICAjICAgdGl0bGVzLmhpZGVcbiAgICAjICAgdGl0bGVzLnNob3dcbiAgICAjXG4gICAgZGVmIGFsaWFzX25hdGl2ZShuZXcsIG9sZCA9IG5ldywgYXM6IG5pbClcbiAgICAgIGlmIG9sZC5lbmRfd2l0aD8gJz0nXG4gICAgICAgIGRlZmluZV9tZXRob2QgbmV3IGRvIHx2YWx1ZXxcbiAgICAgICAgICBgI3tAbmF0aXZlfVsje29sZFswLi4tMl19XSA9ICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfWBcblxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgYXNcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgICAgdmFsdWUgPSBOYXRpdmUuY2FsbChAbmF0aXZlLCBvbGQsICphcmdzLCAmYmxvY2spXG4gICAgICAgICAgaWYgdmFsdWVcbiAgICAgICAgICAgIGFzLm5ldyh2YWx1ZS50b19uKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgICAgTmF0aXZlLmNhbGwoQG5hdGl2ZSwgb2xkLCAqYXJncywgJmJsb2NrKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIG5hdGl2ZV9yZWFkZXIoKm5hbWVzKVxuICAgICAgbmFtZXMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICAgICAgTmF0aXZlKGAje0BuYXRpdmV9W25hbWVdYClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBuYXRpdmVfd3JpdGVyKCpuYW1lcylcbiAgICAgIG5hbWVzLmVhY2ggZG8gfG5hbWV8XG4gICAgICAgIGRlZmluZV9tZXRob2QgXCIje25hbWV9PVwiIGRvIHx2YWx1ZXxcbiAgICAgICAgICBOYXRpdmUoYCN7QG5hdGl2ZX1bbmFtZV0gPSB2YWx1ZWApXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbmF0aXZlX2FjY2Vzc29yKCpuYW1lcylcbiAgICAgIG5hdGl2ZV9yZWFkZXIoKm5hbWVzKVxuICAgICAgbmF0aXZlX3dyaXRlcigqbmFtZXMpXG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBXcmFwcGVyXG4gICAgZGVmIGluaXRpYWxpemUobmF0aXZlKVxuICAgICAgdW5sZXNzIDo6S2VybmVsLm5hdGl2ZT8obmF0aXZlKVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7bmF0aXZlLmluc3BlY3R9IGlzbid0IG5hdGl2ZVwiXG4gICAgICBlbmRcblxuICAgICAgQG5hdGl2ZSA9IG5hdGl2ZVxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBuYXRpdmUgSmF2YVNjcmlwdCB2YWx1ZVxuICAgIGRlZiB0b19uXG4gICAgICBAbmF0aXZlXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5pbmNsdWRlZChrbGFzcylcbiAgICAgIGtsYXNzLmV4dGVuZCBIZWxwZXJzXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluY2x1ZGVkKGJhc2UpXG4gICAgd2FybiAnSW5jbHVkaW5nIDo6TmF0aXZlIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlciBpbnN0ZWFkLidcbiAgICBiYXNlLmluY2x1ZGUgV3JhcHBlclxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBuYXRpdmU/KHZhbHVlKVxuICAgIGB2YWx1ZSA9PSBudWxsIHx8ICF2YWx1ZS4kJGNsYXNzYFxuICBlbmRcblxuICAjIFdyYXBzIGEgbmF0aXZlIEphdmFTY3JpcHQgd2l0aCBgTmF0aXZlOjpPYmplY3QubmV3YFxuICAjXG4gICMgQHJldHVybiBbTmF0aXZlOjpPYmplY3RdIFRoZSB3cmFwcGVkIG9iamVjdCBpZiBpdCBpcyBuYXRpdmVcbiAgIyBAcmV0dXJuIFtuaWxdIGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICMgQHJldHVybiBbb2JqXSBUaGUgb2JqZWN0IGl0c2VsZiBpZiBpdCdzIG5vdCBuYXRpdmVcbiAgZGVmIE5hdGl2ZShvYmopXG4gICAgaWYgYCN7b2JqfSA9PSBudWxsYFxuICAgICAgbmlsXG4gICAgZWxzaWYgbmF0aXZlPyhvYmopXG4gICAgICBOYXRpdmU6Ok9iamVjdC5uZXcob2JqKVxuICAgIGVsc2lmIG9iai5pc19hPyhBcnJheSlcbiAgICAgIG9iai5tYXAgZG8gfG98XG4gICAgICAgIE5hdGl2ZShvKVxuICAgICAgZW5kXG4gICAgZWxzaWYgb2JqLmlzX2E/KFByb2MpXG4gICAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgICBOYXRpdmUob2JqLmNhbGwoKmFyZ3MsICZibG9jaykpXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBvYmpcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgX0FycmF5IEFycmF5XG5cbiAgIyBXcmFwcyBhcnJheS1saWtlIEphdmFTY3JpcHQgb2JqZWN0cyBpbiBOYXRpdmU6OkFycmF5XG4gIGRlZiBBcnJheShvYmplY3QsICphcmdzLCAmYmxvY2spXG4gICAgaWYgbmF0aXZlPyhvYmplY3QpXG4gICAgICByZXR1cm4gTmF0aXZlOjpBcnJheS5uZXcob2JqZWN0LCAqYXJncywgJmJsb2NrKS50b19hXG4gICAgZW5kXG4gICAgX0FycmF5KG9iamVjdClcbiAgZW5kXG5lbmRcblxuY2xhc3MgTmF0aXZlOjpPYmplY3QgPCBCYXNpY09iamVjdFxuICBpbmNsdWRlIDo6TmF0aXZlOjpXcmFwcGVyXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGAje0BuYXRpdmV9ID09PSAjezo6TmF0aXZlLnRyeV9jb252ZXJ0KG90aGVyKX1gXG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhuYW1lKVxuICAgIGBPcGFsLmhhc093blByb3BlcnR5LmNhbGwoI3tAbmF0aXZlfSwgI3tuYW1lfSlgXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCphcmdzKVxuICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiAje0BuYXRpdmV9KSB7XG4gICAgICAgICAgI3t5aWVsZCBga2V5YCwgYCN7QG5hdGl2ZX1ba2V5XWB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIG1ldGhvZF9taXNzaW5nKDplYWNoLCAqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIFtdKGtleSlcbiAgICAleHtcbiAgICAgIHZhciBwcm9wID0gI3tAbmF0aXZlfVtrZXldO1xuXG4gICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjezo6TmF0aXZlLmNhbGwoQG5hdGl2ZSwga2V5KX1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICBuYXRpdmUgPSA6Ok5hdGl2ZS50cnlfY29udmVydCh2YWx1ZSlcblxuICAgIGlmIGAje25hdGl2ZX0gPT09IG5pbGBcbiAgICAgIGAje0BuYXRpdmV9W2tleV0gPSAje3ZhbHVlfWBcbiAgICBlbHNlXG4gICAgICBgI3tAbmF0aXZlfVtrZXldID0gI3tuYXRpdmV9YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWVyZ2UhKG90aGVyKVxuICAgICV4e1xuICAgICAgb3RoZXIgPSAjezo6TmF0aXZlLmNvbnZlcnQob3RoZXIpfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgICAje0BuYXRpdmV9W3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICA6Oktlcm5lbC5pbnN0YW5jZV9tZXRob2QoOnJlc3BvbmRfdG8/KS5iaW5kKHNlbGYpLmNhbGwobmFtZSwgaW5jbHVkZV9hbGwpXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbCgje0BuYXRpdmV9LCAje25hbWV9KWBcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG1pZCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChtaWQuY2hhckF0KG1pZC5sZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgIHJldHVybiAje3NlbGZbbWlkLnNsaWNlKDAsIG1pZC5sZW5ndGggLSAxKV0gPSBhcmdzWzBdfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3s6Ok5hdGl2ZS5jYWxsKEBuYXRpdmUsIG1pZCwgKmFyZ3MsICZibG9jayl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgYE9wYWwuaXNfYShzZWxmLCBrbGFzcylgXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgYHNlbGYuJCRjbGFzcyA9PT0ga2xhc3NgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc1xuICAgIGBzZWxmLiQkY2xhc3NgXG4gIGVuZFxuXG4gIGRlZiB0b19hKG9wdGlvbnMgPSB7fSwgJmJsb2NrKVxuICAgIDo6TmF0aXZlOjpBcnJheS5uZXcoQG5hdGl2ZSwgb3B0aW9ucywgJmJsb2NrKS50b19hXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPE5hdGl2ZToje2BTdHJpbmcoI3tAbmF0aXZlfSlgfT5cIlxuICBlbmRcblxuICBhbGlhcyBpbmNsdWRlPyBoYXNfa2V5P1xuICBhbGlhcyBrZXk/IGhhc19rZXk/XG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG4gIGFsaWFzIG1lbWJlcj8gaGFzX2tleT9cbmVuZFxuXG5jbGFzcyBOYXRpdmU6OkFycmF5XG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGRlZiBpbml0aWFsaXplKG5hdGl2ZSwgb3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgc3VwZXIobmF0aXZlKVxuXG4gICAgQGdldCAgICA9IG9wdGlvbnNbOmdldF0gfHwgb3B0aW9uc1s6YWNjZXNzXVxuICAgIEBuYW1lZCAgPSBvcHRpb25zWzpuYW1lZF1cbiAgICBAc2V0ICAgID0gb3B0aW9uc1s6c2V0XSB8fCBvcHRpb25zWzphY2Nlc3NdXG4gICAgQGxlbmd0aCA9IG9wdGlvbnNbOmxlbmd0aF0gfHwgOmxlbmd0aFxuICAgIEBibG9jayAgPSBibG9ja1xuXG4gICAgaWYgYCN7bGVuZ3RofSA9PSBudWxsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGxlbmd0aCBmb3VuZCBvbiB0aGUgYXJyYXktbGlrZSBvYmplY3QnXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2ggdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSAje2xlbmd0aH07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgI3tzZWxmW2BpYF19KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXShpbmRleClcbiAgICByZXN1bHQgPSBjYXNlIGluZGV4XG4gICAgICAgICAgICAgd2hlbiBTdHJpbmcsIFN5bWJvbFxuICAgICAgICAgICAgICAgQG5hbWVkID8gYCN7QG5hdGl2ZX1bI3tAbmFtZWR9XSgje2luZGV4fSlgIDogYCN7QG5hdGl2ZX1bI3tpbmRleH1dYFxuICAgICAgICAgICAgIHdoZW4gSW50ZWdlclxuICAgICAgICAgICAgICAgQGdldCA/IGAje0BuYXRpdmV9WyN7QGdldH1dKCN7aW5kZXh9KWAgOiBgI3tAbmF0aXZlfVsje2luZGV4fV1gXG4gICAgICAgICAgICAgZW5kXG5cbiAgICBpZiByZXN1bHRcbiAgICAgIGlmIEBibG9ja1xuICAgICAgICBAYmxvY2suY2FsbChyZXN1bHQpXG4gICAgICBlbHNlXG4gICAgICAgIE5hdGl2ZShyZXN1bHQpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIFtdPShpbmRleCwgdmFsdWUpXG4gICAgaWYgQHNldFxuICAgICAgYCN7QG5hdGl2ZX1bI3tAc2V0fV0oI3tpbmRleH0sICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfSlgXG4gICAgZWxzZVxuICAgICAgYCN7QG5hdGl2ZX1bI3tpbmRleH1dID0gI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbGFzdChjb3VudCA9IG5pbClcbiAgICBpZiBjb3VudFxuICAgICAgaW5kZXggID0gbGVuZ3RoIC0gMVxuICAgICAgcmVzdWx0ID0gW11cblxuICAgICAgd2hpbGUgaW5kZXggPj0gMFxuICAgICAgICByZXN1bHQgPDwgc2VsZltpbmRleF1cbiAgICAgICAgaW5kZXggIC09IDFcbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHRcbiAgICBlbHNlXG4gICAgICBzZWxmW2xlbmd0aCAtIDFdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgI3tAbmF0aXZlfVsje0BsZW5ndGh9XWBcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICB0b19hLmluc3BlY3RcbiAgZW5kXG5cbiAgYWxpYXMgdG9fYXJ5IHRvX2FcbmVuZFxuXG5jbGFzcyBOdW1lcmljXG4gICMgQHJldHVybiB0aGUgaW50ZXJuYWwgSmF2YVNjcmlwdCB2YWx1ZSAod2l0aCBgdmFsdWVPZmApLlxuICBkZWYgdG9fblxuICAgIGBzZWxmLnZhbHVlT2YoKWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgUHJvY1xuICAjIEByZXR1cm4gaXRzZWxmIChhbiBpbnN0YW5jZSBvZiBgRnVuY3Rpb25gKVxuICBkZWYgdG9fblxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RyaW5nXG4gICMgQHJldHVybiB0aGUgaW50ZXJuYWwgSmF2YVNjcmlwdCB2YWx1ZSAod2l0aCBgdmFsdWVPZmApLlxuICBkZWYgdG9fblxuICAgIGBzZWxmLnZhbHVlT2YoKWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgUmVnZXhwXG4gICMgQHJldHVybiB0aGUgaW50ZXJuYWwgSmF2YVNjcmlwdCB2YWx1ZSAod2l0aCBgdmFsdWVPZmApLlxuICBkZWYgdG9fblxuICAgIGBzZWxmLnZhbHVlT2YoKWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgTWF0Y2hEYXRhXG4gICMgQHJldHVybiB0aGUgYXJyYXkgb2YgbWF0Y2hlc1xuICBkZWYgdG9fblxuICAgIEBtYXRjaGVzXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cnVjdFxuICAjIEByZXR1cm4gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoZSBtZW1iZXJzIGFzIGtleXMgYW5kIHRoZWlyXG4gICMgdmFsdWVzIGFzIHZhbHVlcy5cbiAgZGVmIHRvX25cbiAgICByZXN1bHQgPSBge31gXG5cbiAgICBlYWNoX3BhaXIgZG8gfG5hbWUsIHZhbHVlfFxuICAgICAgYCN7cmVzdWx0fVsje25hbWV9XSA9ICN7TmF0aXZlLnRyeV9jb252ZXJ0KHZhbHVlLCB2YWx1ZSl9YFxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuZW5kXG5cbmNsYXNzIEFycmF5XG4gICMgUmV0dW5zIGEgY29weSBvZiBpdHNlbGYgdHJ5aW5nIHRvIGNhbGwgI3RvX24gb24gZWFjaCBtZW1iZXIuXG4gIGRlZiB0b19uXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBzZWxmW2ldO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKCN7TmF0aXZlLnRyeV9jb252ZXJ0KGBvYmpgLCBgb2JqYCl9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuZW5kXG5cbmNsYXNzIEJvb2xlYW5cbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBUaW1lXG4gICMgQHJldHVybiBpdHNlbGYgKGFuIGluc3RhbmNlIG9mIGBEYXRlYCkuXG4gIGRlZiB0b19uXG4gICAgc2VsZlxuICBlbmRcbmVuZFxuXG5jbGFzcyBOaWxDbGFzc1xuICAjIEByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgSmF2YVNjcmlwdCB2YWx1ZSAoYG51bGxgKS5cbiAgZGVmIHRvX25cbiAgICBgbnVsbGBcbiAgZW5kXG5lbmRcblxuIyBSdW5uaW5nIHRoaXMgY29kZSB0d2ljZSByZXN1bHRzIGluIGFuIGluZmluaXRlIGxvb3AuIFdoaWxlIGl0J3MgdHJ1ZVxuIyB0aGF0IHdlIHNob3VsZG4ndCBydW4gdGhpcyBmaWxlIHR3aWNlLCB0aGVyZSBhcmUgY2VydGFpbiBjYXNlcywgbGlrZVxuIyBmb3IgZXhhbXBsZSBsaXZlIHJlbG9hZCwgd2hlbiB0aGlzIG1heSBoYXBwZW4uXG51bmxlc3MgSGFzaC5tZXRob2RfZGVmaW5lZD8gOl9pbml0aWFsaXplXG4gIGNsYXNzIEhhc2hcbiAgICBhbGlhcyBfaW5pdGlhbGl6ZSBpbml0aWFsaXplXG5cbiAgICBkZWYgaW5pdGlhbGl6ZShkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICAgJXh7XG4gICAgICAgIGlmIChkZWZhdWx0cyAhPSBudWxsICYmXG4gICAgICAgICAgICAgKGRlZmF1bHRzLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgIGRlZmF1bHRzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpKSB7XG4gICAgICAgICAgdmFyIHNtYXAgPSBzZWxmLiQkc21hcCxcbiAgICAgICAgICAgICAga2V5cyA9IHNlbGYuJCRrZXlzLFxuICAgICAgICAgICAgICBrZXksIHZhbHVlO1xuXG4gICAgICAgICAgZm9yIChrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdHNba2V5XTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgc21hcFtrZXldID0gI3tIYXNoLm5ldyhgdmFsdWVgKX07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtICYmXG4gICAgICAgICAgICAgICAgICAgICAoaXRlbS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAje0hhc2gubmV3KGBpdGVtYCl9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAje05hdGl2ZShgaXRlbWApfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNtYXBba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzbWFwW2tleV0gPSAje05hdGl2ZShgdmFsdWVgKX07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7X2luaXRpYWxpemUoZGVmYXVsdHMsICZibG9jayl9O1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgIyBAcmV0dXJuIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGJ1dCBjYWxsaW5nICN0b19uIG9uXG4gICAgIyBhbGwgdmFsdWVzLlxuICAgIGRlZiB0b19uXG4gICAgICAleHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAga2V5cyA9IHNlbGYuJCRrZXlzLFxuICAgICAgICAgICAgc21hcCA9IHNlbGYuJCRzbWFwLFxuICAgICAgICAgICAga2V5LCB2YWx1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNtYXBba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdFtrZXldID0gI3tOYXRpdmUudHJ5X2NvbnZlcnQoYHZhbHVlYCwgYHZhbHVlYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuY2xhc3MgTW9kdWxlXG4gICMgRXhwb3NlcyB0aGUgY3VycmVudCBtb2R1bGUgYXMgYSBwcm9wZXJ0eSBvZlxuICAjIHRoZSBnbG9iYWwgb2JqZWN0IChlLmcuIGB3aW5kb3dgKS5cbiAgZGVmIG5hdGl2ZV9tb2R1bGVcbiAgICBgT3BhbC5nbG9iYWxbI3tuYW1lfV0gPSAje3NlbGZ9YFxuICBlbmRcbmVuZFxuXG5jbGFzcyBDbGFzc1xuICBkZWYgbmF0aXZlX2FsaWFzKG5ld19qc2lkLCBleGlzdGluZ19taWQpXG4gICAgJXh7XG4gICAgICB2YXIgYWxpYXNlZCA9ICN7c2VsZn0ucHJvdG90eXBlW09wYWwuanNpZCgje2V4aXN0aW5nX21pZH0pXTtcbiAgICAgIGlmICghYWxpYXNlZCkge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje2V4aXN0aW5nX21pZH0nIGZvciBjbGFzcyBgI3tpbnNwZWN0fSdcIiwgZXhpc3RpbmdfbWlkKX07XG4gICAgICB9XG4gICAgICAje3NlbGZ9LnByb3RvdHlwZVsje25ld19qc2lkfV0gPSBhbGlhc2VkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hdGl2ZV9jbGFzc1xuICAgIG5hdGl2ZV9tb2R1bGVcbiAgICBgc2VsZltcIm5ld1wiXSA9IHNlbGYuJG5ld2BcbiAgZW5kXG5lbmRcblxuIyBFeHBvc2VzIHRoZSBnbG9iYWwgdmFsdWUgKHdvdWxkIGJlIGB3aW5kb3dgIGluc2lkZSBhIGJyb3dzZXIpXG4kJCA9ICRnbG9iYWwgPSBOYXRpdmUoYE9wYWwuZ2xvYmFsYClcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpOYXRpdmU+IiwiaXNfYT8iLCJzZWxmIiwib2JqZWN0Iiwia2xhc3MiLCJ0cnlfY29udmVydCIsInZhbHVlIiwiZGVmYXVsdCQiLCJuYXRpdmU/IiwicmVzcG9uZF90bz8iLCJ0b19uIiwiY29udmVydCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImluc3BlY3QiLCJjYWxsIiwib2JqIiwia2V5IiwiTmF0aXZlIiwicHJvYyIsImJsb2NrIiwiTG9jYWxKdW1wRXJyb3IiLCJLZXJuZWwiLCJibG9jayBpbiBwcm9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcm9jIiwibWFwISIsImFyZ3MiLCJhcmciLCJibG9jayAoMyBsZXZlbHMpIGluIHByb2MiLCJpbnN0YW5jZSIsIjxtb2R1bGU6SGVscGVycz4iLCJhbGlhc19uYXRpdmUiLCJuZXckIiwib2xkIiwiZW5kX3dpdGg/IiwiZGVmaW5lX21ldGhvZCIsImJsb2NrIGluIGFsaWFzX25hdGl2ZSIsImJsb2NrICgyIGxldmVscykgaW4gYWxpYXNfbmF0aXZlIiwiQG5hdGl2ZSIsIltdIiwiMCIsIi0yIiwiYXMiLCJ0b19wcm9jIiwibmV3IiwibmF0aXZlX3JlYWRlciIsImVhY2giLCJuYW1lcyIsImJsb2NrIGluIG5hdGl2ZV9yZWFkZXIiLCJuYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuYXRpdmVfcmVhZGVyIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBuYXRpdmVfcmVhZGVyIiwibmF0aXZlX3dyaXRlciIsImJsb2NrIGluIG5hdGl2ZV93cml0ZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIG5hdGl2ZV93cml0ZXIiLCJibG9jayAoMyBsZXZlbHMpIGluIG5hdGl2ZV93cml0ZXIiLCJuYXRpdmVfYWNjZXNzb3IiLCI8bW9kdWxlOldyYXBwZXI+IiwiaW5pdGlhbGl6ZSIsIm5hdGl2ZSQiLCJpbmNsdWRlZCIsImV4dGVuZCIsIkhlbHBlcnMiLCJiYXNlIiwid2FybiIsImluY2x1ZGUiLCJXcmFwcGVyIiwiPG1vZHVsZTpLZXJuZWw+IiwiTmF0aXZlOjpPYmplY3QiLCJBcnJheSIsIm1hcCIsImJsb2NrIGluIE5hdGl2ZSIsIm8iLCJibG9jayAoMiBsZXZlbHMpIGluIE5hdGl2ZSIsIlByb2MiLCJOYXRpdmU6OkFycmF5IiwidG9fYSIsIl9BcnJheSIsIjxjbGFzczpOYXRpdmU6Ok9iamVjdD4iLCJOYXRpdmU6OldyYXBwZXIiLCI9PSIsIm90aGVyIiwiaGFzX2tleT8iLCJibG9ja19naXZlbj8iLCJtZXRob2RfbWlzc2luZyIsIltdPSIsIm1lcmdlISIsImluY2x1ZGVfYWxsIiwiaW5zdGFuY2VfbWV0aG9kIiwiYmluZCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJtaWQiLCJzbGljZSIsIi0iLCJsZW5ndGgiLCIxIiwibmlsPyIsImluc3RhbmNlX29mPyIsImNsYXNzIiwib3B0aW9ucyIsIkJhc2ljT2JqZWN0IiwiPGNsYXNzOk5hdGl2ZTo6QXJyYXk+IiwiRW51bWVyYWJsZSIsIkBnZXQiLCIkcmV0X29yXzEiLCJAbmFtZWQiLCJAc2V0IiwiQGxlbmd0aCIsIkBibG9jayIsImVudW1fZm9yIiwiaW5kZXgiLCJyZXN1bHQiLCJTdHJpbmciLCJTeW1ib2wiLCJJbnRlZ2VyIiwibGFzdCIsImNvdW50IiwiPj0iLCI8PCIsIjxjbGFzczpOdW1lcmljPiIsIjxjbGFzczpQcm9jPiIsIjxjbGFzczpTdHJpbmc+IiwiPGNsYXNzOlJlZ2V4cD4iLCI8Y2xhc3M6TWF0Y2hEYXRhPiIsIjxjbGFzczpTdHJ1Y3Q+IiwiZWFjaF9wYWlyIiwiYmxvY2sgaW4gdG9fbiIsImJsb2NrICgyIGxldmVscykgaW4gdG9fbiIsIjxjbGFzczpBcnJheT4iLCI8Y2xhc3M6Qm9vbGVhbj4iLCI8Y2xhc3M6VGltZT4iLCI8Y2xhc3M6TmlsQ2xhc3M+IiwiSGFzaCIsIm1ldGhvZF9kZWZpbmVkPyIsIjxjbGFzczpIYXNoPiIsImRlZmF1bHRzIiwiX2luaXRpYWxpemUiLCI8Y2xhc3M6TW9kdWxlPiIsIm5hdGl2ZV9tb2R1bGUiLCI8Y2xhc3M6Q2xhc3M+IiwibmF0aXZlX2FsaWFzIiwibmV3X2pzaWQiLCJleGlzdGluZ19taWQiLCJOYW1lRXJyb3IiLCJuYXRpdmVfY2xhc3MiLCIkJCIsIiRnbG9iYWwiXSwibWFwcGluZ3MiOiJBQUFBQSx5QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFpQkFDO0VBQUFBOztJQUFBQTs7O0lBQ0VDLE1BQUlDLElBQUpELFlBQUFBLDZCQUFlRSxNQUFELEVBQVNDLEtBQXZCSDtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBLGVBQWlCRSxNQUFPRixZQUFjQyxJQUFBRyxhQUFBQSxDQUFZRCxLQUFaQyxDQUFtQko7QUFDekRBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBUkVBLENBQUFBO0lBV0FJLE1BQUlILElBQUpHLGtCQUFBQSx1QkFBcUJDLEtBQUQsRUFBUUMsUUFBNUJGO0FBQUFBLE1BQUFBOzs7TUFBNEIsaUNBQVU7O0FBRXhDQSxVQUFZSCxJ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R0FBdkUsRUFBMkVFLFlBQWxFbEcsQ0FBZmhDLENBQStGZ0k7QUFDekdBO0FBQ0FBLE1BQVExSSxJQUFLMEksV0FBYUMsUUFBU0Q7QUFDbkNBO0lBUEVBLENBQUFBO0lBVUFELE9BQUFLLDRCQUFBQSx3QkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFOUksSUFBQXdJLGVBQUFBLENBQUFBO01BQ0FNLE9BQUNBLHVCQUFEQTtJQUZGQSxDQUFBQTtFQVhGTCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQWtCQTVJLE9BQUFrSixDQUFBQSxXQUFLQyxDQUFBQSxnQkFBVWhKLElBQUFnQixRQUFBQSxDQUFRbkIsV0FBUm1CLENBQVZnSSxDQUFMRDtBQXhuQkFsSjsifX0seyJvZmZzZXQiOnsibGluZSI6MjYwMzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2NvbnNvbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnbmF0aXZlJ1xuXG4jIE1hbmlwdWxhdGUgdGhlIGJyb3dzZXIgY29uc29sZS5cbiNcbiMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvY29uc29sZVxuY2xhc3MgQ29uc29sZVxuICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICMgQ2xlYXIgdGhlIGNvbnNvbGUuXG4gIGRlZiBjbGVhclxuICAgIGAje0BuYXRpdmV9LmNsZWFyKClgXG4gIGVuZFxuXG4gICMgUHJpbnQgYSBzdGFja3RyYWNlIGZyb20gdGhlIGNhbGwgc2l0ZS5cbiAgZGVmIHRyYWNlXG4gICAgYCN7QG5hdGl2ZX0udHJhY2UoKWBcbiAgZW5kXG5cbiAgIyBMb2cgdGhlIHBhc3NlZCBvYmplY3RzIGJhc2VkIG9uIGFuIG9wdGlvbmFsIGluaXRpYWwgZm9ybWF0LlxuICBkZWYgbG9nKCphcmdzKVxuICAgIGAje0BuYXRpdmV9LmxvZy5hcHBseSgje0BuYXRpdmV9LCBhcmdzKWBcbiAgZW5kXG5cbiAgIyBMb2cgdGhlIHBhc3NlZCBvYmplY3RzIGJhc2VkIG9uIGFuIG9wdGlvbmFsIGluaXRpYWwgZm9ybWF0IGFzIGluZm9ybWF0aW9uYWxcbiAgIyBsb2cuXG4gIGRlZiBpbmZvKCphcmdzKVxuICAgIGAje0BuYXRpdmV9LmluZm8uYXBwbHkoI3tAbmF0aXZlfSwgYXJncylgXG4gIGVuZFxuXG4gICMgTG9nIHRoZSBwYXNzZWQgb2JqZWN0cyBiYXNlZCBvbiBhbiBvcHRpb25hbCBpbml0aWFsIGZvcm1hdCBhcyB3YXJuaW5nLlxuICBkZWYgd2FybigqYXJncylcbiAgICBgI3tAbmF0aXZlfS53YXJuLmFwcGx5KCN7QG5hdGl2ZX0sIGFyZ3MpYFxuICBlbmRcblxuICAjIExvZyB0aGUgcGFzc2VkIG9iamVjdHMgYmFzZWQgb24gYW4gb3B0aW9uYWwgaW5pdGlhbCBmb3JtYXQgYXMgZXJyb3IuXG4gIGRlZiBlcnJvcigqYXJncylcbiAgICBgI3tAbmF0aXZlfS5lcnJvci5hcHBseSgje0BuYXRpdmV9LCBhcmdzKWBcbiAgZW5kXG5cbiAgIyBUaW1lIHRoZSBnaXZlbiBibG9jayB3aXRoIHRoZSBnaXZlbiBsYWJlbC5cbiAgZGVmIHRpbWUobGFiZWwsICZibG9jaylcbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgYCN7QG5hdGl2ZX0udGltZShsYWJlbClgXG5cbiAgICBiZWdpblxuICAgICAgaWYgYmxvY2suYXJpdHkgPT0gMFxuICAgICAgICBpbnN0YW5jZV9leGVjKCZibG9jaylcbiAgICAgIGVsc2VcbiAgICAgICAgeWllbGQoc2VsZilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgYCN7QG5hdGl2ZX0udGltZUVuZCgpYFxuICAgIGVuZFxuICBlbmRcblxuICAjIEdyb3VwIHRoZSBnaXZlbiBibG9jay5cbiAgZGVmIGdyb3VwKCphcmdzLCAmYmxvY2spXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgIGAje0BuYXRpdmV9Lmdyb3VwLmFwcGx5KCN7QG5hdGl2ZX0sIGFyZ3MpYFxuXG4gICAgYmVnaW5cbiAgICAgIGlmIGJsb2NrLmFyaXR5ID09IDBcbiAgICAgICAgaW5zdGFuY2VfZXhlYygmYmxvY2spXG4gICAgICBlbHNlXG4gICAgICAgIHlpZWxkKHNlbGYpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGAje0BuYXRpdmV9Lmdyb3VwRW5kKClgXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgR3JvdXAgdGhlIGdpdmVuIGJsb2NrIGJ1dCBjb2xsYXBzZSBpdC5cbiAgZGVmIGdyb3VwISgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBgI3tAbmF0aXZlfS5ncm91cENvbGxhcHNlZC5hcHBseSgje0BuYXRpdmV9LCBhcmdzKWBcblxuICAgIGJlZ2luXG4gICAgICBpZiBibG9jay5hcml0eSA9PSAwXG4gICAgICAgIGluc3RhbmNlX2V4ZWMoJmJsb2NrKVxuICAgICAgZWxzZVxuICAgICAgICB5aWVsZChzZWxmKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBgI3tAbmF0aXZlfS5ncm91cEVuZCgpYFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5pZiBkZWZpbmVkPyhgT3BhbC5nbG9iYWwuY29uc29sZWApXG4gICRjb25zb2xlID0gQ29uc29sZS5uZXcoYE9wYWwuZ2xvYmFsLmNvbnNvbGVgKVxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkNvbnNvbGU+IiwiaW5jbHVkZSIsIk5hdGl2ZTo6V3JhcHBlciIsIk5hdGl2ZSIsImNsZWFyIiwiQG5hdGl2ZSIsInRyYWNlIiwibG9nIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsInRpbWUiLCJsYWJlbCIsImJsb2NrIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiYXJpdHkiLCIwIiwiaW5zdGFuY2VfZXhlYyIsInRvX3Byb2MiLCJncm91cCIsImdyb3VwISIsImJsb2NrX2dpdmVuPyIsIiRjb25zb2xlIiwiQ29uc29sZSIsIm5ldyJdLCJtYXBwaW5ncyI6IkFBQUFBLDBCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixRQUFSRTtFQUtBQztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDs7QUFHQUcsSUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBR0MsY0FBUUQ7SUFEYkEsQ0FBQUE7O0FBS0FFLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUdELGNBQVFDO0lBRGJBLENBQUFBOztBQUtBQyxJQUFBQSxtQkFBQUEsZUFuQkYsRUFtQkVBO0FBQUFBLE1BQUFBOzs7TUFuQkY7TUFtQlU7TUFDTkEsT0FBR0YsY0FBUUUsV0FBYUYsY0FBUUU7SUFEbENBLENBQUFBLElBQUFBOztBQU1BQyxJQUFBQSxvQkFBQUEsZ0JBekJGLEVBeUJFQTtBQUFBQSxNQUFBQTs7O01BekJGO01BeUJXO01BQ1BBLE9BQUdILGNBQVFHLFlBQWNILGNBQVFHO0lBRG5DQSxDQUFBQSxJQUFBQTs7QUFLQUMsSUFBQUEsb0JBQUFBLGdCQTlCRixFQThCRUE7QUFBQUEsTUFBQUE7OztNQTlCRjtNQThCVztNQUNQQSxPQUFHSixjQUFRSSxZQUFjSixjQUFRSTtJQURuQ0EsQ0FBQUEsSUFBQUE7O0FBS0FDLElBQUFBLHFCQUFBQSxpQkFuQ0YsRUFtQ0VBO0FBQUFBLE1BQUFBOzs7TUFuQ0Y7TUFtQ1k7TUFDUkEsT0FBR0wsY0FBUUssYUFBZUwsY0FBUUs7SUFEcENBLENBQUFBLElBQUFBOztBQUtBQyxJQUFBQSxvQkFBQUEsZ0JBQVNDLEtBQVREO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0UsS0FBQSxRQUE2Q0UsS0FBN0MsQ0FBQTtRQUFBZixJQUFBZ0IsT0FBQUEsQ0FBTUMsbUJBQU4sRUFBcUJKLGdCQUFyQkc7TUFBQTtNQUVHVCxjQUFRTTs7TUFHVEEsT0FBQSxjQUFBO01BQUEsSUFBQSxNQUFHRSxLQUFLRyxPQUFBQSxDQUFBQSxDQUFSLEVBQWtCQyxDQUFsQixDQUFBO1FBQ0VOLE9BQUFPLE1BQUFwQixJQUFBb0IsaUJBQUFBLEVBQUFBLEVBQUFBLEVBQWVMLEtBQURNLFNBQUFBLENBQUFBLENBQWREO01BREY7UUFHRSxPQUFBLG1CQUFNcEIsSUFBTixDQUFBO01BSEY7TUFBQTtRQU1HTyxjQUFRTTtNQU5YLENBQUE7SUFOSkEsQ0FBQUE7O0FBaUJBUyxJQUFBQSxxQkFBQUEsaUJBekRGLEVBeURFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQXpERjtNQXlEWTtNQUNSLEtBQUEsUUFBNkNQLEtBQTdDLENBQUE7UUFBQWYsSUFBQWdCLE9BQUFBLENBQU1DLG1CQUFOLEVBQXFCSyxnQkFBckJOO01BQUE7TUFFR1QsY0FBUWUsYUFBZWYsY0FBUWU7O01BR2hDQSxPQUFBLGNBQUE7TUFBQSxJQUFBLE1BQUdQLEtBQUtHLE9BQUFBLENBQUFBLENBQVIsRUFBa0JDLENBQWxCLENBQUE7UUFDRUcsT0FBQUYsTUFBQXBCLElBQUFvQixpQkFBQUEsRUFBQUEsRUFBQUEsRUFBZUwsS0FBRE0sU0FBQUEsQ0FBQUEsQ0FBZEQ7TUFERjtRQUdFLE9BQUEsbUJBQU1wQixJQUFOLENBQUE7TUFIRjtNQUFBO1FBTUdPLGNBQVFlO01BTlgsQ0FBQTtJQU5KQSxDQUFBQSxJQUFBQTtJQWlCQXBCLE9BQUFxQixzQkFBQUEsK0JBMUVGLEVBMEVFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQTFFRjtNQTBFYTtNQUNULEtBQWNDLGVBQWQ7UUFBQSxPQUFBO01BQUE7TUFFR2pCLGNBQVFnQixzQkFBd0JoQixjQUFRZ0I7O01BR3pDQSxPQUFBLGNBQUE7TUFBQSxJQUFBLE1BQUdSLEtBQUtHLE9BQUFBLENBQUFBLENBQVIsRUFBa0JDLENBQWxCLENBQUE7UUFDRUksT0FBQUgsTUFBQXBCLElBQUFvQixpQkFBQUEsRUFBQUEsRUFBQUEsRUFBZUwsS0FBRE0sU0FBQUEsQ0FBQUEsQ0FBZEQ7TUFERjtRQUdFLE9BQUEsbUJBQU1wQixJQUFOLENBQUE7TUFIRjtNQUFBO1FBTUdPLGNBQVFnQjtNQU5YLENBQUE7SUFOSkEsQ0FBQUEsSUFBQUE7RUFyRUZyQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQXNGQSxJQUFBLFFBQUcsUUFBVUgsbUJBQVYsa0JBQUgsQ0FBQTtJQUNFQSxPQUFBMEIsQ0FBQUEsaUJBQVdDLGFBQU9DLEtBQUFBLENBQU01QixtQkFBTjRCLENBQWxCRjtFQURGO0lBM0ZBMUIsT0FBQTtFQTJGQTtBQTNGQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2MTc0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidmVuZG9yL3ZpcnR1YWwtZG9tLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLnZpcnR1YWxEb209ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoXCIuL3Zkb20vY3JlYXRlLWVsZW1lbnQuanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVFbGVtZW50XG5cbn0se1wiLi92ZG9tL2NyZWF0ZS1lbGVtZW50LmpzXCI6MTV9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkaWZmID0gcmVxdWlyZShcIi4vdnRyZWUvZGlmZi5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcblxufSx7XCIuL3Z0cmVlL2RpZmYuanNcIjozNX1dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGggPSByZXF1aXJlKFwiLi92aXJ0dWFsLWh5cGVyc2NyaXB0L2luZGV4LmpzXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gaFxuXG59LHtcIi4vdmlydHVhbC1oeXBlcnNjcmlwdC9pbmRleC5qc1wiOjIyfV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZGlmZiA9IHJlcXVpcmUoXCIuL2RpZmYuanNcIilcclxudmFyIHBhdGNoID0gcmVxdWlyZShcIi4vcGF0Y2guanNcIilcclxudmFyIGggPSByZXF1aXJlKFwiLi9oLmpzXCIpXHJcbnZhciBjcmVhdGUgPSByZXF1aXJlKFwiLi9jcmVhdGUtZWxlbWVudC5qc1wiKVxyXG52YXIgVk5vZGUgPSByZXF1aXJlKCcuL3Zub2RlL3Zub2RlLmpzJylcclxudmFyIFZUZXh0ID0gcmVxdWlyZSgnLi92bm9kZS92dGV4dC5qcycpXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGRpZmY6IGRpZmYsXHJcbiAgICBwYXRjaDogcGF0Y2gsXHJcbiAgICBoOiBoLFxyXG4gICAgY3JlYXRlOiBjcmVhdGUsXHJcbiAgICBWTm9kZTogVk5vZGUsXHJcbiAgICBWVGV4dDogVlRleHRcclxufVxyXG5cbn0se1wiLi9jcmVhdGUtZWxlbWVudC5qc1wiOjEsXCIuL2RpZmYuanNcIjoyLFwiLi9oLmpzXCI6MyxcIi4vcGF0Y2guanNcIjoxMyxcIi4vdm5vZGUvdm5vZGUuanNcIjozMSxcIi4vdm5vZGUvdnRleHQuanNcIjozM31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyohXG4gKiBDcm9zcy1Ccm93c2VyIFNwbGl0IDEuMS4xXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDEyIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogRUNNQVNjcmlwdCBjb21wbGlhbnQsIHVuaWZvcm0gY3Jvc3MtYnJvd3NlciBzcGxpdCBtZXRob2RcbiAqL1xuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYSByZWdleCBvciBzdHJpbmcgc2VwYXJhdG9yLiBNYXRjaGVzIG9mIHRoZVxuICogc2VwYXJhdG9yIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBhcnJheS4gSG93ZXZlciwgaWYgYHNlcGFyYXRvcmAgaXMgYSByZWdleCB0aGF0IGNvbnRhaW5zXG4gKiBjYXB0dXJpbmcgZ3JvdXBzLCBiYWNrcmVmZXJlbmNlcyBhcmUgc3BsaWNlZCBpbnRvIHRoZSByZXN1bHQgZWFjaCB0aW1lIGBzZXBhcmF0b3JgIGlzIG1hdGNoZWQuXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5XG4gKiBjcm9zcy1icm93c2VyLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXQuXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZVxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcpO1xuICogLy8gLT4gWydhJywgJ2InLCAnYycsICdkJ11cbiAqXG4gKiAvLyBXaXRoIGxpbWl0XG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJywgMik7XG4gKiAvLyAtPiBbJ2EnLCAnYiddXG4gKlxuICogLy8gQmFja3JlZmVyZW5jZXMgaW4gcmVzdWx0IGFycmF5XG4gKiBzcGxpdCgnLi53b3JkMSB3b3JkMi4uJywgLyhbYS16XSspKFxcZCspL2kpO1xuICogLy8gLT4gWycuLicsICd3b3JkJywgJzEnLCAnICcsICd3b3JkJywgJzInLCAnLi4nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBzcGxpdCh1bmRlZikge1xuXG4gIHZhciBuYXRpdmVTcGxpdCA9IFN0cmluZy5wcm90b3R5cGUuc3BsaXQsXG4gICAgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYyhcIlwiKVsxXSA9PT0gdW5kZWYsXG4gICAgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICBzZWxmO1xuXG4gIHNlbGYgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIGBuYXRpdmVTcGxpdGBcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09IFwiW29iamVjdCBSZWdFeHBdXCIpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChzZXBhcmF0b3IuZXh0ZW5kZWQgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyBcInlcIiA6IFwiXCIpLFxuICAgICAgLy8gRmlyZWZveCAzK1xuICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArIFwiZ1wiKSxcbiAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgc3RyICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBzZXBhcmF0b3Iuc291cmNlICsgXCIkKD8hXFxcXHMpXCIsIGZsYWdzKTtcbiAgICB9XG4gICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAqL1xuICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmID8gLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgbGltaXQgPj4+IDA7IC8vIFRvVWludDMyKGxpbWl0KVxuICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cikpIHtcbiAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB1bmRlZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdChcIlwiKSkge1xuICAgICAgICBvdXRwdXQucHVzaChcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59KSgpO1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBPbmVWZXJzaW9uQ29uc3RyYWludCA9IHJlcXVpcmUoJ2luZGl2aWR1YWwvb25lLXZlcnNpb24nKTtcblxudmFyIE1ZX1ZFUlNJT04gPSAnNyc7XG5PbmVWZXJzaW9uQ29uc3RyYWludCgnZXYtc3RvcmUnLCBNWV9WRVJTSU9OKTtcblxudmFyIGhhc2hLZXkgPSAnX19FVl9TVE9SRV9LRVlAJyArIE1ZX1ZFUlNJT047XG5cbm1vZHVsZS5leHBvcnRzID0gRXZTdG9yZTtcblxuZnVuY3Rpb24gRXZTdG9yZShlbGVtKSB7XG4gICAgdmFyIGhhc2ggPSBlbGVtW2hhc2hLZXldO1xuXG4gICAgaWYgKCFoYXNoKSB7XG4gICAgICAgIGhhc2ggPSBlbGVtW2hhc2hLZXldID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG59XG5cbn0se1wiaW5kaXZpZHVhbC9vbmUtdmVyc2lvblwiOjl9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xuXG52YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID9cbiAgICB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/XG4gICAgZ2xvYmFsIDoge307XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kaXZpZHVhbDtcblxuZnVuY3Rpb24gSW5kaXZpZHVhbChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiByb290KSB7XG4gICAgICAgIHJldHVybiByb290W2tleV07XG4gICAgfVxuXG4gICAgcm9vdFtrZXldID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBJbmRpdmlkdWFsID0gcmVxdWlyZSgnLi9pbmRleC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9uZVZlcnNpb247XG5cbmZ1bmN0aW9uIE9uZVZlcnNpb24obW9kdWxlTmFtZSwgdmVyc2lvbiwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIGtleSA9ICdfX0lORElWSURVQUxfT05FX1ZFUlNJT05fJyArIG1vZHVsZU5hbWU7XG4gICAgdmFyIGVuZm9yY2VLZXkgPSBrZXkgKyAnX0VORk9SQ0VfU0lOR0xFVE9OJztcblxuICAgIHZhciB2ZXJzaW9uVmFsdWUgPSBJbmRpdmlkdWFsKGVuZm9yY2VLZXksIHZlcnNpb24pO1xuXG4gICAgaWYgKHZlcnNpb25WYWx1ZSAhPT0gdmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IGhhdmUgb25lIGNvcHkgb2YgJyArXG4gICAgICAgICAgICBtb2R1bGVOYW1lICsgJy5cXG4nICtcbiAgICAgICAgICAgICdZb3UgYWxyZWFkeSBoYXZlIHZlcnNpb24gJyArIHZlcnNpb25WYWx1ZSArXG4gICAgICAgICAgICAnIGluc3RhbGxlZC5cXG4nICtcbiAgICAgICAgICAgICdUaGlzIG1lYW5zIHlvdSBjYW5ub3QgaW5zdGFsbCB2ZXJzaW9uICcgKyB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSW5kaXZpZHVhbChrZXksIGRlZmF1bHRWYWx1ZSk7XG59XG5cbn0se1wiLi9pbmRleC5qc1wiOjh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgdG9wTGV2ZWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fVxudmFyIG1pbkRvYyA9IHJlcXVpcmUoJ21pbi1kb2N1bWVudCcpO1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIHZhciBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY2N5O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wibWluLWRvY3VtZW50XCI6Nn1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcblx0cmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIHggIT09IG51bGw7XG59O1xuXG59LHt9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXlcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVJc0FycmF5IHx8IGlzQXJyYXlcblxuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCJcbn1cblxufSx7fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHBhdGNoID0gcmVxdWlyZShcIi4vdmRvbS9wYXRjaC5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG5cbn0se1wiLi92ZG9tL3BhdGNoLmpzXCI6MTh9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKFwiaXMtb2JqZWN0XCIpXG52YXIgaXNIb29rID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZob29rLmpzXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlQcm9wZXJ0aWVzXG5cbmZ1bmN0aW9uIGFwcGx5UHJvcGVydGllcyhub2RlLCBwcm9wcywgcHJldmlvdXMpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdXG5cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZW1vdmVQcm9wZXJ0eShub2RlLCBwcm9wTmFtZSwgcHJvcFZhbHVlLCBwcmV2aW91cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNIb29rKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZVByb3BlcnR5KG5vZGUsIHByb3BOYW1lLCBwcm9wVmFsdWUsIHByZXZpb3VzKVxuICAgICAgICAgICAgaWYgKHByb3BWYWx1ZS5ob29rKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlLmhvb2sobm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID8gcHJldmlvdXNbcHJvcE5hbWVdIDogdW5kZWZpbmVkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaE9iamVjdChub2RlLCBwcm9wcywgcHJldmlvdXMsIHByb3BOYW1lLCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHByb3BWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVQcm9wZXJ0eShub2RlLCBwcm9wTmFtZSwgcHJvcFZhbHVlLCBwcmV2aW91cykge1xuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzW3Byb3BOYW1lXVxuXG4gICAgICAgIGlmICghaXNIb29rKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtpXSA9IFwiXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcmV2aW91c1ZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBcIlwiXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzVmFsdWUudW5ob29rKSB7XG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlLnVuaG9vayhub2RlLCBwcm9wTmFtZSwgcHJvcFZhbHVlKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaE9iamVjdChub2RlLCBwcm9wcywgcHJldmlvdXMsIHByb3BOYW1lLCBwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzID8gcHJldmlvdXNbcHJvcE5hbWVdIDogdW5kZWZpbmVkXG5cbiAgICAvLyBTZXQgYXR0cmlidXRlc1xuICAgIGlmIChwcm9wTmFtZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gcHJvcFZhbHVlW2F0dHJOYW1lXVxuXG4gICAgICAgICAgICBpZiAoYXR0clZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmKHByZXZpb3VzVmFsdWUgJiYgaXNPYmplY3QocHJldmlvdXNWYWx1ZSkgJiZcbiAgICAgICAgZ2V0UHJvdG90eXBlKHByZXZpb3VzVmFsdWUpICE9PSBnZXRQcm90b3R5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHByb3BWYWx1ZVxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWlzT2JqZWN0KG5vZGVbcHJvcE5hbWVdKSkge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHt9XG4gICAgfVxuXG4gICAgdmFyIHJlcGxhY2VyID0gcHJvcE5hbWUgPT09IFwic3R5bGVcIiA/IFwiXCIgOiB1bmRlZmluZWRcblxuICAgIGZvciAodmFyIGsgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3BWYWx1ZVtrXVxuICAgICAgICBub2RlW3Byb3BOYW1lXVtrXSA9ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IHJlcGxhY2VyIDogdmFsdWVcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3RvdHlwZSh2YWx1ZSkge1xuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSlcbiAgICB9IGVsc2UgaWYgKHZhbHVlLl9fcHJvdG9fXykge1xuICAgICAgICByZXR1cm4gdmFsdWUuX19wcm90b19fXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlXG4gICAgfVxufVxuXG59LHtcIi4uL3Zub2RlL2lzLXZob29rLmpzXCI6MjYsXCJpcy1vYmplY3RcIjoxMX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoXCJnbG9iYWwvZG9jdW1lbnRcIilcblxudmFyIGFwcGx5UHJvcGVydGllcyA9IHJlcXVpcmUoXCIuL2FwcGx5LXByb3BlcnRpZXNcIilcblxudmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdm5vZGUuanNcIilcbnZhciBpc1ZUZXh0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZ0ZXh0LmpzXCIpXG52YXIgaXNXaWRnZXQgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtd2lkZ2V0LmpzXCIpXG52YXIgaGFuZGxlVGh1bmsgPSByZXF1aXJlKFwiLi4vdm5vZGUvaGFuZGxlLXRodW5rLmpzXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRWxlbWVudFxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHZub2RlLCBvcHRzKSB7XG4gICAgdmFyIGRvYyA9IG9wdHMgPyBvcHRzLmRvY3VtZW50IHx8IGRvY3VtZW50IDogZG9jdW1lbnRcbiAgICB2YXIgd2FybiA9IG9wdHMgPyBvcHRzLndhcm4gOiBudWxsXG5cbiAgICB2bm9kZSA9IGhhbmRsZVRodW5rKHZub2RlKS5hXG5cbiAgICBpZiAoaXNXaWRnZXQodm5vZGUpKSB7XG4gICAgICAgIHJldHVybiB2bm9kZS5pbml0KClcbiAgICB9IGVsc2UgaWYgKGlzVlRleHQodm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dClcbiAgICB9IGVsc2UgaWYgKCFpc1ZOb2RlKHZub2RlKSkge1xuICAgICAgICBpZiAod2Fybikge1xuICAgICAgICAgICAgd2FybihcIkl0ZW0gaXMgbm90IGEgdmFsaWQgdmlydHVhbCBkb20gbm9kZVwiLCB2bm9kZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciBub2RlID0gKHZub2RlLm5hbWVzcGFjZSA9PT0gbnVsbCkgP1xuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudCh2bm9kZS50YWdOYW1lKSA6XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50TlModm5vZGUubmFtZXNwYWNlLCB2bm9kZS50YWdOYW1lKVxuXG4gICAgdmFyIHByb3BzID0gdm5vZGUucHJvcGVydGllc1xuICAgIGFwcGx5UHJvcGVydGllcyhub2RlLCBwcm9wcylcblxuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBjcmVhdGVFbGVtZW50KGNoaWxkcmVuW2ldLCBvcHRzKVxuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlXG59XG5cbn0se1wiLi4vdm5vZGUvaGFuZGxlLXRodW5rLmpzXCI6MjQsXCIuLi92bm9kZS9pcy12bm9kZS5qc1wiOjI3LFwiLi4vdm5vZGUvaXMtdnRleHQuanNcIjoyOCxcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiOjI5LFwiLi9hcHBseS1wcm9wZXJ0aWVzXCI6MTQsXCJnbG9iYWwvZG9jdW1lbnRcIjoxMH1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIE1hcHMgYSB2aXJ0dWFsIERPTSB0cmVlIG9udG8gYSByZWFsIERPTSB0cmVlIGluIGFuIGVmZmljaWVudCBtYW5uZXIuXG4vLyBXZSBkb24ndCB3YW50IHRvIHJlYWQgYWxsIG9mIHRoZSBET00gbm9kZXMgaW4gdGhlIHRyZWUgc28gd2UgdXNlXG4vLyB0aGUgaW4tb3JkZXIgdHJlZSBpbmRleGluZyB0byBlbGltaW5hdGUgcmVjdXJzaW9uIGRvd24gY2VydGFpbiBicmFuY2hlcy5cbi8vIFdlIG9ubHkgcmVjdXJzZSBpbnRvIGEgRE9NIG5vZGUgaWYgd2Uga25vdyB0aGF0IGl0IGNvbnRhaW5zIGEgY2hpbGQgb2Zcbi8vIGludGVyZXN0LlxuXG52YXIgbm9DaGlsZCA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tSW5kZXhcblxuZnVuY3Rpb24gZG9tSW5kZXgocm9vdE5vZGUsIHRyZWUsIGluZGljZXMsIG5vZGVzKSB7XG4gICAgaWYgKCFpbmRpY2VzIHx8IGluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGljZXMuc29ydChhc2NlbmRpbmcpXG4gICAgICAgIHJldHVybiByZWN1cnNlKHJvb3ROb2RlLCB0cmVlLCBpbmRpY2VzLCBub2RlcywgMClcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2Uocm9vdE5vZGUsIHRyZWUsIGluZGljZXMsIG5vZGVzLCByb290SW5kZXgpIHtcbiAgICBub2RlcyA9IG5vZGVzIHx8IHt9XG5cblxuICAgIGlmIChyb290Tm9kZSkge1xuICAgICAgICBpZiAoaW5kZXhJblJhbmdlKGluZGljZXMsIHJvb3RJbmRleCwgcm9vdEluZGV4KSkge1xuICAgICAgICAgICAgbm9kZXNbcm9vdEluZGV4XSA9IHJvb3ROb2RlXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdkNoaWxkcmVuID0gdHJlZS5jaGlsZHJlblxuXG4gICAgICAgIGlmICh2Q2hpbGRyZW4pIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSByb290Tm9kZS5jaGlsZE5vZGVzXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJvb3RJbmRleCArPSAxXG5cbiAgICAgICAgICAgICAgICB2YXIgdkNoaWxkID0gdkNoaWxkcmVuW2ldIHx8IG5vQ2hpbGRcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gcm9vdEluZGV4ICsgKHZDaGlsZC5jb3VudCB8fCAwKVxuXG4gICAgICAgICAgICAgICAgLy8gc2tpcCByZWN1cnNpb24gZG93biB0aGUgdHJlZSBpZiB0aGVyZSBhcmUgbm8gbm9kZXMgZG93biBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4SW5SYW5nZShpbmRpY2VzLCByb290SW5kZXgsIG5leHRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZShjaGlsZE5vZGVzW2ldLCB2Q2hpbGQsIGluZGljZXMsIG5vZGVzLCByb290SW5kZXgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm9vdEluZGV4ID0gbmV4dEluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXNcbn1cblxuLy8gQmluYXJ5IHNlYXJjaCBmb3IgYW4gaW5kZXggaW4gdGhlIGludGVydmFsIFtsZWZ0LCByaWdodF1cbmZ1bmN0aW9uIGluZGV4SW5SYW5nZShpbmRpY2VzLCBsZWZ0LCByaWdodCkge1xuICAgIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgbWluSW5kZXggPSAwXG4gICAgdmFyIG1heEluZGV4ID0gaW5kaWNlcy5sZW5ndGggLSAxXG4gICAgdmFyIGN1cnJlbnRJbmRleFxuICAgIHZhciBjdXJyZW50SXRlbVxuXG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9ICgobWF4SW5kZXggKyBtaW5JbmRleCkgLyAyKSA+PiAwXG4gICAgICAgIGN1cnJlbnRJdGVtID0gaW5kaWNlc1tjdXJyZW50SW5kZXhdXG5cbiAgICAgICAgaWYgKG1pbkluZGV4ID09PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJdGVtID49IGxlZnQgJiYgY3VycmVudEl0ZW0gPD0gcmlnaHRcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50SXRlbSA8IGxlZnQpIHtcbiAgICAgICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMVxuICAgICAgICB9IGVsc2UgIGlmIChjdXJyZW50SXRlbSA+IHJpZ2h0KSB7XG4gICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IC0xXG59XG5cbn0se31dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBhcHBseVByb3BlcnRpZXMgPSByZXF1aXJlKFwiLi9hcHBseS1wcm9wZXJ0aWVzXCIpXG5cbnZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy13aWRnZXQuanNcIilcbnZhciBWUGF0Y2ggPSByZXF1aXJlKFwiLi4vdm5vZGUvdnBhdGNoLmpzXCIpXG5cbnZhciB1cGRhdGVXaWRnZXQgPSByZXF1aXJlKFwiLi91cGRhdGUtd2lkZ2V0XCIpXG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlQYXRjaFxuXG5mdW5jdGlvbiBhcHBseVBhdGNoKHZwYXRjaCwgZG9tTm9kZSwgcmVuZGVyT3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gdnBhdGNoLnR5cGVcbiAgICB2YXIgdk5vZGUgPSB2cGF0Y2gudk5vZGVcbiAgICB2YXIgcGF0Y2ggPSB2cGF0Y2gucGF0Y2hcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFZQYXRjaC5SRU1PVkU6XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlTm9kZShkb21Ob2RlLCB2Tm9kZSlcbiAgICAgICAgY2FzZSBWUGF0Y2guSU5TRVJUOlxuICAgICAgICAgICAgcmV0dXJuIGluc2VydE5vZGUoZG9tTm9kZSwgcGF0Y2gsIHJlbmRlck9wdGlvbnMpXG4gICAgICAgIGNhc2UgVlBhdGNoLlZURVhUOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1BhdGNoKGRvbU5vZGUsIHZOb2RlLCBwYXRjaCwgcmVuZGVyT3B0aW9ucylcbiAgICAgICAgY2FzZSBWUGF0Y2guV0lER0VUOlxuICAgICAgICAgICAgcmV0dXJuIHdpZGdldFBhdGNoKGRvbU5vZGUsIHZOb2RlLCBwYXRjaCwgcmVuZGVyT3B0aW9ucylcbiAgICAgICAgY2FzZSBWUGF0Y2guVk5PREU6XG4gICAgICAgICAgICByZXR1cm4gdk5vZGVQYXRjaChkb21Ob2RlLCB2Tm9kZSwgcGF0Y2gsIHJlbmRlck9wdGlvbnMpXG4gICAgICAgIGNhc2UgVlBhdGNoLk9SREVSOlxuICAgICAgICAgICAgcmVvcmRlckNoaWxkcmVuKGRvbU5vZGUsIHBhdGNoKVxuICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGVcbiAgICAgICAgY2FzZSBWUGF0Y2guUFJPUFM6XG4gICAgICAgICAgICBhcHBseVByb3BlcnRpZXMoZG9tTm9kZSwgcGF0Y2gsIHZOb2RlLnByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gZG9tTm9kZVxuICAgICAgICBjYXNlIFZQYXRjaC5USFVOSzpcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlUm9vdChkb21Ob2RlLFxuICAgICAgICAgICAgICAgIHJlbmRlck9wdGlvbnMucGF0Y2goZG9tTm9kZSwgcGF0Y2gsIHJlbmRlck9wdGlvbnMpKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGVcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUoZG9tTm9kZSwgdk5vZGUpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGRvbU5vZGUucGFyZW50Tm9kZVxuXG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb21Ob2RlKVxuICAgIH1cblxuICAgIGRlc3Ryb3lXaWRnZXQoZG9tTm9kZSwgdk5vZGUpO1xuXG4gICAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnROb2RlLCB2Tm9kZSwgcmVuZGVyT3B0aW9ucykge1xuICAgIHZhciBuZXdOb2RlID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIodk5vZGUsIHJlbmRlck9wdGlvbnMpXG5cbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5ld05vZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gc3RyaW5nUGF0Y2goZG9tTm9kZSwgbGVmdFZOb2RlLCB2VGV4dCwgcmVuZGVyT3B0aW9ucykge1xuICAgIHZhciBuZXdOb2RlXG5cbiAgICBpZiAoZG9tTm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICBkb21Ob2RlLnJlcGxhY2VEYXRhKDAsIGRvbU5vZGUubGVuZ3RoLCB2VGV4dC50ZXh0KVxuICAgICAgICBuZXdOb2RlID0gZG9tTm9kZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZG9tTm9kZS5wYXJlbnROb2RlXG4gICAgICAgIG5ld05vZGUgPSByZW5kZXJPcHRpb25zLnJlbmRlcih2VGV4dCwgcmVuZGVyT3B0aW9ucylcblxuICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBuZXdOb2RlICE9PSBkb21Ob2RlKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBkb21Ob2RlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld05vZGVcbn1cblxuZnVuY3Rpb24gd2lkZ2V0UGF0Y2goZG9tTm9kZSwgbGVmdFZOb2RlLCB3aWRnZXQsIHJlbmRlck9wdGlvbnMpIHtcbiAgICB2YXIgdXBkYXRpbmcgPSB1cGRhdGVXaWRnZXQobGVmdFZOb2RlLCB3aWRnZXQpXG4gICAgdmFyIG5ld05vZGVcblxuICAgIGlmICh1cGRhdGluZykge1xuICAgICAgICBuZXdOb2RlID0gd2lkZ2V0LnVwZGF0ZShsZWZ0Vk5vZGUsIGRvbU5vZGUpIHx8IGRvbU5vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdOb2RlID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIod2lkZ2V0LCByZW5kZXJPcHRpb25zKVxuICAgIH1cblxuICAgIHZhciBwYXJlbnROb2RlID0gZG9tTm9kZS5wYXJlbnROb2RlXG5cbiAgICBpZiAocGFyZW50Tm9kZSAmJiBuZXdOb2RlICE9PSBkb21Ob2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIGRvbU5vZGUpXG4gICAgfVxuXG4gICAgaWYgKCF1cGRhdGluZykge1xuICAgICAgICBkZXN0cm95V2lkZ2V0KGRvbU5vZGUsIGxlZnRWTm9kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3Tm9kZVxufVxuXG5mdW5jdGlvbiB2Tm9kZVBhdGNoKGRvbU5vZGUsIGxlZnRWTm9kZSwgdk5vZGUsIHJlbmRlck9wdGlvbnMpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGRvbU5vZGUucGFyZW50Tm9kZVxuICAgIHZhciBuZXdOb2RlID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIodk5vZGUsIHJlbmRlck9wdGlvbnMpXG5cbiAgICBpZiAocGFyZW50Tm9kZSAmJiBuZXdOb2RlICE9PSBkb21Ob2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIGRvbU5vZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld05vZGVcbn1cblxuZnVuY3Rpb24gZGVzdHJveVdpZGdldChkb21Ob2RlLCB3KSB7XG4gICAgaWYgKHR5cGVvZiB3LmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIiAmJiBpc1dpZGdldCh3KSkge1xuICAgICAgICB3LmRlc3Ryb3koZG9tTm9kZSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlb3JkZXJDaGlsZHJlbihkb21Ob2RlLCBtb3Zlcykge1xuICAgIHZhciBjaGlsZE5vZGVzID0gZG9tTm9kZS5jaGlsZE5vZGVzXG4gICAgdmFyIGtleU1hcCA9IHt9XG4gICAgdmFyIG5vZGVcbiAgICB2YXIgcmVtb3ZlXG4gICAgdmFyIGluc2VydFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3Zlcy5yZW1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlbW92ZSA9IG1vdmVzLnJlbW92ZXNbaV1cbiAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNbcmVtb3ZlLmZyb21dXG4gICAgICAgIGlmIChyZW1vdmUua2V5KSB7XG4gICAgICAgICAgICBrZXlNYXBbcmVtb3ZlLmtleV0gPSBub2RlXG4gICAgICAgIH1cbiAgICAgICAgZG9tTm9kZS5yZW1vdmVDaGlsZChub2RlKVxuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW92ZXMuaW5zZXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBpbnNlcnQgPSBtb3Zlcy5pbnNlcnRzW2pdXG4gICAgICAgIG5vZGUgPSBrZXlNYXBbaW5zZXJ0LmtleV1cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgd2VpcmRlc3QgYnVnIGkndmUgZXZlciBzZWVuIGluIHdlYmtpdFxuICAgICAgICBkb21Ob2RlLmluc2VydEJlZm9yZShub2RlLCBpbnNlcnQudG8gPj0gbGVuZ3RoKysgPyBudWxsIDogY2hpbGROb2Rlc1tpbnNlcnQudG9dKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVJvb3Qob2xkUm9vdCwgbmV3Um9vdCkge1xuICAgIGlmIChvbGRSb290ICYmIG5ld1Jvb3QgJiYgb2xkUm9vdCAhPT0gbmV3Um9vdCAmJiBvbGRSb290LnBhcmVudE5vZGUpIHtcbiAgICAgICAgb2xkUm9vdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdSb290LCBvbGRSb290KVxuICAgIH1cblxuICAgIHJldHVybiBuZXdSb290O1xufVxuXG59LHtcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiOjI5LFwiLi4vdm5vZGUvdnBhdGNoLmpzXCI6MzIsXCIuL2FwcGx5LXByb3BlcnRpZXNcIjoxNCxcIi4vdXBkYXRlLXdpZGdldFwiOjE5fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZShcImdsb2JhbC9kb2N1bWVudFwiKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKFwieC1pcy1hcnJheVwiKVxuXG52YXIgcmVuZGVyID0gcmVxdWlyZShcIi4vY3JlYXRlLWVsZW1lbnRcIilcbnZhciBkb21JbmRleCA9IHJlcXVpcmUoXCIuL2RvbS1pbmRleFwiKVxudmFyIHBhdGNoT3AgPSByZXF1aXJlKFwiLi9wYXRjaC1vcFwiKVxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuXG5mdW5jdGlvbiBwYXRjaChyb290Tm9kZSwgcGF0Y2hlcywgcmVuZGVyT3B0aW9ucykge1xuICAgIHJlbmRlck9wdGlvbnMgPSByZW5kZXJPcHRpb25zIHx8IHt9XG4gICAgcmVuZGVyT3B0aW9ucy5wYXRjaCA9IHJlbmRlck9wdGlvbnMucGF0Y2ggJiYgcmVuZGVyT3B0aW9ucy5wYXRjaCAhPT0gcGF0Y2hcbiAgICAgICAgPyByZW5kZXJPcHRpb25zLnBhdGNoXG4gICAgICAgIDogcGF0Y2hSZWN1cnNpdmVcbiAgICByZW5kZXJPcHRpb25zLnJlbmRlciA9IHJlbmRlck9wdGlvbnMucmVuZGVyIHx8IHJlbmRlclxuXG4gICAgcmV0dXJuIHJlbmRlck9wdGlvbnMucGF0Y2gocm9vdE5vZGUsIHBhdGNoZXMsIHJlbmRlck9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHBhdGNoUmVjdXJzaXZlKHJvb3ROb2RlLCBwYXRjaGVzLCByZW5kZXJPcHRpb25zKSB7XG4gICAgdmFyIGluZGljZXMgPSBwYXRjaEluZGljZXMocGF0Y2hlcylcblxuICAgIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcm9vdE5vZGVcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBkb21JbmRleChyb290Tm9kZSwgcGF0Y2hlcy5hLCBpbmRpY2VzKVxuICAgIHZhciBvd25lckRvY3VtZW50ID0gcm9vdE5vZGUub3duZXJEb2N1bWVudFxuXG4gICAgaWYgKCFyZW5kZXJPcHRpb25zLmRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIHJlbmRlck9wdGlvbnMuZG9jdW1lbnQgPSBvd25lckRvY3VtZW50XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSW5kZXggPSBpbmRpY2VzW2ldXG4gICAgICAgIHJvb3ROb2RlID0gYXBwbHlQYXRjaChyb290Tm9kZSxcbiAgICAgICAgICAgIGluZGV4W25vZGVJbmRleF0sXG4gICAgICAgICAgICBwYXRjaGVzW25vZGVJbmRleF0sXG4gICAgICAgICAgICByZW5kZXJPcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiByb290Tm9kZVxufVxuXG5mdW5jdGlvbiBhcHBseVBhdGNoKHJvb3ROb2RlLCBkb21Ob2RlLCBwYXRjaExpc3QsIHJlbmRlck9wdGlvbnMpIHtcbiAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJvb3ROb2RlXG4gICAgfVxuXG4gICAgdmFyIG5ld05vZGVcblxuICAgIGlmIChpc0FycmF5KHBhdGNoTGlzdCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRjaExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld05vZGUgPSBwYXRjaE9wKHBhdGNoTGlzdFtpXSwgZG9tTm9kZSwgcmVuZGVyT3B0aW9ucylcblxuICAgICAgICAgICAgaWYgKGRvbU5vZGUgPT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUgPSBuZXdOb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdOb2RlID0gcGF0Y2hPcChwYXRjaExpc3QsIGRvbU5vZGUsIHJlbmRlck9wdGlvbnMpXG5cbiAgICAgICAgaWYgKGRvbU5vZGUgPT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgICByb290Tm9kZSA9IG5ld05vZGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb290Tm9kZVxufVxuXG5mdW5jdGlvbiBwYXRjaEluZGljZXMocGF0Y2hlcykge1xuICAgIHZhciBpbmRpY2VzID0gW11cblxuICAgIGZvciAodmFyIGtleSBpbiBwYXRjaGVzKSB7XG4gICAgICAgIGlmIChrZXkgIT09IFwiYVwiKSB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goTnVtYmVyKGtleSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kaWNlc1xufVxuXG59LHtcIi4vY3JlYXRlLWVsZW1lbnRcIjoxNSxcIi4vZG9tLWluZGV4XCI6MTYsXCIuL3BhdGNoLW9wXCI6MTcsXCJnbG9iYWwvZG9jdW1lbnRcIjoxMCxcIngtaXMtYXJyYXlcIjoxMn1dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy13aWRnZXQuanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSB1cGRhdGVXaWRnZXRcblxuZnVuY3Rpb24gdXBkYXRlV2lkZ2V0KGEsIGIpIHtcbiAgICBpZiAoaXNXaWRnZXQoYSkgJiYgaXNXaWRnZXQoYikpIHtcbiAgICAgICAgaWYgKFwibmFtZVwiIGluIGEgJiYgXCJuYW1lXCIgaW4gYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuaWQgPT09IGIuaWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhLmluaXQgPT09IGIuaW5pdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG59XG5cbn0se1wiLi4vdm5vZGUvaXMtd2lkZ2V0LmpzXCI6Mjl9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdlN0b3JlID0gcmVxdWlyZSgnZXYtc3RvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdkhvb2s7XG5cbmZ1bmN0aW9uIEV2SG9vayh2YWx1ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFdkhvb2spKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXZIb29rKHZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cbkV2SG9vay5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uIChub2RlLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICB2YXIgZXMgPSBFdlN0b3JlKG5vZGUpO1xuICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5TmFtZS5zdWJzdHIoMyk7XG5cbiAgICBlc1twcm9wTmFtZV0gPSB0aGlzLnZhbHVlO1xufTtcblxuRXZIb29rLnByb3RvdHlwZS51bmhvb2sgPSBmdW5jdGlvbihub2RlLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICB2YXIgZXMgPSBFdlN0b3JlKG5vZGUpO1xuICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5TmFtZS5zdWJzdHIoMyk7XG5cbiAgICBlc1twcm9wTmFtZV0gPSB1bmRlZmluZWQ7XG59O1xuXG59LHtcImV2LXN0b3JlXCI6N31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBTb2Z0U2V0SG9vaztcblxuZnVuY3Rpb24gU29mdFNldEhvb2sodmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29mdFNldEhvb2spKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29mdFNldEhvb2sodmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuU29mdFNldEhvb2sucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAobm9kZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgaWYgKG5vZGVbcHJvcGVydHlOYW1lXSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB0aGlzLnZhbHVlO1xuICAgIH1cbn07XG5cbn0se31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCd4LWlzLWFycmF5Jyk7XG5cbnZhciBWTm9kZSA9IHJlcXVpcmUoJy4uL3Zub2RlL3Zub2RlLmpzJyk7XG52YXIgVlRleHQgPSByZXF1aXJlKCcuLi92bm9kZS92dGV4dC5qcycpO1xudmFyIGlzVk5vZGUgPSByZXF1aXJlKCcuLi92bm9kZS9pcy12bm9kZScpO1xudmFyIGlzVlRleHQgPSByZXF1aXJlKCcuLi92bm9kZS9pcy12dGV4dCcpO1xudmFyIGlzV2lkZ2V0ID0gcmVxdWlyZSgnLi4vdm5vZGUvaXMtd2lkZ2V0Jyk7XG52YXIgaXNIb29rID0gcmVxdWlyZSgnLi4vdm5vZGUvaXMtdmhvb2snKTtcbnZhciBpc1ZUaHVuayA9IHJlcXVpcmUoJy4uL3Zub2RlL2lzLXRodW5rJyk7XG5cbnZhciBwYXJzZVRhZyA9IHJlcXVpcmUoJy4vcGFyc2UtdGFnLmpzJyk7XG52YXIgc29mdFNldEhvb2sgPSByZXF1aXJlKCcuL2hvb2tzL3NvZnQtc2V0LWhvb2suanMnKTtcbnZhciBldkhvb2sgPSByZXF1aXJlKCcuL2hvb2tzL2V2LWhvb2suanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBoO1xuXG5mdW5jdGlvbiBoKHRhZ05hbWUsIHByb3BlcnRpZXMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBbXTtcbiAgICB2YXIgdGFnLCBwcm9wcywga2V5LCBuYW1lc3BhY2U7XG5cbiAgICBpZiAoIWNoaWxkcmVuICYmIGlzQ2hpbGRyZW4ocHJvcGVydGllcykpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBwcm9wZXJ0aWVzO1xuICAgICAgICBwcm9wcyA9IHt9O1xuICAgIH1cblxuICAgIHByb3BzID0gcHJvcHMgfHwgcHJvcGVydGllcyB8fCB7fTtcbiAgICB0YWcgPSBwYXJzZVRhZyh0YWdOYW1lLCBwcm9wcyk7XG5cbiAgICAvLyBzdXBwb3J0IGtleXNcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAgICAgIGtleSA9IHByb3BzLmtleTtcbiAgICAgICAgcHJvcHMua2V5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnQgbmFtZXNwYWNlXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCduYW1lc3BhY2UnKSkge1xuICAgICAgICBuYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgICAgIHByb3BzLm5hbWVzcGFjZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBmaXggY3Vyc29yIGJ1Z1xuICAgIGlmICh0YWcgPT09ICdJTlBVVCcgJiZcbiAgICAgICAgIW5hbWVzcGFjZSAmJlxuICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSAmJlxuICAgICAgICBwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICFpc0hvb2socHJvcHMudmFsdWUpXG4gICAgKSB7XG4gICAgICAgIHByb3BzLnZhbHVlID0gc29mdFNldEhvb2socHJvcHMudmFsdWUpO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybVByb3BlcnRpZXMocHJvcHMpO1xuXG4gICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgYWRkQ2hpbGQoY2hpbGRyZW4sIGNoaWxkTm9kZXMsIHRhZywgcHJvcHMpO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIG5ldyBWTm9kZSh0YWcsIHByb3BzLCBjaGlsZE5vZGVzLCBrZXksIG5hbWVzcGFjZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENoaWxkKGMsIGNoaWxkTm9kZXMsIHRhZywgcHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChuZXcgVlRleHQoYykpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChuZXcgVlRleHQoU3RyaW5nKGMpKSk7XG4gICAgfSBlbHNlIGlmIChpc0NoaWxkKGMpKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChjKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoYykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhZGRDaGlsZChjW2ldLCBjaGlsZE5vZGVzLCB0YWcsIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCB8fCBjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFVuZXhwZWN0ZWRWaXJ0dWFsRWxlbWVudCh7XG4gICAgICAgICAgICBmb3JlaWduT2JqZWN0OiBjLFxuICAgICAgICAgICAgcGFyZW50Vm5vZGU6IHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiB0YWcsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoaXNIb29rKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUuc3Vic3RyKDAsIDMpID09PSAnZXYtJykge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBldi1mb28gc3VwcG9ydFxuICAgICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGV2SG9vayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQ2hpbGQoeCkge1xuICAgIHJldHVybiBpc1ZOb2RlKHgpIHx8IGlzVlRleHQoeCkgfHwgaXNXaWRnZXQoeCkgfHwgaXNWVGh1bmsoeCk7XG59XG5cbmZ1bmN0aW9uIGlzQ2hpbGRyZW4oeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgfHwgaXNBcnJheSh4KSB8fCBpc0NoaWxkKHgpO1xufVxuXG5mdW5jdGlvbiBVbmV4cGVjdGVkVmlydHVhbEVsZW1lbnQoZGF0YSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcblxuICAgIGVyci50eXBlID0gJ3ZpcnR1YWwtaHlwZXJzY3JpcHQudW5leHBlY3RlZC52aXJ0dWFsLWVsZW1lbnQnO1xuICAgIGVyci5tZXNzYWdlID0gJ1VuZXhwZWN0ZWQgdmlydHVhbCBjaGlsZCBwYXNzZWQgdG8gaCgpLlxcbicgK1xuICAgICAgICAnRXhwZWN0ZWQgYSBWTm9kZSAvIFZ0aHVuayAvIFZXaWRnZXQgLyBzdHJpbmcgYnV0OlxcbicgK1xuICAgICAgICAnZ290OlxcbicgK1xuICAgICAgICBlcnJvclN0cmluZyhkYXRhLmZvcmVpZ25PYmplY3QpICtcbiAgICAgICAgJy5cXG4nICtcbiAgICAgICAgJ1RoZSBwYXJlbnQgdm5vZGUgaXM6XFxuJyArXG4gICAgICAgIGVycm9yU3RyaW5nKGRhdGEucGFyZW50Vm5vZGUpXG4gICAgICAgICdcXG4nICtcbiAgICAgICAgJ1N1Z2dlc3RlZCBmaXg6IGNoYW5nZSB5b3VyIGBoKC4uLiwgWyAuLi4gXSlgIGNhbGxzaXRlLic7XG4gICAgZXJyLmZvcmVpZ25PYmplY3QgPSBkYXRhLmZvcmVpZ25PYmplY3Q7XG4gICAgZXJyLnBhcmVudFZub2RlID0gZGF0YS5wYXJlbnRWbm9kZTtcblxuICAgIHJldHVybiBlcnI7XG59XG5cbmZ1bmN0aW9uIGVycm9yU3RyaW5nKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsICcgICAgJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKG9iaik7XG4gICAgfVxufVxuXG59LHtcIi4uL3Zub2RlL2lzLXRodW5rXCI6MjUsXCIuLi92bm9kZS9pcy12aG9va1wiOjI2LFwiLi4vdm5vZGUvaXMtdm5vZGVcIjoyNyxcIi4uL3Zub2RlL2lzLXZ0ZXh0XCI6MjgsXCIuLi92bm9kZS9pcy13aWRnZXRcIjoyOSxcIi4uL3Zub2RlL3Zub2RlLmpzXCI6MzEsXCIuLi92bm9kZS92dGV4dC5qc1wiOjMzLFwiLi9ob29rcy9ldi1ob29rLmpzXCI6MjAsXCIuL2hvb2tzL3NvZnQtc2V0LWhvb2suanNcIjoyMSxcIi4vcGFyc2UtdGFnLmpzXCI6MjMsXCJ4LWlzLWFycmF5XCI6MTJ9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBzcGxpdCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3BsaXQnKTtcblxudmFyIGNsYXNzSWRTcGxpdCA9IC8oW1xcLiNdP1thLXpBLVowLTlcXHUwMDdGLVxcdUZGRkZfOi1dKykvO1xudmFyIG5vdENsYXNzSWQgPSAvXlxcLnwjLztcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVRhZztcblxuZnVuY3Rpb24gcGFyc2VUYWcodGFnLCBwcm9wcykge1xuICAgIGlmICghdGFnKSB7XG4gICAgICAgIHJldHVybiAnRElWJztcbiAgICB9XG5cbiAgICB2YXIgbm9JZCA9ICEocHJvcHMuaGFzT3duUHJvcGVydHkoJ2lkJykpO1xuXG4gICAgdmFyIHRhZ1BhcnRzID0gc3BsaXQodGFnLCBjbGFzc0lkU3BsaXQpO1xuICAgIHZhciB0YWdOYW1lID0gbnVsbDtcblxuICAgIGlmIChub3RDbGFzc0lkLnRlc3QodGFnUGFydHNbMV0pKSB7XG4gICAgICAgIHRhZ05hbWUgPSAnRElWJztcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NlcywgcGFydCwgdHlwZSwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0YWdQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0ID0gdGFnUGFydHNbaV07XG5cbiAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGUgPSBwYXJ0LmNoYXJBdCgwKTtcblxuICAgICAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgICAgICAgIHRhZ05hbWUgPSBwYXJ0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcuJykge1xuICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2gocGFydC5zdWJzdHJpbmcoMSwgcGFydC5sZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnIycgJiYgbm9JZCkge1xuICAgICAgICAgICAgcHJvcHMuaWQgPSBwYXJ0LnN1YnN0cmluZygxLCBwYXJ0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICBpZiAocHJvcHMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2gocHJvcHMuY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wcy5uYW1lc3BhY2UgPyB0YWdOYW1lIDogdGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xufVxuXG59LHtcImJyb3dzZXItc3BsaXRcIjo1fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi9pcy12bm9kZVwiKVxudmFyIGlzVlRleHQgPSByZXF1aXJlKFwiLi9pcy12dGV4dFwiKVxudmFyIGlzV2lkZ2V0ID0gcmVxdWlyZShcIi4vaXMtd2lkZ2V0XCIpXG52YXIgaXNUaHVuayA9IHJlcXVpcmUoXCIuL2lzLXRodW5rXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gaGFuZGxlVGh1bmtcblxuZnVuY3Rpb24gaGFuZGxlVGh1bmsoYSwgYikge1xuICAgIHZhciByZW5kZXJlZEEgPSBhXG4gICAgdmFyIHJlbmRlcmVkQiA9IGJcblxuICAgIGlmIChpc1RodW5rKGIpKSB7XG4gICAgICAgIHJlbmRlcmVkQiA9IHJlbmRlclRodW5rKGIsIGEpXG4gICAgfVxuXG4gICAgaWYgKGlzVGh1bmsoYSkpIHtcbiAgICAgICAgcmVuZGVyZWRBID0gcmVuZGVyVGh1bmsoYSwgbnVsbClcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhOiByZW5kZXJlZEEsXG4gICAgICAgIGI6IHJlbmRlcmVkQlxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyVGh1bmsodGh1bmssIHByZXZpb3VzKSB7XG4gICAgdmFyIHJlbmRlcmVkVGh1bmsgPSB0aHVuay52bm9kZVxuXG4gICAgaWYgKCFyZW5kZXJlZFRodW5rKSB7XG4gICAgICAgIHJlbmRlcmVkVGh1bmsgPSB0aHVuay52bm9kZSA9IHRodW5rLnJlbmRlcihwcmV2aW91cylcbiAgICB9XG5cbiAgICBpZiAoIShpc1ZOb2RlKHJlbmRlcmVkVGh1bmspIHx8XG4gICAgICAgICAgICBpc1ZUZXh0KHJlbmRlcmVkVGh1bmspIHx8XG4gICAgICAgICAgICBpc1dpZGdldChyZW5kZXJlZFRodW5rKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGh1bmsgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBub2RlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZFRodW5rXG59XG5cbn0se1wiLi9pcy10aHVua1wiOjI1LFwiLi9pcy12bm9kZVwiOjI3LFwiLi9pcy12dGV4dFwiOjI4LFwiLi9pcy13aWRnZXRcIjoyOX1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gaXNUaHVua1xyXG5cclxuZnVuY3Rpb24gaXNUaHVuayh0KSB7XHJcbiAgICByZXR1cm4gdCAmJiB0LnR5cGUgPT09IFwiVGh1bmtcIlxyXG59XHJcblxufSx7fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBpc0hvb2tcblxuZnVuY3Rpb24gaXNIb29rKGhvb2spIHtcbiAgICByZXR1cm4gaG9vayAmJlxuICAgICAgKHR5cGVvZiBob29rLmhvb2sgPT09IFwiZnVuY3Rpb25cIiAmJiAhaG9vay5oYXNPd25Qcm9wZXJ0eShcImhvb2tcIikgfHxcbiAgICAgICB0eXBlb2YgaG9vay51bmhvb2sgPT09IFwiZnVuY3Rpb25cIiAmJiAhaG9vay5oYXNPd25Qcm9wZXJ0eShcInVuaG9va1wiKSlcbn1cblxufSx7fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlcnNpb24gPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gaXNWaXJ0dWFsTm9kZVxuXG5mdW5jdGlvbiBpc1ZpcnR1YWxOb2RlKHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGUgPT09IFwiVmlydHVhbE5vZGVcIiAmJiB4LnZlcnNpb24gPT09IHZlcnNpb25cbn1cblxufSx7XCIuL3ZlcnNpb25cIjozMH1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVmlydHVhbFRleHRcblxuZnVuY3Rpb24gaXNWaXJ0dWFsVGV4dCh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC50eXBlID09PSBcIlZpcnR1YWxUZXh0XCIgJiYgeC52ZXJzaW9uID09PSB2ZXJzaW9uXG59XG5cbn0se1wiLi92ZXJzaW9uXCI6MzB9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGlzV2lkZ2V0XG5cbmZ1bmN0aW9uIGlzV2lkZ2V0KHcpIHtcbiAgICByZXR1cm4gdyAmJiB3LnR5cGUgPT09IFwiV2lkZ2V0XCJcbn1cblxufSx7fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBcIjJcIlxuXG59LHt9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVyc2lvbiA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIilcbnZhciBpc1ZOb2RlID0gcmVxdWlyZShcIi4vaXMtdm5vZGVcIilcbnZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuL2lzLXdpZGdldFwiKVxudmFyIGlzVGh1bmsgPSByZXF1aXJlKFwiLi9pcy10aHVua1wiKVxudmFyIGlzVkhvb2sgPSByZXF1aXJlKFwiLi9pcy12aG9va1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpcnR1YWxOb2RlXG5cbnZhciBub1Byb3BlcnRpZXMgPSB7fVxudmFyIG5vQ2hpbGRyZW4gPSBbXVxuXG5mdW5jdGlvbiBWaXJ0dWFsTm9kZSh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbiwga2V5LCBuYW1lc3BhY2UpIHtcbiAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBub1Byb3BlcnRpZXNcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgbm9DaGlsZHJlblxuICAgIHRoaXMua2V5ID0ga2V5ICE9IG51bGwgPyBTdHJpbmcoa2V5KSA6IHVuZGVmaW5lZFxuICAgIHRoaXMubmFtZXNwYWNlID0gKHR5cGVvZiBuYW1lc3BhY2UgPT09IFwic3RyaW5nXCIpID8gbmFtZXNwYWNlIDogbnVsbFxuXG4gICAgdmFyIGNvdW50ID0gKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkgfHwgMFxuICAgIHZhciBkZXNjZW5kYW50cyA9IDBcbiAgICB2YXIgaGFzV2lkZ2V0cyA9IGZhbHNlXG4gICAgdmFyIGhhc1RodW5rcyA9IGZhbHNlXG4gICAgdmFyIGRlc2NlbmRhbnRIb29rcyA9IGZhbHNlXG4gICAgdmFyIGhvb2tzXG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1twcm9wTmFtZV1cbiAgICAgICAgICAgIGlmIChpc1ZIb29rKHByb3BlcnR5KSAmJiBwcm9wZXJ0eS51bmhvb2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0ge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBob29rc1twcm9wTmFtZV0gPSBwcm9wZXJ0eVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgZGVzY2VuZGFudHMgKz0gY2hpbGQuY291bnQgfHwgMFxuXG4gICAgICAgICAgICBpZiAoIWhhc1dpZGdldHMgJiYgY2hpbGQuaGFzV2lkZ2V0cykge1xuICAgICAgICAgICAgICAgIGhhc1dpZGdldHMgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGFzVGh1bmtzICYmIGNoaWxkLmhhc1RodW5rcykge1xuICAgICAgICAgICAgICAgIGhhc1RodW5rcyA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkZXNjZW5kYW50SG9va3MgJiYgKGNoaWxkLmhvb2tzIHx8IGNoaWxkLmRlc2NlbmRhbnRIb29rcykpIHtcbiAgICAgICAgICAgICAgICBkZXNjZW5kYW50SG9va3MgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWhhc1dpZGdldHMgJiYgaXNXaWRnZXQoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkLmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhc1dpZGdldHMgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWhhc1RodW5rcyAmJiBpc1RodW5rKGNoaWxkKSkge1xuICAgICAgICAgICAgaGFzVGh1bmtzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY291bnQgPSBjb3VudCArIGRlc2NlbmRhbnRzXG4gICAgdGhpcy5oYXNXaWRnZXRzID0gaGFzV2lkZ2V0c1xuICAgIHRoaXMuaGFzVGh1bmtzID0gaGFzVGh1bmtzXG4gICAgdGhpcy5ob29rcyA9IGhvb2tzXG4gICAgdGhpcy5kZXNjZW5kYW50SG9va3MgPSBkZXNjZW5kYW50SG9va3Ncbn1cblxuVmlydHVhbE5vZGUucHJvdG90eXBlLnZlcnNpb24gPSB2ZXJzaW9uXG5WaXJ0dWFsTm9kZS5wcm90b3R5cGUudHlwZSA9IFwiVmlydHVhbE5vZGVcIlxuXG59LHtcIi4vaXMtdGh1bmtcIjoyNSxcIi4vaXMtdmhvb2tcIjoyNixcIi4vaXMtdm5vZGVcIjoyNyxcIi4vaXMtd2lkZ2V0XCI6MjksXCIuL3ZlcnNpb25cIjozMH1dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKVxuXG5WaXJ0dWFsUGF0Y2guTk9ORSA9IDBcblZpcnR1YWxQYXRjaC5WVEVYVCA9IDFcblZpcnR1YWxQYXRjaC5WTk9ERSA9IDJcblZpcnR1YWxQYXRjaC5XSURHRVQgPSAzXG5WaXJ0dWFsUGF0Y2guUFJPUFMgPSA0XG5WaXJ0dWFsUGF0Y2guT1JERVIgPSA1XG5WaXJ0dWFsUGF0Y2guSU5TRVJUID0gNlxuVmlydHVhbFBhdGNoLlJFTU9WRSA9IDdcblZpcnR1YWxQYXRjaC5USFVOSyA9IDhcblxubW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsUGF0Y2hcblxuZnVuY3Rpb24gVmlydHVhbFBhdGNoKHR5cGUsIHZOb2RlLCBwYXRjaCkge1xuICAgIHRoaXMudHlwZSA9IE51bWJlcih0eXBlKVxuICAgIHRoaXMudk5vZGUgPSB2Tm9kZVxuICAgIHRoaXMucGF0Y2ggPSBwYXRjaFxufVxuXG5WaXJ0dWFsUGF0Y2gucHJvdG90eXBlLnZlcnNpb24gPSB2ZXJzaW9uXG5WaXJ0dWFsUGF0Y2gucHJvdG90eXBlLnR5cGUgPSBcIlZpcnR1YWxQYXRjaFwiXG5cbn0se1wiLi92ZXJzaW9uXCI6MzB9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVyc2lvbiA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIilcblxubW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsVGV4dFxuXG5mdW5jdGlvbiBWaXJ0dWFsVGV4dCh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gU3RyaW5nKHRleHQpXG59XG5cblZpcnR1YWxUZXh0LnByb3RvdHlwZS52ZXJzaW9uID0gdmVyc2lvblxuVmlydHVhbFRleHQucHJvdG90eXBlLnR5cGUgPSBcIlZpcnR1YWxUZXh0XCJcblxufSx7XCIuL3ZlcnNpb25cIjozMH1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoXCJpcy1vYmplY3RcIilcbnZhciBpc0hvb2sgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdmhvb2tcIilcblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmUHJvcHNcblxuZnVuY3Rpb24gZGlmZlByb3BzKGEsIGIpIHtcbiAgICB2YXIgZGlmZlxuXG4gICAgZm9yICh2YXIgYUtleSBpbiBhKSB7XG4gICAgICAgIGlmICghKGFLZXkgaW4gYikpIHtcbiAgICAgICAgICAgIGRpZmYgPSBkaWZmIHx8IHt9XG4gICAgICAgICAgICBkaWZmW2FLZXldID0gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYVZhbHVlID0gYVthS2V5XVxuICAgICAgICB2YXIgYlZhbHVlID0gYlthS2V5XVxuXG4gICAgICAgIGlmIChhVmFsdWUgPT09IGJWYWx1ZSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChhVmFsdWUpICYmIGlzT2JqZWN0KGJWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChnZXRQcm90b3R5cGUoYlZhbHVlKSAhPT0gZ2V0UHJvdG90eXBlKGFWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gZGlmZiB8fCB7fVxuICAgICAgICAgICAgICAgIGRpZmZbYUtleV0gPSBiVmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNIb29rKGJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgZGlmZiA9IGRpZmYgfHwge31cbiAgICAgICAgICAgICAgICAgZGlmZlthS2V5XSA9IGJWYWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0RGlmZiA9IGRpZmZQcm9wcyhhVmFsdWUsIGJWYWx1ZSlcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0RGlmZikge1xuICAgICAgICAgICAgICAgICAgICBkaWZmID0gZGlmZiB8fCB7fVxuICAgICAgICAgICAgICAgICAgICBkaWZmW2FLZXldID0gb2JqZWN0RGlmZlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmYgPSBkaWZmIHx8IHt9XG4gICAgICAgICAgICBkaWZmW2FLZXldID0gYlZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBiS2V5IGluIGIpIHtcbiAgICAgICAgaWYgKCEoYktleSBpbiBhKSkge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmYgfHwge31cbiAgICAgICAgICAgIGRpZmZbYktleV0gPSBiW2JLZXldXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlmZlxufVxuXG5mdW5jdGlvbiBnZXRQcm90b3R5cGUodmFsdWUpIHtcbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZikge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpXG4gIH0gZWxzZSBpZiAodmFsdWUuX19wcm90b19fKSB7XG4gICAgcmV0dXJuIHZhbHVlLl9fcHJvdG9fX1xuICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICB9XG59XG5cbn0se1wiLi4vdm5vZGUvaXMtdmhvb2tcIjoyNixcImlzLW9iamVjdFwiOjExfV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKFwieC1pcy1hcnJheVwiKVxuXG52YXIgVlBhdGNoID0gcmVxdWlyZShcIi4uL3Zub2RlL3ZwYXRjaFwiKVxudmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdm5vZGVcIilcbnZhciBpc1ZUZXh0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZ0ZXh0XCIpXG52YXIgaXNXaWRnZXQgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtd2lkZ2V0XCIpXG52YXIgaXNUaHVuayA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy10aHVua1wiKVxudmFyIGhhbmRsZVRodW5rID0gcmVxdWlyZShcIi4uL3Zub2RlL2hhbmRsZS10aHVua1wiKVxuXG52YXIgZGlmZlByb3BzID0gcmVxdWlyZShcIi4vZGlmZi1wcm9wc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcblxuZnVuY3Rpb24gZGlmZihhLCBiKSB7XG4gICAgdmFyIHBhdGNoID0geyBhOiBhIH1cbiAgICB3YWxrKGEsIGIsIHBhdGNoLCAwKVxuICAgIHJldHVybiBwYXRjaFxufVxuXG5mdW5jdGlvbiB3YWxrKGEsIGIsIHBhdGNoLCBpbmRleCkge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBhcHBseSA9IHBhdGNoW2luZGV4XVxuICAgIHZhciBhcHBseUNsZWFyID0gZmFsc2VcblxuICAgIGlmIChpc1RodW5rKGEpIHx8IGlzVGh1bmsoYikpIHtcbiAgICAgICAgdGh1bmtzKGEsIGIsIHBhdGNoLCBpbmRleClcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuXG4gICAgICAgIC8vIElmIGEgaXMgYSB3aWRnZXQgd2Ugd2lsbCBhZGQgYSByZW1vdmUgcGF0Y2ggZm9yIGl0XG4gICAgICAgIC8vIE90aGVyd2lzZSBhbnkgY2hpbGQgd2lkZ2V0cy9ob29rcyBtdXN0IGJlIGRlc3Ryb3llZC5cbiAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBhZGRpbmcgdHdvIHJlbW92ZSBwYXRjaGVzIGZvciBhIHdpZGdldC5cbiAgICAgICAgaWYgKCFpc1dpZGdldChhKSkge1xuICAgICAgICAgICAgY2xlYXJTdGF0ZShhLCBwYXRjaCwgaW5kZXgpXG4gICAgICAgICAgICBhcHBseSA9IHBhdGNoW2luZGV4XVxuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChWUGF0Y2guUkVNT1ZFLCBhLCBiKSlcbiAgICB9IGVsc2UgaWYgKGlzVk5vZGUoYikpIHtcbiAgICAgICAgaWYgKGlzVk5vZGUoYSkpIHtcbiAgICAgICAgICAgIGlmIChhLnRhZ05hbWUgPT09IGIudGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgIGEubmFtZXNwYWNlID09PSBiLm5hbWVzcGFjZSAmJlxuICAgICAgICAgICAgICAgIGEua2V5ID09PSBiLmtleSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wc1BhdGNoID0gZGlmZlByb3BzKGEucHJvcGVydGllcywgYi5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGlmIChwcm9wc1BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVlBhdGNoKFZQYXRjaC5QUk9QUywgYSwgcHJvcHNQYXRjaCkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcGx5ID0gZGlmZkNoaWxkcmVuKGEsIGIsIHBhdGNoLCBhcHBseSwgaW5kZXgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksIG5ldyBWUGF0Y2goVlBhdGNoLlZOT0RFLCBhLCBiKSlcbiAgICAgICAgICAgICAgICBhcHBseUNsZWFyID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChWUGF0Y2guVk5PREUsIGEsIGIpKVxuICAgICAgICAgICAgYXBwbHlDbGVhciA9IHRydWVcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWVGV4dChiKSkge1xuICAgICAgICBpZiAoIWlzVlRleHQoYSkpIHtcbiAgICAgICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksIG5ldyBWUGF0Y2goVlBhdGNoLlZURVhULCBhLCBiKSlcbiAgICAgICAgICAgIGFwcGx5Q2xlYXIgPSB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAoYS50ZXh0ICE9PSBiLnRleHQpIHtcbiAgICAgICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksIG5ldyBWUGF0Y2goVlBhdGNoLlZURVhULCBhLCBiKSlcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNXaWRnZXQoYikpIHtcbiAgICAgICAgaWYgKCFpc1dpZGdldChhKSkge1xuICAgICAgICAgICAgYXBwbHlDbGVhciA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksIG5ldyBWUGF0Y2goVlBhdGNoLldJREdFVCwgYSwgYikpXG4gICAgfVxuXG4gICAgaWYgKGFwcGx5KSB7XG4gICAgICAgIHBhdGNoW2luZGV4XSA9IGFwcGx5XG4gICAgfVxuXG4gICAgaWYgKGFwcGx5Q2xlYXIpIHtcbiAgICAgICAgY2xlYXJTdGF0ZShhLCBwYXRjaCwgaW5kZXgpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaWZmQ2hpbGRyZW4oYSwgYiwgcGF0Y2gsIGFwcGx5LCBpbmRleCkge1xuICAgIHZhciBhQ2hpbGRyZW4gPSBhLmNoaWxkcmVuXG4gICAgdmFyIG9yZGVyZWRTZXQgPSByZW9yZGVyKGFDaGlsZHJlbiwgYi5jaGlsZHJlbilcbiAgICB2YXIgYkNoaWxkcmVuID0gb3JkZXJlZFNldC5jaGlsZHJlblxuXG4gICAgdmFyIGFMZW4gPSBhQ2hpbGRyZW4ubGVuZ3RoXG4gICAgdmFyIGJMZW4gPSBiQ2hpbGRyZW4ubGVuZ3RoXG4gICAgdmFyIGxlbiA9IGFMZW4gPiBiTGVuID8gYUxlbiA6IGJMZW5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGxlZnROb2RlID0gYUNoaWxkcmVuW2ldXG4gICAgICAgIHZhciByaWdodE5vZGUgPSBiQ2hpbGRyZW5baV1cbiAgICAgICAgaW5kZXggKz0gMVxuXG4gICAgICAgIGlmICghbGVmdE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChyaWdodE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlc3Mgbm9kZXMgaW4gYiBuZWVkIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZQYXRjaChWUGF0Y2guSU5TRVJULCBudWxsLCByaWdodE5vZGUpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FsayhsZWZ0Tm9kZSwgcmlnaHROb2RlLCBwYXRjaCwgaW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNWTm9kZShsZWZ0Tm9kZSkgJiYgbGVmdE5vZGUuY291bnQpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IGxlZnROb2RlLmNvdW50XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3JkZXJlZFNldC5tb3Zlcykge1xuICAgICAgICAvLyBSZW9yZGVyIG5vZGVzIGxhc3RcbiAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChcbiAgICAgICAgICAgIFZQYXRjaC5PUkRFUixcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBvcmRlcmVkU2V0Lm1vdmVzXG4gICAgICAgICkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGFwcGx5XG59XG5cbmZ1bmN0aW9uIGNsZWFyU3RhdGUodk5vZGUsIHBhdGNoLCBpbmRleCkge1xuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBhIHNpbmdsZSB3YWxrLCBub3QgdHdvXG4gICAgdW5ob29rKHZOb2RlLCBwYXRjaCwgaW5kZXgpXG4gICAgZGVzdHJveVdpZGdldHModk5vZGUsIHBhdGNoLCBpbmRleClcbn1cblxuLy8gUGF0Y2ggcmVjb3JkcyBmb3IgYWxsIGRlc3Ryb3llZCB3aWRnZXRzIG11c3QgYmUgYWRkZWQgYmVjYXVzZSB3ZSBuZWVkXG4vLyBhIERPTSBub2RlIHJlZmVyZW5jZSBmb3IgdGhlIGRlc3Ryb3kgZnVuY3Rpb25cbmZ1bmN0aW9uIGRlc3Ryb3lXaWRnZXRzKHZOb2RlLCBwYXRjaCwgaW5kZXgpIHtcbiAgICBpZiAoaXNXaWRnZXQodk5vZGUpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygdk5vZGUuZGVzdHJveSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXRjaFtpbmRleF0gPSBhcHBlbmRQYXRjaChcbiAgICAgICAgICAgICAgICBwYXRjaFtpbmRleF0sXG4gICAgICAgICAgICAgICAgbmV3IFZQYXRjaChWUGF0Y2guUkVNT1ZFLCB2Tm9kZSwgbnVsbClcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWTm9kZSh2Tm9kZSkgJiYgKHZOb2RlLmhhc1dpZGdldHMgfHwgdk5vZGUuaGFzVGh1bmtzKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlblxuICAgICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgICAgICAgICBpbmRleCArPSAxXG5cbiAgICAgICAgICAgIGRlc3Ryb3lXaWRnZXRzKGNoaWxkLCBwYXRjaCwgaW5kZXgpXG5cbiAgICAgICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSAmJiBjaGlsZC5jb3VudCkge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGNoaWxkLmNvdW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGh1bmsodk5vZGUpKSB7XG4gICAgICAgIHRodW5rcyh2Tm9kZSwgbnVsbCwgcGF0Y2gsIGluZGV4KVxuICAgIH1cbn1cblxuLy8gQ3JlYXRlIGEgc3ViLXBhdGNoIGZvciB0aHVua3NcbmZ1bmN0aW9uIHRodW5rcyhhLCBiLCBwYXRjaCwgaW5kZXgpIHtcbiAgICB2YXIgbm9kZXMgPSBoYW5kbGVUaHVuayhhLCBiKVxuICAgIHZhciB0aHVua1BhdGNoID0gZGlmZihub2Rlcy5hLCBub2Rlcy5iKVxuICAgIGlmIChoYXNQYXRjaGVzKHRodW5rUGF0Y2gpKSB7XG4gICAgICAgIHBhdGNoW2luZGV4XSA9IG5ldyBWUGF0Y2goVlBhdGNoLlRIVU5LLCBudWxsLCB0aHVua1BhdGNoKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzUGF0Y2hlcyhwYXRjaCkge1xuICAgIGZvciAodmFyIGluZGV4IGluIHBhdGNoKSB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gXCJhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gRXhlY3V0ZSBob29rcyB3aGVuIHR3byBub2RlcyBhcmUgaWRlbnRpY2FsXG5mdW5jdGlvbiB1bmhvb2sodk5vZGUsIHBhdGNoLCBpbmRleCkge1xuICAgIGlmIChpc1ZOb2RlKHZOb2RlKSkge1xuICAgICAgICBpZiAodk5vZGUuaG9va3MpIHtcbiAgICAgICAgICAgIHBhdGNoW2luZGV4XSA9IGFwcGVuZFBhdGNoKFxuICAgICAgICAgICAgICAgIHBhdGNoW2luZGV4XSxcbiAgICAgICAgICAgICAgICBuZXcgVlBhdGNoKFxuICAgICAgICAgICAgICAgICAgICBWUGF0Y2guUFJPUFMsXG4gICAgICAgICAgICAgICAgICAgIHZOb2RlLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWRLZXlzKHZOb2RlLmhvb2tzKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2Tm9kZS5kZXNjZW5kYW50SG9va3MgfHwgdk5vZGUuaGFzVGh1bmtzKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlblxuICAgICAgICAgICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuXG4gICAgICAgICAgICAgICAgdW5ob29rKGNoaWxkLCBwYXRjaCwgaW5kZXgpXG5cbiAgICAgICAgICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkgJiYgY2hpbGQuY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gY2hpbGQuY291bnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGh1bmsodk5vZGUpKSB7XG4gICAgICAgIHRodW5rcyh2Tm9kZSwgbnVsbCwgcGF0Y2gsIGluZGV4KVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdW5kZWZpbmVkS2V5cyhvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge31cblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIExpc3QgZGlmZiwgbmFpdmUgbGVmdCB0byByaWdodCByZW9yZGVyaW5nXG5mdW5jdGlvbiByZW9yZGVyKGFDaGlsZHJlbiwgYkNoaWxkcmVuKSB7XG4gICAgLy8gTyhNKSB0aW1lLCBPKE0pIG1lbW9yeVxuICAgIHZhciBiQ2hpbGRJbmRleCA9IGtleUluZGV4KGJDaGlsZHJlbilcbiAgICB2YXIgYktleXMgPSBiQ2hpbGRJbmRleC5rZXlzXG4gICAgdmFyIGJGcmVlID0gYkNoaWxkSW5kZXguZnJlZVxuXG4gICAgaWYgKGJGcmVlLmxlbmd0aCA9PT0gYkNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGJDaGlsZHJlbixcbiAgICAgICAgICAgIG1vdmVzOiBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPKE4pIHRpbWUsIE8oTikgbWVtb3J5XG4gICAgdmFyIGFDaGlsZEluZGV4ID0ga2V5SW5kZXgoYUNoaWxkcmVuKVxuICAgIHZhciBhS2V5cyA9IGFDaGlsZEluZGV4LmtleXNcbiAgICB2YXIgYUZyZWUgPSBhQ2hpbGRJbmRleC5mcmVlXG5cbiAgICBpZiAoYUZyZWUubGVuZ3RoID09PSBhQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogYkNoaWxkcmVuLFxuICAgICAgICAgICAgbW92ZXM6IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE8oTUFYKE4sIE0pKSBtZW1vcnlcbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXVxuXG4gICAgdmFyIGZyZWVJbmRleCA9IDBcbiAgICB2YXIgZnJlZUNvdW50ID0gYkZyZWUubGVuZ3RoXG4gICAgdmFyIGRlbGV0ZWRJdGVtcyA9IDBcblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhIGFuZCBtYXRjaCBhIG5vZGUgaW4gYlxuICAgIC8vIE8oTikgdGltZSxcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBhQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFJdGVtID0gYUNoaWxkcmVuW2ldXG4gICAgICAgIHZhciBpdGVtSW5kZXhcblxuICAgICAgICBpZiAoYUl0ZW0ua2V5KSB7XG4gICAgICAgICAgICBpZiAoYktleXMuaGFzT3duUHJvcGVydHkoYUl0ZW0ua2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoIHVwIHRoZSBvbGQga2V5c1xuICAgICAgICAgICAgICAgIGl0ZW1JbmRleCA9IGJLZXlzW2FJdGVtLmtleV1cbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGJDaGlsZHJlbltpdGVtSW5kZXhdKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQga2V5ZWQgaXRlbXNcbiAgICAgICAgICAgICAgICBpdGVtSW5kZXggPSBpIC0gZGVsZXRlZEl0ZW1zKytcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNYXRjaCB0aGUgaXRlbSBpbiBhIHdpdGggdGhlIG5leHQgZnJlZSBpdGVtIGluIGJcbiAgICAgICAgICAgIGlmIChmcmVlSW5kZXggPCBmcmVlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBpdGVtSW5kZXggPSBiRnJlZVtmcmVlSW5kZXgrK11cbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGJDaGlsZHJlbltpdGVtSW5kZXhdKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gZnJlZSBpdGVtcyBpbiBiIHRvIG1hdGNoIHdpdGhcbiAgICAgICAgICAgICAgICAvLyB0aGUgZnJlZSBpdGVtcyBpbiBhLCBzbyB0aGUgZXh0cmEgZnJlZSBub2Rlc1xuICAgICAgICAgICAgICAgIC8vIGFyZSBkZWxldGVkLlxuICAgICAgICAgICAgICAgIGl0ZW1JbmRleCA9IGkgLSBkZWxldGVkSXRlbXMrK1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobnVsbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYXN0RnJlZUluZGV4ID0gZnJlZUluZGV4ID49IGJGcmVlLmxlbmd0aCA/XG4gICAgICAgIGJDaGlsZHJlbi5sZW5ndGggOlxuICAgICAgICBiRnJlZVtmcmVlSW5kZXhdXG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggYiBhbmQgYXBwZW5kIGFueSBuZXcga2V5c1xuICAgIC8vIE8oTSkgdGltZVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYkNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBuZXdJdGVtID0gYkNoaWxkcmVuW2pdXG5cbiAgICAgICAgaWYgKG5ld0l0ZW0ua2V5KSB7XG4gICAgICAgICAgICBpZiAoIWFLZXlzLmhhc093blByb3BlcnR5KG5ld0l0ZW0ua2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgbmV3IGtleWVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFkZGluZyBuZXcgaXRlbXMgdG8gdGhlIGVuZCBhbmQgdGhlbiBzb3J0aW5nIHRoZW1cbiAgICAgICAgICAgICAgICAvLyBpbiBwbGFjZS4gSW4gZnV0dXJlIHdlIHNob3VsZCBpbnNlcnQgbmV3IGl0ZW1zIGluIHBsYWNlLlxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobmV3SXRlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChqID49IGxhc3RGcmVlSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhbnkgbGVmdG92ZXIgbm9uLWtleWVkIGl0ZW1zXG4gICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKG5ld0l0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2ltdWxhdGUgPSBuZXdDaGlsZHJlbi5zbGljZSgpXG4gICAgdmFyIHNpbXVsYXRlSW5kZXggPSAwXG4gICAgdmFyIHJlbW92ZXMgPSBbXVxuICAgIHZhciBpbnNlcnRzID0gW11cbiAgICB2YXIgc2ltdWxhdGVJdGVtXG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGJDaGlsZHJlbi5sZW5ndGg7KSB7XG4gICAgICAgIHZhciB3YW50ZWRJdGVtID0gYkNoaWxkcmVuW2tdXG4gICAgICAgIHNpbXVsYXRlSXRlbSA9IHNpbXVsYXRlW3NpbXVsYXRlSW5kZXhdXG5cbiAgICAgICAgLy8gcmVtb3ZlIGl0ZW1zXG4gICAgICAgIHdoaWxlIChzaW11bGF0ZUl0ZW0gPT09IG51bGwgJiYgc2ltdWxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZW1vdmVzLnB1c2gocmVtb3ZlKHNpbXVsYXRlLCBzaW11bGF0ZUluZGV4LCBudWxsKSlcbiAgICAgICAgICAgIHNpbXVsYXRlSXRlbSA9IHNpbXVsYXRlW3NpbXVsYXRlSW5kZXhdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNpbXVsYXRlSXRlbSB8fCBzaW11bGF0ZUl0ZW0ua2V5ICE9PSB3YW50ZWRJdGVtLmtleSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgbmVlZCBhIGtleSBpbiB0aGlzIHBvc2l0aW9uLi4uXG4gICAgICAgICAgICBpZiAod2FudGVkSXRlbS5rZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2ltdWxhdGVJdGVtICYmIHNpbXVsYXRlSXRlbS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW4gaW5zZXJ0IGRvZXNuJ3QgcHV0IHRoaXMga2V5IGluIHBsYWNlLCBpdCBuZWVkcyB0byBtb3ZlXG4gICAgICAgICAgICAgICAgICAgIGlmIChiS2V5c1tzaW11bGF0ZUl0ZW0ua2V5XSAhPT0gayArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZXMucHVzaChyZW1vdmUoc2ltdWxhdGUsIHNpbXVsYXRlSW5kZXgsIHNpbXVsYXRlSXRlbS5rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2ltdWxhdGVJdGVtID0gc2ltdWxhdGVbc2ltdWxhdGVJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZW1vdmUgZGlkbid0IHB1dCB0aGUgd2FudGVkIGl0ZW0gaW4gcGxhY2UsIHdlIG5lZWQgdG8gaW5zZXJ0IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbXVsYXRlSXRlbSB8fCBzaW11bGF0ZUl0ZW0ua2V5ICE9PSB3YW50ZWRJdGVtLmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydHMucHVzaCh7a2V5OiB3YW50ZWRJdGVtLmtleSwgdG86IGt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlbXMgYXJlIG1hdGNoaW5nLCBzbyBza2lwIGFoZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW11bGF0ZUluZGV4KytcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydHMucHVzaCh7a2V5OiB3YW50ZWRJdGVtLmtleSwgdG86IGt9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRzLnB1c2goe2tleTogd2FudGVkSXRlbS5rZXksIHRvOiBrfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaysrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhIGtleSBpbiBzaW11bGF0ZSBoYXMgbm8gbWF0Y2hpbmcgd2FudGVkIGtleSwgcmVtb3ZlIGl0XG4gICAgICAgICAgICBlbHNlIGlmIChzaW11bGF0ZUl0ZW0gJiYgc2ltdWxhdGVJdGVtLmtleSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZXMucHVzaChyZW1vdmUoc2ltdWxhdGUsIHNpbXVsYXRlSW5kZXgsIHNpbXVsYXRlSXRlbS5rZXkpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2ltdWxhdGVJbmRleCsrXG4gICAgICAgICAgICBrKytcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbGwgdGhlIHJlbWFpbmluZyBub2RlcyBmcm9tIHNpbXVsYXRlXG4gICAgd2hpbGUoc2ltdWxhdGVJbmRleCA8IHNpbXVsYXRlLmxlbmd0aCkge1xuICAgICAgICBzaW11bGF0ZUl0ZW0gPSBzaW11bGF0ZVtzaW11bGF0ZUluZGV4XVxuICAgICAgICByZW1vdmVzLnB1c2gocmVtb3ZlKHNpbXVsYXRlLCBzaW11bGF0ZUluZGV4LCBzaW11bGF0ZUl0ZW0gJiYgc2ltdWxhdGVJdGVtLmtleSkpXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9ubHkgbW92ZXMgd2UgaGF2ZSBhcmUgZGVsZXRlcyB0aGVuIHdlIGNhbiBqdXN0XG4gICAgLy8gbGV0IHRoZSBkZWxldGUgcGF0Y2ggcmVtb3ZlIHRoZXNlIGl0ZW1zLlxuICAgIGlmIChyZW1vdmVzLmxlbmd0aCA9PT0gZGVsZXRlZEl0ZW1zICYmICFpbnNlcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuLFxuICAgICAgICAgICAgbW92ZXM6IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlbixcbiAgICAgICAgbW92ZXM6IHtcbiAgICAgICAgICAgIHJlbW92ZXM6IHJlbW92ZXMsXG4gICAgICAgICAgICBpbnNlcnRzOiBpbnNlcnRzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShhcnIsIGluZGV4LCBrZXkpIHtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAxKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogaW5kZXgsXG4gICAgICAgIGtleToga2V5XG4gICAgfVxufVxuXG5mdW5jdGlvbiBrZXlJbmRleChjaGlsZHJlbikge1xuICAgIHZhciBrZXlzID0ge31cbiAgICB2YXIgZnJlZSA9IFtdXG4gICAgdmFyIGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXG4gICAgICAgIGlmIChjaGlsZC5rZXkpIHtcbiAgICAgICAgICAgIGtleXNbY2hpbGQua2V5XSA9IGlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyZWUucHVzaChpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5czoga2V5cywgICAgIC8vIEEgaGFzaCBvZiBrZXkgbmFtZSB0byBpbmRleFxuICAgICAgICBmcmVlOiBmcmVlICAgICAgLy8gQW4gYXJyYXkgb2YgdW5rZXllZCBpdGVtIGluZGljZXNcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFBhdGNoKGFwcGx5LCBwYXRjaCkge1xuICAgIGlmIChhcHBseSkge1xuICAgICAgICBpZiAoaXNBcnJheShhcHBseSkpIHtcbiAgICAgICAgICAgIGFwcGx5LnB1c2gocGF0Y2gpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBseSA9IFthcHBseSwgcGF0Y2hdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXBwbHlcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0Y2hcbiAgICB9XG59XG5cbn0se1wiLi4vdm5vZGUvaGFuZGxlLXRodW5rXCI6MjQsXCIuLi92bm9kZS9pcy10aHVua1wiOjI1LFwiLi4vdm5vZGUvaXMtdm5vZGVcIjoyNyxcIi4uL3Zub2RlL2lzLXZ0ZXh0XCI6MjgsXCIuLi92bm9kZS9pcy13aWRnZXRcIjoyOSxcIi4uL3Zub2RlL3ZwYXRjaFwiOjMyLFwiLi9kaWZmLXByb3BzXCI6MzQsXCJ4LWlzLWFycmF5XCI6MTJ9XX0se30sWzRdKSg0KVxufSk7XG5PcGFsLmxvYWRlZChbXCJ2ZW5kb3IvdmlydHVhbC1kb20uanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNKOztBQUVBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVFO0FBQ0U7QUFDQTtBQUNBOztBQUVGO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNBOztBQUVKOztBQUVBO0FBQ0k7QUFDSTtBQUNKOztBQUVBOztBQUVBO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0k7QUFDQTs7QUFFQTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDUjs7QUFFQTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNJO0FBQ0o7O0FBRUE7QUFDSTtBQUNKO0FBQ0k7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0M7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7QUFDSTs7QUFFQTtBQUNJO0FBQ0o7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ1I7QUFDSjtBQUNJO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7O0FBRUE7QUFDSTtBQUNJOztBQUVBO0FBQ0k7QUFDSTtBQUNJO0FBQ0o7QUFDSjtBQUNJO0FBQ0k7QUFDSjtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSjtBQUNJO0FBQ0o7QUFDSjtBQUNKOztBQUVBO0FBQ0k7O0FBRUE7QUFDQTtBQUNJO0FBQ0k7O0FBRUE7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNKOztBQUVBO0FBQ0o7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDSjs7QUFFQTtBQUNJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDSTtBQUNBO0FBQ0o7QUFDSjs7QUFFQTtBQUNJO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNJO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0k7QUFDSjtBQUNBO0FBQ0o7O0FBRUE7QUFDSTtBQUNBOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDSjtBQUNKOztBQUVBO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0k7QUFDSTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0o7O0FBRUE7QUFDSTs7O0FBR0E7QUFDSTtBQUNJO0FBQ0o7O0FBRUE7O0FBRUE7O0FBRUk7O0FBRUE7QUFDSTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNKOztBQUVBO0FBQ0o7QUFDSjtBQUNKOztBQUVBO0FBQ0o7O0FBRUE7QUFDQTtBQUNJO0FBQ0k7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7O0FBRUE7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0k7QUFDUjtBQUNJO0FBQ1I7QUFDSjs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTs7QUFFQTtBQUNKOztBQUVBO0FBQ0k7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0o7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7O0FBRUE7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNJO0FBQ0E7O0FBRUE7QUFDSTtBQUNKO0FBQ0k7QUFDSjs7QUFFQTs7QUFFQTtBQUNJO0FBQ0o7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0o7O0FBRUE7QUFDSTtBQUNBOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTtBQUNKOztBQUVBO0FBQ0k7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSjtBQUNBO0FBQ0o7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0o7QUFDSjs7QUFFQTtBQUNJO0FBQ0k7QUFDSjs7QUFFQTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDUjs7QUFFQTtBQUNKOztBQUVBO0FBQ0k7QUFDSTtBQUNKOztBQUVBOztBQUVBO0FBQ0k7QUFDSTs7QUFFQTtBQUNJO0FBQ0o7QUFDSjtBQUNKO0FBQ0k7O0FBRUE7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7QUFDSTtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0k7QUFDSTtBQUNKOztBQUVBO0FBQ0o7O0FBRUE7QUFDSTtBQUNBOztBQUVBO0FBQ0o7O0FBRUE7QUFDSTtBQUNBOztBQUVBO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNJO0FBQ0k7QUFDSjs7QUFFQTtBQUNKOztBQUVBO0FBQ0k7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDSjs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNKOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDSjs7QUFFQTs7QUFFQTtBQUNJO0FBQ0o7OztBQUdBO0FBQ0o7O0FBRUE7QUFDSTtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0k7QUFDSjtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7QUFFQTtBQUNJO0FBQ0k7QUFDSTs7QUFFQTtBQUNJO0FBQ0o7O0FBRUE7QUFDSTtBQUNBO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTtBQUNJOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0o7QUFDQTs7QUFFQTtBQUNKOztBQUVBO0FBQ0k7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNJO0FBQ0k7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTs7QUFFQTtBQUNJO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDSTtBQUNJO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNBOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTtBQUNJO0FBQ0o7O0FBRUE7QUFDSTtBQUNBO0FBQ0o7QUFDSjs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTtBQUNRO0FBQ0E7QUFDSjtBQUNKOztBQUVBO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNJO0FBQ0U7QUFDQztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSjs7QUFFQTtBQUNKO0FBQ0o7QUFDSjs7QUFFQTtBQUNJO0FBQ0E7QUFDSTs7QUFFQTtBQUNJO0FBQ0o7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0k7QUFDSjtBQUNKO0FBQ0k7QUFDSTtBQUNKO0FBQ0o7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7O0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDSjtBQUNJO0FBQ0k7QUFDQTtBQUNKO0FBQ0s7QUFDQTtBQUNMO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSjtBQUNKO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSjs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUNKO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDSjs7QUFFQTtBQUNJO0FBQ0k7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDSjs7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSjs7QUFFQTtBQUNKO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNSO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0o7QUFDSTtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0o7QUFDSjtBQUNJO0FBQ0k7QUFDSjs7QUFFQTtBQUNKOztBQUVBO0FBQ0k7QUFDSjs7QUFFQTtBQUNJO0FBQ0o7QUFDSjs7QUFFQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNSO0FBQ0o7QUFDSTtBQUNKOztBQUVBO0FBQ0k7QUFDSjtBQUNKOztBQUVBO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSjtBQUNKO0FBQ0o7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7QUFDSjtBQUNKO0FBQ0o7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0o7QUFDSjs7QUFFQTtBQUNJO0FBQ0k7QUFDSTtBQUNKO0FBQ0o7O0FBRUE7QUFDSjs7QUFFQTtBQUNBO0FBQ0k7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0o7QUFDSjs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNKO0FBQ0o7QUFDSjtBQUNKO0FBQ0k7QUFDSjtBQUNKOztBQUVBO0FBQ0k7O0FBRUE7QUFDSTtBQUNKOztBQUVBO0FBQ0o7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBQ0o7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUNKO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSjtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0o7QUFDSjtBQUNKOztBQUVBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0E7QUFDSTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSjtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDSjs7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0k7QUFDSjtBQUNKO0FBQ0E7QUFDSTtBQUNKO0FBQ0o7QUFDQTtBQUNJO0FBQ0o7QUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNJO0FBQ0o7QUFDSjtBQUNBO0FBQ0k7QUFDQTtBQUNKO0FBQ0o7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSjtBQUNKOztBQUVBO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSjtBQUNKO0FBQ0o7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDSjtBQUNKOztBQUVBO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBQ0k7O0FBRUE7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNKOztBQUVBO0FBQ0k7QUFDQTtBQUNKO0FBQ0o7O0FBRUE7QUFDSTtBQUNJO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7O0FBRUE7QUFDSjtBQUNJO0FBQ0o7QUFDSjs7QUFFQTtBQUNBO0FBQ0EifX0seyJvZmZzZXQiOnsibGluZSI6Mjc4NDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ2aXJ0dWFsX2RvbS9kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIFZpcnR1YWxET01cbiAgbW9kdWxlIERPTVxuICAgIEhUTUxfVEFHUyA9ICV3KGEgYWJiciBhZGRyZXNzIGFyZWEgYXJ0aWNsZSBhc2lkZSBhdWRpbyBiIGJhc2UgYmRpIGJkbyBiaWcgYmxvY2txdW90ZSBib2R5IGJyXG4gICAgICAgICAgICAgICAgICBidXR0b24gY2FudmFzIGNhcHRpb24gY2l0ZSBjb2RlIGNvbCBjb2xncm91cCBkYXRhIGRhdGFsaXN0IGRkIGRlbCBkZXRhaWxzIGRmblxuICAgICAgICAgICAgICAgICAgZGlhbG9nIGRpdiBkbCBkdCBlbSBlbWJlZCBmaWVsZHNldCBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgZm9ybSBoMSBoMiBoMyBoNCBoNVxuICAgICAgICAgICAgICAgICAgaDYgaGVhZCBoZWFkZXIgaHIgaHRtbCBpIGlmcmFtZSBpbWcgaW5wdXQgaW5zIGtiZCBrZXlnZW4gbGFiZWwgbGVnZW5kIGxpIGxpbmtcbiAgICAgICAgICAgICAgICAgIG1haW4gbWFwIG1hcmsgbWVudSBtZW51aXRlbSBtZXRhIG1ldGVyIG5hdiBub3NjcmlwdCBvYmplY3Qgb2wgb3B0Z3JvdXAgb3B0aW9uXG4gICAgICAgICAgICAgICAgICBvdXRwdXQgcCBwYXJhbSBwaWN0dXJlIHByZSBwcm9ncmVzcyBxIHJwIHJ0IHJ1YnkgcyBzYW1wIHNjcmlwdCBzZWN0aW9uIHNlbGVjdFxuICAgICAgICAgICAgICAgICAgc21hbGwgc291cmNlIHNwYW4gc3Ryb25nIHN0eWxlIHN1YiBzdW1tYXJ5IHN1cCB0YWJsZSB0Ym9keSB0ZCB0ZXh0YXJlYSB0Zm9vdCB0aFxuICAgICAgICAgICAgICAgICAgdGhlYWQgdGltZSB0aXRsZSB0ciB0cmFjayB1IHVsIHZhciB2aWRlbyB3YnIpXG5cbiAgICBIVE1MX1RBR1MuZWFjaCBkbyB8dGFnfFxuICAgICAgZGVmaW5lX21ldGhvZCB0YWcgZG8gfHBhcmFtcyA9IHt9LCAmYmxvY2t8XG4gICAgICAgIGlmIHBhcmFtcy5pc19hPyhTdHJpbmcpXG4gICAgICAgICAgcHJvY2Vzc190YWcodGFnLCB7fSwgYmxvY2ssIHBhcmFtcylcbiAgICAgICAgZWxzaWYgcGFyYW1zLmlzX2E/KEhhc2gpXG4gICAgICAgICAgcHJvY2Vzc190YWcodGFnLCBwYXJhbXMsIGJsb2NrKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHByb2Nlc3NfdGFnKHRhZywgcGFyYW1zLCBibG9jaywgY2hpbGRyZW4gPSBbXSlcbiAgICAgIEBfX3ZpcnR1YWxfbm9kZXNfXyB8fD0gW11cbiAgICAgIGlmIGJsb2NrXG4gICAgICAgIGN1cnJlbnQgPSBAX192aXJ0dWFsX25vZGVzX19cbiAgICAgICAgQF9fdmlydHVhbF9ub2Rlc19fID0gW11cbiAgICAgICAgcmVzdWx0ID0gYmxvY2suY2FsbCB8fCBjaGlsZHJlblxuICAgICAgICB2bm9kZSA9IFZpcnR1YWxOb2RlLm5ldyh0YWcsIHByb2Nlc3NfcGFyYW1zKHBhcmFtcyksIEBfX3ZpcnR1YWxfbm9kZXNfXy5jb3VudC56ZXJvPyA/IHJlc3VsdCA6IEBfX3ZpcnR1YWxfbm9kZXNfXylcbiAgICAgICAgQF9fdmlydHVhbF9ub2Rlc19fID0gY3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICB2bm9kZSA9IFZpcnR1YWxOb2RlLm5ldyh0YWcsIHByb2Nlc3NfcGFyYW1zKHBhcmFtcyksIGNoaWxkcmVuKVxuICAgICAgZW5kXG4gICAgICBAX19sYXN0X3ZpcnR1YWxfbm9kZV9fID0gdm5vZGVcbiAgICAgIEBfX3ZpcnR1YWxfbm9kZXNfXyA8PCBAX19sYXN0X3ZpcnR1YWxfbm9kZV9fLnRvX25cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBtZXRob2RfbWlzc2luZyhjbGF6eiwgcGFyYW1zID0ge30sICZibG9jaylcbiAgICAgIHJldHVybiB1bmxlc3MgQF9fbGFzdF92aXJ0dWFsX25vZGVfX1xuICAgICAgcmV0dXJuIHVubGVzcyBAX192aXJ0dWFsX25vZGVzX19cbiAgICAgIEBfX3ZpcnR1YWxfbm9kZXNfXy5wb3BcbiAgICAgIGNoaWxkcmVuID0gW11cblxuICAgICAgaWYgcGFyYW1zLmlzX2E/KFN0cmluZylcbiAgICAgICAgY2hpbGRyZW4gPSBbcGFyYW1zXVxuICAgICAgICBwYXJhbXMgPSB7fVxuICAgICAgZW5kXG5cbiAgICAgIGNsYXNzX3BhcmFtcyA9IEBfX2xhc3RfdmlydHVhbF9ub2RlX18ucGFyYW1zLmRlbGV0ZSg6Y2xhc3NOYW1lKVxuICAgICAgbWV0aG9kX3BhcmFtcyA9IGlmIGNsYXp6LmVuZF93aXRoPygnIScpXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiBjbGF6elswLi4tMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBtZXJnZV9zdHJpbmcoY2xhc3NfcGFyYW1zLCBwYXJhbXNbOmNsYXNzXSkgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3M6IG1lcmdlX3N0cmluZyhjbGFzc19wYXJhbXMsIHBhcmFtc1s6Y2xhc3NdLCBjbGF6ei5nc3ViKCdfJywgJy0nKS5nc3ViKCctLScsICdfJykpIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgIHBhcmFtcyA9IEBfX2xhc3RfdmlydHVhbF9ub2RlX18ucGFyYW1zLm1lcmdlKHBhcmFtcykubWVyZ2UobWV0aG9kX3BhcmFtcylcbiAgICAgIHByb2Nlc3NfdGFnKEBfX2xhc3RfdmlydHVhbF9ub2RlX18ubmFtZSwgcGFyYW1zLCBibG9jaywgY2hpbGRyZW4pXG4gICAgZW5kXG5cbiAgICBkZWYgbWVyZ2Vfc3RyaW5nKCpwYXJhbXMpXG4gICAgICBhcnIgPSBbXVxuICAgICAgcGFyYW1zLmVhY2ggZG8gfHN0cmluZ3xcbiAgICAgICAgbmV4dCB1bmxlc3Mgc3RyaW5nXG4gICAgICAgIGFyciA8PCBzdHJpbmcuc3BsaXQoJyAnKVxuICAgICAgZW5kXG4gICAgICBhcnIuam9pbignICcpXG4gICAgZW5kXG5cbiAgICBkZWYgcHJvY2Vzc19wYXJhbXMocGFyYW1zKVxuICAgICAgcGFyYW1zLmR1cC5lYWNoIGRvIHxrLCB2fFxuICAgICAgICBjYXNlIGtcbiAgICAgICAgICB3aGVuICdmb3InXG4gICAgICAgICAgICBwYXJhbXNbJ2h0bWxGb3InXSA9IHBhcmFtcy5kZWxldGUoJ2ZvcicpXG4gICAgICAgIHdoZW4gJ2NsYXNzJ1xuICAgICAgICAgIHBhcmFtc1snY2xhc3NOYW1lJ10gPSBwYXJhbXMuZGVsZXRlKCdjbGFzcycpXG4gICAgICAgIHdoZW4gJ2RhdGEnXG4gICAgICAgICAgcGFyYW1zWydkYXRhc2V0J10gPSBwYXJhbXMuZGVsZXRlKCdkYXRhJylcbiAgICAgICAgd2hlbiAnZGVmYXVsdCdcbiAgICAgICAgICBwYXJhbXNbJ2RlZmF1bHRWYWx1ZSddID0gcGFyYW1zLmRlbGV0ZSgnZGVmYXVsdCcpXG4gICAgICAgIHdoZW4gL15vbi9cbiAgICAgICAgICBwYXJhbXNba10gPSBldmVudF9jYWxsYmFjayh2KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcGFyYW1zXG4gICAgZW5kXG5cbiAgICBkZWYgZXZlbnRfY2FsbGJhY2sodilcbiAgICAgIHByb2MgZG8gfGV8XG4gICAgICAgIHYuY2FsbChTdXBwb3J0LndyYXBfZXZlbnQoZSkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0ZXh0KHN0cmluZylcbiAgICAgIEBfX3ZpcnR1YWxfbm9kZXNfXyA8PCBzdHJpbmcudG9fc1xuICAgIGVuZFxuXG4gICAgZGVmIHRvX3Zub2RlXG4gICAgICBpZiBAX192aXJ0dWFsX25vZGVzX18ub25lP1xuICAgICAgICBAX192aXJ0dWFsX25vZGVzX18uZmlyc3RcbiAgICAgIGVsc2VcbiAgICAgICAgVmlydHVhbE5vZGUubmV3KCdkaXYnLCB7fSwgQF9fdmlydHVhbF9ub2Rlc19fKS50b19uXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBjbGFzc19uYW1lcyhoYXNoKVxuICAgICAgY2xhc3NfbmFtZXMgPSBbXVxuICAgICAgaGFzaC5lYWNoIGRvIHxrZXksIHZhbHVlfFxuICAgICAgICBjbGFzc19uYW1lcyA8PCBrZXkgaWYgdmFsdWVcbiAgICAgIGVuZFxuICAgICAgY2xhc3NfbmFtZXMuam9pbignICcpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6VmlydHVhbERPTT4iLCI8bW9kdWxlOkRPTT4iLCJlYWNoIiwiSFRNTF9UQUdTIiwiYmxvY2sgaW4gPG1vZHVsZTpET00+IiwidGFnIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8bW9kdWxlOkRPTT4iLCJkZWZpbmVfbWV0aG9kIiwic2VsZiIsInBhcmFtcyIsImJsb2NrICgzIGxldmVscykgaW4gPG1vZHVsZTpET00+IiwiaXNfYT8iLCJTdHJpbmciLCJwcm9jZXNzX3RhZyIsImJsb2NrIiwiSGFzaCIsImNoaWxkcmVuIiwiQF9fdmlydHVhbF9ub2Rlc19fIiwiJHJldF9vcl8xIiwiY3VycmVudCIsInJlc3VsdCIsImNhbGwiLCJ2bm9kZSIsIlZpcnR1YWxOb2RlIiwibmV3IiwicHJvY2Vzc19wYXJhbXMiLCJjb3VudCIsInplcm8/IiwiQF9fbGFzdF92aXJ0dWFsX25vZGVfXyIsIjw8IiwidG9fbiIsIm1ldGhvZF9taXNzaW5nIiwiY2xhenoiLCJwb3AiLCJjbGFzc19wYXJhbXMiLCJkZWxldGUiLCJtZXRob2RfcGFyYW1zIiwiZW5kX3dpdGg/IiwiW10iLCIwIiwiLTIiLCJtZXJnZV9zdHJpbmciLCJnc3ViIiwibWVyZ2UiLCJuYW1lIiwiYXJyIiwiYmxvY2sgaW4gbWVyZ2Vfc3RyaW5nIiwic3RyaW5nIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtZXJnZV9zdHJpbmciLCJzcGxpdCIsImpvaW4iLCJkdXAiLCJibG9jayBpbiBwcm9jZXNzX3BhcmFtcyIsImsiLCJ2IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcm9jZXNzX3BhcmFtcyIsIltdPSIsImV2ZW50X2NhbGxiYWNrIiwicHJvYyIsImJsb2NrIGluIGV2ZW50X2NhbGxiYWNrIiwiZSIsImJsb2NrICgyIGxldmVscykgaW4gZXZlbnRfY2FsbGJhY2siLCJTdXBwb3J0Iiwid3JhcF9ldmVudCIsInRleHQiLCJ0b19zIiwidG9fdm5vZGUiLCJvbmU/IiwiZmlyc3QiLCJjbGFzc19uYW1lcyIsImhhc2giLCJibG9jayBpbiBjbGFzc19uYW1lcyIsImtleSIsInZhbHVlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjbGFzc19uYW1lcyJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFDRSxxQ0FBWSxJQUFBLG1CQUFBLENBQUEsb2xCQUFBLENBQVo7TUFTU0MsTUFBVEMsZUFBU0QsUUFBQUEsRUFBQUEsRUFBQUEsRUFBVEUsZ0JBQW1CQyxHQUFuQkQsRUFBQUU7OztRQUFt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RnBFLEdBQUFBLFdBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODAxNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZpcnR1YWxfZG9tL3ZpcnR1YWxfbm9kZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgVmlydHVhbERPTVxuICBjbGFzcyBWaXJ0dWFsTm9kZVxuICAgICNpbmNsdWRlIFZpcnR1YWxET006OkRPTVxuXG4gICAgYXR0cl9yZWFkZXIgOm5hbWUsIDpwYXJhbXMsIDpjaGlsZHJlblxuXG4gICAgZGVmIGluaXRpYWxpemUobmFtZSwgcGFyYW1zID0ge30sIGNoaWxkcmVuID0gW10pXG4gICAgICBAbmFtZSA9IG5hbWVcbiAgICAgIEBwYXJhbXMgPSBwYXJhbXNcbiAgICAgIEBjaGlsZHJlbiA9IGNoaWxkcmVuXG4gICAgZW5kXG5cbiAgICBkZWYgdG9fblxuICAgICAgYHZpcnR1YWxEb20uaCgje0BuYW1lfSwgI3tAcGFyYW1zLnRvX259LCAje0BjaGlsZHJlbn0pYFxuICAgIGVuZFxuXG4gICAgZGVmIHRvX3NcbiAgICAgIFwiPCN7QG5hbWV9I3t0b19zX3BhcmFtc30+I3t0b19zX2NoaWxkcmVufTwvI3tAbmFtZX0+XCJcbiAgICBlbmRcblxuICAgIGRlZiB0b19zX3BhcmFtc1xuICAgICAgcmV0dXJuIHVubGVzcyBAcGFyYW1zLmFueT9cbiAgICAgICcgJyArIEBwYXJhbXMubWFwIGRvIHxrLCB2fFxuICAgICAgICBcIiN7a309XFxcIiN7dn1cXFwiXCJcbiAgICAgIGVuZC5qb2luKCcgJylcbiAgICBlbmRcblxuICAgIGRlZiB0b19zX2NoaWxkcmVuXG4gICAgICByZXR1cm4gQGNoaWxkcmVuIGlmIEBjaGlsZHJlbi5pc19hPyhTdHJpbmcpXG4gICAgICByZXR1cm4gdW5sZXNzIEBjaGlsZHJlbi5hbnk/XG4gICAgICBAY2hpbGRyZW5cbiAgICAgICAgLm1hcCgmOnRvX3MpXG4gICAgICAgIC5qb2luXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6VmlydHVhbERPTT4iLCI8Y2xhc3M6VmlydHVhbE5vZGU+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIm5hbWUiLCJwYXJhbXMiLCJjaGlsZHJlbiIsIkBuYW1lIiwiQHBhcmFtcyIsIkBjaGlsZHJlbiIsInRvX24iLCJ0b19zIiwidG9fc19wYXJhbXMiLCJ0b19zX2NoaWxkcmVuIiwiYW55PyIsIisiLCJtYXAiLCJibG9jayBpbiB0b19zX3BhcmFtcyIsImsiLCJ2IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19zX3BhcmFtcyIsImpvaW4iLCJpc19hPyIsIlN0cmluZyIsInRvX3Byb2MiXSwibWFwcGluZ3MiOiJBQUFBQSwyQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BR0VDLElBQUFDLGFBQUFBLENBQVksTUFBWixFQUFtQixRQUFuQixFQUE0QixVQUE1QkE7O0FBRUFDLE1BQUFBLDBCQUFBQSxzQkFBZUMsSUFBRCxFQUFPQyxNQUFQLEVBQW9CQyxRQUFsQ0g7QUFBQUEsUUFBQUE7OztRQUFxQiw2QkFBUyxZQUFBO1FBQUksaUNBQVc7UUFDM0NJLFlBQVFIO1FBQ1JJLGNBQVVIO1FBQ1ZGLE9BQUFNLENBQUFBLGdCQUFZSCxRQUFaRztNQUhGTixDQUFBQSxJQUFBQTs7QUFNQU8sTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQ0EsYUFBZUgsU0FBTUcsRUFBSUYsV0FBT0UsTUFBQUEsQ0FBQUEsQ0FBTUEsRUFBSUQsYUFBVUM7TUFEdkRBLENBQUFBOztBQUlBQyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFDQSxHQUFELEdBQUEsQ0FBSUosU0FBSixDQUFBLEdBQUEsQ0FBWU4sSUFBQVcsYUFBQUEsQ0FBQUEsQ0FBWixDQUFBLEdBQXdCRCxHQUF4QixHQUFBLENBQTJCVixJQUFBWSxlQUFBQSxDQUFBQSxDQUEzQixDQUFBLEdBQXlDRixJQUF6QyxHQUFBLENBQTZDSixTQUE3QyxDQUFBLEdBQW1ESTtNQURyREEsQ0FBQUE7O0FBSUFDLE1BQUFBLDJCQUFBQSx1QkFBQUE7QUFBQUEsUUFBQUE7OztRQUNFLEtBQUEsUUFBY0osV0FBT00sU0FBQUEsQ0FBQUEsQ0FBckIsQ0FBQTtVQUFBLE9BQUE7UUFBQTtRQUNBRixPQUFJRyxTQUFKSCxHQUFJRyxFQUFTQyxNQUFQUixXQUFPUSxPQUFBQSxFQUFBQSxFQUFBQSxFQUFQQyxhQUFnQkMsQ0FBRCxFQUFJQyxDQUFuQkY7O1VBQWdCO1VBQUc7VUFDdkJHLE9BQUEsRUFBQSxHQUFBLENBQUdGLENBQUgsQ0FBQSxHQUFLRSxLQUFMLEdBQUEsQ0FBVUQsQ0FBVixDQUFBLEdBQVlDLEtBRFJILENBQU9ELENBRVZLLE1BQUFBLENBQU1ULEdBQU5TLENBRkNOO01BRk5ILENBQUFBO01BT0FaLE9BQUFhLDZCQUFBQSx5QkFBQUE7QUFBQUEsUUFBQUE7OztRQUNFLElBQUEsUUFBb0JKLGFBQVNhLFVBQUFBLENBQU9DLFlBQVBELENBQTdCLENBQUE7VUFBQSxPQUFPYjtRQUFQO1FBQ0EsS0FBQSxRQUFjQSxhQUFTSyxTQUFBQSxDQUFBQSxDQUF2QixDQUFBO1VBQUEsT0FBQTtRQUFBO1FBQ0FELE9BQ0VHLE1BREZQLGFBQ0VPLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sTUFBRFEsU0FBQUEsQ0FBQUEsQ0FBTFIsQ0FDQUssTUFBQUEsQ0FBQUE7TUFMSlIsQ0FBQUE7SUExQkZiLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODA4NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZpcnR1YWxfZG9tL3dyYXBwZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIFZpcnR1YWxET01cbiAgbW9kdWxlIFdyYXBwZXJcbiAgICBkZWYgY3JlYXRlKHZub2RlKVxuICAgICAgYHZpcnR1YWxEb20uY3JlYXRlKCN7dm5vZGV9KWBcbiAgICBlbmRcblxuICAgIGRlZiBkaWZmKG9sZCwgbmV3KVxuICAgICAgYHZpcnR1YWxEb20uZGlmZigje29sZH0sICN7bmV3fSlgXG4gICAgZW5kXG5cbiAgICBkZWYgcGF0Y2goZG9tLCBkaWZmKVxuICAgICAgYHZpcnR1YWxEb20ucGF0Y2goI3tkb219LCAje2RpZmZ9KWBcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpWaXJ0dWFsRE9NPiIsIjxtb2R1bGU6V3JhcHBlcj4iLCJjcmVhdGUiLCJ2bm9kZSIsImRpZmYiLCJvbGQiLCJuZXckIiwicGF0Y2giLCJkb20iXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOzs7OztBQUNFQyxNQUFBQSxzQkFBQUEsa0JBQVdDLEtBQVhEO0FBQUFBO1FBQ0VBLE9BQUNBLGtCQUFvQkMsS0FBTUQ7TUFEN0JBLENBQUFBOztBQUlBRSxNQUFBQSxvQkFBQUEsZ0JBQVNDLEdBQUQsRUFBTUMsSUFBZEY7QUFBQUE7UUFDRUEsT0FBQ0EsZ0JBQWtCQyxHQUFJRCxFQUFJRSxJQUFJRjtNQURqQ0EsQ0FBQUE7TUFJQUgsT0FBQU0scUJBQUFBLGlCQUFVQyxHQUFELEVBQU1KLElBQWZHO0FBQUFBO1FBQ0VBLE9BQUNBLGlCQUFtQkMsR0FBSUQsRUFBSUgsSUFBS0c7TUFEbkNBLENBQUFBO0lBVEZOLEdBQUFBLFdBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODExNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZpcnR1YWxfZG9tL2hvb2sucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIFZpcnR1YWxET01cbiAgY2xhc3MgQ29tbW9uSG9va1xuICAgIGRlZiBzZWxmLm1ldGhvZChtdGhkKVxuICAgICAgbmV3IGRvIHxub2RlLCBuYW1lLCBwcmV2aW91c3xcbiAgICAgICAgbXRoZC5jYWxsKG5vZGUsIG5hbWUsIHByZXZpb3VzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgICBAYmxvY2sgPSBibG9ja1xuICAgIGVuZFxuXG4gICAgZGVmIHRvX25cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBjYWxsX2Jsb2NrKG5vZGUsIG5hbWUsIHByZXZpb3VzKVxuICAgICAgbm9kZSA9IFN1cHBvcnQud3JhcF9ub2RlKG5vZGUpXG4gICAgICBuYW1lID0gTmF0aXZlKG5hbWUpXG4gICAgICBwcmV2aW91cyA9IE5hdGl2ZShwcmV2aW91cylcbiAgICAgIEBibG9jay5jYWxsKG5vZGUsIG5hbWUsIHByZXZpb3VzKVxuICAgIGVuZFxuICBlbmRcblxuICBjbGFzcyBIb29rIDwgQ29tbW9uSG9va1xuICAgICV4e1xuICAgICAgT3BhbC5kZWZuKHNlbGYsICdob29rJywgZnVuY3Rpb24obm9kZSwgbmFtZSwgcHJldmlvdXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAje2NhbGxfYmxvY2soYG5vZGVgLCBgbmFtZWAsIGBwcmV2aW91c2ApfTtcbiAgICAgIH0pO1xuICAgICAgT3BhbC5kZWZuKHNlbGYsICd1bmhvb2snLCBmdW5jdGlvbihub2RlLCBuYW1lLCBwcmV2aW91cykge30pO1xuICAgIH1cbiAgZW5kXG5cbiAgY2xhc3MgVW5Ib29rIDwgQ29tbW9uSG9va1xuICAgICV4e1xuICAgICAgT3BhbC5kZWZuKHNlbGYsICd1bmhvb2snLCBmdW5jdGlvbihub2RlLCBuYW1lLCBwcmV2aW91cykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICN7Y2FsbF9ibG9jayhgbm9kZWAsIGBuYW1lYCwgYHByZXZpb3VzYCl9O1xuICAgICAgfSk7XG4gICAgICBPcGFsLmRlZm4oc2VsZiwgJ2hvb2snLCBmdW5jdGlvbihub2RlLCBuYW1lLCBwcmV2aW91cykge30pO1xuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpWaXJ0dWFsRE9NPiIsIjxjbGFzczpDb21tb25Ib29rPiIsIm1ldGhvZCIsInNlbGYiLCJtdGhkIiwibmV3IiwiYmxvY2sgaW4gbWV0aG9kIiwibm9kZSIsIm5hbWUiLCJwcmV2aW91cyIsImJsb2NrICgyIGxldmVscykgaW4gbWV0aG9kIiwiY2FsbCIsImluaXRpYWxpemUiLCJAYmxvY2siLCJibG9jayIsInRvX24iLCJjYWxsX2Jsb2NrIiwiU3VwcG9ydCIsIndyYXBfbm9kZSIsIk5hdGl2ZSIsIjxjbGFzczpIb29rPiIsIkNvbW1vbkhvb2siLCI8Y2xhc3M6VW5Ib29rPiJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0VDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLE1BQUlDLElBQUpELGFBQUFBLGtCQUFnQkUsSUFBaEJGO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBRyxNQUFBRixJQUFBRSxPQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyxhQUFRQyxJQUFELEVBQU9DLElBQVAsRUFBYUMsUUFBcEJIOztVQUFRO1VBQU07VUFBTTtVQUNsQkksT0FBQU4sSUFBSU8sTUFBQUEsQ0FBTUosSUFBVixFQUFnQkMsSUFBaEIsRUFBc0JDLFFBQWxCRSxFQUROTCxDQUFBRDtNQURGSCxDQUFBQTs7QUFNQVUsTUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNFQSxPQUFBQyxDQUFBQSxhQUFTQyxLQUFURDtNQURGRCxDQUFBQTs7QUFJQUcsTUFBQUEsb0JBQUFBLFlBQUFBO01BSUFkLE9BQUFlLDBCQUFBQSxzQkFBZVQsSUFBRCxFQUFPQyxJQUFQLEVBQWFDLFFBQTNCTztBQUFBQSxRQUFBQTs7O1FBQ0VULE9BQU9VLGFBQU9DLFdBQUFBLENBQVdYLElBQVhXO1FBQ2RWLE9BQU9MLElBQUFnQixRQUFBQSxDQUFPWCxJQUFQVztRQUNQVixXQUFXTixJQUFBZ0IsUUFBQUEsQ0FBT1YsUUFBUFU7UUFDWEgsT0FBQUgsVUFBTUYsTUFBQUEsQ0FBTUosSUFBWixFQUFrQkMsSUFBbEIsRUFBd0JDLFFBQWxCRTtNQUpSSyxDQUFBQTtJQWZGZixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQXVCQW1CO0lBQUFBOzs7O0FBRUZBO0FBQ0FBO0FBQ0FBLFFBQVVqQixJQUFBYSxZQUFBQSxDQUFZSSxJQUFaLEVBQW9CQSxJQUFwQixFQUE0QkEsUUFBNUJKLENBQXVDSTtBQUNqREE7QUFDQUE7QUFDQUE7SUFQRUEsR0FBQUEsV0FBQUEsRUFBYUMsZ0JBQWJEO0lBVUFwQixPQUFBc0I7SUFBQUE7Ozs7QUFFRkE7QUFDQUE7QUFDQUEsUUFBVW5CLElBQUFhLFlBQUFBLENBQVlNLElBQVosRUFBb0JBLElBQXBCLEVBQTRCQSxRQUE1Qk4sQ0FBdUNNO0FBQ2pEQTtBQUNBQTtBQUNBQTtJQVBFQSxHQUFBQSxXQUFBQSxFQUFlRCxnQkFBZkM7RUFsQ0Z0QixHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjgxOTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ2aXJ0dWFsX2RvbS9zdXBwb3J0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBWaXJ0dWFsRE9NXG4gIG1vZHVsZSBTdXBwb3J0XG4gICAgbW9kdWxlX2Z1bmN0aW9uXG5cbiAgICBkZWYgd3JhcF9ub2RlKG5vZGUpXG4gICAgICBOYXRpdmUobm9kZSlcbiAgICBlbmRcblxuICAgIGRlZiB3cmFwX2V2ZW50KGV2ZW50KVxuICAgICAgTmF0aXZlKGV2ZW50KVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOlZpcnR1YWxET00+IiwiPG1vZHVsZTpTdXBwb3J0PiIsInNlbGYiLCJtb2R1bGVfZnVuY3Rpb24iLCJ3cmFwX25vZGUiLCJub2RlIiwiTmF0aXZlIiwid3JhcF9ldmVudCIsImV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7OztNQUNFQyxJQUFBQyxpQkFBQUEsQ0FBQUE7O0FBRUFDLE1BQUFBLHlCQUFBQSxxQkFBY0MsSUFBZEQ7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFGLElBQUFJLFFBQUFBLENBQU9ELElBQVBDO01BREZGLENBQUFBO01BSUFILE9BQUFNLDBCQUFBQSxzQkFBZUMsS0FBZkQ7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFMLElBQUFJLFFBQUFBLENBQU9FLEtBQVBGO01BREZDLENBQUFBO0lBUEZOLEdBQUFBLFdBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODIyMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vdmlydHVhbF9kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAndmVuZG9yL3ZpcnR1YWwtZG9tJ1xucmVxdWlyZSAndmlydHVhbF9kb20vZG9tJ1xucmVxdWlyZSAndmlydHVhbF9kb20vdmlydHVhbF9ub2RlJ1xucmVxdWlyZSAndmlydHVhbF9kb20vd3JhcHBlcidcbnJlcXVpcmUgJ3ZpcnR1YWxfZG9tL2hvb2snXG5yZXF1aXJlICd2aXJ0dWFsX2RvbS9zdXBwb3J0J1xuXG5tb2R1bGUgVmlydHVhbERPTVxuICBpbmNsdWRlIFZpcnR1YWxET006OkRPTVxuICBleHRlbmQgVmlydHVhbERPTTo6V3JhcHBlclxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpWaXJ0dWFsRE9NPiIsImluY2x1ZGUiLCJWaXJ0dWFsRE9NOjpET00iLCJWaXJ0dWFsRE9NIiwiZXh0ZW5kIiwiVmlydHVhbERPTTo6V3JhcHBlciJdLCJtYXBwaW5ncyI6IkFBQUFBLDhCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDBCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsa0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxJQUFBQyxnQkFBQUQsUUFBUkQ7SUFDQUQsT0FBQUYsSUFBQU0sUUFBQUEsQ0FBT0MsSUFBQUYsZ0JBQUFFLFlBQVBEO0VBRkZKLEdBQUFBLFdBQUFBO0FBUEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODI0NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImluZXNpdGEvYnJvd3Nlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgSW5lc2l0YVxuICBtb2R1bGUgQnJvd3NlclxuICAgIG1vZHVsZV9mdW5jdGlvblxuXG4gICAgV2luZG93ID0gSlMuZ2xvYmFsXG4gICAgRG9jdW1lbnQgPSBXaW5kb3cuSlNbOmRvY3VtZW50XVxuICAgIEFkZEV2ZW50TGlzdGVuZXIgPSBXaW5kb3cuSlNbOmFkZEV2ZW50TGlzdGVuZXJdXG5cbiAgICBpZiBOYXRpdmUoV2luZG93LkpTWzpyZXF1ZXN0QW5pbWF0aW9uRnJhbWVdKVxuICAgICAgZGVmIGFuaW1hdGlvbl9mcmFtZSgmYmxvY2spXG4gICAgICAgIFdpbmRvdy5KUy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYmxvY2spXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBkZWYgYW5pbWF0aW9uX2ZyYW1lKCZibG9jaylcbiAgICAgICAgYmxvY2suY2FsbFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhZHk/KCZibG9jaylcbiAgICAgIEFkZEV2ZW50TGlzdGVuZXIuY2FsbCgnbG9hZCcsIGJsb2NrKVxuICAgIGVuZFxuXG4gICAgZGVmIGJvZHlcbiAgICAgIERvY3VtZW50LkpTWzpib2R5XVxuICAgIGVuZFxuXG4gICAgZGVmIGFwcGVuZF9jaGlsZChub2RlLCBuZXdfbm9kZSlcbiAgICAgIG5vZGUgPSBub2RlLnRvX24gdW5sZXNzIG5hdGl2ZT8obm9kZSlcbiAgICAgIG5ld19ub2RlID0gbmV3X25vZGUudG9fbiB1bmxlc3MgbmF0aXZlPyhuZXdfbm9kZSlcbiAgICAgIG5vZGUuSlMuYXBwZW5kQ2hpbGQobmV3X25vZGUpXG4gICAgZW5kXG5cbiAgICBkZWYgcXVlcnlfZWxlbWVudChjc3MpXG4gICAgICBEb2N1bWVudC5KUy5xdWVyeVNlbGVjdG9yKGNzcylcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpJbmVzaXRhPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCJzZWxmIiwibW9kdWxlX2Z1bmN0aW9uIiwiSlMiLCJnbG9iYWwiLCJXaW5kb3ciLCJOYXRpdmUiLCJhbmltYXRpb25fZnJhbWUiLCJibG9jayIsImNhbGwiLCJyZWFkeT8iLCJBZGRFdmVudExpc3RlbmVyIiwiYm9keSIsIkRvY3VtZW50IiwiYXBwZW5kX2NoaWxkIiwibm9kZSIsIm5ld19ub2RlIiwibmF0aXZlPyIsInRvX24iLCJxdWVyeV9lbGVtZW50IiwiY3NzIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7OztNQUNFQyxJQUFBQyxpQkFBQUEsQ0FBQUE7TUFFQSxrQ0FBU0MsUUFBRUMsUUFBQUEsQ0FBQUEsQ0FBWDtNQUNBLG9DQUFXQyxZQUFBLENBQVUsVUFBVixDQUFYO01BQ0EsNENBQW1CQSxZQUFBLENBQVUsa0JBQVYsQ0FBbkI7TUFFQSxJQUFBLFFBQUdKLElBQUFLLFFBQUFBLENBQU9ELFlBQUEsQ0FBVSx1QkFBVixDQUFQQyxDQUFILENBQUE7O0FBQ0VDLFFBQUFBLCtCQUFBQSwyQkFBQUE7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFDRUEsT0FBQUYsWUFBQSxzQkFBQSxDQUFnQ0csS0FBaEM7UUFERkQsQ0FBQUE7TUFERjs7QUFLRUEsUUFBQUEsK0JBQUFBLDJCQUFBQTtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQUNFQSxPQUFBQyxLQUFLQyxNQUFBQSxDQUFBQTtRQURQRixDQUFBQTtNQUxGOztBQVVBRyxNQUFBQSxzQkFBQUEsK0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0VBLE9BQUFDLHNCQUFnQkYsTUFBQUEsQ0FBTUMsTUFBdEIsRUFBOEJGLEtBQWRDO01BRGxCQyxDQUFBQTs7QUFJQUUsTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQTtRQUNFQSxPQUFBQyxjQUFBLENBQVksTUFBWjtNQURGRCxDQUFBQTs7QUFJQUUsTUFBQUEsNEJBQUFBLHdCQUFpQkMsSUFBRCxFQUFPQyxRQUF2QkY7QUFBQUEsUUFBQUE7OztRQUNFLEtBQUEsUUFBd0JiLElBQUFnQixZQUFBQSxDQUFRRixJQUFSRSxDQUF4QixDQUFBO1VBQUFGLE9BQU9BLElBQUlHLE1BQUFBLENBQUFBO1FBQVg7UUFDQSxLQUFBLFFBQWdDakIsSUFBQWdCLFlBQUFBLENBQVFELFFBQVJDLENBQWhDLENBQUE7VUFBQUQsV0FBV0EsUUFBUUUsTUFBQUEsQ0FBQUE7UUFBbkI7UUFDQUosT0FBQUMsSUFBQSxZQUFBLENBQW9CQyxRQUFwQjtNQUhGRixDQUFBQTtNQU1BZCxPQUFBbUIsNkJBQUFBLHlCQUFrQkMsR0FBbEJEO0FBQUFBO1FBQ0VBLE9BQUFOLGNBQUEsY0FBQSxDQUEwQk8sR0FBMUI7TUFERkQsQ0FBQUE7SUEvQkZuQixHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjgzMTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmVzaXRhL2Vycm9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBJbmVzaXRhXG4gIGNsYXNzIEVycm9yIDwgU3RhbmRhcmRFcnJvclxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkluZXNpdGE+IiwiPGNsYXNzOkVycm9yPiIsIlN0YW5kYXJkRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxnQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDLFFBQUFBLFdBQUFBLEVBQWNDLG1CQUFkRDtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjgzMzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmVzaXRhL2luamVjdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgSW5lc2l0YVxuICBtb2R1bGUgSW5qZWN0aW9uXG4gICAgZGVmIGluaXQ7IGVuZFxuXG4gICAgZGVmIHdpdGhfcm9vdF9jb21wb25lbnQoY29tcG9uZW50KVxuICAgICAgQHJvb3RfY29tcG9uZW50ID0gY29tcG9uZW50XG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgaW5qZWN0XG4gICAgICBAcm9vdF9jb21wb25lbnQuaW5qZWN0aW9ucy5lYWNoIGRvIHxuYW1lLCBpbnN0YW5jZXxcbiAgICAgICAgZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QobmFtZSkgZG9cbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgc2VsZlxuICAgIGVuZFxuXG4gICAgYXR0cl9yZWFkZXIgOmluamVjdGlvbnNcbiAgICBkZWYgaW5pdF9pbmplY3Rpb25zXG4gICAgICBAaW5qZWN0aW9ucyB8fD0ge31cbiAgICAgIHNlbGYuY2xhc3MuaW5qZWN0aW9ucy5lYWNoIGRvIHxuYW1lLCBjbGF6enxcbiAgICAgICAgaWYgY2xhenouaW5jbHVkZWRfbW9kdWxlcy5pbmNsdWRlPyhJbmVzaXRhOjpJbmplY3Rpb24pXG4gICAgICAgICAgQGluamVjdGlvbnNbbmFtZV0gPSBjbGF6elxuICAgICAgICAgICAgLm5ld1xuICAgICAgICAgICAgLndpdGhfcm9vdF9jb21wb25lbnQoQHJvb3RfY29tcG9uZW50KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmFpc2UgRXJyb3IsIFwiSW52YWxpZCAje2NsYXp6fSBjbGFzcywgc2hvdWxkIG1peGluIEluZXNpdGE6OkluamVjdGlvblwiXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBAaW5qZWN0aW9ucy5lYWNoIGRvIHxrZXksIGluc3RhbmNlfFxuICAgICAgICBpbnN0YW5jZS5pbmplY3RcbiAgICAgICAgaW5zdGFuY2UuaW5pdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgcmVuZGVyIVxuICAgICAgQnJvd3Nlci5hbmltYXRpb25fZnJhbWUgZG9cbiAgICAgICAgQHJvb3RfY29tcG9uZW50LnJlbmRlcl9pZl9yb290XG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpJbmVzaXRhPiIsIjxtb2R1bGU6SW5qZWN0aW9uPiIsImluaXQiLCJ3aXRoX3Jvb3RfY29tcG9uZW50IiwiY29tcG9uZW50IiwiQHJvb3RfY29tcG9uZW50Iiwic2VsZiIsImluamVjdCIsImVhY2giLCJpbmplY3Rpb25zIiwiYmxvY2sgaW4gaW5qZWN0IiwibmFtZSIsImluc3RhbmNlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbmplY3QiLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImJsb2NrICgzIGxldmVscykgaW4gaW5qZWN0IiwiYXR0cl9yZWFkZXIiLCJpbml0X2luamVjdGlvbnMiLCJAaW5qZWN0aW9ucyIsIiRyZXRfb3JfMSIsImNsYXNzIiwiYmxvY2sgaW4gaW5pdF9pbmplY3Rpb25zIiwiY2xhenoiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRfaW5qZWN0aW9ucyIsImluY2x1ZGVkX21vZHVsZXMiLCJpbmNsdWRlPyIsIkluZXNpdGE6OkluamVjdGlvbiIsIkluZXNpdGEiLCJbXT0iLCJuZXciLCJyYWlzZSIsIkVycm9yIiwia2V5IiwicmVuZGVyISIsImFuaW1hdGlvbl9mcmFtZSIsIkJyb3dzZXIiLCJibG9jayBpbiByZW5kZXIhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZW5kZXIhIiwicmVuZGVyX2lmX3Jvb3QiXSwibWFwcGluZ3MiOiJBQUFBQSxvQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7OztBQUNFQyxNQUFBQSxvQkFBQUEsWUFGSixHQUVJQSxDQUFBQTs7QUFFQUMsTUFBQUEsbUNBQUFBLCtCQUF3QkMsU0FBeEJEO0FBQUFBLFFBQUFBOzs7UUFDRUUsc0JBQWtCRDtRQUNsQkQsT0FBQUc7TUFGRkgsQ0FBQUE7O0FBS0FJLE1BQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsUUFBQUE7QUFBQUE7OztRQUM0QkMsTUFBMUJILG1CQUFlSSxZQUFBQSxDQUFBQSxDQUFXRCxRQUFBQSxFQUFBQSxFQUFBQSxFQUExQkUsYUFBb0NDLElBQUQsRUFBT0MsUUFBMUNGLEVBQUFHOzs7VUFBb0M7VUFBTTtVQUN4Q0EsT0FBQUMsTUFBQVIsSUFBQVEsMkJBQUFBLEVBQUFBLENBQXdCSCxJQUF4QkcsQ0FBQUEsRUFBQUQsYUFBQUE7WUFDRUUsT0FBQUgsUUFERkMsQ0FBQUMsRUFERkosQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBMEJGO1FBSzFCRCxPQUFBRDtNQU5GQyxDQUFBQTtNQVNBRCxJQUFBVSxhQUFBQSxDQUFZLFlBQVpBOztBQUNBQyxNQUFBQSwrQkFBQUEsMkJBQUFBO0FBQUFBLFFBQUFBO0FBQUFBOzs7UUFDRUMsa0JBcEJOLENBQUEsUUFBQUMsQ0FBQUEsWUFvQk1ELGVBcEJOQyxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQW9Cc0IsWUFBQSxFQXBCdEIsQ0FBQTtRQXFCMkJYLE1BQXJCRixJQUFJYyxPQUFBQSxDQUFBQSxDQUFNWCxZQUFBQSxDQUFBQSxDQUFXRCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFyQmEsYUFBK0JWLElBQUQsRUFBT1csS0FBckNELEVBQUFFO0FBQUFBO0FBQUFBOzs7VUFBK0I7VUFBTTtVQUNuQyxJQUFBLFFBQUdELEtBQUtFLGtCQUFBQSxDQUFBQSxDQUFpQkMsYUFBQUEsQ0FBVUMsSUFBQUMsYUFBQUQsY0FBVkQsQ0FBekIsQ0FBQTtZQUNFRixPQUFXSyxNQUFBQSxDQUFDakIsSUFBWixFQUFvQlcsS0FDbEJPLEtBQUFBLENBQUFBLENBQ0ExQixxQkFBQUEsQ0FBcUJFLG1CQUFyQkYsQ0FGU3lCLENBQUFBLEVBQUFBLE1BQVhWLGVBQVdVLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBO1VBRGI7WUFLRUwsT0FBQWpCLElBQUF3QixPQUFBQSxDQUFNQyxXQUFOLEVBQWNSLFVBQUQsR0FBQSxDQUFXRCxLQUFYLENBQUEsR0FBaUJDLHlDQUE5Qk87VUFMRixFQURGVCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFxQmI7UUFTckJTLE9BQVdULE1BQVhVLGVBQVdWLFFBQUFBLEVBQUFBLEVBQUFBLEVBQVhhLGFBQXFCVyxHQUFELEVBQU1wQixRQUExQlM7O1VBQXFCO1VBQUs7VUFDeEJULFFBQVFMLFFBQUFBLENBQUFBO1VBQ1JnQixPQUFBWCxRQUFRVixNQUFBQSxDQUFBQSxFQUZWbUIsQ0FBV2I7TUFYYlMsQ0FBQUE7TUFpQkFoQixPQUFBZ0MsdUJBQUFBLGtDQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBT0MsTUFBUEMsYUFBT0QsbUJBQUFBLEVBQUFBLEVBQUFBLEVBQVBFLGFBQUFBLEVBQUFDO0FBQUFBOztVQUNFQSxPQUFBaEMsbUJBQWVpQyxnQkFBQUEsQ0FBQUEsQ0FEakJGLENBQUFBLEdBQUFBLFNBQUFBLENBQU9GO01BRFRELENBQUFBO0lBbkNGaEMsR0FBQUEsV0FBQUE7RUFERkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4NDEwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaW5lc2l0YS9jb21wb25lbnQvY2xhc3NfbWV0aG9kcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgSW5lc2l0YVxuICBtb2R1bGUgQ29tcG9uZW50XG4gICAgbW9kdWxlIENsYXNzTWV0aG9kc1xuICAgICAgZGVmIG1vdW50X3RvKGVsZW1lbnQpXG4gICAgICAgIG5ldy5tb3VudF90byhlbGVtZW50KVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBpbmplY3QoY2xhenosIG9wdHMgPSB7fSlcbiAgICAgICAgbWV0aG9kX25hbWUgPSBvcHRzWzphc10gfHwgY2xhenoudG9fcy5kb3duY2FzZVxuICAgICAgICBAaW5qZWN0aW9ucyB8fD0ge31cbiAgICAgICAgQGluamVjdGlvbnNbbWV0aG9kX25hbWVdID0gY2xhenpcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgaW5qZWN0aW9uc1xuICAgICAgICBAaW5qZWN0aW9ucyB8fCB7fVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6SW5lc2l0YT4iLCI8bW9kdWxlOkNvbXBvbmVudD4iLCI8bW9kdWxlOkNsYXNzTWV0aG9kcz4iLCJtb3VudF90byIsImVsZW1lbnQiLCJzZWxmIiwibmV3IiwiaW5qZWN0IiwiY2xhenoiLCJvcHRzIiwibWV0aG9kX25hbWUiLCIkcmV0X29yXzEiLCJbXSIsInRvX3MiLCJkb3duY2FzZSIsIkBpbmplY3Rpb25zIiwiW109IiwiaW5qZWN0aW9ucyJdLCJtYXBwaW5ncyI6IkFBQUFBLGtEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUNFQSxPQUFBQztNQUFBQTs7Ozs7QUFDRUMsUUFBQUEsd0JBQUFBLG9CQUFhQyxPQUFiRDtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUUsSUFBQUMsS0FBQUEsQ0FBQUEsQ0FBR0gsVUFBQUEsQ0FBVUMsT0FBVkQ7UUFETEEsQ0FBQUE7O0FBSUFJLFFBQUFBLHNCQUFBQSxrQkFBV0MsS0FBRCxFQUFRQyxJQUFsQkY7QUFBQUEsVUFBQUE7QUFBQUE7OztVQUFrQix5QkFBTyxZQUFBO1VBQ3ZCRyxjQUFjLENBQUEsUUFBQUMsQ0FBQUEsWUFBQUYsSUFBSUcsT0FBQUEsQ0FBQyxJQUFEQSxDQUFKRCxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQUFhSCxLQUFLSyxNQUFBQSxDQUFBQSxDQUFLQyxVQUFBQSxDQUFBQSxDQUF2QixDQUFBO1VBQ2RDLGtCQVRSLENBQUEsUUFBQUosQ0FBQUEsWUFTUUksZUFUUkosQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FTd0IsWUFBQSxFQVR4QixDQUFBO1VBVVFKLE9BQVdTLE1BQUFBLENBQUNOLFdBQVosRUFBMkJGLEtBQWhCUSxDQUFBQSxFQUFBQSxNQUFYRCxlQUFXQyxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtRQUhiVCxDQUFBQSxJQUFBQTtRQU1BTCxPQUFBZSwwQkFBQUEsc0JBQUFBO0FBQUFBLFVBQUFBO0FBQUFBOztVQUNFLElBQUEsUUFBQU4sQ0FBQUEsWUFBQUksZUFBQUosQ0FBQSxDQUFBO1lBQUFNLE9BQUE7VUFBQTtZQUFlQSxPQUFBLFlBQUE7VUFBZjtRQURGQSxDQUFBQTtNQVhGZixHQUFBQSxXQUFBQTtJQURGRCxHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg0NjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmVzaXRhL2NvbXBvbmVudC92aXJ0dWFsX2RvbS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgSW5lc2l0YVxuICBtb2R1bGUgQ29tcG9uZW50XG4gICAgbW9kdWxlIFZpcnR1YWxEb21cbiAgICAgIGRlZiBjb21wb25lbnQoY29tcCwgb3B0cyA9IHt9KVxuICAgICAgICByYWlzZSBFcnJvciwgXCJDb21wb25lbnQgaXMgbmlsIGluICN7c2VsZi5jbGFzc30gY2xhc3NcIiBpZiBjb21wLm5pbD9cbiAgICAgICAgQF9fdmlydHVhbF9ub2Rlc19fIHx8PSBbXVxuICAgICAgICBAX192aXJ0dWFsX25vZGVzX18gPDwgY2FjaGVfY29tcG9uZW50KGNvbXApIGRvXG4gICAgICAgICAgY29tcCA9IChjb21wLmlzX2E/KENsYXNzKSA/IGNvbXAubmV3IDogY29tcClcbiAgICAgICAgICAgIC53aXRoX3Jvb3RfY29tcG9uZW50KEByb290X2NvbXBvbmVudClcbiAgICAgICAgICAgIC5pbmplY3RcbiAgICAgICAgICBjb21wLmluaXRcbiAgICAgICAgICBjb21wXG4gICAgICAgIGVuZC53aXRoX3Byb3BzKG9wdHNbOnByb3BzXSB8fCB7fSkucmVuZGVyX3ZpcnR1YWxfZG9tXG4gICAgICAgIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgaG9vayhtdGhkKVxuICAgICAgICBWaXJ0dWFsRE9NOjpIb29rLm1ldGhvZChtZXRob2QobXRoZCkpXG4gICAgICBlbmRcblxuICAgICAgZGVmIHVuaG9vayhtdGhkKVxuICAgICAgICBWaXJ0dWFsRE9NOjpVbkhvb2subWV0aG9kKG1ldGhvZChtdGhkKSlcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkluZXNpdGE+IiwiPG1vZHVsZTpDb21wb25lbnQ+IiwiPG1vZHVsZTpWaXJ0dWFsRG9tPiIsImNvbXBvbmVudCIsImNvbXAiLCJvcHRzIiwibmlsPyIsInNlbGYiLCJyYWlzZSIsIkVycm9yIiwiY2xhc3MiLCJAX192aXJ0dWFsX25vZGVzX18iLCIkcmV0X29yXzEiLCI8PCIsImNhY2hlX2NvbXBvbmVudCIsImJsb2NrIGluIGNvbXBvbmVudCIsImJsb2NrICgyIGxldmVscykgaW4gY29tcG9uZW50IiwiaXNfYT8iLCJDbGFzcyIsIm5ldyIsIndpdGhfcm9vdF9jb21wb25lbnQiLCJAcm9vdF9jb21wb25lbnQiLCJpbmplY3QiLCJpbml0Iiwid2l0aF9wcm9wcyIsIltdIiwicmVuZGVyX3ZpcnR1YWxfZG9tIiwiaG9vayIsIm10aGQiLCJWaXJ0dWFsRE9NOjpIb29rIiwiVmlydHVhbERPTSIsIm1ldGhvZCIsInVuaG9vayIsIlZpcnR1YWxET006OlVuSG9vayJdLCJtYXBwaW5ncyI6IkFBQUFBLGdEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUNFQSxPQUFBQztNQUFBQTs7UUFBQUE7Ozs7QUFDRUMsUUFBQUEseUJBQUFBLHFCQUFjQyxJQUFELEVBQU9DLElBQXBCRjtBQUFBQSxVQUFBQTtBQUFBQTs7O1VBQW9CLHlCQUFPLFlBQUE7VUFDekIsSUFBQSxRQUEwREMsSUFBSUUsU0FBQUEsQ0FBQUEsQ0FBOUQsQ0FBQTtZQUFBQyxJQUFBQyxPQUFBQSxDQUFNQyxXQUFOLEVBQWNOLHNCQUFELEdBQUEsQ0FBdUJJLElBQUlHLE9BQUFBLENBQUFBLENBQTNCLENBQUEsR0FBa0NQLFFBQS9DSztVQUFBO1VBQ0FHLHlCQUxSLENBQUEsUUFBQUMsQ0FBQUEsWUFLUUQsc0JBTFJDLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBSytCLEVBTC9CLENBQUE7VUFNUUQsc0JBQW1CRSxPQUFBQSxDQUFHQyxNQUFBUCxJQUFBTyxtQkFBQUEsRUFBQUEsQ0FBZ0JWLElBQWhCVSxDQUFBQSxFQUFBQyxhQUFBQSxFQUFBQztBQUFBQTs7O1lBQ3BCWixPQUFRLENBQUEsUUFBQUEsSUFBSWEsVUFBQUEsQ0FBT0MsV0FBUEQsQ0FBSixDQUFBLEdBQUEsQ0FBb0JiLElBQUllLEtBQUFBLENBQUFBLENBQXhCLElBQUEsQ0FBK0JmLElBQS9CLENBQUEsQ0FDTmdCLHFCQUFBQSxDQUFxQkMsbUJBQXJCRCxDQUNBRSxRQUFBQSxDQUFBQTtZQUNGbEIsSUFBSW1CLE1BQUFBLENBQUFBO1lBQ0pQLE9BQUFaLEtBTG9CVyxDQUFBQSxHQUFBQSxTQUFBQSxDQUFBRCxDQU1uQlUsWUFBQUEsQ0FBWSxDQUFBLFFBQUFaLENBQUFBLFlBQUFQLElBQUlvQixPQUFBQSxDQUFDLE9BQURBLENBQUpiLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQWdCLFlBQUEsRUFBaEIsQ0FBQSxDQUFaWSxDQUErQkUsb0JBQUFBLENBQUFBLENBTmZiO1VBT25CVixPQUFBSTtRQVZGSixDQUFBQSxJQUFBQTs7QUFhQXdCLFFBQUFBLG9CQUFBQSxnQkFBU0MsSUFBVEQ7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFFLElBQUFDLGdCQUFBRCxTQUFnQkUsUUFBQUEsQ0FBUXhCLElBQUF3QixRQUFBQSxDQUFPSCxJQUFQRyxDQUFSQTtRQURsQkosQ0FBQUE7UUFJQXpCLE9BQUE4QixzQkFBQUEsa0JBQVdKLElBQVhJO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBQyxJQUFBSCxnQkFBQUcsV0FBa0JGLFFBQUFBLENBQVF4QixJQUFBd0IsUUFBQUEsQ0FBT0gsSUFBUEcsQ0FBUkE7UUFEcEJDLENBQUFBO01BbEJGOUIsR0FBQUEsV0FBQUE7SUFERkQsR0FBQUEsV0FBQUE7RUFERkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4NTE3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaW5lc2l0YS9jb21wb25lbnQvcmVuZGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBJbmVzaXRhXG4gIG1vZHVsZSBDb21wb25lbnRcbiAgICBtb2R1bGUgUmVuZGVyXG4gICAgICBkZWYgcmVuZGVyXG4gICAgICAgIHJhaXNlIEVycm9yLCBcIkltcGxlbWVudCAjcmVuZGVyIGluICN7c2VsZi5jbGFzc30gY29tcG9uZW50XCJcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgcmVuZGVyX2lmX3Jvb3RcbiAgICAgICAgcmV0dXJuIHVubGVzcyBAdmlydHVhbF9kb20gJiYgQHJvb3Rfbm9kZVxuICAgICAgICBuZXdfdmlydHVhbF9kb20gPSByZW5kZXJfdmlydHVhbF9kb21cbiAgICAgICAgZGlmZiA9IFZpcnR1YWxET00uZGlmZihAdmlydHVhbF9kb20sIG5ld192aXJ0dWFsX2RvbSlcbiAgICAgICAgVmlydHVhbERPTS5wYXRjaChAcm9vdF9ub2RlLCBkaWZmKVxuICAgICAgICBAdmlydHVhbF9kb20gPSBuZXdfdmlydHVhbF9kb21cbiAgICAgIGVuZFxuXG4gICAgICBkZWYgYmVmb3JlX3JlbmRlcjsgZW5kO1xuXG4gICAgICBkZWYgcmVuZGVyX3ZpcnR1YWxfZG9tXG4gICAgICAgIGJlZm9yZV9yZW5kZXJcbiAgICAgICAgQGNhY2hlX2NvbXBvbmVudF9jb3VudGVyID0gMFxuICAgICAgICBAX192aXJ0dWFsX25vZGVzX18gPSBbXVxuICAgICAgICByZW5kZXJcbiAgICAgICAgdG9fdm5vZGVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkluZXNpdGE+IiwiPG1vZHVsZTpDb21wb25lbnQ+IiwiPG1vZHVsZTpSZW5kZXI+IiwicmVuZGVyIiwic2VsZiIsInJhaXNlIiwiRXJyb3IiLCJjbGFzcyIsInJlbmRlcl9pZl9yb290IiwiQHZpcnR1YWxfZG9tIiwiQHJvb3Rfbm9kZSIsIm5ld192aXJ0dWFsX2RvbSIsInJlbmRlcl92aXJ0dWFsX2RvbSIsImRpZmYiLCJWaXJ0dWFsRE9NIiwicGF0Y2giLCJiZWZvcmVfcmVuZGVyIiwiQGNhY2hlX2NvbXBvbmVudF9jb3VudGVyIiwiMCIsIkBfX3ZpcnR1YWxfbm9kZXNfXyIsInRvX3Zub2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQ0VBLE9BQUFDO01BQUFBOztRQUFBQTs7OztBQUNFQyxRQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBQyxJQUFBQyxPQUFBQSxDQUFNQyxXQUFOLEVBQWNILHVCQUFELEdBQUEsQ0FBd0JDLElBQUlHLE9BQUFBLENBQUFBLENBQTVCLENBQUEsR0FBbUNKLFlBQWhERTtRQURGRixDQUFBQTs7QUFJQUssUUFBQUEsOEJBQUFBLDBCQUFBQTtBQUFBQSxVQUFBQTtBQUFBQTtBQUFBQTs7O1VBQ0UsS0FBYyxDQUFBLFFBQUFDLGdCQUFBLENBQUEsSUFBQSxDQUFBLFFBQWdCQyxjQUFoQixDQUFBLENBQUEsQ0FBZDtZQUFBLE9BQUE7VUFBQTtVQUNBQyxrQkFBa0JQLElBQUFRLG9CQUFBQSxDQUFBQTtVQUNsQkMsT0FBT0MsZ0JBQVVELE1BQUFBLENBQU1KLGdCQUFoQixFQUE4QkUsZUFBcEJFO1VBQ2pCQyxnQkFBVUMsT0FBQUEsQ0FBT0wsY0FBakIsRUFBNkJHLElBQW5CRTtVQUNWUCxPQUFBQyxDQUFBQSxtQkFBZUUsZUFBZkY7UUFMRkQsQ0FBQUE7O0FBUUFRLFFBQUFBLDZCQUFBQSxZQWZOLEdBZU1BLENBQUFBO1FBRUFkLE9BQUFVLGtDQUFBQSw4QkFBQUE7QUFBQUEsVUFBQUE7OztVQUNFUixJQUFBWSxlQUFBQSxDQUFBQTtVQUNBQywrQkFBMkJDO1VBQzNCQyx5QkFBcUI7VUFDckJmLElBQUFELFFBQUFBLENBQUFBO1VBQ0FTLE9BQUFSLElBQUFnQixVQUFBQSxDQUFBQTtRQUxGUixDQUFBQTtNQWZGVixHQUFBQSxXQUFBQTtJQURGRCxHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg1NzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmVzaXRhL2NvbXBvbmVudC9jYWNoZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgSW5lc2l0YVxuICBtb2R1bGUgQ29tcG9uZW50XG4gICAgbW9kdWxlIENhY2hlXG4gICAgICBkZWYgY2FjaGVfY29tcG9uZW50KGNvbXBvbmVudCwgJmJsb2NrKVxuICAgICAgICBAY2FjaGVfY29tcG9uZW50IHx8PSB7fVxuICAgICAgICBAY2FjaGVfY29tcG9uZW50X2NvdW50ZXIgfHw9IDBcbiAgICAgICAgQGNhY2hlX2NvbXBvbmVudF9jb3VudGVyICs9IDFcbiAgICAgICAgQGNhY2hlX2NvbXBvbmVudFtcIiN7Y29tcG9uZW50fS0je0BjYWNoZV9jb21wb25lbnRfY291bnRlcn1cIl0gfHwgQGNhY2hlX2NvbXBvbmVudFtcIiN7Y29tcG9uZW50fS0je0BjYWNoZV9jb21wb25lbnRfY291bnRlcn1cIl0gPSBibG9jay5jYWxsXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpJbmVzaXRhPiIsIjxtb2R1bGU6Q29tcG9uZW50PiIsIjxtb2R1bGU6Q2FjaGU+IiwiY2FjaGVfY29tcG9uZW50IiwiY29tcG9uZW50IiwiQGNhY2hlX2NvbXBvbmVudCIsIiRyZXRfb3JfMSIsIkBjYWNoZV9jb21wb25lbnRfY291bnRlciIsIjAiLCIrIiwiMSIsIltdIiwiW109IiwiYmxvY2siLCJjYWxsIl0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQ0VBLE9BQUFDO01BQUFBOzs7UUFDRUEsT0FBQUMsK0JBQUFBLDJCQUFvQkMsU0FBcEJEO0FBQUFBLFVBQUFBO0FBQUFBO0FBQUFBOztVQUFBQTs7O1VBQ0VFLHVCQUpSLENBQUEsUUFBQUMsQ0FBQUEsWUFJUUQsb0JBSlJDLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBSTZCLFlBQUEsRUFKN0IsQ0FBQTtVQUtRQywrQkFMUixDQUFBLFFBQUFELENBQUFBLFlBS1FDLDRCQUxSRCxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQUtxQ0UsQ0FMckMsQ0FBQTtVQU1RRCwrQkFBeUJFLFNBQXpCRiw0QkFBeUJFLEVBQUdDLENBQUhEO1VBQ3pCLElBQUEsUUFBQUgsQ0FBQUEsWUFBQUQsb0JBQWdCTSxPQUFBQSxDQUFDLEVBQUEsR0FBQSxDQUFHUCxTQUFILENBQUEsR0FBYUQsR0FBYixHQUFBLENBQWdCSSw0QkFBaEIsQ0FBREksQ0FBaEJMLENBQUEsQ0FBQTtZQUFBSCxPQUFBO1VBQUE7WUFBZ0VBLE9BQWdCUyxNQUFBQSxDQUFDLEVBQUEsR0FBQSxDQUFHUixTQUFILENBQUEsR0FBYUQsR0FBYixHQUFBLENBQWdCSSw0QkFBaEIsQ0FBakIsRUFBK0RNLEtBQUtDLE1BQUFBLENBQUFBLENBQXBERixDQUFBQSxFQUFBQSxNQUFoQlAsb0JBQWdCTyxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtVQUFoRjtRQUpGVCxDQUFBQTtNQURGRCxHQUFBQSxXQUFBQTtJQURGRCxHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg2MTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmVzaXRhL2NvbXBvbmVudC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgSW5lc2l0YVxuICBtb2R1bGUgQ29tcG9uZW50XG4gICAgaW5jbHVkZSBWaXJ0dWFsRE9NOjpET01cbiAgICBpbmNsdWRlIFZpcnR1YWxEb21cbiAgICBpbmNsdWRlIFJlbmRlclxuICAgIGluY2x1ZGUgQ2FjaGVcbiAgICBpbmNsdWRlIEluamVjdGlvblxuXG4gICAgZGVmIHNlbGYuaW5jbHVkZWQoYmFzZSlcbiAgICAgIGJhc2UuZXh0ZW5kIEluZXNpdGE6OkNvbXBvbmVudDo6Q2xhc3NNZXRob2RzXG4gICAgZW5kXG5cbiAgICBkZWYgbW91bnRfdG8oZWxlbWVudClcbiAgICAgIHJhaXNlIEVycm9yLCBcIkNhbid0IG1vdW50ICN7c2VsZi5jbGFzc30sIHRhcmdldCBlbGVtZW50IG5vdCBmb3VuZCFcIiB1bmxlc3MgZWxlbWVudFxuICAgICAgQHJvb3RfY29tcG9uZW50ID0gc2VsZlxuICAgICAgaW5pdF9pbmplY3Rpb25zXG4gICAgICBpbmplY3RcbiAgICAgIEB2aXJ0dWFsX2RvbSA9IHJlbmRlcl92aXJ0dWFsX2RvbVxuICAgICAgQHJvb3Rfbm9kZSA9IFZpcnR1YWxET00uY3JlYXRlKEB2aXJ0dWFsX2RvbSlcbiAgICAgIEJyb3dzZXIuYXBwZW5kX2NoaWxkKGVsZW1lbnQsIEByb290X25vZGUpXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBhdHRyX3JlYWRlciA6cHJvcHNcbiAgICBkZWYgd2l0aF9wcm9wcyhwcm9wcylcbiAgICAgIEBwcm9wcyA9IHByb3BzXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6SW5lc2l0YT4iLCI8bW9kdWxlOkNvbXBvbmVudD4iLCJzZWxmIiwiaW5jbHVkZSIsIlZpcnR1YWxET006OkRPTSIsIlZpcnR1YWxET00iLCJWaXJ0dWFsRG9tIiwiUmVuZGVyIiwiQ2FjaGUiLCJJbmplY3Rpb24iLCJpbmNsdWRlZCIsImJhc2UiLCJleHRlbmQiLCJJbmVzaXRhOjpDb21wb25lbnQ6OkNsYXNzTWV0aG9kcyIsIkluZXNpdGE6OkNvbXBvbmVudCIsIkluZXNpdGEiLCJtb3VudF90byIsImVsZW1lbnQiLCJyYWlzZSIsIkVycm9yIiwiY2xhc3MiLCJAcm9vdF9jb21wb25lbnQiLCJpbml0X2luamVjdGlvbnMiLCJpbmplY3QiLCJAdmlydHVhbF9kb20iLCJyZW5kZXJfdmlydHVhbF9kb20iLCJAcm9vdF9ub2RlIiwiY3JlYXRlIiwiQnJvd3NlciIsImFwcGVuZF9jaGlsZCIsImF0dHJfcmVhZGVyIiwid2l0aF9wcm9wcyIsInByb3BzIiwiQHByb3BzIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7OztNQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxnQkFBQUQsUUFBUkQ7TUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUcsZ0JBQVJIO01BQ0FELElBQUFDLFNBQUFBLENBQVFJLFlBQVJKO01BQ0FELElBQUFDLFNBQUFBLENBQVFLLFdBQVJMO01BQ0FELElBQUFDLFNBQUFBLENBQVFNLGVBQVJOO01BRUFPLE1BQUlSLElBQUpRLGVBQUFBLG9CQUFrQkMsSUFBbEJEO0FBQUFBO1FBQ0VBLE9BQUFDLElBQUlDLFFBQUFBLENBQVFDLElBQUFDLElBQUFDLGFBQUFELGNBQUFELGlCQUFSRDtNQURORixDQUFBQTs7QUFJQU0sTUFBQUEsd0JBQUFBLG9CQUFhQyxPQUFiRDtBQUFBQSxRQUFBQTtBQUFBQTtBQUFBQTs7O1FBQ0UsS0FBQSxRQUEyRUMsT0FBM0UsQ0FBQTtVQUFBZixJQUFBZ0IsT0FBQUEsQ0FBTUMsV0FBTixFQUFjSCxjQUFELEdBQUEsQ0FBZWQsSUFBSWtCLE9BQUFBLENBQUFBLENBQW5CLENBQUEsR0FBMEJKLDZCQUF2Q0U7UUFBQTtRQUNBRyxzQkFBa0JuQjtRQUNsQkEsSUFBQW9CLGlCQUFBQSxDQUFBQTtRQUNBcEIsSUFBQXFCLFFBQUFBLENBQUFBO1FBQ0FDLG1CQUFldEIsSUFBQXVCLG9CQUFBQSxDQUFBQTtRQUNmQyxpQkFBYXJCLGdCQUFVc0IsUUFBQUEsQ0FBUUgsZ0JBQVJHO1FBQ3ZCQyxhQUFPQyxjQUFBQSxDQUFjWixPQUFyQixFQUE4QlMsY0FBdkJHO1FBQ1BiLE9BQUFkO01BUkZjLENBQUFBO01BV0FkLElBQUE0QixhQUFBQSxDQUFZLE9BQVpBO01BQ0E3QixPQUFBOEIsMEJBQUFBLHNCQUFlQyxLQUFmRDtBQUFBQSxRQUFBQTs7O1FBQ0VFLGFBQVNEO1FBQ1RELE9BQUE3QjtNQUZGNkIsQ0FBQUE7SUF2QkY5QixHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg2NjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2luZXNpdGEucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnb3BhbCdcbnJlcXVpcmUgJ2pzJ1xucmVxdWlyZSAnY29uc29sZSdcblxucmVxdWlyZSAndmlydHVhbF9kb20nXG5cbnJlcXVpcmUgJ2luZXNpdGEvYnJvd3NlcidcbnJlcXVpcmUgJ2luZXNpdGEvZXJyb3InXG5yZXF1aXJlICdpbmVzaXRhL2luamVjdGlvbidcbnJlcXVpcmUgJ2luZXNpdGEvY29tcG9uZW50L2NsYXNzX21ldGhvZHMnXG5yZXF1aXJlICdpbmVzaXRhL2NvbXBvbmVudC92aXJ0dWFsX2RvbSdcbnJlcXVpcmUgJ2luZXNpdGEvY29tcG9uZW50L3JlbmRlcidcbnJlcXVpcmUgJ2luZXNpdGEvY29tcG9uZW50L2NhY2hlJ1xucmVxdWlyZSAnaW5lc2l0YS9jb21wb25lbnQnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsMEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLE1BQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLElBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLFNBQVJFO0VBRUFELElBQUFDLFNBQUFBLENBQVFGLGFBQVJFO0VBRUFELElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixlQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixtQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUNBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLCtCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiwwQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYseUJBQVJFO0VBQ0FGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLG1CQUFSRTtBQWJBRjsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg2ODgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmVzaXRhLXJvdXRlci9icm93c2VyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBJbmVzaXRhXG4gIG1vZHVsZSBCcm93c2VyXG4gICAgbW9kdWxlX2Z1bmN0aW9uXG5cbiAgICBMb2NhdGlvbiA9IERvY3VtZW50LkpTWzpsb2NhdGlvbl1cbiAgICBIaXN0b3J5ID0gV2luZG93LkpTWzpoaXN0b3J5XVxuXG4gICAgZGVmIHBhdGhcbiAgICAgIExvY2F0aW9uLkpTWzpwYXRobmFtZV1cbiAgICBlbmRcblxuICAgIGRlZiBxdWVyeVxuICAgICAgTG9jYXRpb24uSlNbOnNlYXJjaF1cbiAgICBlbmRcblxuICAgIGRlZiBkZWNvZGVfdXJpX2NvbXBvbmVudCh2YWx1ZSlcbiAgICAgIEpTLmRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIGRlZiBwdXNoX3N0YXRlKHBhdGgpXG4gICAgICBIaXN0b3J5LkpTLnB1c2hTdGF0ZSh7fSwgbmlsLCBwYXRoKVxuICAgIGVuZFxuXG4gICAgZGVmIG9uX3BvcF9zdGF0ZSgmYmxvY2spXG4gICAgICBXaW5kb3cuSlNbOm9ucG9wc3RhdGVdID0gYmxvY2tcbiAgICBlbmRcblxuICAgIGRlZiBoYXNoX2NoYW5nZSgmYmxvY2spXG4gICAgICBBZGRFdmVudExpc3RlbmVyLmNhbGwoOmhhc2hjaGFuZ2UsIGJsb2NrKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkluZXNpdGE+IiwiPG1vZHVsZTpCcm93c2VyPiIsInNlbGYiLCJtb2R1bGVfZnVuY3Rpb24iLCJEb2N1bWVudCIsIldpbmRvdyIsInBhdGgiLCJMb2NhdGlvbiIsInF1ZXJ5IiwiZGVjb2RlX3VyaV9jb21wb25lbnQiLCJ2YWx1ZSIsIkpTIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicHVzaF9zdGF0ZSIsIkhpc3RvcnkiLCJvbl9wb3Bfc3RhdGUiLCJibG9jayIsImhhc2hfY2hhbmdlIiwiQWRkRXZlbnRMaXN0ZW5lciIsImNhbGwiXSwibWFwcGluZ3MiOiJBQUFBQSx5Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7O01BQ0VDLElBQUFDLGlCQUFBQSxDQUFBQTtNQUVBLG9DQUFXQyxjQUFBLENBQVksVUFBWixDQUFYO01BQ0EsbUNBQVVDLFlBQUEsQ0FBVSxTQUFWLENBQVY7O0FBRUFDLE1BQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7UUFDRUEsT0FBQUMsY0FBQSxDQUFZLFVBQVo7TUFERkQsQ0FBQUE7O0FBSUFFLE1BQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUE7UUFDRUEsT0FBQUQsY0FBQSxDQUFZLFFBQVo7TUFERkMsQ0FBQUE7O0FBSUFDLE1BQUFBLG9DQUFBQSxnQ0FBeUJDLEtBQXpCRDtBQUFBQTtRQUNFQSxPQUFBRSxRQUFFQyxvQkFBQUEsQ0FBb0JGLEtBQXBCRTtNQURKSCxDQUFBQTs7QUFJQUksTUFBQUEsMEJBQUFBLHNCQUFlUCxJQUFmTztBQUFBQTtRQUNFQSxPQUFBQyxhQUFBLFVBQUEsQ0FBcUIsWUFBQSxFQUFyQixFQUF5QixHQUF6QixFQUE4QlIsSUFBOUI7TUFERk8sQ0FBQUE7O0FBSUFFLE1BQUFBLDRCQUFBQSx3QkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFDRUEsT0FBQVYsWUFBQSxDQUFVLFlBQVYsSUFBeUJXO01BRDNCRCxDQUFBQTtNQUlBZCxPQUFBZ0IsMkJBQUFBLHVCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNFQSxPQUFBQyxzQkFBZ0JDLE1BQUFBLENBQU0sWUFBdEIsRUFBbUNILEtBQW5CRztNQURsQkYsQ0FBQUE7SUExQkZoQixHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg3NDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmVzaXRhLXJvdXRlci9yb3V0ZXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEluZXNpdGFcbiAgY2xhc3MgUm91dGVzXG4gICAgYXR0cl9yZWFkZXIgOnJvdXRlc1xuXG4gICAgZGVmIGluaXRpYWxpemUocGFyZW50ID0gbmlsKVxuICAgICAgQHBhcmVudCA9IHBhcmVudFxuICAgICAgQHJvdXRlcyA9IFtdXG4gICAgZW5kXG5cbiAgICBkZWYgcm91dGUoKnBhcmFtcywgJmJsb2NrKVxuICAgICAgcGF0aCA9IHBhcmFtcy5maXJzdC5nc3ViKC9eXFwvLywgJycpXG4gICAgICBwYXRoID0gQHBhcmVudCA/IFwiI3tAcGFyZW50fS8je3BhdGh9XCIgOiBcIi8je3BhdGh9XCJcblxuICAgICAgYWRkX3N1YnJvdXRlcyhwYXRoLCAmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgICBpZiBwYXJhbXMubGFzdFs6cmVkaXJlY3RfdG9dXG4gICAgICAgIGFkZF9yZWRpcmVjdChwYXRoLCBwYXJhbXMubGFzdFs6cmVkaXJlY3RfdG9dKVxuICAgICAgZWxzZVxuICAgICAgICBhZGRfcm91dGUocGFyYW1zLmxhc3RbOmFzXSwgcGF0aCwgcGFyYW1zLmxhc3RbOnRvXSwgcGFyYW1zLmxhc3RbOnByb3BzXSwgcGFyYW1zLmxhc3RbOm9uX2VudGVyXSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQpXG4gICAgICByYWlzZSBFcnJvciwgJ0NvbXBvbmVudCBub3QgZXhpc3RzJyB1bmxlc3MgY29tcG9uZW50XG4gICAgICByYWlzZSBFcnJvciwgXCJJbnZhbGlkICN7Y29tcG9uZW50fSBjbGFzcywgc2hvdWxkIG1peGluIEluZXNpdGE6OkNvbXBvbmVudFwiIHVubGVzcyBjb21wb25lbnQuaW5jbHVkZT8oSW5lc2l0YTo6Q29tcG9uZW50KVxuICAgIGVuZFxuXG4gICAgZGVmIGFkZF9yZWRpcmVjdChwYXRoLCByZWRpcmVjdF90bylcbiAgICAgIEByb3V0ZXMgPDwge1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICByZWRpcmVjdF90bzogcmVkaXJlY3RfdG9cbiAgICAgIH0ubWVyZ2UoYnVpbGRfcGFyYW1zX2FuZF9yZWdleChwYXRoKSlcbiAgICBlbmRcblxuICAgIGRlZiBhZGRfcm91dGUobmFtZSwgcGF0aCwgY29tcG9uZW50LCBjb21wb25lbnRfcHJvcHMsIG9uX2VudGVyKVxuICAgICAgdmFsaWRhdGVfY29tcG9uZW50KGNvbXBvbmVudClcbiAgICAgIEByb3V0ZXMgPDwge1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgY29tcG9uZW50X3Byb3BzOiBjb21wb25lbnRfcHJvcHMsXG4gICAgICAgIG9uX2VudGVyOiBvbl9lbnRlcixcbiAgICAgICAgbmFtZTogbmFtZSB8fCBjb21wb25lbnQudG9fcy5nc3ViKC8oLikoW0EtWl0pLywgJ1xcMV9cXDInKS5kb3duY2FzZVxuICAgICAgfS5tZXJnZShidWlsZF9wYXJhbXNfYW5kX3JlZ2V4KHBhdGgpKVxuICAgIGVuZFxuXG4gICAgZGVmIGFkZF9zdWJyb3V0ZXMocGF0aCwgJmJsb2NrKVxuICAgICAgc3Vicm91dGVzID0gUm91dGVzLm5ldyhwYXRoKVxuICAgICAgc3Vicm91dGVzLmluc3RhbmNlX2V4ZWMoJmJsb2NrKVxuICAgICAgQHJvdXRlcyArPSBzdWJyb3V0ZXMucm91dGVzXG4gICAgZW5kXG5cbiAgICBkZWYgYnVpbGRfcGFyYW1zX2FuZF9yZWdleChwYXRoKVxuICAgICAgcmVnZXggPSBbJ14nXVxuICAgICAgcGFyYW1zID0gW11cbiAgICAgIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpXG4gICAgICByZWdleCA8PCAnXFwvJyBpZiBwYXJ0cy5lbXB0eT9cbiAgICAgIHBhcnRzLmVhY2ggZG8gfHBhcnR8XG4gICAgICAgIG5leHQgaWYgcGFydC5lbXB0eT9cbiAgICAgICAgcmVnZXggPDwgJ1xcLydcbiAgICAgICAgY2FzZSBwYXJ0WzBdXG4gICAgICAgIHdoZW4gJzonXG4gICAgICAgICAgcGFyYW1zIDw8IHBhcnRbMS4uLTFdXG4gICAgICAgICAgcmVnZXggPDwgJyhbXlxcL10rKSdcbiAgICAgICAgd2hlbiAnKidcbiAgICAgICAgICBwYXJhbXMgPDwgcGFydFsxLi4tMV1cbiAgICAgICAgICByZWdleCA8PCAnKC4qKSdcbiAgICAgICAgICBicmVha1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVnZXggPDwgcGFydFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcmVnZXggPDwgJyQnXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiBSZWdleHAubmV3KHJlZ2V4LmpvaW4pLFxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkluZXNpdGE+IiwiPGNsYXNzOlJvdXRlcz4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwicGFyZW50IiwiQHBhcmVudCIsIkByb3V0ZXMiLCJyb3V0ZSIsInBhdGgiLCJwYXJhbXMiLCJmaXJzdCIsImdzdWIiLCJibG9ja19naXZlbj8iLCJhZGRfc3Vicm91dGVzIiwiYmxvY2siLCJ0b19wcm9jIiwibGFzdCIsIltdIiwiYWRkX3JlZGlyZWN0IiwiYWRkX3JvdXRlIiwidmFsaWRhdGVfY29tcG9uZW50IiwiY29tcG9uZW50IiwicmFpc2UiLCJFcnJvciIsImluY2x1ZGU/IiwiSW5lc2l0YTo6Q29tcG9uZW50IiwiSW5lc2l0YSIsInJlZGlyZWN0X3RvIiwiPDwiLCJtZXJnZSIsImJ1aWxkX3BhcmFtc19hbmRfcmVnZXgiLCJuYW1lIiwiY29tcG9uZW50X3Byb3BzIiwib25fZW50ZXIiLCIkcmV0X29yXzEiLCJ0b19zIiwiZG93bmNhc2UiLCJzdWJyb3V0ZXMiLCJSb3V0ZXMiLCJuZXciLCJpbnN0YW5jZV9leGVjIiwiKyIsInJvdXRlcyIsInJlZ2V4IiwicGFydHMiLCJzcGxpdCIsImVtcHR5PyIsImVhY2giLCJibG9jayBpbiBidWlsZF9wYXJhbXNfYW5kX3JlZ2V4IiwicGFydCIsImJsb2NrICgyIGxldmVscykgaW4gYnVpbGRfcGFyYW1zX2FuZF9yZWdleCIsIjAiLCIxIiwiLTEiLCJSZWdleHAiLCJqb2luIl0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxJQUFBQyxhQUFBQSxDQUFZLFFBQVpBOztBQUVBQyxNQUFBQSwwQkFBQUEsc0JBQWVDLE1BQWZEO0FBQUFBLFFBQUFBOzs7UUFBZSw2QkFBUztRQUN0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c0IsV0FBSHRCO1VBRlIsT0FHQSxJQUFBLFFBQUtzQixHQUFMLEVBL0RSLFNBK0RRLENBQUE7O1lBQ0V6QyxNQUFPbUIsT0FBQUEsQ0FBR3FCLElBQUloQyxPQUFBQSxDQUFDLE9BQUFtQyxDQUFBLEVBQUdDLEVBQUgsUUFBRHBDLENBQVBXO1lBQ1BlLEtBQU1mLE9BQUFBLENBQUdzQixNQUFIdEI7WUFDTixRQUFBLFFBQUE7VUFIRjtZQUtFc0IsT0FBQVAsS0FBTWYsT0FBQUEsQ0FBR3FCLElBQUhyQjtVQUxSLEVBUEZvQixDQUFLRCxDQUFBQTtVQUFBQTtVQUFBQTtRQUFBQSxDQUFBQTtRQWVMSixLQUFNZixPQUFBQSxDQUFHRSxHQUFIRjtRQUNORSxPQUFBLDZCQUFBLFNBQ1N3QixZQUFNZixLQUFBQSxDQUFLSSxLQUFLWSxNQUFBQSxDQUFBQSxDQUFWaEIsQ0FEZixFQUFBLFVBRVU5QixNQUZWO01BckJGcUIsQ0FBQUE7SUFsREY5QixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg4NzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmVzaXRhLXJvdXRlci9yb3V0ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEluZXNpdGFcbiAgbW9kdWxlIFJvdXRlclxuICAgIGluY2x1ZGUgSW5lc2l0YTo6Q29tcG9uZW50XG5cbiAgICBhdHRyX3JlYWRlciA6cGFyYW1zXG5cbiAgICBkZWYgaW5pdGlhbGl6ZVxuICAgICAgQHJvdXRlcyA9IFJvdXRlcy5uZXdcbiAgICAgIHJhaXNlIEVycm9yLCAnQWRkICNyb3V0ZXMgbWV0aG9kIHRvIHJvdXRlciEnIHVubGVzcyByZXNwb25kX3RvPyg6cm91dGVzKVxuICAgICAgcm91dGVzXG4gICAgICByYWlzZSBFcnJvciwgJ0FkZCAjcm91dGUgdG8geW91ciAjcm91dGVzIG1ldGhvZCEnIGlmIEByb3V0ZXMucm91dGVzLmVtcHR5P1xuICAgICAgZmluZF9yb3V0ZVxuICAgICAgcGFyc2VfdXJsX3BhcmFtc1xuICAgICAgYWRkX2xpc3RlbmVyc1xuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuaW5jbHVkZWQoYmFzZSlcbiAgICAgIGJhc2UuZXh0ZW5kKEluZXNpdGE6OkNvbXBvbmVudDo6Q2xhc3NNZXRob2RzKVxuICAgICAgQ29tcG9uZW50Lm1vZHVsZV9ldmFsIGRvXG4gICAgICAgIHVubGVzcyByZXNwb25kX3RvPyg6X19hKVxuICAgICAgICAgIGFsaWFzX21ldGhvZCA6X19hLCA6YVxuICAgICAgICAgIGRlZmluZV9tZXRob2QoOmEpIGRvIHxwYXJhbXMgPSB7fSwgJmJsb2NrfFxuICAgICAgICAgICAgcGFyYW1zID0geyBvbmNsaWNrOiAtPihlKSB7IHJvdXRlci5nb190byhlLnRhcmdldC5wYXRobmFtZSkgdW5sZXNzIHBhcmFtc1s6dGFyZ2V0XSA9PSBcIl9ibGFua1wiIH0gfS5tZXJnZShwYXJhbXMpXG4gICAgICAgICAgICBfX2EocGFyYW1zLCAmYmxvY2spXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgYWRkX2xpc3RlbmVyc1xuICAgICAgQnJvd3Nlci5vbl9wb3Bfc3RhdGUgeyBmaW5kX3JvdXRlOyBwYXJzZV91cmxfcGFyYW1zOyByZW5kZXIhIH1cbiAgICAgIEJyb3dzZXIuaGFzaF9jaGFuZ2UgeyBmaW5kX3JvdXRlOyBwYXJzZV91cmxfcGFyYW1zOyByZW5kZXIhIH1cbiAgICBlbmRcblxuICAgIGRlZiByb3V0ZSgqcGFyYW1zLCAmYmxvY2spXG4gICAgICBAcm91dGVzLnJvdXRlKCpwYXJhbXMsICZibG9jaylcbiAgICBlbmRcblxuICAgIGRlZiBmaW5kX3JvdXRlXG4gICAgICBAcm91dGVzLnJvdXRlcy5lYWNoIGRvIHxyb3V0ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgcGF0aC5tYXRjaChyb3V0ZVs6cmVnZXhdKVxuICAgICAgICByZXR1cm4gZ29fdG8odXJsX2Zvcihyb3V0ZVs6cmVkaXJlY3RfdG9dKSkgaWYgcm91dGVbOnJlZGlyZWN0X3RvXVxuICAgICAgICByZXR1cm4gQHJvdXRlID0gcm91dGVcbiAgICAgIGVuZFxuICAgICAgcmFpc2UgRXJyb3IsIFwiQ2FuJ3QgZmluZCByb3V0ZSBmb3IgdXJsXCJcbiAgICBlbmRcblxuICAgIGRlZiBmaW5kX2NvbXBvbmVudChyb3V0ZSlcbiAgICAgIGNhbGxfb25fZW50ZXJfY2FsbGJhY2socm91dGUpXG4gICAgICBAY29tcG9uZW50X3Byb3BzID0gcm91dGVbOmNvbXBvbmVudF9wcm9wc11cbiAgICAgIHJvdXRlWzpjb21wb25lbnRdXG4gICAgZW5kXG5cbiAgICBkZWYgcmVuZGVyXG4gICAgICBjb21wb25lbnQgZmluZF9jb21wb25lbnQoQHJvdXRlKSwgcHJvcHM6IEBjb21wb25lbnRfcHJvcHMgaWYgQHJvdXRlXG4gICAgZW5kXG5cbiAgICBkZWYgY2FsbF9vbl9lbnRlcl9jYWxsYmFjayhyb3V0ZSlcbiAgICAgIHJldHVybiB1bmxlc3Mgcm91dGVbOm9uX2VudGVyXVxuICAgICAgaWYgcm91dGVbOm9uX2VudGVyXS5yZXNwb25kX3RvPyg6Y2FsbClcbiAgICAgICAgcm91dGVbOm9uX2VudGVyXS5jYWxsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBnb190byhwYXRoKVxuICAgICAgQnJvd3Nlci5wdXNoX3N0YXRlKHBhdGgpXG4gICAgICBmaW5kX3JvdXRlXG4gICAgICBwYXJzZV91cmxfcGFyYW1zXG4gICAgICByZW5kZXIhXG4gICAgICBmYWxzZVxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlX3VybF9wYXJhbXNcbiAgICAgIEBwYXJhbXMgPSBjb21wb3RlbnRfdXJsX3BhcmFtc1xuICAgICAgcXVlcnlbMS4uLTFdLnNwbGl0KCcmJykuZWFjaCBkbyB8cGFyYW18XG4gICAgICAgIGtleSwgdmFsdWUgPSBwYXJhbS5zcGxpdCgnPScpXG4gICAgICAgIEBwYXJhbXNbQnJvd3Nlci5kZWNvZGVfdXJpX2NvbXBvbmVudChrZXkpXSA9IEJyb3dzZXIuZGVjb2RlX3VyaV9jb21wb25lbnQodmFsdWUpXG4gICAgICBlbmQgdW5sZXNzIHF1ZXJ5LmVtcHR5P1xuICAgIGVuZFxuXG4gICAgZGVmIGNvbXBvdGVudF91cmxfcGFyYW1zXG4gICAgICBIYXNoW0Byb3V0ZVs6cGFyYW1zXS56aXAocGF0aC5tYXRjaChAcm91dGVbOnJlZ2V4XSlbMS4uLTFdKV1cbiAgICBlbmRcblxuICAgIGRlZiB1cmxfZm9yKG5hbWUsIHBhcmFtcyA9IG5pbClcbiAgICAgIHJvdXRlID0gQHJvdXRlcy5yb3V0ZXMuZmluZCBkbyB8cnxcbiAgICAgICAgY2FzZSBuYW1lXG4gICAgICAgIHdoZW4gU3RyaW5nXG4gICAgICAgICAgcls6bmFtZV0gPT0gbmFtZSB8fCByWzpwYXRoXSA9PSBuYW1lXG4gICAgICAgIHdoZW4gT2JqZWN0XG4gICAgICAgICAgcls6Y29tcG9uZW50XSA9PSBuYW1lXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcm91dGUgPyB1cmxfd2l0aF9wYXJhbXMocm91dGUsIHBhcmFtcykgOiByYWlzZShFcnJvciwgXCJSb3V0ZSAnI3tuYW1lfScgbm90IGZvdW5kLlwiKVxuICAgIGVuZFxuXG4gICAgZGVmIHF1ZXJ5XG4gICAgICBCcm93c2VyLnF1ZXJ5XG4gICAgZW5kXG5cbiAgICBkZWYgcGF0aFxuICAgICAgQnJvd3Nlci5wYXRoXG4gICAgZW5kXG5cbiAgICBkZWYgY3VycmVudF91cmw/KG5hbWUpXG4gICAgICBwYXRoID09IHVybF9mb3IobmFtZSwgcGFyYW1zKVxuICAgIGVuZFxuXG4gICAgZGVmIHVybF93aXRoX3BhcmFtcyhyb3V0ZSwgcGFyYW1zKVxuICAgICAgcGF0aCA9IHJvdXRlWzpwYXRoXVxuICAgICAgcGFyYW1zLmVhY2ggZG8gfGtleSwgdmFsdWV8XG4gICAgICAgIHBhdGggPSBwYXRoLmdzdWIoXCI6I3trZXl9XCIsIFwiI3t2YWx1ZX1cIilcbiAgICAgIGVuZCBpZiBwYXJhbXNcbiAgICAgIHBhdGhcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpJbmVzaXRhPiIsIjxtb2R1bGU6Um91dGVyPiIsInNlbGYiLCJpbmNsdWRlIiwiSW5lc2l0YTo6Q29tcG9uZW50IiwiSW5lc2l0YSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkByb3V0ZXMiLCJSb3V0ZXMiLCJuZXciLCJyZXNwb25kX3RvPyIsInJhaXNlIiwiRXJyb3IiLCJyb3V0ZXMiLCJlbXB0eT8iLCJmaW5kX3JvdXRlIiwicGFyc2VfdXJsX3BhcmFtcyIsImFkZF9saXN0ZW5lcnMiLCJpbmNsdWRlZCIsImJhc2UiLCJleHRlbmQiLCJJbmVzaXRhOjpDb21wb25lbnQ6OkNsYXNzTWV0aG9kcyIsIm1vZHVsZV9ldmFsIiwiQ29tcG9uZW50IiwiYmxvY2sgaW4gaW5jbHVkZWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGluY2x1ZGVkIiwiYWxpYXNfbWV0aG9kIiwiZGVmaW5lX21ldGhvZCIsInBhcmFtcyIsImJsb2NrICgzIGxldmVscykgaW4gaW5jbHVkZWQiLCJlIiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiBpbmNsdWRlZCIsIltdIiwicm91dGVyIiwiZ29fdG8iLCJ0YXJnZXQiLCJwYXRobmFtZSIsIm1lcmdlIiwiX19hIiwiYmxvY2siLCJ0b19wcm9jIiwib25fcG9wX3N0YXRlIiwiQnJvd3NlciIsImJsb2NrIGluIGFkZF9saXN0ZW5lcnMiLCJibG9jayAoMiBsZXZlbHMpIGluIGFkZF9saXN0ZW5lcnMiLCJyZW5kZXIhIiwiaGFzaF9jaGFuZ2UiLCJyb3V0ZSIsImVhY2giLCJibG9jayBpbiBmaW5kX3JvdXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX3JvdXRlIiwicGF0aCIsIm1hdGNoIiwidXJsX2ZvciIsIkByb3V0ZSIsImZpbmRfY29tcG9uZW50IiwiY2FsbF9vbl9lbnRlcl9jYWxsYmFjayIsIkBjb21wb25lbnRfcHJvcHMiLCJyZW5kZXIiLCJjb21wb25lbnQiLCJjYWxsIiwicHVzaF9zdGF0ZSIsIkBwYXJhbXMiLCJjb21wb3RlbnRfdXJsX3BhcmFtcyIsInF1ZXJ5IiwiMSIsIi0xIiwic3BsaXQiLCJibG9jayBpbiBwYXJzZV91cmxfcGFyYW1zIiwicGFyYW0iLCJibG9jayAoMiBsZXZlbHMpIGluIHBhcnNlX3VybF9wYXJhbXMiLCJrZXkiLCJ2YWx1ZSIsIltdPSIsImRlY29kZV91cmlfY29tcG9uZW50IiwiSGFzaCIsInppcCIsIm5hbWUiLCJmaW5kIiwiYmxvY2sgaW4gdXJsX2ZvciIsInIiLCJibG9jayAoMiBsZXZlbHMpIGluIHVybF9mb3IiLCJTdHJpbmciLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCI9PSIsIk9iamVjdCIsInVybF93aXRoX3BhcmFtcyIsImN1cnJlbnRfdXJsPyIsImJsb2NrIGluIHVybF93aXRoX3BhcmFtcyIsImJsb2NrICgyIGxldmVscykgaW4gdXJsX3dpdGhfcGFyYW1zIiwiZ3N1YiJdLCJtYXBwaW5ncyI6IkFBQUFBLHdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsY0FBUkQ7TUFFQUQsSUFBQUksYUFBQUEsQ0FBWSxRQUFaQTs7QUFFQUMsTUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxRQUFBQTtBQUFBQTs7O1FBQ0VDLGNBQVVDLFlBQU1DLEtBQUFBLENBQUFBO1FBQ2hCLEtBQUEsUUFBb0RSLElBQUFTLGdCQUFBQSxDQUFZLFFBQVpBLENBQXBELENBQUE7VUFBQVQsSUFBQVUsT0FBQUEsQ0FBTUMsV0FBTixFQUFhTiwrQkFBYks7UUFBQTtRQUNBVixJQUFBWSxRQUFBQSxDQUFBQTtRQUNBLElBQUEsUUFBcUROLFdBQU9NLFFBQUFBLENBQUFBLENB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QUFwQztNQUxGb0MsQ0FBQUE7SUE3R0Z2RixHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjkxMjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2luZXNpdGEtcm91dGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2luZXNpdGEtcm91dGVyL2Jyb3dzZXInXG5yZXF1aXJlICdpbmVzaXRhLXJvdXRlci9yb3V0ZXMnXG5yZXF1aXJlICdpbmVzaXRhLXJvdXRlci9yb3V0ZXInXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLHdCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix1QkFBUkU7RUFDQUYsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsdUJBQVJFO0FBRkFGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTEzMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vcm91dGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFJvdXRlclxuICBpbmNsdWRlIEluZXNpdGE6OlJvdXRlclxuXG4gIGRlZiByb3V0ZXNcbiAgICByb3V0ZSAnLycsIHRvOiBBYm91dFxuICAgIHJvdXRlICcvaGVscCcsIHRvOiBIZWxwXG4gICAgcm91dGUgJy9kaXNjJywgdG86IERpc2NcbiAgICByb3V0ZSAnL2V4YW1wbGVzJywgdG86IEV4YW1wbGVzXG4gICAgcm91dGUgJy9yb2FkbWFwJywgdG86IFJvYWRtYXBcbiAgICByb3V0ZSAnL3BhdHJlb25zJywgdG86IFBhdHJlb25zXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSb3V0ZXI+Iiwic2VsZiIsImluY2x1ZGUiLCJJbmVzaXRhOjpSb3V0ZXIiLCJJbmVzaXRhIiwicm91dGVzIiwicm91dGUiLCJBYm91dCIsIkhlbHAiLCJEaXNjIiwiRXhhbXBsZXMiLCJSb2FkbWFwIiwiUGF0cmVvbnMiXSwibWFwcGluZ3MiOiJBQUFBQSx5QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCxXQUFSRDtJQUVBRixPQUFBSyxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUosSUFBQUssT0FBQUEsQ0FBTUQsR0FBTixFQUFXLGdCQUFBLE1BQUlFLFdBQUosRUFBWEQ7TUFDQUwsSUFBQUssT0FBQUEsQ0FBTUQsT0FBTixFQUFlLGdCQUFBLE1BQUlHLFVBQUosRUFBZkY7TUFDQUwsSUFBQUssT0FBQUEsQ0FBTUQsT0FBTixFQUFlLGdCQUFBLE1BQUlJLFVBQUosRUFBZkg7TUFDQUwsSUFBQUssT0FBQUEsQ0FBTUQsV0FBTixFQUFtQixnQkFBQSxNQUFJSyxjQUFKLEVBQW5CSjtNQUNBTCxJQUFBSyxPQUFBQSxDQUFNRCxVQUFOLEVBQWtCLGdCQUFBLE1BQUlNLGFBQUosRUFBbEJMO01BQ0FELE9BQUFKLElBQUFLLE9BQUFBLENBQU1ELFdBQU4sRUFBbUIsZ0JBQUEsTUFBSU8sY0FBSixFQUFuQk47SUFORkQsQ0FBQUE7RUFIRkwsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5MTU3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9zdG9yZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTdG9yZVxuICBpbmNsdWRlIEluZXNpdGE6OkluamVjdGlvblxuXG4gIGF0dHJfYWNjZXNzb3IgOmNvbW1hbmRzLCA6cHJvZ3JhbXNcblxuICBCQVNfRVhUID0gJy5CQVMnXG5cbiAgZGVmIGNvbW1hbmRzXG4gICAgQ29tbWFuZHM6OkNPTU1BTkRTXG4gIGVuZFxuXG4gIGRlZiBleGFtcGxlc1xuICAgIEV4YW1wbGVzOjpFWEFNUExFU1xuICBlbmRcblxuICBkZWYgaW5pdFxuICAgIGZldGNoX2NvbW1uYWRzXG4gICAgZmV0Y2hfcHJvZ3JhbXNcbiAgZW5kXG5cbiAgZGVmIGZldGNoX2NvbW1uYWRzXG4gICAgQGNvbW1hbmRzID0gW11cbiAgZW5kXG5cbiAgZGVmIGZldGNoX3Byb2dyYW1zXG4gICAgQHByb2dyYW1zID0gW11cblxuICAgICgwLi4uc3RvcmFnZV9sZW5ndGgpLmVhY2ggZG8gfGl8XG4gICAgICBuYW1lID0gc3RvcmFnZV9rZXkoaSlcbiAgICAgIGlmIG5hbWUuZW5kX3dpdGg/KEJBU19FWFQpXG4gICAgICAgIGNvZGUgPSBzdG9yYWdlX3ZhbHVlKGkpXG4gICAgICAgIEBwcm9ncmFtcyA8PCB7XG4gICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgbmFtZTogbmFtZVswLi4tNV0sXG4gICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzdG9yYWdlX2xlbmd0aFxuICAgIGBsb2NhbFN0b3JhZ2UubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgc3RvcmFnZV9rZXkoaSlcbiAgICBOYXRpdmUoYGxvY2FsU3RvcmFnZS5rZXkoaSlgKVxuICBlbmRcblxuICBkZWYgc3RvcmFnZV92YWx1ZShpKVxuICAgIE5hdGl2ZShgbG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxTdG9yYWdlLmtleShpKSlgKVxuICBlbmRcblxuICBkZWYgZXhpc3Q/KG5hbWUpXG4gICAgbmFtZSA9IGZpbGVuYW1lKG5hbWUpXG4gICAgIU5hdGl2ZShgbG9jYWxTdG9yYWdlLmdldEl0ZW0oI3tuYW1lfSlgKS5uaWw/XG4gIGVuZFxuXG4gIGRlZiBjb3B5X3Byb2dyYW0obmFtZSwgY29kZSlcbiAgICBuYW1lID0gZmlsZW5hbWUobmFtZSlcbiAgICBgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgY29kZSlgXG4gIGVuZFxuXG4gIGRlZiBmaWxlbmFtZShuYW1lKVxuICAgIFwiI3tuYW1lfSN7QkFTX0VYVH1cIi51cGNhc2VcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlN0b3JlPiIsInNlbGYiLCJpbmNsdWRlIiwiSW5lc2l0YTo6SW5qZWN0aW9uIiwiSW5lc2l0YSIsImF0dHJfYWNjZXNzb3IiLCJjb21tYW5kcyIsIkNvbW1hbmRzOjpDT01NQU5EUyIsIkNvbW1hbmRzIiwiZXhhbXBsZXMiLCJFeGFtcGxlczo6RVhBTVBMRVMiLCJFeGFtcGxlcyIsImluaXQiLCJmZXRjaF9jb21tbmFkcyIsImZldGNoX3Byb2dyYW1zIiwiQGNvbW1hbmRzIiwiQHByb2dyYW1zIiwiZWFjaCIsIjAiLCJzdG9yYWdlX2xlbmd0aCIsImJsb2NrIGluIGZldGNoX3Byb2dyYW1zIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gZmV0Y2hfcHJvZ3JhbXMiLCJuYW1lIiwic3RvcmFnZV9rZXkiLCJlbmRfd2l0aD8iLCJCQVNfRVhUIiwiY29kZSIsInN0b3JhZ2VfdmFsdWUiLCI8PCIsIltdIiwiLTUiLCJOYXRpdmUiLCJleGlzdD8iLCJmaWxlbmFtZSIsIm5pbD8iLCIhIiwiY29weV9wcm9ncmFtIiwidXBjYXNlIl0sIm1hcHBpbmdzIjoiQUFBQUEsd0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsY0FBUkQ7SUFFQUQsSUFBQUksZUFBQUEsQ0FBYyxVQUFkLEVBQXlCLFVBQXpCQTtJQUVBLG1DQUFVTCxNQUFWOztBQUVBTSxJQUFBQSx3QkFBQUEsb0JBQUFBO0FBQUFBO01BQ0VBLE9BQUFDLElBQUFDLGNBQUFEO0lBREZELENBQUFBOztBQUlBRyxJQUFBQSx3QkFBQUEsb0JBQUFBO0FBQUFBO01BQ0VBLE9BQUFDLElBQUFDLGNBQUFEO0lBREZELENBQUFBOztBQUlBRyxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRVgsSUFBQVksZ0JBQUFBLENBQUFBO01BQ0FELE9BQUFYLElBQUFhLGdCQUFBQSxDQUFBQTtJQUZGRixDQUFBQTs7QUFLQUMsSUFBQUEsOEJBQUFBLDBCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUUsQ0FBQUEsZ0JBQVksRUFBWkE7SUFERkYsQ0FBQUE7O0FBSUFDLElBQUFBLDhCQUFBQSwwQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFRSxnQkFBWTtNQUVaRixPQUFvQkcsTUFBbkIsZ0JBQUFDLENBQUEsQ0FBSWpCLElBQUFrQixnQkFBQUEsQ0FBQUEsQ0FBSixPQUFtQkYsUUFBQUEsRUFBQUEsRUFBQUEsRUFBcEJHLGFBQThCQyxDQUE5QkQsRUFBQUU7QUFBQUE7OztRQUE4QjtRQUM1QkMsT0FBT3RCLElBQUF1QixhQUFBQSxDQUFZSCxDQUFaRztRQUNQLElBQUEsUUFBR0QsSUFBSUUsY0FBQUEsQ0FBV0MsYUFBWEQsQ0FBUCxDQUFBOztVQUNFRSxPQUFPMUIsSUFBQTJCLGVBQUFBLENBQWNQLENBQWRPO1VBQ1BOLE9BQUFOLGFBQVVhLE9BQUFBLENBQUcsd0NBQUEsTUFDUFIsQ0FETyxFQUFBLFFBRUxFLElBQUlPLE9BQUFBLENBQUMsT0FBQVosQ0FBQSxFQUFHYSxFQUFILFFBQURELENBRkMsRUFBQSxRQUdMSCxJQUhLLEVBQUEsUUFJTCxLQUpLLEVBQUhFO1FBRlo7VUE3Qk5QLE9BQUE7UUE2Qk0sRUFGRkYsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBb0JIO0lBSHRCSCxDQUFBQTs7QUFpQkFLLElBQUFBLDhCQUFBQSwwQkFBQUE7QUFBQUE7TUFDRUEsT0FBQ0EsbUJBQURBO0lBREZBLENBQUFBOztBQUlBSyxJQUFBQSwyQkFBQUEsdUJBQWdCSCxDQUFoQkc7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF2QixJQUFBK0IsUUFBQUEsQ0FBUVIsbUJBQVJRO0lBREZSLENBQUFBOztBQUlBSSxJQUFBQSw2QkFBQUEseUJBQWtCUCxDQUFsQk87QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEzQixJQUFBK0IsUUFBQUEsQ0FBUUoseUNBQVJJO0lBREZKLENBQUFBOztBQUlBSyxJQUFBQSxzQkFBQUEsNkJBQVdWLElBQVhVO0FBQUFBLE1BQUFBOzs7TUFDRVYsT0FBT3RCLElBQUFpQyxVQUFBQSxDQUFTWCxJQUFUVztNQUNQRCxPQUFDaEMsSUFBQStCLFFBQUFBLENBQVFDLHFCQUF1QlYsSUFBS1UsQ0FBcENELENBQXVDRyxTQUFBQSxDQUFBQSxDQUF4Q0MsTUFBQUEsQ0FBQUE7SUFGRkgsQ0FBQUE7O0FBS0FJLElBQUFBLDRCQUFBQSx3QkFBaUJkLElBQUQsRUFBT0ksSUFBdkJVO0FBQUFBLE1BQUFBOzs7TUFDRWQsT0FBT3RCLElBQUFpQyxVQUFBQSxDQUFTWCxJQUFUVztNQUNQRyxPQUFDQSxnQ0FBREE7SUFGRkEsQ0FBQUE7SUFLQXJDLE9BQUFrQyx3QkFBQUEsb0JBQWFYLElBQWJXO0FBQUFBO01BQ0VBLE9BQUEsQ0FBQSxDQUFBLEVBQUEsR0FBQSxDQUFHWCxJQUFILENBQUEsQ0FBQSxHQUFBLENBQVVHLGFBQVYsQ0FBQSxDQUFtQlksUUFBQUEsQ0FBQUE7SUFEckJKLENBQUFBO0VBL0RGbEMsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5MjU0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tcG9uZW50cy9hYm91dC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBBYm91dFxuICBpbmNsdWRlIEluZXNpdGE6OkNvbXBvbmVudFxuXG4gIGRlZiByZW5kZXJcbiAgICBoMyBcIldoYXQgaXMgdGhpcz9cIlxuICAgIHAgZG9cbiAgICAgIHAgY2xhc3M6IFwiaW1hZ2VcIiBkb1xuICAgICAgICBhIGhyZWY6IFwiL2ZhemljXCIgZG9cbiAgICAgICAgICBpbWcgc3JjOiBcIi9zdGF0aWMvaW1hZ2VzL2ZhemljLmpwZ1wiXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBhIGhyZWY6IFwiL2ZhemljXCIgZG9cbiAgICAgICAgJ0ZBWklDICdcbiAgICAgIGVuZFxuICAgICAgc3BhbiBcImlzIGEgZmFudGFzeSByZXRybyBjb21wdXRlci4gWW91IGNhbiBjcmVhdGUsIHNoYXJlLCBhbmQgcGxheSB0aW55IGdhbWVzIG9yIHByb2dyYW1zLiBZb3UgaGF2ZSB0aGUgYnVpbHQtaW4gQkFTSUMgaW50ZXJwcmV0ZXIsIHNvIHlvdSBjYW4gc3RhcnQgbm93IGxpa2UgaXQncyB0aGUgODBzLlwiXG4gICAgZW5kXG4gICAgICBhIGhyZWY6IFwiL2ZhemljXCIgZG9cbiAgICAgICAgJ0NMSUNLIEhFUkUgVE8gU1RBUlQnXG4gICAgICBlbmRcbiAgICBoMyBcIldoYXQgbm93P1wiXG4gICAgcCBkb1xuICAgICAgc3BhbiBcIldoZW4geW91IHdpbGwgc2VlIFJFQURZIHByb21wdCBpdCdzIHRpbWUgdG8gd3JpdGUgeW91ciBmaXJzdCBiYXNpYyBwcm9ncmFtLiBEb24ndCBrbm93IGJhc2ljPyBHbyB0b1wiXG4gICAgICBhIGhyZWY6IHJvdXRlci51cmxfZm9yKDpoZWxwKSBkb1xuICAgICAgICAnIEhFTFAgJ1xuICAgICAgZW5kXG4gICAgICBzcGFuIFwic2VjdGlvbi4gWW91J2xsIHNlZSBob3cgdG8gd3JpdGUgeW91ciBmaXJzdCBiYXNpYyBwcm9ncmFtLCBhdmFpbGFibGUgY29tbWFuZHMsIGFuZCBldmVyeXRoaW5nIHlvdSBuZWVkIHRvIHN0YXJ0LlwiXG4gICAgZW5kXG4gICAgYSBocmVmOiByb3V0ZXIudXJsX2Zvcig6aGVscCkgZG9cbiAgICAgICdJIE5FRUQgSEVMUCdcbiAgICBlbmRcbiAgICBoMyBcIkNhbiBJIHNhdmUgb3IgbG9hZCBteSBwcm9ncmFtcz9cIlxuICAgIHAgZG9cbiAgICAgIHNwYW4gXCJZZXMuIEFueSB0aW1lIHlvdSB3YW50LiBKdXN0IHR5cGUgU0FWRSBcXFwiTkFNRVxcXCIgYW5kIHRoYXRzIGl0LiBZb3UgY2FuIGdvIHRvXCJcbiAgICAgIGEgaHJlZjogcm91dGVyLnVybF9mb3IoOmRpc2MpIGRvXG4gICAgICAgICcgRElTQyAnXG4gICAgICBlbmRcbiAgICAgIHNwYW4gXCJzZWN0aW9uIHRvIHNlZSB5b3UgcHJvZ3JhbXMgb3IgY29weSB0aGVtLiBPZiBjb3Vyc2UgeW91IGNhbiBsb2FkIHRoZW0gYnkgdHlwaW5nIExPQUQgXFxcIk5BTUVcXFwiLlwiXG4gICAgZW5kXG4gICAgYSBocmVmOiByb3V0ZXIudXJsX2Zvcig6ZGlzYykgZG9cbiAgICAgICdTSE9XIE1ZIEZMT1BQWSBESVNDJ1xuICAgIGVuZFxuICAgIGgzIFwiSXMgaXQgZXZlcnl0aGluZz9cIlxuICAgIHAgZG9cbiAgICAgIHNwYW4gXCJOby4gSWYgeW91IHdhbnQgdG8gc2VlIHdoYXQgaXMgcGxhbm5lZCBnbyB0b1wiXG4gICAgICBhIGhyZWY6IHJvdXRlci51cmxfZm9yKDpyb2FkbWFwKSBkb1xuICAgICAgICAnIFJPQURNQVAgJ1xuICAgICAgZW5kXG4gICAgICBzcGFuIFwic2VjdGlvbi4gWW91J2xsIGZpbmQgdGhlcmUgYWxsIHRoaW5ncyB0aGF0IHdpbGwgaGFwcGVuIGluIHRoZSBmdXR1cmUuIFwiXG4gICAgZW5kXG4gICAgYSBocmVmOiByb3V0ZXIudXJsX2Zvcig6cm9hZG1hcCkgZG9cbiAgICAgICdTSE9XIE1FIFRIRSBST0FETUFQJ1xuICAgIGVuZFxuICAgIGgzIFwiSG93IGNhbiBJIHRoYW5rIHlvdT9cIlxuICAgIHAgZG9cbiAgICAgIHNwYW4gXCJJZiB5b3UgbGlrZSBpdCwgY2hlY2tcIlxuICAgICAgYSBocmVmOiByb3V0ZXIudXJsX2Zvcig6cm9hZG1hcCkgZG9cbiAgICAgICAgJyBQQVRSRU9OUyAnXG4gICAgICBlbmRcbiAgICAgIHNwYW4gXCJzZWN0aW9uIG5vdy4gT3IgZm9sbG93IHVzIG9uIHR3aXR0ZXIhXCJcbiAgICBlbmRcbiAgICBkaXYuc29jaWFsIGRvXG4gICAgICBhIGNsYXNzOiBcImZhIGZhLXR3aXR0ZXJcIiwgaHJlZjogXCJodHRwczovL3R3aXR0ZXIuY29tL2ZhemljMVwiXG4gICAgICBhIGNsYXNzOiBcImJvbGRcIiwgaHJlZjogXCJodHRwczovL3d3dy5wYXRyZW9uLmNvbS9mYXppY1wiIGRvXG4gICAgICAgIFwiUFwiXG4gICAgICBlbmRcbiAgICAgIGEgY2xhc3M6IFwiYm9sZFwiLCBocmVmOiBcImh0dHBzOi8vZmF6aWJlYXIuaXRjaC5pby9mYXppY1wiIGRvXG4gICAgICAgIFwiaVwiXG4gICAgICBlbmRcbiAgICAgIGEgY2xhc3M6IFwiZmEgZmEtZ2l0aHViXCIsIGhyZWY6IFwiaHR0cHM6Ly9naXRodWIuY29tL2ZhemliZWFyL2ZhemljXCJcbiAgICBlbmRcbiAgICBoMyBcIkZvdW5kIGEgYnVnP1wiXG4gICAgcCBkb1xuICAgICAgc3BhbiBcIlRoYXQgZ3JlYXQsIHBsZWFzZSByZXBvcnQgaXQgaW50byBcIlxuICAgICAgYSBocmVmOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9mYXppYmVhci9mYXppYy9pc3N1ZXNcIiBkb1xuICAgICAgICAnZ2l0aHViIGlzc3VlIHRyYWNrZXInXG4gICAgICBlbmRcbiAgICAgIHNwYW4gXCIuIFRoYW5rcyFcIlxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6QWJvdXQ+Iiwic2VsZiIsImluY2x1ZGUiLCJJbmVzaXRhOjpDb21wb25lbnQiLCJJbmVzaXRhIiwicmVuZGVyIiwiaDMiLCJwIiwiYmxvY2sgaW4gcmVuZGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZW5kZXIiLCJibG9jayAoMyBsZXZlbHMpIGluIHJlbmRlciIsImEiLCJibG9jayAoNCBsZXZlbHMpIGluIHJlbmRlciIsImltZyIsInNwYW4iLCJyb3V0ZXIiLCJ1cmxfZm9y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QUEsRUFBQUEsQ0FBRSwyQkFBQSxTQUFPRixNQUFQLEVBQUEsUUFBcUJBLGdDQUFyQixFQUFGRSxDQUFBQSxFQUFBRixZQUNFQSxHQURGQSxDQUFBRTtRQUdBRixPQUFBUixJQUFBVSxHQUFBQSxDQUFFLDJCQUFBLFNBQU9GLGNBQVAsRUFBQSxRQUE2QkEsbUNBQTdCLEVBQUZFLEVBUkZILENBQUFBLEdBQUFBLFNBQUFBLENBQUdTO01BVUhoQixJQUFBSyxJQUFBQSxDQUFHRCxjQUFIQztNQUNBRCxPQUFBRSxNQUFBTixJQUFBTSxLQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyxhQUFBQSxFQUFBQzs7O1FBQ0VSLElBQUFhLE1BQUFBLENBQUtMLG9DQUFMSztRQUNBSCxNQUFBVixJQUFBVSxLQUFBQSxFQUFBQSxDQUFFLGtCQUFBLFFBQU1GLDBDQUFOLEVBQUZFLENBQUFBLEVBQUFGLFlBQ0VBLHNCQURGQSxDQUFBRTtRQUdBRixPQUFBUixJQUFBYSxNQUFBQSxDQUFLTCxXQUFMSyxFQUxGTixDQUFBQSxHQUFBQSxTQUFBQSxDQUFBRDtJQXBFRkYsQ0FBQUE7RUFIRkwsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5MzMwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tcG9uZW50cy9kaXNjLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIERpc2NcbiAgaW5jbHVkZSBJbmVzaXRhOjpDb21wb25lbnRcblxuICBkZWYgdG9nZ2xlKHByb2dyYW0pXG4gICAgcHJvZ3JhbVs6c2hvd10gPSAhcHJvZ3JhbVs6c2hvd11cbiAgICByZW5kZXIhXG4gIGVuZFxuXG4gIGRlZiBnb190b19wcm9ncmFtKG5hbWUpXG4gICAgbmFtZSA9IFwicHJvZ3JhbV8je25hbWV9XCIudG9fblxuICAgIGB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICN7bmFtZX1gXG4gIGVuZFxuXG4gIGRlZiByZW5kZXJcbiAgICBoMyBcIllvdXIgcHJpdmF0ZSBmbG9wcHkgZGlzY1wiXG4gICAgaWYgc3RvcmUucHJvZ3JhbXMuYW55P1xuICAgICAgcCBcIkxpc3Qgb2YgYWxsIHlvdXIgc2F2ZWQgcHJvZ3JhbXMuIENsaWNrIHRvIHNob3cgdGhlIGNvZGUuXCJcbiAgICAgIHVsLnByb2dyYW1zIGRvXG4gICAgICAgIHN0b3JlLnByb2dyYW1zLmVhY2ggZG8gfHByb2dyYW18XG4gICAgICAgICAgbGkucHJvZ3JhbSBpZDogXCJwcm9ncmFtXyN7cHJvZ3JhbVs6aWRdfVwiIGRvXG4gICAgICAgICAgICBhIGhyZWY6IFwiI1wiLCBvbmNsaWNrOiAtPiB7IHRvZ2dsZShwcm9ncmFtKSB9IGRvXG4gICAgICAgICAgICAgIHByb2dyYW1bOm5hbWVdXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIHByZSBwcm9ncmFtWzpjb2RlXSBpZiBwcm9ncmFtWzpzaG93XVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHAgZG9cbiAgICAgICAgc3BhbiBcIllvdSBkb24ndCBoYXZlIGFueSBwcm9ncmFtcy4gWW91IGNhbiBjb3B5IGZyb20gXCJcbiAgICAgICAgYSBocmVmOiByb3V0ZXIudXJsX2Zvcig6ZXhhbXBsZXMpLCBjbGFzczogXCIje1wiYWN0aXZlXCIgaWYgcm91dGVyLmN1cnJlbnRfdXJsPyg6ZXhhbXBsZXMpfVwiIGRvXG4gICAgICAgICAgJ0VYQU1QTEVTJ1xuICAgICAgICBlbmRcbiAgICAgICAgc3BhbiBcIiBzZWN0aW9uLCBvciBzYXZlIHlvdSBvd24gdXNpbmcgc2F2ZSBjb21tYW5kIVwiXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkRpc2M+Iiwic2VsZiIsImluY2x1ZGUiLCJJbmVzaXRhOjpDb21wb25lbnQiLCJJbmVzaXRhIiwidG9nZ2xlIiwicHJvZ3JhbSIsIltdPSIsIltdIiwiISIsInJlbmRlciEiLCJnb190b19wcm9ncmFtIiwibmFtZSIsInRvX24iLCJyZW5kZXIiLCJoMyIsInN0b3JlIiwicHJvZ3JhbXMiLCJhbnk/IiwicCIsInVsIiwiYmxvY2sgaW4gcmVuZGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZW5kZXIiLCJlYWNoIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiByZW5kZXIiLCJsaSIsImJsb2NrICg0IGxldmVscykgaW4gcmVuZGVyIiwiYSIsImJsb2NrICg1IGxldmVscykgaW4gcmVuZGVyIiwicHJlIiwic3BhbiIsInJvdXRlciIsInVybF9mb3IiLCJjdXJyZW50X3VybD8iXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCxjQUFSRDs7QUFFQUcsSUFBQUEsc0JBQUFBLGtCQUFXQyxPQUFYRDtBQUFBQSxNQUFBQTs7O01BQ0VDLE9BQU9DLFFBQUFBLENBQUMsTUFBUixFQUFrQkQsT0FBT0UsT0FBQUEsQ0FBQyxNQUFEQSxDQUFSQyxNQUFBQSxDQUFBQSxDQUFWRjtNQUNQRixPQUFBSixJQUFBUyxZQUFBQSxDQUFBQTtJQUZGTCxDQUFBQTs7QUFLQU0sSUFBQUEsNkJBQUFBLHlCQUFrQkMsSUFBbEJEO0FBQUFBOztNQUNFQyxPQUFPLENBQUEsQ0FBQ0QsVUFBRCxDQUFBLEdBQUEsQ0FBV0MsSUFBWCxDQUFBLENBQWlCQyxNQUFBQSxDQUFBQTtNQUN4QkYsT0FBQ0EsdUJBQXlCQztJQUY1QkQsQ0FBQUE7SUFLQVgsT0FBQWMsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0ViLElBQUFjLElBQUFBLENBQUdELDBCQUFIQztNQUNBLElBQUEsUUFBR2QsSUFBQWUsT0FBQUEsQ0FBQUEsQ0FBS0MsVUFBQUEsQ0FBQUEsQ0FBU0MsU0FBQUEsQ0FBQUEsQ0FBakIsQ0FBQTs7UUFDRWpCLElBQUFrQixHQUFBQSxDQUFFTCwwREFBRks7UUFDQUwsT0FBRUcsTUFBRmhCLElBQUFtQixJQUFBQSxDQUFBQSxDQUFFSCxZQUFBQSxFQUFBQSxFQUFBQSxFQUFGSSxhQUFBQSxFQUFBQzs7VUFDRUEsT0FBY0MsTUFBZHRCLElBQUFlLE9BQUFBLENBQUFBLENBQUtDLFVBQUFBLENBQUFBLENBQVNNLFFBQUFBLEVBQUFBLEVBQUFBLEVBQWRELGFBQXdCaEIsT0FBeEJnQixFQUFBRTs7O1lBQXdCO1lBQ3RCQSxPQUFFbEIsTUFBRkwsSUFBQXdCLElBQUFBLENBQUFBLENBQUVuQixXQUFBQSxFQUFBQSxDQUFTLGdCQUFBLE1BQUtrQixVQUFELEdBQUEsQ0FBV2xCLE9BQU9FLE9BQUFBLENBQUMsSUFBREEsQ0FBbEIsQ0FBSixFQUFURixDQUFBQSxFQUFGa0IsYUFBQUEsRUFBQUU7OztjQUNFQyxNQUFBMUIsSUFBQTBCLEtBQUFBLEVBQUFBLENBQUUsNkJBQUEsUUFBTUQsR0FBTixFQUFBLFdBQW9CLFFBQUFBLGFBQUFBLEVBQUFFOztnQkFBS0EsT0FBQTNCLElBQUFJLFFBQUFBLENBQU9DLE9BQVBELENBQUxxQixDQUFBQSxHQUFBQSxTQUFBQSxDQUFBLENBQXBCLEVBQUZDLENBQUFBLEVBQUFELGFBQUFBO2dCQUNFRSxPQUFBdEIsT0FBT0UsT0FBQUEsQ0FBQyxNQUFEQSxDQURUa0IsQ0FBQUM7Y0FHQSxJQUFBLFFBQXNCckIsT0FBT0UsT0FBQUEsQ0FBQyxNQUFEQSxDQUE3QixDQUFBO2dCQUFBa0IsT0FBQXpCLElBQUE0QixLQUFBQSxDQUFJdkIsT0FBT0UsT0FBQUEsQ0FBQyxNQUFEQSxDQUFYcUI7Y0FBQTtnQkF2QlpILE9BQUE7Y0F1QlksRUFKRkYsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBRWxCLEVBREpnQixDQUFBQSxHQUFBQSxTQUFBQSxDQUFjQyxDQURoQkYsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBRUo7TUFGSjtRQWFFSCxPQUFBSyxNQUFBbEIsSUFBQWtCLEtBQUFBLEVBQUFBLEVBQUFBLEVBQUFFLGFBQUFBLEVBQUFDOzs7VUFDRXJCLElBQUE2QixNQUFBQSxDQUFLUixpREFBTFE7VUFDQUgsTUFBQTFCLElBQUEwQixLQUFBQSxFQUFBQSxDQUFFLDJCQUFBLFFBQU0xQixJQUFBOEIsUUFBQUEsQ0FBQUEsQ0FBTUMsU0FBQUEsQ0FBUyxVQUFUQSxDQUFaLEVBQUEsU0FBd0MsRUFBQSxHQUFBLENBQUcsQ0FBQSxRQUFZL0IsSUFBQThCLFFBQUFBLENBQUFBLENBQU1FLGlCQUFBQSxDQUFjLFVBQWRBLENBQWxCLENBQUEsR0FBQSxDQUFBWCxRQUFBLElBQUEsR0FBQSxDQUFILENBQXhDLEVBQUZLLENBQUFBLEVBQUFMLFlBQ0VBLFVBREZBLENBQUFLO1VBR0FMLE9BQUFyQixJQUFBNkIsTUFBQUEsQ0FBS1IsK0NBQUxRLEVBTEZULENBQUFBLEdBQUFBLFNBQUFBLENBQUFGO01BYkY7SUFGRkwsQ0FBQUE7RUFiRmQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5Mzk0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tcG9uZW50cy9leGFtcGxlcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBFeGFtcGxlc1xuICBpbmNsdWRlIEluZXNpdGE6OkNvbXBvbmVudFxuXG4gIGRlZiBjb3B5KHByb2dyYW0pXG4gICAgc3RvcmUuY29weV9wcm9ncmFtKHByb2dyYW1bOm5hbWVdLCBwcm9ncmFtWzpjb2RlXSlcbiAgICBzdG9yZS5mZXRjaF9wcm9ncmFtc1xuICAgIHJlbmRlciFcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgcmVuZGVyXG4gICAgaDMgXCJQcm9ncmFtIEV4YW1wbGVzXCJcbiAgICBwIFwiSWYgeW91IHdhbnQgdG8gdHJ5IGZldyBwcm9ncmFtcywgb24gdGhpcyBwYWdlLCB5b3UgY2FuIGZpbmQgc29tZSBvZiBiYXNpYyBwcm9ncmFtcy4gQ2xpY2sgZGlzYyBpY29uIHRvIGNvcHkgaW50byB5b3VyIGRpc2MuXCJcbiAgICB1bC5leGFtcGxlcyBkb1xuICAgICAgc3RvcmUuZXhhbXBsZXMuZWFjaCBkbyB8cHJvZ3JhbXxcbiAgICAgICAgbGkuY29tbWFuZCBpZDogXCJwcm9ncmFtXyN7cHJvZ3JhbVs6bmFtZV19XCIgZG9cbiAgICAgICAgICBhIGNsYXNzOiBcImNvcHlcIiwgaHJlZjogXCIjXCIsIG9uY2xpY2s6IC0+IHsgY29weShwcm9ncmFtKSB9IGRvXG4gICAgICAgICAgICBzdG9yZS5leGlzdD8ocHJvZ3JhbVs6bmFtZV0pID8gXCLinIVcIiA6IFwi8J+SvlwiXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgc3Bhbi5uYW1lIHByb2dyYW1bOm5hbWVdXG4gICAgICAgICAgZGl2LmRlc2NyaXB0aW9uIHByb2dyYW1bOmRlc2NyaXB0aW9uXVxuICAgICAgICAgIHByZSBwcm9ncmFtWzpjb2RlXVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RXhhbXBsZXM+Iiwic2VsZiIsImluY2x1ZGUiLCJJbmVzaXRhOjpDb21wb25lbnQiLCJJbmVzaXRhIiwiY29weSIsInByb2dyYW0iLCJzdG9yZSIsImNvcHlfcHJvZ3JhbSIsIltdIiwiZmV0Y2hfcHJvZ3JhbXMiLCJyZW5kZXIhIiwicmVuZGVyIiwiaDMiLCJwIiwiZXhhbXBsZXMiLCJ1bCIsImJsb2NrIGluIHJlbmRlciIsImJsb2NrICgyIGxldmVscykgaW4gcmVuZGVyIiwiZWFjaCIsImJsb2NrICgzIGxldmVscykgaW4gcmVuZGVyIiwiY29tbWFuZCIsImxpIiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiByZW5kZXIiLCJhIiwiYmxvY2sgKDUgbGV2ZWxzKSBpbiByZW5kZXIiLCJleGlzdD8iLCJzcGFuIiwibmFtZSIsImRpdiIsImRlc2NyaXB0aW9uIiwicHJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsY0FBUkQ7O0FBRUFHLElBQUFBLG9CQUFBQSxnQkFBU0MsT0FBVEQ7QUFBQUEsTUFBQUE7OztNQUNFSixJQUFBTSxPQUFBQSxDQUFBQSxDQUFLQyxjQUFBQSxDQUFjRixPQUFPRyxPQUFBQSxDQUFDLE1BQURBLENBQTFCLEVBQW1DSCxPQUFPRyxPQUFBQSxDQUFDLE1BQURBLENBQXJDRDtNQUNMUCxJQUFBTSxPQUFBQSxDQUFBQSxDQUFLRyxnQkFBQUEsQ0FBQUE7TUFDTFQsSUFBQVUsWUFBQUEsQ0FBQUE7TUFDQU4sT0FBQTtJQUpGQSxDQUFBQTtJQU9BTCxPQUFBWSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRVgsSUFBQVksSUFBQUEsQ0FBR0Qsa0JBQUhDO01BQ0FaLElBQUFhLEdBQUFBLENBQUVGLDZIQUFGRTtNQUNBRixPQUFFRyxNQUFGZCxJQUFBZSxJQUFBQSxDQUFBQSxDQUFFRCxZQUFBQSxFQUFBQSxFQUFBQSxFQUFGRSxhQUFBQSxFQUFBQzs7UUFDRUEsT0FBY0MsTUFBZGxCLElBQUFNLE9BQUFBLENBQUFBLENBQUtRLFVBQUFBLENBQUFBLENBQVNJLFFBQUFBLEVBQUFBLEVBQUFBLEVBQWRELGFBQXdCWixPQUF4QlksRUFBQUU7OztVQUF3QjtVQUN0QkEsT0FBRUMsTUFBRnBCLElBQUFxQixJQUFBQSxDQUFBQSxDQUFFRCxXQUFBQSxFQUFBQSxDQUFTLGdCQUFBLE1BQUtELFVBQUQsR0FBQSxDQUFXZCxPQUFPRyxPQUFBQSxDQUFDLE1BQURBLENBQWxCLENBQUosRUFBVFksQ0FBQUEsRUFBRkQsYUFBQUEsRUFBQUc7OztZQUNFQyxNQUFBdkIsSUFBQXVCLEtBQUFBLEVBQUFBLENBQUUsc0NBQUEsU0FBT0QsTUFBUCxFQUFBLFFBQXFCQSxHQUFyQixFQUFBLFdBQW1DLFFBQUFBLGFBQUFBLEVBQUFFOztjQUFLQSxPQUFBeEIsSUFBQUksTUFBQUEsQ0FBS0MsT0FBTEQsQ0FBTGtCLENBQUFBLEdBQUFBLFNBQUFBLENBQUEsQ0FBbkMsRUFBRkMsQ0FBQUEsRUFBQUQsYUFBQUEsRUFBQUU7O2NBQ0UsSUFBQSxRQUFBeEIsSUFBQU0sT0FBQUEsQ0FBQUEsQ0FBS21CLFdBQUFBLENBQVFwQixPQUFPRyxPQUFBQSxDQUFDLE1BQURBLENBQWZpQixDQUFMLENBQUE7Z0JBQStCRCxPQUFBQTtjQUEvQjtnQkFBcUNBLE9BQUFBO2NBQXJDLENBREZGLENBQUFBLEdBQUFBLFNBQUFBLENBQUFDO1lBR0F2QixJQUFBMEIsTUFBQUEsQ0FBQUEsQ0FBSUMsTUFBQUEsQ0FBTXRCLE9BQU9HLE9BQUFBLENBQUMsTUFBREEsQ0FBYm1CO1lBQ0ozQixJQUFBNEIsS0FBQUEsQ0FBQUEsQ0FBR0MsYUFBQUEsQ0FBYXhCLE9BQU9HLE9BQUFBLENBQUMsYUFBREEsQ0FBcEJxQjtZQUNIUCxPQUFBdEIsSUFBQThCLEtBQUFBLENBQUl6QixPQUFPRyxPQUFBQSxDQUFDLE1BQURBLENBQVhzQixFQU5GWCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFFQyxFQURKSCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFjQyxDQURoQkYsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBRUY7SUFISkgsQ0FBQUE7RUFWRlosR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NDQ2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tcG9uZW50cy9mb290ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRm9vdGVyXG4gIGluY2x1ZGUgSW5lc2l0YTo6Q29tcG9uZW50XG5cbiAgZGVmIHJlbmRlclxuICAgIGZvb3RlciBcIkNvcHlyaWdodCBNaWNoYWwgS2FsYmFyY3p5ayDCriAyMDE4XCJcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkZvb3Rlcj4iLCJzZWxmIiwiaW5jbHVkZSIsIkluZXNpdGE6OkNvbXBvbmVudCIsIkluZXNpdGEiLCJyZW5kZXIiLCJmb290ZXIiXSwibWFwcGluZ3MiOiJBQUFBQSxvQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCxjQUFSRDtJQUVBRixPQUFBSyxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBSixJQUFBSyxRQUFBQSxDQUFPRCxvQ0FBUEM7SUFERkQsQ0FBQUE7RUFIRkwsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NDY1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tcG9uZW50cy9oZWxwLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEhlbHBcbiAgaW5jbHVkZSBJbmVzaXRhOjpDb21wb25lbnRcblxuICBkZWYgcmVuZGVyXG4gICAgaDMgXCJBdmFpbGFibGUgQ29tbWFuZHNcIlxuICAgIHAgXCJMaXN0IG9mIGFsbCBjb21tYW5kcyB3aXRoIGV4YW1wbGUgdGhhdCBhcmUgc3VwcG9ydGVkLlwiXG4gICAgdWwuY29tbWFuZHNfdG9jIGRvXG4gICAgICBzdG9yZS5jb21tYW5kcy5lYWNoIGRvIHxjb21tYW5kfFxuICAgICAgICBsaS5jb21tYW5kIGRvXG4gICAgICAgICAgYSBocmVmOiBcIiNcIiwgb25jbGljazogLT4ge2B3aW5kb3cubG9jYXRpb24uaGFzaCA9ICN7XCJjb21tYW5kXyN7Y29tbWFuZFs6bmFtZV0udG9fbn1cIn1gOyBmYWxzZX0gZG9cbiAgICAgICAgICAgIGNvbW1hbmRbOm5hbWVdXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgdWwuY29tbWFuZHMgZG9cbiAgICAgIHN0b3JlLmNvbW1hbmRzLmVhY2ggZG8gfGNvbW1hbmR8XG4gICAgICAgIGxpLmNvbW1hbmQgaWQ6IFwiY29tbWFuZF8je2NvbW1hbmRbOm5hbWVdfVwiIGRvXG4gICAgICAgICAgZGl2Lm5hbWUgY29tbWFuZFs6bmFtZV1cbiAgICAgICAgICBkaXYuZGVzY3JpcHRpb24gY29tbWFuZFs6ZGVzY3JpcHRpb25dXG4gICAgICAgICAgcHJlIGNvbW1hbmRbOmNvZGVdXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpIZWxwPiIsInNlbGYiLCJpbmNsdWRlIiwiSW5lc2l0YTo6Q29tcG9uZW50IiwiSW5lc2l0YSIsInJlbmRlciIsImgzIiwicCIsImNvbW1hbmRzX3RvYyIsInVsIiwiYmxvY2sgaW4gcmVuZGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZW5kZXIiLCJlYWNoIiwic3RvcmUiLCJjb21tYW5kcyIsImNvbW1hbmQiLCJibG9jayAoMyBsZXZlbHMpIGluIHJlbmRlciIsImxpIiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiByZW5kZXIiLCJhIiwiYmxvY2sgKDUgbGV2ZWxzKSBpbiByZW5kZXIiLCJbXSIsInRvX24iLCJkaXYiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJwcmUiXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCxjQUFSRDtJQUVBRixPQUFBSyxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUosSUFBQUssSUFBQUEsQ0FBR0Qsb0JBQUhDO01BQ0FMLElBQUFNLEdBQUFBLENBQUVGLHVEQUFGRTtNQUNFQyxNQUFGUCxJQUFBUSxJQUFBQSxDQUFBQSxDQUFFRCxnQkFBQUEsRUFBQUEsRUFBQUEsRUFBRkUsYUFBQUEsRUFBQUM7O1FBQ0VBLE9BQWNDLE1BQWRYLElBQUFZLE9BQUFBLENBQUFBLENBQUtDLFVBQUFBLENBQUFBLENBQVNGLFFBQUFBLEVBQUFBLEVBQUFBLEVBQWRELGFBQXdCSSxPQUF4QkosRUFBQUs7OztVQUF3QjtVQUN0QkEsT0FBRUQsTUFBRmQsSUFBQWdCLElBQUFBLENBQUFBLENBQUVGLFdBQUFBLEVBQUFBLEVBQUFBLEVBQUZDLGFBQUFBLEVBQUFFOztZQUNFQSxPQUFBQyxNQUFBbEIsSUFBQWtCLEtBQUFBLEVBQUFBLENBQUUsNkJBQUEsUUFBTUQsR0FBTixFQUFBLFdBQW9CLFFBQUFBLGFBQUFBOztjQUFLRSx1QkFBMEJBLFVBQUQsR0FBQSxDQUFXTCxPQUFPTSxPQUFBQSxDQUFDLE1BQURBLENBQU9DLE1BQUFBLENBQUFBLENBQXpCO2NBQW9DRixPQUFBLE1BQWxFRixDQUFBLENBQXBCLEVBQUZDLENBQUFBLEVBQUFELGFBQUFBO2NBQ0VFLE9BQUFMLE9BQU9NLE9BQUFBLENBQUMsTUFBREEsQ0FEVEgsQ0FBQUMsQ0FERkgsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBRUQsRUFESkosQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBY0MsQ0FEaEJGLENBQUFBLEdBQUFBLFNBQUFBLENBQUVGO01BU0ZILE9BQUVTLE1BQUZiLElBQUFRLElBQUFBLENBQUFBLENBQUVLLFlBQUFBLEVBQUFBLEVBQUFBLEVBQUZKLGFBQUFBLEVBQUFDOztRQUNFQSxPQUFjQyxNQUFkWCxJQUFBWSxPQUFBQSxDQUFBQSxDQUFLQyxVQUFBQSxDQUFBQSxDQUFTRixRQUFBQSxFQUFBQSxFQUFBQSxFQUFkRCxhQUF3QkksT0FBeEJKLEVBQUFLOzs7VUFBd0I7VUFDdEJBLE9BQUVELE1BQUZkLElBQUFnQixJQUFBQSxDQUFBQSxDQUFFRixXQUFBQSxFQUFBQSxDQUFTLGdCQUFBLE1BQUtDLFVBQUQsR0FBQSxDQUFXRCxPQUFPTSxPQUFBQSxDQUFDLE1BQURBLENBQWxCLENBQUosRUFBVE4sQ0FBQUEsRUFBRkMsYUFBQUEsRUFBQUU7OztZQUNFakIsSUFBQXNCLEtBQUFBLENBQUFBLENBQUdDLE1BQUFBLENBQU1ULE9BQU9NLE9BQUFBLENBQUMsTUFBREEsQ0FBYkc7WUFDSHZCLElBQUFzQixLQUFBQSxDQUFBQSxDQUFHRSxhQUFBQSxDQUFhVixPQUFPTSxPQUFBQSxDQUFDLGFBQURBLENBQXBCSTtZQUNIUCxPQUFBakIsSUFBQXlCLEtBQUFBLENBQUlYLE9BQU9NLE9BQUFBLENBQUMsTUFBREEsQ0FBWEssRUFIRlYsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBRUQsRUFESkosQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBY0MsQ0FEaEJGLENBQUFBLEdBQUFBLFNBQUFBLENBQUVJO0lBWkpULENBQUFBO0VBSEZMLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTUxMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvbmF2YmFyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5hdkJhclxuICBpbmNsdWRlIEluZXNpdGE6OkNvbXBvbmVudFxuXG4gIGRlZiByZW5kZXJcbiAgICBuYXYgZG9cbiAgICAgIHVsIGRvXG4gICAgICAgIGxpIGRvXG4gICAgICAgICAgYSBocmVmOiBcIi9mYXppY1wiIGRvXG4gICAgICAgICAgICAnRmF6aWMnXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICBsaSBkb1xuICAgICAgICAgIGEgaHJlZjogcm91dGVyLnVybF9mb3IoOmRpc2MpLCBjbGFzczogXCIje1wiYWN0aXZlXCIgaWYgcm91dGVyLmN1cnJlbnRfdXJsPyg6ZGlzYyl9XCIgZG9cbiAgICAgICAgICAgICdEaXNjJ1xuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgbGkgZG9cbiAgICAgICAgICBhIGhyZWY6IHJvdXRlci51cmxfZm9yKDpleGFtcGxlcyksIGNsYXNzOiBcIiN7XCJhY3RpdmVcIiBpZiByb3V0ZXIuY3VycmVudF91cmw/KDpleGFtcGxlcyl9XCIgZG9cbiAgICAgICAgICAgICdFeGFtcGxlcydcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIGxpIGRvXG4gICAgICAgICAgYSBocmVmOiByb3V0ZXIudXJsX2Zvcig6YWJvdXQpLCBjbGFzczogXCIje1wiYWN0aXZlXCIgaWYgcm91dGVyLmN1cnJlbnRfdXJsPyg6YWJvdXQpfVwiIGRvXG4gICAgICAgICAgICAnQWJvdXQnXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICBsaSBkb1xuICAgICAgICAgIGEgaHJlZjogcm91dGVyLnVybF9mb3IoOmhlbHApLCBjbGFzczogXCIje1wiYWN0aXZlXCIgaWYgcm91dGVyLmN1cnJlbnRfdXJsPyg6aGVscCl9XCIgZG9cbiAgICAgICAgICAgICdIZWxwJ1xuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgbGkgZG9cbiAgICAgICAgICBhIGhyZWY6IHJvdXRlci51cmxfZm9yKDpyb2FkbWFwKSwgY2xhc3M6IFwiI3tcImFjdGl2ZVwiIGlmIHJvdXRlci5jdXJyZW50X3VybD8oOnJvYWRtYXApfVwiIGRvXG4gICAgICAgICAgICAnUm9hZG1hcCdcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIGxpIGRvXG4gICAgICAgICAgYSBocmVmOiByb3V0ZXIudXJsX2Zvcig6cGF0cmVvbnMpLCBjbGFzczogXCIje1wiYWN0aXZlXCIgaWYgcm91dGVyLmN1cnJlbnRfdXJsPyg6cGF0cmVvbnMpfVwiIGRvXG4gICAgICAgICAgICAnUGF0cmVvbnMnXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpOYXZCYXI+Iiwic2VsZiIsImluY2x1ZGUiLCJJbmVzaXRhOjpDb21wb25lbnQiLCJJbmVzaXRhIiwicmVuZGVyIiwibmF2IiwiYmxvY2sgaW4gcmVuZGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZW5kZXIiLCJ1bCIsImJsb2NrICgzIGxldmVscykgaW4gcmVuZGVyIiwibGkiLCJibG9jayAoNCBsZXZlbHMpIGluIHJlbmRlciIsImEiLCJyb3V0ZXIiLCJ1cmxfZm9yIiwiY3VycmVudF91cmw/Il0sIm1hcHBpbmdzIjoiQUFBQUEsb0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsY0FBUkQ7SUFFQUYsT0FBQUssc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUMsTUFBQUwsSUFBQUssT0FBQUEsRUFBQUEsRUFBQUEsRUFBQUMsYUFBQUEsRUFBQUM7O1FBQ0VBLE9BQUFDLE1BQUFSLElBQUFRLE1BQUFBLEVBQUFBLEVBQUFBLEVBQUFELGFBQUFBLEVBQUFFOzs7VUFDRUMsTUFBQVYsSUFBQVUsTUFBQUEsRUFBQUEsRUFBQUEsRUFBQUQsYUFBQUEsRUFBQUU7O1lBQ0VBLE9BQUFDLE1BQUFaLElBQUFZLEtBQUFBLEVBQUFBLENBQUUsa0JBQUEsUUFBTUQsUUFBTixFQUFGQyxDQUFBQSxFQUFBRCxZQUNFQSxPQURGQSxDQUFBQyxDQURGSCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFBQztVQUtBQSxNQUFBVixJQUFBVSxNQUFBQSxFQUFBQSxFQUFBQSxFQUFBRCxhQUFBQSxFQUFBRTs7WUFDRUEsT0FBQUMsTUFBQVosSUFBQVksS0FBQUEsRUFBQUEsQ0FBRSwyQkFBQSxRQUFNWixJQUFBYSxRQUFBQSxDQUFBQSxDQUFNQyxTQUFBQSxDQUFTLE1BQVRBLENBQVosRUFBQSxTQUFvQyxFQUFBLEdBQUEsQ0FBRyxDQUFBLFFBQVlkLElBQUFhLFFBQUFBLENBQUFBLENBQU1FLGlCQUFBQSxDQUFjLE1BQWRBLENBQWxCLENBQUEsR0FBQSxDQUFBSixRQUFBLElBQUEsR0FBQSxDQUFILENBQXBDLEVBQUZDLENBQUFBLEVBQUFELFlBQ0VBLE1BREZB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QUEsQ0FBQUMsQ0FERkYsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUQ7SUFERkQsQ0FBQUE7RUFIRkwsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NTU1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tcG9uZW50cy9wYXRyZW9ucy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBQYXRyZW9uc1xuICBpbmNsdWRlIEluZXNpdGE6OkNvbXBvbmVudFxuXG4gIGRlZiByZW5kZXJcbiAgICBoMyBcIlBhdHJlb25cIlxuICAgIHAgXCJJZiB5b3UgbGlrZSBpdC4gV2FudCBtb3JlLiBZb3UgY2FuIHN1cHBvcnQgbWUgb24gcGF0cmVvbiFcIlxuICAgIGEgaHJlZjogXCJodHRwczovL3d3dy5wYXRyZW9uLmNvbS9mYXppYmVhclwiIGRvXG4gICAgICBcImh0dHBzOi8vd3d3LnBhdHJlb24uY29tL2ZhemliZWFyXCJcbiAgICBlbmRcbiAgICBwIFwiVGhhbmtzIVwiXG4gICAgaDMgXCJpdGNoLmlvXCJcbiAgICBwIFwiWW91IGNhbiBhbHNvIGNoZWNrIG91dCBpdGNoLmlvIHBhZ2UuXCJcbiAgICBhIGhyZWY6IFwiaHR0cHM6Ly9mYXppYmVhci5pdGNoLmlvL2ZhemljXCIgZG9cbiAgICAgIFwiaHR0cHM6Ly9mYXppYmVhci5pdGNoLmlvL2ZhemljXCJcbiAgICBlbmRcbiAgICBwIFwiVGhhbmtzIVwiXG4gICAgaDMgXCJXaG8gc3VwcG9ydCB0aGlzIHByb2plY3Q/XCJcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhdHJlb25zPiIsInNlbGYiLCJpbmNsdWRlIiwiSW5lc2l0YTo6Q29tcG9uZW50IiwiSW5lc2l0YSIsInJlbmRlciIsImgzIiwicCIsImEiLCJibG9jayBpbiByZW5kZXIiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCxjQUFSRDtJQUVBRixPQUFBSyxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUosSUFBQUssSUFBQUEsQ0FBR0QsU0FBSEM7TUFDQUwsSUFBQU0sR0FBQUEsQ0FBRUYsMkRBQUZFO01BQ0FDLE1BQUFQLElBQUFPLEtBQUFBLEVBQUFBLENBQUUsa0JBQUEsUUFBTUgsa0NBQU4sRUFBRkcsQ0FBQUEsRUFBQUMsWUFDRUosa0NBREZJLENBQUFEO01BR0FQLElBQUFNLEdBQUFBLENBQUVGLFNBQUZFO01BQ0FOLElBQUFLLElBQUFBLENBQUdELFNBQUhDO01BQ0FMLElBQUFNLEdBQUFBLENBQUVGLHNDQUFGRTtNQUNBQyxNQUFBUCxJQUFBTyxLQUFBQSxFQUFBQSxDQUFFLGtCQUFBLFFBQU1ILGdDQUFOLEVBQUZHLENBQUFBLEVBQUFDLFlBQ0VKLGdDQURGSSxDQUFBRDtNQUdBUCxJQUFBTSxHQUFBQSxDQUFFRixTQUFGRTtNQUNBRixPQUFBSixJQUFBSyxJQUFBQSxDQUFHRCwyQkFBSEM7SUFiRkQsQ0FBQUE7RUFIRkwsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NTgzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tcG9uZW50cy9yb2FkbWFwLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFJvYWRtYXBcbiAgaW5jbHVkZSBJbmVzaXRhOjpDb21wb25lbnRcblxuICBkZWYgcmVuZGVyXG4gICAgaDMgXCJUaGluZ3MgdG8gZG8hXCJcbiAgICBoNCBcIkJBU0lDXCJcbiAgICB1bCBkb1xuICAgICAgbGkgXCJQRVQgQVNDSUkgU3VwcG9ydFwiXG4gICAgICBsaSBcIlVzZXIgSW5wdXQgQ29tbWFuZHNcIlxuICAgICAgbGkgXCJHcmFwaGljIENvbW1hbmRzXCJcbiAgICAgIGxpIFwiU3ByaXRlcyBTdXBwb3J0XCJcbiAgICAgIGxpIFwiU291bmRcIlxuICAgICAgbGkgXCJBcnJheXMgU3VwcG9ydFwiXG4gICAgICBsaSBcIkhhc2hlcyBTdXBwb3J0XCJcbiAgICAgIGxpIFwiTmV0d29ya2luZyBTdXBwb3J0XCJcbiAgICBlbmRcbiAgICBoNCBcIkluZnJhc3RydWN0dXJlXCJcbiAgICB1bCBkb1xuICAgICAgbGkgXCJVcGxvYWQgeW91IHByb2dyYW1zXCJcbiAgICAgIGxpIFwiU2F2ZSBwcm9ncmFtcyBpbiB0aGUgY2xvdWRcIlxuICAgICAgbGkgXCJTaGFyZSBwcm9ncmFtcyB3aXRoIG90aGVyIGNsaWVudHNcIlxuICAgICAgbGkgXCJTaGFyZSBwcm9ncmFtcyB3aXRoIG90aGVyIHVzZXJzXCJcbiAgICAgIGxpIFwiTG9hZCBvdGhlciB1c2VycyBwcm9ncmFtc1wiXG4gICAgZW5kXG4gICAgaDQgXCJOYXRpdmUgY2xpZW50c1wiXG4gICAgdWwgZG9cbiAgICAgIGxpIFwiT1NYXCJcbiAgICAgIGxpIFwiV2luZG93c1wiXG4gICAgICBsaSBcIkxpbnV4XCJcbiAgICAgIGxpIFwiaU9TXCJcbiAgICAgIGxpIFwiQW5kcm9pZFwiXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSb2FkbWFwPiIsInNlbGYiLCJpbmNsdWRlIiwiSW5lc2l0YTo6Q29tcG9uZW50IiwiSW5lc2l0YSIsInJlbmRlciIsImgzIiwiaDQiLCJ1bCIsImJsb2NrIGluIHJlbmRlciIsImJsb2NrICgyIGxldmVscykgaW4gcmVuZGVyIiwibGkiXSwibWFwcGluZ3MiOiJBQUFBQSxxQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCxjQUFSRDtJQUVBRixPQUFBSyxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUosSUFBQUssSUFBQUEsQ0FBR0QsZUFBSEM7TUFDQUwsSUFBQU0sSUFBQUEsQ0FBR0YsT0FBSEU7TUFDQUMsTUFBQVAsSUFBQU8sTUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsYUFBQUEsRUFBQUM7OztRQUNFVCxJQUFBVSxJQUFBQSxDQUFHRCxtQkFBSEM7UUFDQVYsSUFBQVUsSUFBQUEsQ0FBR0QscUJBQUhDO1FBQ0FWLElBQUFVLElBQUFBLENBQUdELGtCQUFIQztRQUNBVixJQUFBVSxJQUFBQSxDQUFHRCxpQkFBSEM7UUFDQVYsSUFBQVUsSUFBQUEsQ0FBR0QsT0FBSEM7UUFDQVYsSUFBQVUsSUFBQUEsQ0FBR0QsZ0JBQUhDO1FBQ0FWLElBQUFVLElBQUFBLENBQUdELGdCQUFIQztRQUNBRCxPQUFBVCxJQUFBVSxJQUFBQSxDQUFHRCxvQkFBSEMsRUFSRkYsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUQ7TUFVQVAsSUFBQU0sSUFBQUEsQ0FBR0YsZ0JBQUhFO01BQ0FDLE1BQUFQLElBQUFPLE1BQUFBLEVBQUFBLEVBQUFBLEVBQUFDLGFBQUFBLEVBQUFDOzs7UUFDRVQsSUFBQVUsSUFBQUEsQ0FBR0QscUJBQUhDO1FBQ0FWLElBQUFVLElBQUFBLENBQUdELDRCQUFIQztRQUNBVixJQUFBVSxJQUFBQSxDQUFHRCxtQ0FBSEM7UUFDQVYsSUFBQVUsSUFBQUEsQ0FBR0QsaUNBQUhDO1FBQ0FELE9BQUFULElBQUFVLElBQUFBLENBQUdELDJCQUFIQyxFQUxGRixDQUFBQSxHQUFBQSxTQUFBQSxDQUFBRDtNQU9BUCxJQUFBTSxJQUFBQSxDQUFHRixnQkFBSEU7TUFDQUYsT0FBQUcsTUFBQVAsSUFBQU8sTUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsYUFBQUEsRUFBQUM7OztRQUNFVCxJQUFBVSxJQUFBQSxDQUFHRCxLQUFIQztRQUNBVixJQUFBVSxJQUFBQSxDQUFHRCxTQUFIQztRQUNBVixJQUFBVSxJQUFBQSxDQUFHRCxPQUFIQztRQUNBVixJQUFBVSxJQUFBQSxDQUFHRCxLQUFIQztRQUNBRCxPQUFBVCxJQUFBVSxJQUFBQSxDQUFHRCxTQUFIQyxFQUxGRixDQUFBQSxHQUFBQSxTQUFBQSxDQUFBRDtJQXRCRkgsQ0FBQUE7RUFIRkwsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NjMzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tcG9uZW50cy9zdHJpcGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFN0cmlwZXNcbiAgaW5jbHVkZSBJbmVzaXRhOjpDb21wb25lbnRcblxuICBkZWYgcmVuZGVyXG4gICAgZGl2LnN0cmlwZXMgZG9cbiAgICAgIGRpdi5zMWwgXCJcIlxuICAgICAgZGl2LnMybCBcIlwiXG4gICAgICBkaXYuczNsIFwiXCJcbiAgICAgIGRpdi5zM3IgXCJcIlxuICAgICAgZGl2LnMyciBcIlwiXG4gICAgICBkaXYuczFyIFwiXCJcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlN0cmlwZXM+Iiwic2VsZiIsImluY2x1ZGUiLCJJbmVzaXRhOjpDb21wb25lbnQiLCJJbmVzaXRhIiwicmVuZGVyIiwic3RyaXBlcyIsImRpdiIsImJsb2NrIGluIHJlbmRlciIsImJsb2NrICgyIGxldmVscykgaW4gcmVuZGVyIiwiczFsIiwiczJsIiwiczNsIiwiczNyIiwiczJyIiwiczFyIl0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsY0FBUkQ7SUFFQUYsT0FBQUssc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBR0MsTUFBSEwsSUFBQU0sS0FBQUEsQ0FBQUEsQ0FBR0QsV0FBQUEsRUFBQUEsRUFBQUEsRUFBSEUsYUFBQUEsRUFBQUM7OztRQUNFUixJQUFBTSxLQUFBQSxDQUFBQSxDQUFHRyxLQUFBQSxDQUFLRCxFQUFMQztRQUNIVCxJQUFBTSxLQUFBQSxDQUFBQSxDQUFHSSxLQUFBQSxDQUFLRixFQUFMRTtRQUNIVixJQUFBTSxLQUFBQSxDQUFBQSxDQUFHSyxLQUFBQSxDQUFLSCxFQUFMRztRQUNIWCxJQUFBTSxLQUFBQSxDQUFBQSxDQUFHTSxLQUFBQSxDQUFLSixFQUFMSTtRQUNIWixJQUFBTSxLQUFBQSxDQUFBQSxDQUFHTyxLQUFBQSxDQUFLTCxFQUFMSztRQUNITCxPQUFBUixJQUFBTSxLQUFBQSxDQUFBQSxDQUFHUSxLQUFBQSxDQUFLTixFQUFMTSxFQU5MUCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFHRjtJQURMRCxDQUFBQTtFQUhGTCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk2NjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzdG9yZS9jb21tYW5kcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTdG9yZVxuICBtb2R1bGUgQ29tbWFuZHNcbiAgICBDT01NQU5EUyA9IFtcbiAgICAgIHtuYW1lOiBcIkFCU1wiLCBkZXNjcmlwdGlvbjogXCJFdmFsdWF0ZXMgdG8gdGhlIGFic29sdXRlIHZhbHVlICh2YWx1ZSB3aXRob3V0IHRoZSBzaWduKSBvZiB0aGUgZ2l2ZW4gbnVtZXJpYyB0ZXJtLlwiLCBjb2RlOiAlUXtQUklOVCBBQlMoLTEwKVxcbjEwfX0sXG4gICAgICB7bmFtZTogXCJBTkRcIiwgZGVzY3JpcHRpb246IFwiQm9vbGVhbiBBTkQgb3IgYml0d2lzZSBBTkQgb3BlcmF0aW9uIGRlcGVuZGluZyBvbiBhcmd1bWVudHNcIiwgY29kZTogJVF7UFJJTlQgMz4yIEFORCA1PDZcXG50cnVlXFxuUFJJTlQgMTk5IEFORCA2NFxcbjY0fX0sXG4gICAgICB7bmFtZTogXCJBU0NcIiwgZGVzY3JpcHRpb246IFwiRXZhbHVhdGVzIHRoZSBmaXJzdCBjaGFyIG9mIGEgc3RyaW5nIGFzIGEgbnVtZXJpYyBpbmRleC5cIiwgY29kZTogJVF7UFJJTlQgQVNDKFwiQVwiKVxcbjY1fX0sXG4gICAgICB7bmFtZTogXCJBVE5cIiwgZGVzY3JpcHRpb246IFwiQSBtYXRoZW1hdGljYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBhcmMgdGFuZ2VudCBvZiBhIG51bWVyaWMgdmFsdWUgKHRoZSBpbnZlcnNlIGZ1bmN0aW9uIG9mIFRBTikuIFRoZSByZXN1bHRpbmcgdmFsdWUgaXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb2YgdGhlIGdpdmVuIHRhbmdlbnQuXCIsIGNvZGU6ICV7UFJJTlQgQVROKDEpXFxuMC43ODU0fX0sXG4gICAgICB7bmFtZTogXCJDSFJcIiwgZGVzY3JpcHRpb246IFwiQ2FuIGJlIHVzZWQgdG8gY29udmVydCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDI1NSBpbnRvIGFuIEFTQ0lJLWNoYXIgYW5kIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBmdW5jdGlvbiBBU0MuXCIsIGNvZGU6ICVRe1BSSU5UIENIUig0OSlcXG4xfX0sXG4gICAgICB7bmFtZTogXCJDTFJcIiwgZGVzY3JpcHRpb246IFwiRGVsZXRlcyBhbGwgdmFyaWFibGVzLlwiLCBjb2RlOiAlUXtBPTEwXFxuUFJJTlQgQVxcbjEwXFxuQ0xSXFxuUFJJTlQgQVxcbm51bGx9fSxcbiAgICAgIHtuYW1lOiBcIkNPU1wiLCBkZXNjcmlwdGlvbjogXCJJcyBhIG1hdGhlbWF0aWNhbCBmdW5jdGlvbiB3aGljaCBldmFsdWF0ZXMgdG8gdGhlIGNvc2luZSBmb3IgYSBnaXZlbiBhbmdsZSwgYSBudW1iZXIgcmVnYXJkZWQgYXMgYmVpbmcgaW4gcmFkaWFucy5cIiwgY29kZTogJVF7UFJJTlQgQ09TKDApXFxuMS4wMDAwfX0sXG4gICAgICB7bmFtZTogXCJET1RcIiwgZGVzY3JpcHRpb246IFwiRHJhcHdzIGEgcGl4ZWwgb24geCwgeSBwb3NpdGlvblwiLCBjb2RlOiAlUXtET1QgMSw1fX0sXG4gICAgICB7bmFtZTogXCJFTkRcIiwgZGVzY3JpcHRpb246IFwiRW5kcyBhIEJBU0lDLXByb2dyYW0gYW5kIHRoZSBCQVNJQy1JbnRlcnByZXRlciB3cml0ZXMgUkVBRFkuIFwiLCBjb2RlOiAlUXsxMCBQUklOVCBcIlNUQVJUXCJcXG4yMCBFTkRcXG4zMCBQUklOVCBcIk5FVkVSIEhBUFBFTkVEXCJ9fSxcbiAgICAgIHtuYW1lOiBcIkVYUFwiLCBkZXNjcmlwdGlvbjogXCJJcyBhIG1hdGhlbWF0aGljYWwgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdGhlIGludmVyc2UgbmF0dXJhbCBMT0cgb2YgdGhlIGFyZ3VtZW50LlwiLCBjb2RlOiAlUXtQUklOVCBFWFAoMSlcXG4yLjcxODN9fSxcbiAgICAgIHtuYW1lOiBcIkZMSVBcIiwgZGVzY3JpcHRpb246IFwiV2hlbiBNT0RFIDEgaXMgdXNlZCwgZHJhdyBjdXJyZW50IHNjcmVlbiBidWZmZXJcIiwgY29kZTogJVF7RkxJUH19LFxuICAgICAge25hbWU6IFwiRk9SXCIsIGRlc2NyaXB0aW9uOiBcImlzIHRoZSBzdGFydCBjb21tYW5kIG9mIGEgRk9S4oCmVE/igKZTVEVQ4oCmTkVYVCBsb29wLiBUaGlzIEZPUi4uLk5FWFQgbG9vcCBpcyBleGVjdXRlZCB1bnRpbCBjb3VudGVyIHZhcmlhYmxlIGVxdWFscyB0aGUgdmFsdWUgaW4gdGhlIFRPIGNsYXVzZS4gV2l0aCB0aGUgc3RlcC1zaXplLW51bWJlciwgdGhlIGNvdW50ZXIgdmFyaWFibGUgdmFsdWUgaXMgZWl0aGVyIGluY3JlYXNlZCAocG9zaXRpdmUpIG9yIGRlY3JlYXNlZCAobmVnYXRpdmUpLiBXaGVuIHRoZSBTVEVQIGNvbW1hbmQgaXNuJ3QgdXNlZCB0aGVuIHRoZSBzdGVwLXNpemUtbnVtYmVyIGRlZmF1bHRzIHRvIDEuXCIsIGNvZGU6ICVRe0ZPUiBYPTEgVE8gNTpQUklOVCBYOk5FWFRcXG4xXFxuMlxcbjNcXG40XFxuNX19LFxuICAgICAge25hbWU6IFwiR09TVUJcIiwgZGVzY3JpcHRpb246IFwiSnVtcHMgdG8gYSBzdWJyb3V0aW5lIGF0IHRoZSBpbmRpY2F0ZWQgbGluZSBudW1iZXIuIFRoZSBzdWJyb3V0aW5lIGZpbmFsaXplcyB1c2luZyBhIFJFVFVSTiBjb21tYW5kLlwiLCBjb2RlOiAlUXsxMCBHT1NVQiA0MFxcbjIwIFBSSU5UIFwiSEVMTE9cIlxcbjMwIEVORFxcbjQwIFBSSU5UIFwiSEVMTE8gR09TVUJcIlxcbjUwIFJFVFVSTn19LFxuICAgICAge25hbWU6IFwiR09UT1wiLCBkZXNjcmlwdGlvbjogXCJNYWtlcyB0aGUgQkFTSUMgaW50ZXJwcmV0ZXIganVtcCB0byB0aGUgaW5kaWNhdGVkIGxpbmUgYW5kIHRoZSBleGVjdXRpb24gb2YgdGhlIEJBU0lDIHByb2dyYW0gaXMgY29udGludWVkIGF0IHRoYXQgbGluZS5cIiwgY29kZTogJVF7MTAgUFJJTlQgXCJIRUxMT1wiXFxuMjAgR09UTyAxMH19LFxuICAgICAge25hbWU6IFwiSUZcIiwgZGVzY3JpcHRpb246IFwiSXMgdXNlZCB0b2dldGhlciB3aXRoIHRoZSBCQVNJQyBjb21tYW5kIFRIRU4gb3Igd2l0aCB0aGUgQkFTSUMgY29tbWFuZCBHT1RPIGJ5IGNvbmRpdGlvbi5cIiwgY29kZTogJXtJRiBBPjAgVEhFTiBQUklOVCBcIkEgaXMgcG9zaXRpdmVcIn19LFxuICAgICAge25hbWU6IFwiSU5UXCIsIGRlc2NyaXB0aW9uOiBcIklzIHVzZWQgdG8gcm91bmQgbnVtYmVycywgd2hlcmVhcyByb3VuZGluZyBpcyBkaWZmZXJlbnQgZnJvbSBpdHMgY29tbW9uIG1hdGhlbWF0aWNhbCBkZWZpbml0aW9uLlwiLCBjb2RlOiAlUXtQUklOVCBJTlQoMS41MylcXG4xfX0sXG4gICAgICB7bmFtZTogXCJMRU5cIiwgZGVzY3JpcHRpb246IFwiVmlld3MgdGhlIG51bWJlciBvZiBhbGwgY2hhcnMgaW4gYSBzdHJpbmcuXCIsIGNvZGU6ICVRe1BSSU5UIExFTihcImp1c3QgYW5kIGV4YW1wbGVcIilcXG4xNn19LFxuICAgICAge25hbWU6IFwiTEVUXCIsIGRlc2NyaXB0aW9uOiBcIklzIGZvciBhc3NpZ24gbnVtZXJpY2FsIHZhbHVlcyBvciBjaGFycyBpbiB0aGUgcmlnaHQgdHlwZSBvZiB2YXJpYWJsZS4gQXNzaWdubWVudCBvZiB2YXJpYWJsZXMgY2FuIGFsc28gYmUgZG9uZSB3aXRob3V0IExFVC5cIiwgY29kZTogJVF7TEVUIEE9XCJURVNUXCJcXG5CPVwiQ09NTU9ET1JFXCJ9fSxcbiAgICAgIHtuYW1lOiBcIkxJU1RcIiwgZGVzY3JpcHRpb246IFwiRGlzcGxheXMgdGhlIEJBU0lDIHByb2dyYW0gY3VycmVudGx5IGluIG1lbW9yeS5cIiwgY29kZTogXCJMSVNUXCJ9LFxuICAgICAge25hbWU6IFwiTE9BRFwiLCBkZXNjcmlwdGlvbjogXCJMb2FkIGEgcHJvZ3JhbSBpbnRvIG1lbW9yeVwiLCBjb2RlOiAlUXtMT0FEIFwiTVlQUk9HXCJ9fSxcbiAgICAgIHtuYW1lOiBcIkxPR1wiLCBkZXNjcmlwdGlvbjogXCJJcyBhIG5hdHVyYWwgbG9nYXJpdGhtIHdpdGggdGhlIGJhc2lzIGUoRSkuXCIsIGNvZGU6ICVRe1BSSU5UIExPRygxKVxcbjB9fSxcbiAgICAgIHtuYW1lOiBcIk1PREVcIiwgZGVzY3JpcHRpb246IFwiU2V0cyBkaXNwbGF5IG1vZGU6IDAgLSB0ZXh0IG1vZGUsIDEgLSBHcmFwaGljIG1vZGUgd2l0aCBmcmFtZSBidWZmZXIsIHVzZSBGTElQIHRvIHNob3csIDIgLSBHcmFwaGljIGRpcmVjdCBtb2RlXCIsIGNvZGU6ICVRe01PREUgMX19LFxuICAgICAge25hbWU6IFwiTkVYVFwiLCBkZXNjcmlwdGlvbjogXCJJcyB1c2VkIHdpdGggdGhlIEJBU0lDLUNvbW1hbmQgRk9SLlwiLCBjb2RlOiAlUXt9fSxcbiAgICAgIHtuYW1lOiBcIk5PVFwiLCBkZXNjcmlwdGlvbjogXCJSZXZlcnNlIHRoZSBib29sZWFuIHRydWUgaW50byBmYWxzZS5cIiwgY29kZTogJVF7fX0sXG4gICAgICB7bmFtZTogXCJPUlwiLCBkZXNjcmlwdGlvbjogXCJCb29sZWFuIE9SIG9yIGJpdHdpc2UgT1Igb3BlcmF0aW9uIGRlcGVuZGluZyBvbiBhcmd1bWVudHNcIiwgY29kZTogJVF7UFJJTlQgMzwyIE9SIDU8NlxcbnRydWVcXG5QUklOVCAwIE9SIDBcXG4wfX0sXG4gICAgICB7bmFtZTogXCJQUklOVFwiLCBkZXNjcmlwdGlvbjogXCJJcyB1c2VkIHRvIHByaW50IGRhdGEgb250byB0aGUgc2NyZWVuLlwiLCBjb2RlOiAlUXtQUklOVCAxMisyXFxuMTR9fSxcbiAgICAgIHtuYW1lOiBcIlJFTVwiLCBkZXNjcmlwdGlvbjogXCJJcyB1c2VkIHRvIHBsYWNlIHJlbWFya3MgaW50byBCQVNJQy1wcm9ncmFtcy5cIiwgY29kZTogJVF7MTAgUkVNIE5JQ0UgQ09NTUVOVH19LFxuICAgICAge25hbWU6IFwiUkVUVVJOXCIsIGRlc2NyaXB0aW9uOiBcIkZpbmlzaGVzIGEgc3Vicm91dGluZSwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIEJBU0lDLWNvbW1hbmQgR09TVUIuXCIsIGNvZGU6ICVRe319LFxuICAgICAge25hbWU6IFwiUlVOXCIsIGRlc2NyaXB0aW9uOiBcIlN0YXJ0cyBhIEJBU0lDIHByb2dyYW0uXCIsIGNvZGU6ICVRe1JVTn19LFxuICAgICAge25hbWU6IFwiU0FWRVwiLCBkZXNjcmlwdGlvbjogXCJTYXZlIGN1cnJlbnQgcHJvZ3JhbVwiLCBjb2RlOiAlUXtTQVZFfX0sXG4gICAgICB7bmFtZTogXCJTR05cIiwgZGVzY3JpcHRpb246IFwiR2l2ZXMgYXV0b25vbW91cyBvZiB0aGUgYWxnZWJyYWljIHNpZ24gdGhlIG51bWJlciAoLTE7IDA7IDEpIG9mIGEgbnVtZXJpY2FsIGFyZ3VtZW50LlwiLCBjb2RlOiAlUXtQUklOVCBTR04oLTExKVxcbi0xfX0sXG4gICAgICB7bmFtZTogXCJTSU5cIiwgZGVzY3JpcHRpb246IFwiSXMgYSBtYXRoZW1hdGljYWwgZnVuY3Rpb24gd2hpY2ggZXZhbHVhdGVzIHRvIHRoZSBzaW5lIGZvciBhIGdpdmVuIGFuZ2xlLCBhIG51bWJlciByZWdhcmRlZCBhcyBiZWluZyBpbiByYWRpYW5zLlwiLCBjb2RlOiAlUXtQUklOVCBTSU4oMSl9fSxcbiAgICAgIHtuYW1lOiBcIlNRUlwiLCBkZXNjcmlwdGlvbjogXCIgSXMgYSBtYXRoZW1hdGhpY2FsIGZ1bmN0aW9uIGZvciBzcXVhcmUgcm9vdCBvZiBhIG51bWJlci5cIiwgY29kZTogJVF7UFJJTlQgU1FMKDQpXFxuMn19LFxuICAgICAge25hbWU6IFwiU1RPUFwiLCBkZXNjcmlwdGlvbjogXCJCcmVha3MgYSBwcm9ncmFtLlwiLCBjb2RlOiAlUXtTVE9QfX0sXG4gICAgICB7bmFtZTogXCJTVFJcIiwgZGVzY3JpcHRpb246IFwiSXMgZm9yIGNvbnZlcnRpbmcgbnVtZXJpY2FsIHZhbHVlcyBvciB2YXJpYmFsZXMgaW50byBhIHN0cmluZy5cIiwgY29kZTogJVF7UFJJTlQgU1RSKDEyKVxcbjEyfX0sXG4gICAgICB7bmFtZTogXCJUQU5cIiwgZGVzY3JpcHRpb246IFwiSXMgYSBtYXRoZW1hdGljYWwgZnVuY3Rpb24gd2hpY2ggZXZhbHVhdGVzIHRvIHRoZSB0YW5nZW50IGZvciBhIGdpdmVuIGFuZ2xlLCBhIG51bWJlciByZWdhcmRlZCBhcyBiZWluZyBpbiByYWRpYW5zLlwiLCBjb2RlOiAlUXtQUklOVCBUQU4oMSl9fSxcbiAgICAgIHtuYW1lOiBcIlZBTFwiLCBkZXNjcmlwdGlvbjogXCJGaW5kcyBhIG51bWVyaWNhbCB2YWx1ZSBpbiBhIHN0cmluZy5cIiwgY29kZTogJVF7UFJJTlQgVkFMKFwiMTBcIilcXG4xMH19LFxuICAgIF1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlN0b3JlPiIsIjxtb2R1bGU6Q29tbWFuZHM+Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJ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cUJBQWxGLEVBM0JTLEVBNEJULHlDQUFBLFFBQU9BLFFBQVAsRUFBQSxlQUE4QkEsc0VBQTlCLEVBQUEsUUFBNEcsRUFBNUcsRUE1QlMsRUE2QlQseUNBQUEsUUFBT0EsS0FBUCxFQUFBLGVBQTJCQSx5QkFBM0IsRUFBQSxRQUE0REEsS0FBNUQsRUE3QlMsRUE4QlQseUNBQUEsUUFBT0EsTUFBUCxFQUFBLGVBQTRCQSxzQkFBNUIsRUFBQSxRQUEwREEsTUFBMUQsRUE5QlMsRUErQlQseUNBQUEsUUFBT0EsS0FBUCxFQUFBLGVBQTJCQSx1RkFBM0IsRUFBQSxRQUEwSEEsb0JBQTFILEVBL0JTLEVBZ0NULHlDQUFBLFFBQU9BLEtBQVAsRUFBQSxlQUEyQkEsa0hBQTNCLEVBQUEsUUFBcUpBLGNBQXJKLEVBaENTLEVBaUNULHlDQUFBLFFBQU9BLEtBQVAsRUFBQSxlQUEyQkEsMkRBQTNCLEVBQUEsUUFBOEZBLGlCQUE5RixFQWpDUyxFQWtDVCx5Q0FBQSxRQUFPQSxNQUFQLEVBQUEsZUFBNEJBLG1CQUE1QixFQUFBLFFBQXVEQSxNQUF2RCxFQWxDUyxFQW1DVCx5Q0FBQSxRQUFPQSxLQUFQLEVBQUEsZUFBMkJBLGdFQUEzQixFQUFBLFFBQW1HQSxtQkFBbkcsRUFuQ1MsRUFvQ1QseUNBQUEsUUFBT0EsS0FBUCxFQUFBLGVBQTJCQSxxSEFBM0IsRUFBQSxRQUF3SkEsY0FBeEosRUFwQ1MsRUFxQ1QseUNBQUEsUUFBT0EsS0FBUCxFQUFBLGVBQTJCQSxzQ0FBM0IsRUFBQSxRQUF5RUEsdUJBQXpFLEVBckNTLENBQVg7SUFERkEsR0FBQUEsV0FBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5Njc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3RvcmUvZXhhbXBsZXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgU3RvcmVcbiAgbW9kdWxlIEV4YW1wbGVzXG4gICAgRVhBTVBMRVMgPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiSEVMTE9cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2ltcGxlICdoZWxsbyB3b3JsZCcgYmFzaWMgcHJvZ3JhbVwiLFxuICAgICAgICBjb2RlOiA8PH5FT1BcbiAgICAgICAgICAxMCBQUklOVCBcIkhlbGxvXCJcbiAgICAgICAgICAyMCBHT1RPIDEwXG4gICAgICAgIEVPUFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJDT0xPUlNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmlsbCBhbGwgc2NyZWVuIHdpdGggcGl4ZWwgYW5kIHNob3cgaXQuXCIsXG4gICAgICAgIGNvZGU6IDw8fkVPUFxuICAgICAgICAgIDUgbW9kZSAxXG4gICAgICAgICAgMTAgZm9yIGM9MCB0byAxNVxuICAgICAgICAgIDIwIGZvciB5PTAgdG8gMjQwXG4gICAgICAgICAgMzAgZm9yIHg9MCB0byAzMjBcbiAgICAgICAgICA0MCBkb3QgeCx5XG4gICAgICAgICAgNTAgbmV4dFxuICAgICAgICAgIDYwIG5leHRcbiAgICAgICAgICA3MCBmbGlwXG4gICAgICAgICAgODAgY29sb3IgY1xuICAgICAgICAgIDkwIG5leHRcbiAgICAgICAgRU9QXG4gICAgICB9LFxuICAgIF1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlN0b3JlPiIsIjxtb2R1bGU6RXhhbXBsZXM+Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQ0VBLE9BQUEsb0NBQVcsQ0FDVCx5Q0FBQSxRQUNRQSxPQURSLEVBQUEsZUFFZUEsb0NBRmYsRUFBQSxRQUlOQSxzQkFEYyxHQUVkQSxjQUxNLEVBRFMsRUFTVCx5Q0FBQSxRQUNRQSxRQURSLEVBQUEsZUFFZUEseUNBRmYsRUFBQSxRQUlOQSxZQURjLEdBRWRBLG9CQUZjLEdBR2RBLHFCQUhjLEdBSWRBLHFCQUpjLEdBS2RBLGNBTGMsR0FNZEEsV0FOYyxHQU9kQSxXQVBjLEdBUWRBLFdBUmMsR0FTZEEsY0FUYyxHQVVkQSxXQWJNLEVBVFMsQ0FBWDtJQURGQSxHQUFBQSxXQUFBQTtFQURGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk2OTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2FwcGxpY2F0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgcmVxdWlyZSBJbmVzaXRhXG5yZXF1aXJlICdpbmVzaXRhJ1xucmVxdWlyZSAnaW5lc2l0YS1yb3V0ZXInXG5cbiMgcmVxdWlyZSBtYWluIHBhcnRzIG9mIGFwcGxpY2F0aW9uXG5yZXF1aXJlICdyb3V0ZXInXG5yZXF1aXJlICdzdG9yZSdcblxuIyByZXF1aXJlIGFsbCBjb21wb25lbnRzXG5yZXF1aXJlX3RyZWUgJy4vY29tcG9uZW50cydcbnJlcXVpcmVfdHJlZSAnLi9zdG9yZSdcblxuIyB3aGVuIGRvY3VtZW50IGlzIHJlYWR5IHJlbmRlciBhcHBsaWNhdGlvbiB0byA8Ym9keT5cblxuY2xhc3MgQXBwbGljYXRpb25cbiAgaW5jbHVkZSBJbmVzaXRhOjpDb21wb25lbnRcblxuICBpbmplY3QgUm91dGVyXG4gIGluamVjdCBTdG9yZVxuXG4gIGRlZiByZW5kZXJcbiAgICBjb21wb25lbnQgTmF2QmFyXG4gICAgZGl2LmNvbnRhaW5lciBkb1xuICAgICAgY29tcG9uZW50IFN0cmlwZXNcbiAgICAgIGRpdi5jb250ZW50IGRvXG4gICAgICAgIGgxIFwiRkFaSUNcIlxuICAgICAgICBoMiBcImZhbnRhc3kgcmV0cm8gY29tcHV0ZXJcIlxuICAgICAgICBkaXYuc29jaWFsIGRvXG4gICAgICAgICAgYSBjbGFzczogXCJmYSBmYS10d2l0dGVyXCIsIGhyZWY6IFwiaHR0cHM6Ly90d2l0dGVyLmNvbS9mYXppYzFcIlxuICAgICAgICAgIGEgY2xhc3M6IFwiYm9sZFwiLCBocmVmOiBcImh0dHBzOi8vd3d3LnBhdHJlb24uY29tL2ZhemliZWFyXCIgZG9cbiAgICAgICAgICAgIFwiUFwiXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgYSBjbGFzczogXCJib2xkXCIsIGhyZWY6IFwiaHR0cHM6Ly9mYXppYmVhci5pdGNoLmlvL2ZhemljXCIgZG9cbiAgICAgICAgICAgIFwiaVwiXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgYSBjbGFzczogXCJmYSBmYS1naXRodWJcIiwgaHJlZjogXCJodHRwczovL2dpdGh1Yi5jb20vZmF6aWJlYXIvZmF6aWNcIlxuICAgICAgICBlbmRcbiAgICAgICAgY29tcG9uZW50IHJvdXRlclxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgY29tcG9uZW50IEZvb3RlclxuICBlbmRcbmVuZFxuXG5cbkluZXNpdGE6OkJyb3dzZXIucmVhZHk/IGRvXG4gIEFwcGxpY2F0aW9uLm1vdW50X3RvKEluZXNpdGE6OkJyb3dzZXIuYm9keSlcbmVuZFxuIl0sIm5hbWVzIjpbIjxtYWluPiIsInNlbGYiLCJyZXF1aXJlIiwicmVxdWlyZV90cmVlIiwiPGNsYXNzOkFwcGxpY2F0aW9uPiIsImluY2x1ZGUiLCJJbmVzaXRhOjpDb21wb25lbnQiLCJJbmVzaXRhIiwiaW5qZWN0IiwiUm91dGVyIiwiU3RvcmUiLCJyZW5kZXIiLCJjb21wb25lbnQiLCJOYXZCYXIiLCJjb250YWluZXIiLCJkaXYiLCJibG9jayBpbiByZW5kZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlbmRlciIsIlN0cmlwZXMiLCJjb250ZW50IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiByZW5kZXIiLCJoMSIsImgyIiwic29jaWFsIiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiByZW5kZXIiLCJhIiwicm91dGVyIiwiRm9vdGVyIiwicmVhZHk/IiwiSW5lc2l0YTo6QnJvd3NlciIsImJsb2NrIGluIDxtYWluPiIsImJsb2NrICgyIGxldmVscykgaW4gPG1haW4+IiwiQXBwbGljYXRpb24iLCJtb3VudF90byIsImJvZHkiXSwibWFwcGluZ3MiOiJBQUFBQSwyQkFBQUE7RUFBQUE7O0VBQUFBOztFQUNBQyxJQUFBQyxTQUFBQSxDQUFRRixTQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFHQUQsSUFBQUMsU0FBQUEsQ0FBUUYsUUFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsT0FBUkU7RUFHQUQsSUFBQUUsY0FBQUEsQ0FBYUgsWUFBYkc7RUFDQUYsSUFBQUUsY0FBQUEsQ0FBYUgsT0FBYkc7RUFJQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUgsSUFBQUksU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsY0FBUkQ7SUFFQUosSUFBQU8sUUFBQUEsQ0FBT0MsWUFBUEQ7SUFDQVAsSUFBQU8sUUFBQUEsQ0FBT0UsV0FBUEY7SUFFQUosT0FBQU8sc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0VWLElBQUFXLFdBQUFBLENBQVVDLFlBQVZEO01BQ0dFLE1BQUhiLElBQUFjLEtBQUFBLENBQUFBLENBQUdELGFBQUFBLEVBQUFBLEVBQUFBLEVBQUhFLGFBQUFBLEVBQUFDOzs7UUFDRWhCLElBQUFXLFdBQUFBLENBQVVNLGFBQVZOO1FBQ0FLLE9BQUdFLE1BQUhsQixJQUFBYyxLQUFBQSxDQUFBQSxDQUFHSSxXQUFBQSxFQUFBQSxFQUFBQSxFQUFIRixhQUFBQSxFQUFBRzs7O1VBQ0VuQixJQUFBb0IsSUFBQUEsQ0FBR0QsT0FBSEM7VUFDQXBCLElBQUFxQixJQUFBQSxDQUFHRix3QkFBSEU7VUFDR0MsTUFBSHRCLElBQUFjLEtBQUFBLENBQUFBLENBQUdRLFVBQUFBLEVBQUFBLEVBQUFBLEVBQUhILGFBQUFBLEVBQUFJOzs7WUFDRXZCLElBQUF3QixHQUFBQSxDQUFFLDJCQUFBLFNBQU9ELGVBQVAsRUFBQSxRQUE4QkEsNEJBQTlCLEVBQUZDO1lBQ0FBLE1BQUF4QixJQUFBd0IsS0FBQUEsRUFBQUEsQ0FBRSwyQkFBQSxTQUFPRCxNQUFQLEVBQUEsUUFBcUJBLGtDQUFyQixFQUFGQyxDQUFBQSxFQUFBRCxZQUNFQSxHQURGQSxDQUFBQztZQUdBQSxNQUFBeEIsSUFBQXdCLEtBQUFBLEVBQUFBLENBQUUsMkJBQUEsU0FBT0QsTUFBUCxFQUFBLFFBQXFCQSxnQ0FBckIsRUFBRkMsQ0FBQUEsRUFBQUQsWUFDRUEsR0FERkEsQ0FBQUM7WUFHQUQsT0FBQXZCLElBQUF3QixHQUFBQSxDQUFFLDJCQUFBLFNBQU9ELGNBQVAsRUFBQSxRQUE2QkEsbUNBQTdCLEVBQUZDLEVBUkZMLENBQUFBLEdBQUFBLFNBQUFBLENBQUdHO1VBVUhILE9BQUFuQixJQUFBVyxXQUFBQSxDQUFVWCxJQUFBeUIsUUFBQUEsQ0FBQUEsQ0FBVmQsRUFiRkssQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBR0UsRUFGTEgsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBR0Y7TUFrQkhILE9BQUFWLElBQUFXLFdBQUFBLENBQVVlLFlBQVZmO0lBcEJGRCxDQUFBQTtFQU5GUCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQStCQUosT0FBZ0I0QixNQUFoQkMsSUFBQXRCLGFBQUFzQixZQUFnQkQsVUFBQUEsRUFBQUEsRUFBQUEsRUFBaEJFLGFBQUFBO0lBQ0VDLE9BQUFDLGlCQUFXQyxVQUFBQSxDQUFVSixJQUFBdEIsYUFBQXNCLFlBQWdCSyxNQUFBQSxDQUFBQSxDQUExQkQsQ0FEYkgsQ0FBZ0JGO0FBN0NoQjVCOyJ9fV19